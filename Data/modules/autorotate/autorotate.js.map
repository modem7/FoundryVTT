{"version":3,"file":"autorotate.js","sources":["../../module/src/core.js","../../module/src/rotation.js"],"sourcesContent":["// import version as manifestVersion from '../module.json';\n//\nexport const MODULE_SCOPE = 'autorotate';\n// export const VERSION = manifestVersion;\n/* ------------------------------------------------------------------------- */\n\nexport function getSetting(key){\n    return game.settings.get(MODULE_SCOPE, key);\n}\n\n\nexport function setSetting(key, value){\n    return game.settings.set(MODULE_SCOPE, key, value);\n}\n\n\nexport function registerSetting(key, value, link){\n    const typ = value.type;\n    if (value?.type?.prototype instanceof FormApplication) {\n        return game.settings.registerMenu(MODULE_SCOPE, key, value);       \n    }\n\n    const originalOnChange = value.onChange;\n    if (link != null) {\n        if (originalOnChange != null) {\n            value.onChange = function (v) {\n                link[key] = v;\n                originalOnChange(v);\n            }\n        } else {\n            value.onChange = function (v) {\n                link[key] = v;\n            }\n        }\n    }\n\n    if (value.default === undefined && link[key] !== undefined){\n        value.default = link[key]\n    }\n\n    const result = game.settings.register(MODULE_SCOPE, key, value);\n    if (value.onChange != null){\n        value.onChange(getSetting(key));\n    }\n    return result;\n}\n\n\nexport function registerSettings(link, settings){\n    for (var [key, value] of Object.entries(settings)){\n        registerSetting(key, value, link);\n    }\n}\n\n\nexport async function getFlag(doc, flag, defaults){\n    let result = doc.getFlag(MODULE_SCOPE, flag)\n    if (result === undefined){\n        setFlag(document, defaults)\n        result = defaults;\n    }\n    return result\n}\n\nexport function setFlag(entity, flag, value){\n    return entity.setFlag(MODULE_SCOPE, flag, value)\n}\n\n\n// Helper functions for math operations.\nexport function pointToAngle(x, y, snap){\n    let angle = toDegrees(Math.atan2(y, x));\n    if (snap != null && snap > 0){\n        angle = Math.round(angle / snap) * snap;\n    }\n    return angle;\n}\n\nexport function angleToPoint(angle, radius){\n    let x = Math.cos(toRadians(angle)) * radius;\n    let y = Math.sin(toRadians(angle)) * radius;\n}\n\nexport function escapeRegExp(string) {\n  return string.replace(/[.*+\\-?^${}()|[\\]\\\\]/g, '\\\\$&'); // $& means the whole matched string\n}\n\nexport function toDegrees(radians) {\n  return radians / (Math.PI / 180);\n};\n\n\nexport function toRadians(degrees) {\n  return degrees * (Math.PI / 180);\n};\n\n\nexport function normalizeDegrees(degrees) {\n  const delta = degrees % 360;\n  return delta < 0 ? delta + 360 : delta;\n}\n\nexport function normalizeRadians(radians) {\n  let pi2 = 2 * Math.PI;\n  let nr = (radians + pi2) % pi2;\n  return (nr > Math.PI) ? nr - pi2 : nr;\n}","import * as core from \"./core.js\";\n\n//// Settings ////\nconst settings = {\n    version: \"\",\n    defaultRotationMode: \"regular\"\n}\n\nHooks.on('ready', () => {\n    core.registerSettings(\n        settings,\n        {\n            version: {\n                scope: \"world\"\n            },\n\n            defaultRotationMode: {\n                name: \"Default Rotation Mode\",\n                hint: \"The rotation mode used for tokens that do not have \" +\n                      \"automatic rotation explicitly enabled or disabled.\",\n                scope: \"world\",\n                config: true,\n                choices: {\n                    \"regular\"  : \"Regular\",\n                    \"automatic\": \"Automatic\",\n                },\n            }\n        },\n    );\n})\n\n\n//// Utility Functions ////\n\n\nconst UP = 'ArrowUp';\nconst DOWN = 'ArrowDown';\nconst LEFT = 'ArrowLeft';\nconst RIGHT = 'ArrowRight';\nconst SHIFT = 'Shift';\n\n\nfunction getFlag(document, flag){\n    return document.flags[core.MODULE_SCOPE]?.[flag];\n}\n\n\nfunction shouldRotate(tokenDocument){\n    // `null` if not set, otherwise `true` or `false`\n    const enabled = getFlag(tokenDocument, 'enabled');\n    return (\n        (\n            enabled === true\n        ) || (\n            enabled == null &&\n            settings.defaultRotationMode === 'automatic'\n        )\n    )\n}\n\n\nfunction rotationOffset(tokenDocument){\n    const offset = getFlag(tokenDocument, 'offset');\n    if (offset == null) return 0;\n    return offset;\n}\n\n\nfunction rotationFromPositionDelta(deltaX, deltaY, offset){\n    // Convert our delta to an angle, then adjust for the fact that the\n    // rotational perspective in Foundry is shifted 90 degrees\n    // counterclockwise.\n    return core.normalizeDegrees(\n        core.pointToAngle(deltaX, deltaY) - 90 + offset\n    );\n}\n\n\n//// Hooks ////\n\n\nasync function rotateTokenOnPreUpdate(tokenDocument, change, options, userId) {\n    const cont = (\n        userId === game.user.id &&\n        shouldRotate(tokenDocument)\n    )\n    if (!cont){\n        return;\n    }\n\n    // At least one part of the token's location must be changing.\n    // If a coordinate isn't defined in the set of data to update, we default\n    // to the token's current position.\n    const newX = change.x || tokenDocument.x;\n    const newY = change.y || tokenDocument.y;\n    if (newX === tokenDocument.x && newY === tokenDocument.y) {\n        return;\n    }\n\n    const deltaX = newX - tokenDocument.x;\n    const deltaY = newY - tokenDocument.y;\n\n    const offset = rotationOffset(tokenDocument);\n\n    change.rotation = rotationFromPositionDelta(deltaX, deltaY, offset);\n\n    const STOP_MOVEMENT = (\n        game.keyboard.downKeys.has(SHIFT) &&\n        (\n            game.keyboard.downKeys.has(UP)   ||\n            game.keyboard.downKeys.has(DOWN) ||\n            game.keyboard.downKeys.has(LEFT) ||\n            game.keyboard.downKeys.has(RIGHT)\n        )\n    );\n    if (STOP_MOVEMENT) {\n        change.x = undefined;\n        change.y = undefined;\n    }\n}\n\n\nasync function rotateTokensOnTarget(user, targetToken, targetActive) {\n    const cont = (\n        targetActive             &&\n        user.id === game.user.id\n    )\n    if (!cont){\n        return;\n    }\n\n    // The user must have at least one token controlled\n    const controlled = canvas.tokens.controlled;\n    if (controlled.length === 0) {\n        return;\n    }\n\n    const updates = controlled\n        .filter(t => shouldRotate(t.document))\n        .filter(t => t.id !== targetToken.id)\n        .map(controlledToken => ({\n            _id: controlledToken.id,\n            rotation: rotationFromPositionDelta(\n                targetToken.document.x - controlledToken.document.x,\n                targetToken.document.y - controlledToken.document.y,\n                rotationOffset(controlledToken.document)\n            )\n        }));\n    await canvas.scene.updateEmbeddedDocuments(\"Token\", updates);\n}\n\n\nasync function injectAutoRotateOptions(app, html, data){\n    const enabled = data.object.flags[core.MODULE_SCOPE]?.[\"enabled\"]\n    const offset = data.object.flags[core.MODULE_SCOPE]?.[\"offset\"]\n    const form = html.find(\"div[data-tab='appearance']:first\");\n    let snippet = await renderTemplate(\n        \"modules/autorotate/templates/token-config-snippet.html\",\n        {\n            selectDefault: enabled == null,\n            selectYes    : enabled === true,\n            selectNo     : enabled === false,\n            offsetToSet  : offset,\n        }\n    );\n    form.append(snippet);\n}\n\nHooks.on(\"preUpdateToken\",    rotateTokenOnPreUpdate);\nHooks.on(\"targetToken\",       rotateTokensOnTarget);\nHooks.on(\"renderTokenConfig\", injectAutoRotateOptions);\n"],"names":["registerSetting","key","value","link","type","prototype","FormApplication","game","settings","registerMenu","originalOnChange","onChange","v","undefined","default","result","register","get","getSetting","version","defaultRotationMode","getFlag","document","flag","flags","shouldRotate","tokenDocument","enabled","rotationOffset","rotationFromPositionDelta","deltaX","deltaY","offset","degrees","delta","core.normalizeDegrees","x","y","snap","angle","Math","atan2","PI","core.pointToAngle","Hooks","on","Object","entries","scope","name","hint","config","choices","regular","automatic","core.registerSettings","async","change","options","userId","user","id","newX","newY","rotation","keyboard","downKeys","has","targetToken","targetActive","controlled","canvas","tokens","length","updates","filter","t","map","controlledToken","_id","scene","updateEmbeddedDocuments","app","html","data","object","form","find","snippet","renderTemplate","selectDefault","selectYes","selectNo","offsetToSet","append"],"mappings":"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"}