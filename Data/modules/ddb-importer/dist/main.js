/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ 37:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const DICTIONARY = {
  types: {
    full: ["weapon", "equipment", "consumable", "tool", "loot", "class", "subclass", "background", "spell", "feat", "backpack"],
    equipment: ["equipment", "consumable", "tool", "loot", "backpack"],
    inventory: ["equipment", "consumable", "tool", "loot", "backpack", "weapon"],
    monster: ["equipment", "consumable", "tool", "loot", "backpack", "weapon", "feat"],
  },
  sizes: [
    { name: "Tiny", value: "tiny", size: 0.5 },
    { name: "Small", value: "sm", size: 0.8 },
    { name: "Medium", value: "med", size: 1 },
    { name: "Large", value: "lg", size: 2 },
    { name: "Huge", value: "huge", size: 3 },
    { name: "Gargantuan", value: "grg", size: 4 },
  ],
  numbers: [
    { num: 1, natural: "a" },
    { num: 1, natural: "one" },
    { num: 2, natural: "two" },
    { num: 3, natural: "three" },
    { num: 4, natural: "four" },
    { num: 5, natural: "five" },
    { num: 6, natural: "six" },
    { num: 7, natural: "seven" },
    { num: 8, natural: "eight" },
    { num: 9, natural: "nine" },
    { num: 10, natural: "ten" },
    { num: 11, natural: "eleven" },
    { num: 12, natural: "twelve" },
    { num: 13, natural: "thirteen" },
    { num: 14, natural: "fourteen" },
    { num: 15, natural: "fifteen" },
    { num: 16, natural: "sixteen" },
    { num: 17, natural: "seventeen" },
    { num: 18, natural: "eighteen" },
    { num: 19, natural: "nineteen" },
    { num: 20, natural: "twenty" },
  ],
  magicitems: {
    rechargeUnits: [
      { id: 1, value: "r4" },
      { id: "ShortRest", value: "r4" },
      { id: 2, value: "r5" },
      { id: "LongRest", value: "r5" },
      { id: "Dawn", value: "r2" },
      { id: "Dusk", value: "r3" },
      { id: "Sunset", value: "r3" },
      { id: "Consumable", value: "" },
      { id: "Other", value: "" },
      { id: "Daily", value: "r1" },
      { id: "sr", value: "r4" },
      { id: "lr", value: "r5" },
    ],
    nums: [
      { id: "once", value: 1 },
      { id: "twice", value: 2 },
      { id: "thrice", value: 3 },
      { id: "one", value: 1 },
      { id: "two", value: 2 },
      { id: "three", value: 3 },
    ],
  },
  resets: [
    { id: 1, value: "sr" },
    { id: "ShortRest", value: "sr" },
    { id: "Short", value: "sr" },
    { id: "short", value: "sr" },
    { id: 2, value: "lr" },
    { id: "LongRest", value: "lr" },
    { id: "Long", value: "lr" },
    { id: "long", value: "lr" },
    { id: "Day", value: "day" },
    { id: "day", value: "day" },
    { id: "Dawn", value: "day" },
    { id: "dusk", value: "day" },
    { id: "Consumable", value: "charges" },
    { id: "Other", value: "charges" },
    { id: "", value: "" },
    { id: null, value: "" },
    { id: 3, value: "day" },
    { id: 4, value: "charges" },
  ],
  // CONFIG.Canvas.visionModes
  senseMap: {
    blindsight: "basic",
    darkvision: "darkvision",
    // tremorsense: "tremorsense",
    truesight: "basic",
    unknown: "basic",
  },
  // CONFIG.Canvas.detectionModes
  detectionMap: {
    blindsight: "senseAll",
    truesight: "seeAll",
    tremorsense: "feelTremor",
  },
  conditions: [
    { label: "Blinded", foundry: "blinded", statusId: "Convenient Effect: Blinded", ddbId: 1, levelId: null, ddbType: 1 },
    { label: "Charmed", foundry: "charmed", statusId: "Convenient Effect: Charmed", ddbId: 2, levelId: null, ddbType: 1 },
    { label: "Deafened", foundry: "deafened", statusId: "Convenient Effect: Deafened", ddbId: 3, levelId: null, ddbType: 1 },
    { label: "Exhaustion", foundry: "exhaustion", statusId: null, ddbId: null, levelId: null, ddbType: null },
    { label: "Exhaustion 1", foundry: null, statusId: "Convenient Effect: Exhaustion 1", ddbId: 4, levelId: 1, ddbType: 2 },
    { label: "Exhaustion 2", foundry: null, statusId: "Convenient Effect: Exhaustion 2", ddbId: 4, levelId: 2, ddbType: 2 },
    { label: "Exhaustion 3", foundry: null, statusId: "Convenient Effect: Exhaustion 3", ddbId: 4, levelId: 3, ddbType: 2 },
    { label: "Exhaustion 4", foundry: null, statusId: "Convenient Effect: Exhaustion 4", ddbId: 4, levelId: 4, ddbType: 2 },
    { label: "Exhaustion 5", foundry: null, statusId: "Convenient Effect: Exhaustion 5", ddbId: 4, levelId: 5, ddbType: 2 },
    { label: "Exhaustion 6", foundry: null, statusId: "Convenient Effect: Exhaustion 6", ddbId: 4, levelId: 6, ddbType: 2 },
    { label: "Frightened", foundry: "frightened", statusId: "Convenient Effect: Frightened", ddbId: 5, levelId: null, ddbType: 1 },
    { label: "Grappled", foundry: "grappled", statusId: "Convenient Effect: Grappled", ddbId: 6, levelId: null, ddbType: 1 },
    { label: "Incapacitated", foundry: "incapacitated", statusId: "Convenient Effect: Incapacitated", ddbId: 7, levelId: null, ddbType: 1 },
    { label: "Invisible", foundry: "invisible", statusId: "Convenient Effect: Invisible", ddbId: 8, levelId: null, ddbType: 1 },
    { label: "Paralyzed", foundry: "paralyzed", statusId: "Convenient Effect: Paralyzed", ddbId: 9, levelId: null, ddbType: 1 },
    { label: "Petrified", foundry: "petrified", statusId: "Convenient Effect: Petrified", ddbId: 10, levelId: null, ddbType: 1 },
    { label: "Poisoned", foundry: "poisoned", statusId: "Convenient Effect: Poisoned", ddbId: 11, levelId: null, ddbType: 1 },
    { label: "Prone", foundry: "prone", statusId: "Convenient Effect: Prone", ddbId: 12, levelId: null, ddbType: 1 },
    { label: "Restrained", foundry: "restrained", statusId: "Convenient Effect: Restrained", ddbId: 13, levelId: null, ddbType: 1 },
    { label: "Stunned", foundry: "stunned", statusId: "Convenient Effect: Stunned", ddbId: 14, levelId: null, ddbType: 1 },
    { label: "Unconscious", foundry: "unconscious", statusId: "Convenient Effect: Unconscious", ddbId: 15, levelId: null, ddbType: 1 },
    { label: "Diseased", foundry: "diseased", statusId: null, ddbId: null, levelId: null, ddbType: null },
    { label: "Disease", foundry: "diseased", statusId: null, ddbId: null, levelId: null, ddbType: null },
  ],
  character: {
    abilities: [
      { id: 1, value: "str", long: "strength" },
      { id: 2, value: "dex", long: "dexterity" },
      { id: 3, value: "con", long: "constitution" },
      { id: 4, value: "int", long: "intelligence" },
      { id: 5, value: "wis", long: "wisdom" },
      { id: 6, value: "cha", long: "charisma" },
    ],
    skills: [
      { name: "acr", label: "Acrobatics", ability: "dex", subType: "acrobatics", valueId: 3 },
      { name: "ani", label: "Animal Handling", ability: "wis", subType: "animal-handling", valueId: 11 },
      { name: "arc", label: "Arcana", ability: "int", subType: "arcana", valueId: 6 },
      { name: "ath", label: "Athletics", ability: "str", subType: "athletics", valueId: 2 },
      { name: "dec", label: "Deception", ability: "cha", subType: "deception", valueId: 16 },
      { name: "his", label: "History", ability: "int", subType: "history", valueId: 7 },
      { name: "ins", label: "Insight", ability: "wis", subType: "insight", valueId: 12 },
      { name: "itm", label: "Intimidation", ability: "cha", subType: "intimidation", valueId: 17 },
      { name: "inv", label: "Investigation", ability: "int", subType: "investigation", valueId: 8 },
      { name: "med", label: "Medicine", ability: "wis", subType: "medicine", valueId: 13 },
      { name: "nat", label: "Nature", ability: "int", subType: "nature", valueId: 9 },
      { name: "prc", label: "Perception", ability: "wis", subType: "perception", valueId: 14 },
      { name: "prf", label: "Performance", ability: "cha", subType: "performance", valueId: 18 },
      { name: "per", label: "Persuasion", ability: "cha", subType: "persuasion", valueId: 19 },
      { name: "rel", label: "Religion", ability: "int", subType: "religion", valueId: 10 },
      { name: "slt", label: "Sleight of Hand", ability: "dex", subType: "sleight-of-hand", valueId: 4 },
      { name: "ste", label: "Stealth", ability: "dex", subType: "stealth", valueId: 5 },
      { name: "sur", label: "Survival", ability: "wis", subType: "survival", valueId: 15 },
    ],
    customSkillProficiencies: [
      // typeId:26
      // value not: 1, half 2, prof: 3, expertise 4
      { value: 1, proficient: 0 },
      { value: 2, proficient: 0.5 },
      { value: 3, proficient: 1 },
      { value: 4, proficient: 2 },
    ],
    alignments: [
      { id: 1, name: "Lawful Good", value: "lg" },
      { id: 2, name: "Neutral Good", value: "ng" },
      { id: 3, name: "Chaotic Good", value: "cg" },
      { id: 4, name: "Lawful Neutral", value: "ln" },
      { id: 5, name: "True Neutral", value: "tn" },
      { id: 6, name: "Chaotic Neutral", value: "cn" },
      { id: 7, name: "Lawful Evil", value: "le" },
      { id: 8, name: "Neutral Evil", value: "ne" },
      { id: 9, name: "Chaotic Evil", value: "ce" },
    ],
    actorSizes: [
      { id: 2, name: "Tiny", value: "tiny" }, // wild guess
      { id: 3, name: "Small", value: "sm" }, // consistent
      { id: 4, name: "Medium", value: "med" }, // consistent
      { id: 5, name: "Large", value: "lg" }, // wild guess
      { id: 6, name: "Huge", value: "huge" }, // wild guess
      { id: 7, name: "Gargantuan", value: "grg" }, // wild guess
    ],
    senses: [
      { id: 1, name: "Blindsight" },
      { id: 2, name: "Darkvision" },
      { id: 3, name: "Tremorsense" },
    ],
    speeds: [
      { id: 1, type: "walk", innate: "walking" },
      { id: 2, type: "burrow", innate: "burrowing" },
      { id: 3, type: "climb", innate: "climbing" },
      { id: 4, type: "fly", innate: "flying" },
      { id: 5, type: "swim", innate: "swimming" },
    ],
    languages: [
      { name: "Common", value: "common" },
      { name: "Aarakocra", value: "aarakocra" },
      { name: "Abyssal", value: "abyssal" },
      { name: "Aquan", value: "aquan" },
      { name: "Auran", value: "auran" },
      { name: "Celestial", value: "celestial" },
      { name: "Deep Speech", value: "deep" },
      { name: "Draconic", value: "draconic" },
      { name: "Druidic", value: "druidic" },
      { name: "Dwarvish", value: "dwarvish" },
      { name: "Elvish", value: "elvish" },
      { name: "Giant", value: "giant" },
      { name: "Gith", value: "gith" },
      { name: "Gnomish", value: "gnomish" },
      { name: "Goblin", value: "goblin" },
      { name: "Gnoll", value: "gnoll" },
      { name: "Halfling", value: "halfling" },
      { name: "Ignan", value: "ignan" },
      { name: "Infernal", value: "infernal" },
      { name: "Orc", value: "orc" },
      { name: "Primordial", value: "primordial" },
      { name: "Terran", value: "terran" },
      { name: "Sylvan", value: "sylvan" },
      { name: "Thieves' Cant", value: "cant" },
      { name: "Thievesâ€™ Cant", value: "cant" },
      { name: "Undercommon", value: "undercommon" },
    ],
    armorTypes: [
      { name: "Clothing", value: "clothing" },
      { name: "Light Armor", value: "light" },
      { name: "Medium Armor", value: "medium" },
      { name: "Heavy Armor", value: "heavy" },
      { name: "Magical Bonus", value: "bonus" },
      { name: "Natural Armor", value: "natural" },
      { name: "Shield", value: "shield" },
    ],
    damageAdjustments: [
      { id: 1, type: 2, kind: "resistance", name: "Bludgeoning", value: "bludgeoning" },
      { id: 2, type: 2, kind: "resistance", name: "Piercing", value: "piercing" },
      { id: 3, type: 2, kind: "resistance", name: "Slashing", value: "slashing" },
      { id: 4, type: 2, kind: "resistance", name: "Lightning", value: "lightning" },
      { id: 5, type: 2, kind: "resistance", name: "Thunder", value: "thunder" },
      { id: 6, type: 2, kind: "resistance", name: "Poison", value: "poison" },
      { id: 7, type: 2, kind: "resistance", name: "Cold", value: "cold" },
      { id: 8, type: 2, kind: "resistance", name: "Radiant", value: "radiant" },
      { id: 9, type: 2, kind: "resistance", name: "Fire", value: "fire" },
      { id: 10, type: 2, kind: "resistance", name: "Necrotic", value: "necrotic" },
      { id: 11, type: 2, kind: "resistance", name: "Acid", value: "acid" },
      { id: 12, type: 2, kind: "resistance", name: "Psychic", value: "psychic" },
      { id: 13, type: 2, kind: "resistance", name: "Physical", value: "bludgeoning-piercing-and-slashing-from-nonmagical-weapons", foundryValue: "physical" },
      { id: 14, type: 2, kind: "resistance", name: "Physical", value: "bludgeoning-piercing-and-slashing-from-nonmagical-attacks-that-arent-silvered", foundryValue: "physical" },
      { id: 15, type: 2, kind: "resistance", name: "Physical", value: "bludgeoning-piercing-and-slashing-from-nonmagical-attacks-that-arent-adamantine", foundryValue: "physical" },
      // { id: 16, type: 2, kind: "resistance", name: "Physical", value: "piercing-and-slashing-from-nonmagical-attacks-that-arent-adamantine", foundryValue: "physical" },
      { id: 17, type: 2, kind: "immunity", name: "Bludgeoning", value: "bludgeoning" },
      { id: 18, type: 2, kind: "immunity", name: "Piercing", value: "piercing" },
      { id: 19, type: 2, kind: "immunity", name: "Slashing", value: "slashing" },
      { id: 20, type: 2, kind: "immunity", name: "Lightning", value: "lightning" },
      { id: 21, type: 2, kind: "immunity", name: "Thunder", value: "thunder" },
      { id: 22, type: 2, kind: "immunity", name: "Poison", value: "poison" },
      { id: 23, type: 2, kind: "immunity", name: "Cold", value: "cold" },
      { id: 24, type: 2, kind: "immunity", name: "Radiant", value: "radiant" },
      { id: 25, type: 2, kind: "immunity", name: "Fire", value: "fire" },
      { id: 26, type: 2, kind: "immunity", name: "Necrotic", value: "necrotic" },
      { id: 27, type: 2, kind: "immunity", name: "Acid", value: "acid" },
      { id: 28, type: 2, kind: "immunity", name: "Psychic", value: "psychic" },
      { id: 29, type: 2, kind: "immunity", name: "Physical", value: "bludgeoning-piercing-and-slashing-from-nonmagical-weapons", foundryValue: "physical" },
      { id: 30, type: 2, kind: "immunity", name: "Physical", value: "bludgeoning-piercing-and-slashing-from-nonmagical-attacks-that-arent-silvered", foundryValue: "physical" },
      { id: 31, type: 2, kind: "immunity", name: "Physical", value: "bludgeoning-piercing-and-slashing-from-nonmagical-attacks-that-arent-adamantine", foundryValue: "physical" },
      // { id: 32, type: 2, kind: "immunity", name: "Physical", value: "piercing-and-slashing-from-nonmagical-attacks-that-arent-adamantine", foundryValue: "physical" },
      { id: 33, type: 2, kind: "vulnerability", name: "Bludgeoning", value: "bludgeoning" },
      { id: 34, type: 2, kind: "vulnerability", name: "Piercing", value: "piercing" },
      { id: 35, type: 2, kind: "vulnerability", name: "Slashing", value: "slashing" },
      { id: 36, type: 2, kind: "vulnerability", name: "Lightning", value: "lightning" },
      { id: 37, type: 2, kind: "vulnerability", name: "Thunder", value: "thunder" },
      { id: 38, type: 2, kind: "vulnerability", name: "Poison", value: "poison" },
      { id: 39, type: 2, kind: "vulnerability", name: "Cold", value: "cold" },
      { id: 40, type: 2, kind: "vulnerability", name: "Radiant", value: "radiant" },
      { id: 41, type: 2, kind: "vulnerability", name: "Fire", value: "fire" },
      { id: 42, type: 2, kind: "vulnerability", name: "Necrotic", value: "necrotic" },
      { id: 43, type: 2, kind: "vulnerability", name: "Acid", value: "acid" },
      { id: 44, type: 2, kind: "vulnerability", name: "Psychic", value: "psychic" },

      { id: 47, type: 2, kind: "resistance", name: "Force", value: "force" },
      { id: 48, type: 2, kind: "immunity", name: "Force", value: "force" },
      { id: 49, type: 2, kind: "vulnerability", name: "Force", value: "force" },
      { id: 51, type: 2, kind: "resistance", name: "Ranged attacks" },
      { id: 52, type: 2, kind: "resistance", name: "Damage dealt by traps" },
      { id: 54, type: 2, kind: "resistance", name: "Bludgeoning from non magical attacks" },

      { id: 1, type: 1, kind: "immunity", name: "Blinded", value: "blinded" },
      { id: 2, type: 1, kind: "immunity", name: "Charmed", value: "charmed" },
      { id: 3, type: 1, kind: "immunity", name: "Deafened", value: "deafened" },
      { id: 4, type: 1, kind: "immunity", name: "Exhaustion", value: "exhaustion" },
      { id: 5, type: 1, kind: "immunity", name: "Frightened", value: "frightened" },
      { id: 6, type: 1, kind: "immunity", name: "Grappled", value: "grappled" },
      { id: 7, type: 1, kind: "immunity", name: "Incapacitated", value: "incapacitated" },
      { id: 8, type: 1, kind: "immunity", name: "Invisible", value: "invisible" },
      { id: 9, type: 1, kind: "immunity", name: "Paralyzed", value: "paralyzed" },
      { id: 10, type: 1, kind: "immunity", name: "Petrified", value: "petrified" },
      { id: 11, type: 1, kind: "immunity", name: "Poisoned", value: "poisoned" },
      { id: 12, type: 1, kind: "immunity", name: "Prone", value: "prone" },
      { id: 13, type: 1, kind: "immunity", name: "Restrained", value: "restrained" },
      { id: 14, type: 1, kind: "immunity", name: "Stunned", value: "stunned" },
      { id: 15, type: 1, kind: "immunity", name: "Unconscious", value: "unconscious" },
      // In DDB it is disease, but in FVTT ut is diseased
      { id: 16, type: 1, kind: "immunity", name: "Diseased", value: "disease", foundryValue: "diseased" },
    ],
    proficiencies: [
      // Armor
      { name: "Studded Leather", type: "Armor", subType: "Light Armor" },
      { name: "Scale Mail", type: "Armor", subType: "Medium Armor" },
      { name: "Shield", type: "Armor", subType: "Shield" },
      { name: "Padded", type: "Armor", subType: "Light Armor" },
      { name: "Leather", type: "Armor", subType: "Light Armor" },
      { name: "Hide", type: "Armor", subType: "Medium Armor" },
      { name: "Chain Shirt", type: "Armor", subType: "Medium Armor" },
      { name: "Breastplate", type: "Armor", subType: "Medium Armor" },
      { name: "Half Plate", type: "Armor", subType: "Medium Armor" },
      { name: "Ring Mail", type: "Armor", subType: "Heavy Armor" },
      { name: "Chain Mail", type: "Armor", subType: "Heavy Armor" },
      { name: "Splint", type: "Armor", subType: "Heavy Armor" },
      { name: "Plate", type: "Armor", subType: "Heavy Armor" },
      { name: "Spiked Armor", type: "Armor", subType: "Medium Armor" },

      // Weapons
      { name: "Crossbow, Hand", type: "Weapon", subType: "Martial Weapon", foundryValue: "" },
      { name: "Glaive", type: "Weapon", subType: "Martial Weapon", foundryValue: "" },
      { name: "Dagger", type: "Weapon", subType: "Simple Weapon", foundryValue: "" },
      { name: "Longsword", type: "Weapon", subType: "Martial Weapon", foundryValue: "" },
      { name: "Club", type: "Weapon", subType: "Simple Weapon", foundryValue: "" },
      { name: "Greatclub", type: "Weapon", subType: "Simple Weapon", foundryValue: "" },
      { name: "Handaxe", type: "Weapon", subType: "Simple Weapon", foundryValue: "" },
      { name: "Javelin", type: "Weapon", subType: "Simple Weapon", foundryValue: "" },
      { name: "Light Hammer", type: "Weapon", subType: "Simple Weapon", foundryValue: "" },
      { name: "Mace", type: "Weapon", subType: "Simple Weapon", foundryValue: "" },
      { name: "Quarterstaff", type: "Weapon", subType: "Simple Weapon", foundryValue: "" },
      { name: "Sickle", type: "Weapon", subType: "Simple Weapon", foundryValue: "" },
      { name: "Spear", type: "Weapon", subType: "Simple Weapon", foundryValue: "" },
      { name: "Crossbow, Light", type: "Weapon", subType: "Simple Weapon", foundryValue: "" },
      { name: "Dart", type: "Weapon", subType: "Simple Weapon", foundryValue: "" },
      { name: "Shortbow", type: "Weapon", subType: "Simple Weapon", foundryValue: "" },
      { name: "Sling", type: "Weapon", subType: "Simple Weapon", foundryValue: "" },
      { name: "Battleaxe", type: "Weapon", subType: "Martial Weapon", foundryValue: "" },
      { name: "Flail", type: "Weapon", subType: "Martial Weapon", foundryValue: "" },
      { name: "Greataxe", type: "Weapon", subType: "Martial Weapon", foundryValue: "" },
      { name: "Greatsword", type: "Weapon", subType: "Martial Weapon", foundryValue: "" },
      { name: "Halberd", type: "Weapon", subType: "Martial Weapon", foundryValue: "" },
      { name: "Lance", type: "Weapon", subType: "Martial Weapon", foundryValue: "" },
      { name: "Maul", type: "Weapon", subType: "Martial Weapon", foundryValue: "" },
      { name: "Morningstar", type: "Weapon", subType: "Martial Weapon", foundryValue: "" },
      { name: "Pike", type: "Weapon", subType: "Martial Weapon", foundryValue: "" },
      { name: "Rapier", type: "Weapon", subType: "Martial Weapon", foundryValue: "" },
      { name: "Scimitar", type: "Weapon", subType: "Martial Weapon", foundryValue: "" },
      { name: "Shortsword", type: "Weapon", subType: "Martial Weapon", foundryValue: "" },
      { name: "Trident", type: "Weapon", subType: "Martial Weapon", foundryValue: "" },
      { name: "War Pick", type: "Weapon", subType: "Martial Weapon", foundryValue: "" },
      { name: "Warhammer", type: "Weapon", subType: "Martial Weapon", foundryValue: "" },
      { name: "Whip", type: "Weapon", subType: "Martial Weapon", foundryValue: "" },
      { name: "Blowgun", type: "Weapon", subType: "Martial Weapon", foundryValue: "" },
      { name: "Crossbow, Heavy", type: "Weapon", subType: "Martial Weapon", foundryValue: "" },
      { name: "Longbow", type: "Weapon", subType: "Martial Weapon", foundryValue: "" },
      { name: "Net", type: "Weapon", subType: "Martial Weapon", foundryValue: "" },
      { name: "Boomerang", type: "Weapon", subType: "Simple Weapon", foundryValue: "" },
      { name: "Yklwa", type: "Weapon", subType: "Simple Weapon", foundryValue: "" },
      { name: "Pistol", type: "Weapon", subType: "Martial Weapon", foundryValue: "" },
      { name: "Musket", type: "Weapon", subType: "Martial Weapon", foundryValue: "" },
      { name: "Pistol, Automatic", type: "Weapon", subType: "Martial Weapon", foundryValue: "" },
      { name: "Revolver", type: "Weapon", subType: "Martial Weapon", foundryValue: "" },
      { name: "Rifle, Hunting", type: "Weapon", subType: "Martial Weapon", foundryValue: "" },
      { name: "Rifle, Automatic", type: "Weapon", subType: "Martial Weapon", foundryValue: "" },
      { name: "Shotgun", type: "Weapon", subType: "Martial Weapon", foundryValue: "" },
      { name: "Laser Pistol", type: "Weapon", subType: "Martial Weapon", foundryValue: "" },
      { name: "Antimatter Rifle", type: "Weapon", subType: "Martial Weapon", foundryValue: "" },
      { name: "Laser Rifle", type: "Weapon", subType: "Martial Weapon", foundryValue: "" },
      { name: "Double-Bladed Scimitar", type: "Weapon", subType: "Martial Weapon", foundryValue: "" },
      { name: "Revenant Double-Bladed Scimitar", type: "Weapon", subType: "Martial Weapon", foundryValue: "" },
      { name: "Ammunition", type: "Weapon", subType: "Simple Weapon", foundryValue: "" },

      // Tools and Instruments and Stuff
      { name: "Carpenter's Tools", type: "Tool", subType: "Artisan's Tools", ability: "dex", baseTool: "carpenter", toolType: "art" },
      { name: "Cartographer's Tools", type: "Tool", subType: "Artisan's Tools", ability: "dex", baseTool: "cartographer", toolType: "art" },
      { name: "Cobbler's Tools", type: "Tool", subType: "Artisan's Tools", ability: "dex", baseTool: "cobbler", toolType: "art" },
      { name: "Cook's Utensils", type: "Tool", subType: "Artisan's Tools", ability: "wis", baseTool: "cook", toolType: "art" },
      { name: "Glassblower's Tools", type: "Tool", subType: "Artisan's Tools", ability: "dex", baseTool: "glassblower", toolType: "art" },
      { name: "Jeweler's Tools", type: "Tool", subType: "Artisan's Tools", ability: "dex", baseTool: "jeweler", toolType: "art" },
      { name: "Leatherworker's Tools", type: "Tool", subType: "Artisan's Tools", ability: "dex", baseTool: "leatherworker", toolType: "art" },
      { name: "Mason's Tools", type: "Tool", subType: "Artisan's Tools", ability: "dex", baseTool: "mason", toolType: "art" },
      { name: "Navigator's Tools", type: "Tool", subType: "Artisan's Tools", ability: "int", baseTool: "navg", toolType: "" },
      { name: "Potter's Tools", type: "Tool", subType: "Artisan's Tools", ability: "dex", baseTool: "potter", toolType: "art" },
      { name: "Smith's Tools", type: "Tool", subType: "Artisan's Tools", ability: "dex", baseTool: "smith", toolType: "art" },
      { name: "Thieves' Tools", type: "Tool", subType: "Artisan's Tools", ability: "dex", baseTool: "thief", toolType: "" },
      { name: "Tinker's Tools", type: "Tool", subType: "Artisan's Tools", ability: "dex", baseTool: "tinker", toolType: "art" },
      { name: "Weaver's Tools", type: "Tool", subType: "Artisan's Tools", ability: "dex", baseTool: "weaver", toolType: "art" },
      { name: "Woodcarver's Tools", type: "Tool", subType: "Artisan's Tools", ability: "dex", baseTool: "woodcarver", toolType: "art" },
      { name: "Dice Set", type: "Tool", subType: "Gaming Set", ability: "int", baseTool: "dice", toolType: "game" },
      { name: "Dragonchess Set", type: "Tool", subType: "Gaming Set", ability: "int", baseTool: "chess", toolType: "game" },
      { name: "Playing Card Set", type: "Tool", subType: "Gaming Set", ability: "int", baseTool: "card", toolType: "game" },
      { name: "Three-Dragon Ante Set", type: "Tool", subType: "Gaming Set", ability: "int", baseTool: "card", toolType: "game" },
      { name: "Disguise Kit", type: "Tool", subType: "Kit", ability: "int", baseTool: "disg", toolType: "" },
      { name: "Forgery Kit", type: "Tool", subType: "Kit", ability: "int", baseTool: "forge", toolType: "" },
      { name: "Herbalism Kit", type: "Tool", subType: "Kit", ability: "int", baseTool: "herb", toolType: "" },
      { name: "Poisoner's Kit", type: "Tool", subType: "Kit", ability: "int", baseTool: "pois", toolType: "" },
      { name: "Bagpipes", type: "Tool", subType: "Musical Instrument", ability: "con", baseTool: "bagpipes", toolType: "music" },
      { name: "Birdpipes", type: "Tool", subType: "Musical Instrument", ability: "con", baseTool: "", toolType: "music" },
      { name: "Drum", type: "Tool", subType: "Musical Instrument", ability: "dex", baseTool: "drum", toolType: "music" },
      { name: "Dulcimer", type: "Tool", subType: "Musical Instrument", ability: "dex", baseTool: "dulcimer", toolType: "music" },
      { name: "Flute", type: "Tool", subType: "Musical Instrument", ability: "dex", baseTool: "flute", toolType: "music" },
      { name: "Glaur", type: "Tool", subType: "Musical Instrument", ability: "dex", baseTool: "", toolType: "music" },
      { name: "Hand Drum", type: "Tool", subType: "Musical Instrument", ability: "dex", baseTool: "", toolType: "music" },
      { name: "Horn", type: "Tool", subType: "Musical Instrument", ability: "dex", baseTool: "horn", toolType: "music" },
      { name: "Longhorn", type: "Tool", subType: "Musical Instrument", ability: "dex", baseTool: "", toolType: "music" },
      { name: "Lute", type: "Tool", subType: "Musical Instrument", ability: "dex", baseTool: "lute", toolType: "music" },
      { name: "Lyre", type: "Tool", subType: "Musical Instrument", ability: "dex", baseTool: "lyre", toolType: "music" },
      { name: "Pan Flute", type: "Tool", subType: "Musical Instrument", ability: "dex", baseTool: "", toolType: "music" },
      { name: "Shawm", type: "Tool", subType: "Musical Instrument", ability: "dex", baseTool: "", toolType: "music" },
      { name: "Songhorn", type: "Tool", subType: "Musical Instrument", ability: "dex", baseTool: "", toolType: "music" },
      { name: "Tantan", type: "Tool", subType: "Musical Instrument", ability: "dex", baseTool: "", toolType: "music" },
      { name: "Thelarr", type: "Tool", subType: "Musical Instrument", ability: "dex", baseTool: "", toolType: "music" },
      { name: "Tocken", type: "Tool", subType: "Musical Instrument", ability: "dex", baseTool: "", toolType: "music" },
      { name: "Viol", type: "Tool", subType: "Musical Instrument", ability: "dex", baseTool: "viol", toolType: "music" },
      { name: "Wargong", type: "Tool", subType: "Musical Instrument", ability: "dex", baseTool: "", toolType: "music" },
      { name: "Yarting", type: "Tool", subType: "Musical Instrument", ability: "dex", baseTool: "", toolType: "music" },
      { name: "Zulkoon", type: "Tool", subType: "Musical Instrument", ability: "dex", baseTool: "", toolType: "music" },
      { name: "Alchemist's Supplies", type: "Tool", subType: "Supplies", ability: "int", baseTool: "alchemist", toolType: "art" },
      { name: "Brewer's Supplies", type: "Tool", subType: "Supplies", ability: "int", baseTool: "brewer", toolType: "art" },
      { name: "Calligrapher's Supplies", type: "Tool", subType: "Supplies", ability: "dex", baseTool: "calligrapher", toolType: "art" },
      { name: "Painter's Supplies", type: "Tool", subType: "Supplies", ability: "dex", baseTool: "painter", toolType: "art" },
      { name: "Vehicles (Land)", type: "Tool", subType: "Vehicles", ability: "dex", baseTool: "land", toolType: "" },
      { name: "Vehicles (Air)", type: "Tool", subType: "Vehicles", ability: "dex", baseTool: "air", toolType: "" },
      { name: "Vehicles (Water)", type: "Tool", subType: "Vehicles", ability: "dex", baseTool: "water", toolType: "" },
    ],
    characterValuesLookup: [
      { name: "pactWeapon", typeId: 28 },
      { name: "hexWarrior", typeId: 29 },
    ],
    // Supported Warlock Pact Weapon options
    pactFeatures: ["Improved Pact Weapon", "Lifedrinker"],
  },
  item: {
    characterValues: [
      { typeId: 8, value: "name" },
      //   { typeId: 9, value: 'notes'},  // note: Not supported by Foundry right now, skipping
      { typeId: 19, value: "price" },
      { typeId: 22, value: "weight" },
    ],
  },
  items: [
    { filterType: "Armor", img: "https://www.dndbeyond.com/content/1-0-1358-0/skins/waterdeep/images/icons/item_types/armor.jpg" },
    { filterType: "Potion", img: "https://www.dndbeyond.com/content/1-0-1358-0/skins/waterdeep/images/icons/item_types/potion.jpg" },
    { filterType: "Ring", img: "https://www.dndbeyond.com/content/1-0-1358-0/skins/waterdeep/images/icons/item_types/ring.jpg" },
    { filterType: "Rod", img: "https://www.dndbeyond.com/content/1-0-1358-0/skins/waterdeep/images/icons/item_types/rod.jpg" },
    { filterType: "Scroll", img: "https://www.dndbeyond.com/content/1-0-1358-0/skins/waterdeep/images/icons/item_types/scroll.jpg" },
    { filterType: "Staff", img: "https://www.dndbeyond.com/content/1-0-1358-0/skins/waterdeep/images/icons/item_types/staff.jpg" },
    { filterType: "Wand", img: "https://www.dndbeyond.com/content/1-0-1358-0/skins/waterdeep/images/icons/item_types/wand.jpg" },
    { filterType: "Weapon", img: "https://www.dndbeyond.com/content/1-0-1358-0/skins/waterdeep/images/icons/item_types/weapon.jpg" },
    { filterType: "Wondrous item", img: "https://www.dndbeyond.com/content/1-0-1358-0/skins/waterdeep/images/icons/item_types/wondrousitem.jpg" },
  ],
  genericItemIcons: [
    { name: "Adventuring Gear", img: "https://www.dndbeyond.com/content/1-0-1358-0/skins/waterdeep/images/icons/equipment/adventuring-gear.jpg" },
    { name: "Tool", img: "https://www.dndbeyond.com/content/1-0-1358-0/skins/waterdeep/images/icons/equipment/tool.jpg" },
    { name: "Gemstone", img: "https://www.dndbeyond.com/content/1-0-1358-0/skins/waterdeep/images/icons/equipment/gemstone.jpg" },
    { name: "Holy Symbol", img: "https://www.dndbeyond.com/content/1-0-1358-0/skins/waterdeep/images/icons/equipment/holy-symbol.jpg" },
    { name: "Weapon", img: "https://www.dndbeyond.com/content/1-0-1358-0/skins/waterdeep/images/icons/equipment/weapon.jpg" },
    { name: "Arcane Focus", img: "https://www.dndbeyond.com/content/1-0-1358-0/skins/waterdeep/images/icons/equipment/arcane-focus.jpg" },
    { name: "Druidic Focus", img: "https://www.dndbeyond.com/content/1-0-1358-0/skins/waterdeep/images/icons/equipment/druidic-focus.jpg" },
    { name: "Ammunition", img: "https://www.dndbeyond.com/content/1-0-1358-0/skins/waterdeep/images/icons/equipment/ammunition.jpg" },
    { name: "Poison", img: "https://www.dndbeyond.com/content/1-0-1358-0/skins/waterdeep/images/icons/equipment/poison.jpg" },
    { name: "Mount", img: "https://www.dndbeyond.com/content/1-0-1358-0/skins/waterdeep/images/icons/equipment/mount.jpg" },
    { name: "Potion", img: "https://www.dndbeyond.com/content/1-0-1358-0/skins/waterdeep/images/icons/equipment/potion.jpg" },
    { name: "Equipment Pack", img: "https://www.dndbeyond.com/content/1-0-1358-0/skins/waterdeep/images/icons/equipment/pack.jpg" },
    // Vehicle (Land)/(Water)
    { name: "Vehicle", img: "https://www.dndbeyond.com/content/1-0-1358-0/skins/waterdeep/images/icons/equipment/vehicle.jpg" },
  ],
  equipment: {
    armorType: [
      { name: "Light Armor", id: 1, value: "light" },
      { name: "Medium Armor", id: 2, value: "medium" },
      { name: "Heavy Armor", id: 3, value: "heavy" },
      { name: "Shield", id: 4, value: "shield" },
      { name: "Unarmored", id: 0, value: null },
      { name: "Unarmored Defense", id: -1, value: null },
      { name: "Natural Armor", id: -2, value: "natural" },
      { name: "Magical Bonus", id: -3, value: "bonus" },
      { name: "Clothing", id: -4, value: "clothing" },
    ],
  },
  weapon: {
    weaponRange: [
      { attackType: 1, value: "M" },
      { attackType: 2, value: "R" },
      { attackType: null, value: "R" },
    ],
    weaponType: [
      { categoryId: 1, value: "simple" },
      { categoryId: 2, value: "martial" },
      { categoryId: 3, value: "martial" }, // this is not 100% correct. a martialF for "Martial Firearms" would be better
      { categoryId: 0, value: "simple" }, // this is totally incorrect, this is of type ammunition
    ],
    properties: [
      { name: "Ammunition", value: "amm" },
      { name: "Ammunition (Firearms)", value: "fir" },
      { name: "Finesse", value: "fin" },
      { name: "Heavy", value: "hvy" },
      { name: "Light", value: "lgt" },
      { name: "Loading", value: "lod" },
      { name: "Range", value: "fir" },
      { name: "Reach", value: "rch" },
      { name: "Reload", value: "rel" },
      { name: "Special", value: "spc" },
      { name: "Thrown", value: "thr" },
      { name: "Two-Handed", value: "two" },
      { name: "Versatile", value: "ver" },
      { name: "Returning", value: "ret" },
      { name: "Focus", value: "foc" },
      { name: "Adamantine", value: "ada" },
      { name: "Magical", value: "mgc" },
      { name: "Silvered", value: "sil" },
    ],
  },
  actions: {
    activationTypes: [
      { id: 0, value: "none" },
      { id: 1, value: "action" },
      { id: 2, value: "action" },
      { id: 3, value: "bonus" },
      { id: 4, value: "reaction" },
      { id: 5, value: "action" },
      { id: 6, value: "minute" },
      { id: 7, value: "hour" },
      { id: 8, value: "special" },
    ],
    attackTypes: [
      //  natural improv
      // { attackSubtype: 1, value: "" },
      { attackSubtype: 2, value: "natural" },
      { attackSubtype: 3, value: "simpleM" }, // unarmed
    ],
    damageType: [
      { name: "bludgeoning", id: 1 },
      { name: "piercing", id: 2 },
      { name: "slashing", id: 3 },
      { name: "necrotic", id: 4 },
      { name: "acid", id: 5 },
      { name: "cold", id: 6 },
      { name: "fire", id: 7 },
      { name: "lightning", id: 8 },
      { name: "thunder", id: 9 },
      { name: "poison", id: 10 },
      { name: "psychic", id: 11 },
      { name: "radiant", id: 12 },
      { name: "force", id: 13 },
      { name: null, id: null },
    ],
    aoeType: [
      { id: 1, value: "cone" },
      { id: 2, value: "" },
      { id: 3, value: "" },
      { id: 4, value: "line" },
      // presumably others here too! add when found
    ],
  },
  spell: {
    schools: [
      { id: "abj", name: "abjuration", img: "https://www.dndbeyond.com/content/1-0-1337-0/skins/waterdeep/images/spell-schools/35/abjuration.png" },
      { id: "con", name: "conjuration", img: "https://www.dndbeyond.com/content/1-0-1337-0/skins/waterdeep/images/spell-schools/35/conjuration.png" },
      { id: "div", name: "divination", img: "https://www.dndbeyond.com/content/1-0-1337-0/skins/waterdeep/images/spell-schools/35/divination.png" },
      { id: "enc", name: "enchantment", img: "https://www.dndbeyond.com/content/1-0-1337-0/skins/waterdeep/images/spell-schools/35/enchantment.png" },
      { id: "evo", name: "evocation", img: "https://www.dndbeyond.com/content/1-0-1337-0/skins/waterdeep/images/spell-schools/35/evocation.png" },
      { id: "ill", name: "illusion", img: "https://www.dndbeyond.com/content/1-0-1337-0/skins/waterdeep/images/spell-schools/35/illusion.png" },
      { id: "nec", name: "necromancy", img: "https://www.dndbeyond.com/content/1-0-1337-0/skins/waterdeep/images/spell-schools/35/necromancy.png" },
      { id: "trs", name: "transmutation", img: "https://www.dndbeyond.com/content/1-0-1337-0/skins/waterdeep/images/spell-schools/35/transmutation.png" },
    ],
    progression: [
      { name: "Artificer", value: "artificer" },
      { name: "Artificer (UA)", value: "artificer" },
      { name: "Bard", value: "full" },
      { name: "Barbarian", value: "none" },
      { name: "Blood Hunter", value: "pact" },
      { name: "Blood Hunter (archived)", value: "pact" },
      { name: "Cleric", value: "full" },
      { name: "Druid", value: "full" },
      { name: "Fighter", value: "third" },
      { name: "Hunter", value: "half" },
      { name: "Paladin", value: "half" },
      { name: "Ranger", value: "half" },
      { name: "Rogue", value: "third" },
      { name: "Sorcerer", value: "full" },
      { name: "Warlock", value: "pact" },
      { name: "Wizard", value: "full" },
      { name: "Monk", value: "none" },
    ],
    preparationModes: [
      { name: "Artificer", value: "prepared" },
      { name: "Artificer (UA)", value: "prepared" },
      { name: "Bard", value: "always" },
      { name: "Blood Hunter", value: "pact" },
      { name: "Blood Hunter (archived)", value: "pact" },
      { name: "Cleric", value: "prepared" },
      { name: "Druid", value: "prepared" },
      { name: "Fighter", value: "always" },
      { name: "Hunter", value: "always" },
      { name: "Paladin", value: "prepared" },
      { name: "Ranger", value: "always" },
      { name: "Rogue", value: "always" },
      { name: "Sorcerer", value: "always" },
      { name: "Warlock", value: "pact" },
      { name: "Wizard", value: "prepared" },
      { name: "Monk", value: "always" },
    ],
    activationTypes: [
      { activationType: 0, value: "none", name: "No Action" }, // doesn't exist an more
      { activationType: 1, value: "action", name: "Action", }, // action
      { activationType: 2, value: "none", name: "No Action" }, // no action
      { activationType: 3, value: "bonus", name: "Bonus Action" }, // bonus action
      { activationType: 4, value: "reaction", name: "Reaction", }, // reaction
      { activationType: 5, value: "special", name: "Unknown" }, // no longer exists
      { activationType: 6, value: "minute", name: "Minute" }, // minute
      { activationType: 7, value: "hour", name: "Hour" }, // hour
      { activationType: 8, value: "special", name: "Special" }, // special
    ],
  },
  monsters: {
    weapons: [
      { name: "Hand Crossbow", actionType: "rwak", weaponType: "martialR", properties: { amm: true, lgt: true, lod: true } },
      { name: "Glaive", actionType: "mwak", weaponType: "martialM", properties: { hvy: true, rch: true, two: true } },
      { name: "Dagger", actionType: "mwak", weaponType: "simpleM", properties: { lgt: true, fin: true, thr: true } },
      { name: "Longsword", actionType: "mwak", weaponType: "martialM", properties: { ver: true } },
      { name: "Club", actionType: "mwak", weaponType: "simpleM", properties: { lgt: true } },
      { name: "Greatclub", actionType: "mwak", weaponType: "simpleM", properties: { two: true } },
      { name: "Handaxe", actionType: "mwak", weaponType: "simpleM", properties: { lgt: true, thr: true } },
      { name: "Javelin", actionType: "mwak", weaponType: "simpleM", properties: { thr: true } },
      { name: "Light Hammer", actionType: "mwak", weaponType: "simpleM", properties: { lgt: true, thr: true } },
      { name: "Mace", actionType: "mwak", weaponType: "simpleM", properties: {} },
      { name: "Quarterstaff", actionType: "mwak", weaponType: "simpleM", properties: { ver: true } },
      { name: "Sickle", actionType: "mwak", weaponType: "simpleM", properties: { lgt: true } },
      { name: "Spear", actionType: "mwak", weaponType: "simpleM", properties: { thr: true, ver: true } },
      { name: "Light Crossbow", actionType: "rwak", weaponType: "simpleR", properties: { amm: true, lod: true, two: true } },
      { name: "Dart", actionType: "rwak", weaponType: "simpleR", properties: { fin: true, thr: true } },
      { name: "Shortbow", actionType: "rwak", weaponType: "simpleR", properties: { amm: true, two: true } },
      { name: "Sling", actionType: "rwak", weaponType: "simpleR", properties: { amm: true } },
      { name: "Battleaxe", actionType: "mwak", weaponType: "martialM", properties: { ver: true } },
      { name: "Flail", actionType: "mwak", weaponType: "martialM", properties: {} },
      { name: "Greataxe", actionType: "mwak", weaponType: "martialM", properties: { hvy: true, two: true } },
      { name: "Greatsword", actionType: "mwak", weaponType: "martialM", properties: { hvy: true, two: true } },
      { name: "Halberd", actionType: "mwak", weaponType: "martialM", properties: { hvy: true, two: true, rch: true } },
      { name: "Lance", actionType: "mwak", weaponType: "martialM", properties: { rch: true, spc: true } },
      { name: "Maul", actionType: "mwak", weaponType: "martialM", properties: { hvy: true, two: true } },
      { name: "Morningstar", actionType: "mwak", weaponType: "martialM", properties: {} },
      { name: "Pike", actionType: "mwak", weaponType: "martialM", properties: { hvy: true, two: true, rch: true } },
      { name: "Rapier", actionType: "mwak", weaponType: "martialM", properties: { fin: true } },
      { name: "Scimitar", actionType: "mwak", weaponType: "martialM", properties: { fin: true, lgt: true } },
      { name: "Shortsword", actionType: "mwak", weaponType: "martialM", properties: { fin: true, lgt: true } },
      { name: "Trident", actionType: "mwak", weaponType: "martialM", properties: { ver: true, thr: true } },
      { name: "War Pick", actionType: "mwak", weaponType: "martialM", properties: {} },
      { name: "Warhammer", actionType: "mwak", weaponType: "martialM", properties: { ver: true } },
      { name: "Whip", actionType: "mwak", weaponType: "martialM", properties: { fin: true, rch: true } },
      { name: "Blowgun", actionType: "rwak", weaponType: "martialR", properties: { amm: true, lod: true } },
      { name: "Heavy Crossbow", actionType: "rwak", weaponType: "martialR", properties: { amm: true, hvy: true, two: true, lod: true } },
      { name: "Longbow", actionType: "rwak", weaponType: "martialR", properties: { amm: true, hvy: true, two: true } },
      { name: "Net", actionType: "mwak", weaponType: "martialR", properties: { spc: true, thw: true } },
      { name: "Boomerang", actionType: "rwak", weaponType: "simpleR", properties: { amm: true } },
      { name: "Yklwa", actionType: "rwak", weaponType: "simpleR", properties: { amm: true } },
      { name: "Pistol", actionType: "rwak", weaponType: "martialR", properties: { amm: true, lod: true, fir: true } },
      { name: "Musket", actionType: "rwak", weaponType: "martialR", properties: { amm: true, lod: true, fir: true } },
      { name: "Bite", actionType: "mwak", weaponType: "natural", properties: {} },
      { name: "Claw", actionType: "mwak", weaponType: "natural", properties: {} },
      { name: "Tail", actionType: "mwak", weaponType: "natural", properties: {} },
      { name: "Wing", actionType: "mwak", weaponType: "natural", properties: {} },
      { name: "Slam", actionType: "mwak", weaponType: "natural", properties: {} },
      { name: "Rake", actionType: "mwak", weaponType: "natural", properties: {} },
      { name: "Beak", actionType: "mwak", weaponType: "natural", properties: {} },
      { name: "Tentacles", actionType: "mwak", weaponType: "natural", properties: {} },
    ],
    resets: [
      { id: 1, value: "sr" },
      { id: "ShortRest", value: "sr" },
      { id: "Short", value: "sr" },
      { id: "short", value: "sr" },
      { id: 2, value: "lr" },
      { id: "LongRest", value: "lr" },
      { id: "Long", value: "lr" },
      { id: "long", value: "lr" },
      { id: "Day", value: "day" },
      { id: "day", value: "day" },
      { id: "Dawn", value: "day" },
      { id: "dusk", value: "day" },
      { id: "Consumable", value: "charges" },
      { id: "Other", value: "charges" },
    ],
  }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DICTIONARY);


/***/ }),

/***/ 2877:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AD": () => (/* binding */ generateBonusACEffect),
/* harmony export */   "LY": () => (/* binding */ generateFixedACEffect),
/* harmony export */   "qI": () => (/* binding */ generateACEffectChangesForItem),
/* harmony export */   "se": () => (/* binding */ generateBaseACItemEffect)
/* harmony export */ });
/* harmony import */ var _lib_DDBHelper_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1438);
/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5259);
/* harmony import */ var _dictionary_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(37);
/* harmony import */ var _effects_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(5751);





// // ac -
// { type: "bonus", subType: "armor-class" },
// // e.g. robe of the archm
// { type: "set", subType: "unarmored-armor-class" },
// // bracers of defence
// { type: "bonus", subType: "unarmored-armor-class" },

/**
 *
 * @param {*} label
 */
function buildBaseACEffect(label) {
  let effect = {
    changes: [],
    duration: {
      seconds: null,
      startTime: null,
      rounds: null,
      turns: null,
      startRound: null,
      startTurn: null,
    },
    origin: null,
    label,
    tint: "",
    disabled: true,
    transfer: true,
    selectedKey: [],
    icon: "icons/svg/shield.svg",
  };
  return effect;
}

/**
 *
 * Generate an effect given inputs for AC
 * This is a high priority set effect that will typically override all other AE.
 * @param {*} formula
 * @param {*} label
 * @param {*} alwaysActive
 * @param {*} priority
 * @param {*} mode
 */
function generateFixedACEffect(formula, label, alwaysActive = false, priority = 30, mode = CONST.ACTIVE_EFFECT_MODES.OVERRIDE) {
  let effect = buildBaseACEffect(label);

  effect.flags = {
    dae: { transfer: true, armorEffect: true },
    ddbimporter: { disabled: !alwaysActive, itemId: null, entityTypeId: null, characterEffect: true },
  };
  // effect.disabled = !alwaysActive;
  effect.disabled = false;
  effect.origin = "AC";

  const change = {
    key: "system.attributes.ac.value",
    value: formula,
    mode,
    priority,
  };

  effect.changes.push(change);

  return effect;
}

/**
 * Generate stat sets
 *
 * @param {*} modifiers
 * @param {*} name
 * @param {*} subType
 */
function addACSetEffect(modifiers, name, subType) {
  let bonuses;

  if (modifiers.some((mod) => mod.statId !== null && mod.type === "set" && mod.subType === subType)) {
    modifiers.filter((mod) => mod.statId !== null && mod.type === "set" && mod.subType === subType)
      .forEach((mod) => {
        const ability = _dictionary_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].character.abilities.find */ .Z.character.abilities.find((ability) => ability.id === mod.statId);
        if (bonuses) {
          bonuses += " ";
        } else {
          bonuses = "";
        }
        bonuses += `@abilities.${ability.value}.mod`;
      });
  } else {
    // others are picked up here e.g. Draconic Resilience
    const fixedValues = modifiers.filter((mod) => mod.type === "set" && mod.subType === subType).map((mod) => mod.value);
    bonuses = Math.max(fixedValues);
  }

  let effects = [];
  const maxDexTypes = ["ac-max-dex-unarmored-modifier", "ac-max-dex-modifier"];

  if (bonuses && bonuses != 0) {
    let effectString = "";
    switch (subType) {
      case "unarmored-armor-class": {
        let maxDexMod = 99;
        const ignoreDexMod = modifiers.some((mod) => mod.type === "ignore" && mod.subType === "unarmored-dex-ac-bonus");
        const maxDexArray = modifiers
          .filter((mod) => mod.type === "set" && maxDexTypes.includes(mod.subType))
          .map((mod) => mod.value);
        if (maxDexArray.length > 0) maxDexMod = Math.min(maxDexArray);
        if (ignoreDexMod) {
          effectString = `10 + ${bonuses}`;
        } else {
          effectString = `@abilities.dex.mod > ${maxDexMod} ? 10 + ${bonuses} + ${maxDexMod} : 10 + ${bonuses} + @abilities.dex.mod`;
        }
        break;
      }
      default: {
        effectString = `10 + ${bonuses} + @abilities.dex.mod`;
      }
    }

    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Generating ${subType} AC set for ${name}: ${effectString}`);
    effects.push(
      (0,_effects_js__WEBPACK_IMPORTED_MODULE_3__/* .generateUpgradeChange */ .OY)(
        effectString,
        15,
        "system.attributes.ac.value"
      )
    );
  }
  return effects;
}

/**
 *
 * @param {*} modifiers
 * @param {*} name
 */
function addACSets(modifiers, name) {
  let changes = [];
  const stats = ["unarmored-armor-class"];
  stats.forEach((set) => {
    const result = addACSetEffect(modifiers, name, set);
    changes = changes.concat(result);
  });

  return changes;
}

/**
 * Generates an AC bonus for an item
 *
 * @param {*} modifiers
 * @param {*} name
 * @param {*} subType
 */
function addACBonusEffect(modifiers, name, subType, restrictions = ["while wearing heavy armor", "while not wearing heavy armor", "", null]) {
  const bonusModifiers = _lib_DDBHelper_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].filterModifiers */ .Z.filterModifiers(modifiers, "bonus", subType, restrictions);

  // using bonus here adds them to the bonus field, but then items that add a bonsu don't get applied
  // (e.g. bracers of defense) if wearing something like robi of archmage.
  // this is set to value, and show up as separate line in ac calculation.
  // we set this to bonus if dae is not installed as otherwise it is not applied.
  const key = game.modules.get("dae")?.active
    ? "system.attributes.ac.value"
    : "system.attributes.ac.bonus";

  const changes = (0,_effects_js__WEBPACK_IMPORTED_MODULE_3__/* .addAddEffect */ .Xk)(bonusModifiers, name, subType, key);
  if (changes.length > 0) _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Generating ${subType} bonus for ${name}`);

  return changes;
}


/**
 *
 * Generate an effect given inputs for AC
 * This is a high priority set effect that will typically override all other AE.
 * @param {*} formula
 * @param {*} label
 * @param {*} alwaysActive
 * @param {*} priority
 * @param {*} mode
 */
function generateBonusACEffect(modifiers, label, subType, restrictions = [], alwaysActive = true) {
  let effect = buildBaseACEffect(label);

  effect.flags = {
    dae: { transfer: true, armorEffect: true },
    ddbimporter: { disabled: !alwaysActive, itemId: null, entityTypeId: null, characterEffect: true },
  };
  // effect.disabled = !alwaysActive;
  effect.disabled = false;
  effect.origin = "AC";

  const changes = addACBonusEffect(modifiers, label, subType, restrictions);
  if (changes.length > 0) effect.changes = changes;

  return effect;
}

function addEffectFlags(foundryItem, effect, ddbItem, isCompendiumItem) {
  if (
    isCompendiumItem
    || foundryItem.type === "feat"
    || (ddbItem.isAttuned && ddbItem.equipped) // if it is attuned and equipped
    || (ddbItem.isAttuned && !ddbItem.definition.canEquip) // if it is attuned but can't equip
    || (!ddbItem.definition.canAttune && ddbItem.equipped) // can't attune but is equipped
  ) {
    setProperty(foundryItem, "flags.dae.alwaysActive", false);
    setProperty(effect, "flags.ddbimporter.disabled", false);
    effect.disabled = false;
  } else {
    effect.disabled = true;
    setProperty(effect, "flags.ddbimporter.disabled", true);
    setProperty(foundryItem, "flags.dae.alwaysActive", false);
  }

  setProperty(effect, "flags.ddbimporter.itemId", ddbItem.id);
  setProperty(effect, "flags.ddbimporter.itemEntityTypeId", ddbItem.entityTypeId);
  // set dae flag for active equipped
  if (ddbItem.definition?.canEquip || ddbItem.definition?.canAttune) {
    setProperty(foundryItem, "flags.dae.activeEquipped", true);
  } else {
    setProperty(foundryItem, "flags.dae.activeEquipped", false);
  }

  return [foundryItem, effect];
}

function generateBaseACEffectChanges(ddb, character, ddbItem, foundryItem, isCompendiumItem, effect) {
  const noModifiers = !ddbItem.definition?.grantedModifiers || ddbItem.definition.grantedModifiers.length === 0;
  // const noACValue = !foundryItem.system?.armor?.value;

  // note: I don't know why I had noACValue here. does this break stuff if I remove it?
  // if (noModifiers && noACValue) return [];
  if (noModifiers) return [];
  // console.error(`Item: ${foundryItem.name}`, ddbItem);
  _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Generating supported AC changes for ${foundryItem.name} for effect ${effect.label}`);

  // base ac from modifiers
  const acSets = game.modules.get("dae")?.active
    ? addACSets(ddbItem.definition.grantedModifiers, foundryItem.name)
    : [];

  // ac bonus effects
  const acBonus = addACBonusEffect(
    ddbItem.definition.grantedModifiers,
    foundryItem.name,
    "armor-class",
  );
  const unarmoredACBonus = addACBonusEffect(
    ddbItem.definition.grantedModifiers,
    foundryItem.name,
    "unarmored-armor-class",
  );
  const armoredACBonus = addACBonusEffect(
    ddbItem.definition.grantedModifiers,
    foundryItem.name,
    "armored-armor-class",
  );
  const dualWieldACBonus = addACBonusEffect(
    ddbItem.definition.grantedModifiers,
    foundryItem.name,
    "dual-wield-armor-class",
  );

  const acChanges = [
    ...acSets,
    ...acBonus,
    ...unarmoredACBonus,
    ...armoredACBonus,
    ...dualWieldACBonus,
  ];

  return acChanges;

}

// generates changes and adds to effect for item
function generateACEffectChangesForItem(ddb, character, ddbItem, foundryItem, isCompendiumItem, effect) {
  const noModifiers = !ddbItem.definition?.grantedModifiers || ddbItem.definition.grantedModifiers.length === 0;

  if (noModifiers) return [foundryItem, effect];

  const acChanges = generateBaseACEffectChanges(ddb, character, ddbItem, foundryItem, isCompendiumItem, effect);

  if (acChanges.length === 0) return [foundryItem, effect]; ;

  effect.changes = effect.changes.concat(acChanges);

  // generate flags for effect (e.g. checking attunement and equipped status)
  [foundryItem, effect] = addEffectFlags(foundryItem, effect, ddbItem, isCompendiumItem);

  return [foundryItem, effect];

}

/**
 *
 * @param {*} ddb
 * @param {*} character
 * @param {*} ddbItem
 * @param {*} foundryItem
 * @param {*} isCompendiumItem
 */
function generateBaseACItemEffect(ddb, character, ddbItem, foundryItem, isCompendiumItem) {
  const noModifiers = !ddbItem.definition?.grantedModifiers || ddbItem.definition.grantedModifiers.length === 0;
  const noACValue = !foundryItem.system?.armor?.value;

  if (noModifiers && noACValue) return foundryItem;
  // console.error(`Item: ${foundryItem.name}`, ddbItem);
  _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Generating supported AC effects for ${foundryItem.name}`);

  let effect = (0,_effects_js__WEBPACK_IMPORTED_MODULE_3__/* .baseItemEffect */ .uT)(foundryItem, `AC: ${foundryItem.name}`);

  // generate flags for effect (e.g. checking attunement and equipped status)
  [foundryItem, effect] = generateACEffectChangesForItem(ddb, character, ddbItem, foundryItem, isCompendiumItem, effect);

  if (effect.changes?.length > 0) {
    if (!foundryItem.effects) foundryItem.effects = [];
    foundryItem.effects.push(effect);
  }
  return foundryItem;
}


/***/ }),

/***/ 5751:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "Xk": () => (/* binding */ addAddEffect),
  "uT": () => (/* binding */ baseItemEffect),
  "Wk": () => (/* binding */ forceItemEffect),
  "Ci": () => (/* binding */ generateATLChange),
  "R5": () => (/* binding */ generateAddChange),
  "Tb": () => (/* binding */ generateBaseSkillEffect),
  "wv": () => (/* binding */ generateCustomChange),
  "K7": () => (/* binding */ generateEffects),
  "zs": () => (/* binding */ generateMultiplyChange),
  "Pk": () => (/* binding */ generateOverrideChange),
  "f6": () => (/* binding */ generateStatusEffectChange),
  "UY": () => (/* binding */ generateTokenMagicFXChange),
  "OY": () => (/* binding */ generateUpgradeChange),
  "qk": () => (/* binding */ getEffectExcludedModifiers)
});

// UNUSED EXPORTS: generateChange, generateCustomBonusChange, generateDowngradeChange, getMidiCEOnFlags

// EXTERNAL MODULE: ./src/lib/utils.js
var utils = __webpack_require__(7669);
// EXTERNAL MODULE: ./src/lib/DDBHelper.js
var DDBHelper = __webpack_require__(1438);
// EXTERNAL MODULE: ./src/logger.js
var logger = __webpack_require__(5259);
// EXTERNAL MODULE: ./src/dictionary.js
var dictionary = __webpack_require__(37);
// EXTERNAL MODULE: ./src/effects/specialEquipment.js + 5 modules
var specialEquipment = __webpack_require__(2340);
;// CONCATENATED MODULE: ./src/effects/specialInfusions.js
// import {
//   baseItemEffect,
//   generateUpgradeChange,
//   generateAddChange,
//   generateMultiplyChange,
//   generateCustomChange,
// } from "./effects.js";

/**
 * This function is mainly for effects that can't be dynamically generated
 * @param {*} document
 */
function infusionEffectAdjustment(document) {

  return document;
}

// EXTERNAL MODULE: ./src/effects/acEffects.js
var acEffects = __webpack_require__(2877);
// EXTERNAL MODULE: ./src/parser/DDBCharacter.js + 2 modules
var DDBCharacter = __webpack_require__(1269);
;// CONCATENATED MODULE: ./src/effects/effects.js








// import { spellEffectAdjustment } from "./specialSpells.js";

/**
 * Add supported effects here to exclude them from calculations.
 */
const EFFECT_EXCLUDED_COMMON_MODIFIERS = [
  { type: "bonus", subType: "saving-throws" },
  { type: "bonus", subType: "ability-checks" },
  { type: "bonus", subType: "skill-checks" },
  { type: "bonus", subType: "proficiency-bonus" },

  { type: "set", subType: "strength-score" },
  { type: "set", subType: "dexterity-score" },
  { type: "set", subType: "constitution-score" },
  { type: "set", subType: "wisdom-score" },
  { type: "set", subType: "intelligence-score" },
  { type: "set", subType: "charisma-score" },

  // skills
  { type: "bonus", subType: "acrobatics" },
  { type: "bonus", subType: "animal-handling" },
  { type: "bonus", subType: "arcana" },
  { type: "bonus", subType: "athletics" },
  { type: "bonus", subType: "deception" },
  { type: "bonus", subType: "history" },
  { type: "bonus", subType: "insight" },
  { type: "bonus", subType: "intimidation" },
  { type: "bonus", subType: "investigation" },
  { type: "bonus", subType: "medicine" },
  { type: "bonus", subType: "nature" },
  { type: "bonus", subType: "perception" },
  { type: "bonus", subType: "performance" },
  { type: "bonus", subType: "persuasion" },
  { type: "bonus", subType: "religion" },
  { type: "bonus", subType: "sleight-of-hand" },
  { type: "bonus", subType: "stealth" },
  { type: "bonus", subType: "survival" },
  // advantage on skills - not added here as not used elsewhere in importer.
  // { type: "advantage", subType: "acrobatics" },

  // initiative
  { type: "advantage", subType: "initiative" },

  { type: "bonus", subType: "strength-ability-checks" },
  { type: "bonus", subType: "dexterity-ability-checks" },
  { type: "bonus", subType: "constitution-ability-checks" },
  { type: "bonus", subType: "wisdom-ability-checks" },
  { type: "bonus", subType: "intelligence-ability-checks" },
  { type: "bonus", subType: "charisma-ability-checks" },

  { type: "bonus", subType: "strength-saving-throws" },
  { type: "bonus", subType: "dexterity-saving-throws" },
  { type: "bonus", subType: "constitution-saving-throws" },
  { type: "bonus", subType: "wisdom-saving-throws" },
  { type: "bonus", subType: "intelligence-saving-throws" },
  { type: "bonus", subType: "charisma-saving-throws" },

  // attack modifiers
  { type: "bonus", subType: "weapon-attacks" },
  { type: "bonus", subType: "melee-attacks" },
  { type: "bonus", subType: "ranged-attacks" },
  { type: "bonus", subType: "melee-weapon-attacks" },
  { type: "bonus", subType: "ranged-weapon-attacks" },
  { type: "damage", subType: null },
];

const EFFECT_EXCLUDED_SPELL_MODIFIERS = [
  { type: "bonus", subType: "spell-save-dc" },
  { type: "bonus", subType: "spell-attacks" },
  { type: "bonus", subType: "warlock-spell-save-dc" },
  { type: "bonus", subType: "warlock-spell-attacks" },
  { type: "bonus", subType: "spell-group-healing" } // system.bonuses.heal.damage
];

const EFFECT_EXCLUDED_HP_MODIFIERS = [
  { type: "bonus", subType: "hit-points-per-level" },
  { type: "bonus", subType: "hit-points" },
];

const EFFECT_EXCLUDED_SENSE_MODIFIERS = [
  // senses
  { type: "set-base", subType: "darkvision" },
  { type: "sense", subType: "darkvision" },
  { type: "set-base", subType: "blindsight" },
  { type: "sense", subType: "blindsight" },
  { type: "set-base", subType: "tremorsense" },
  { type: "sense", subType: "tremorsense" },
  { type: "set-base", subType: "truesight" },
  { type: "sense", subType: "truesight" },
];

const EFFECT_EXCLUDED_SPEED_SET_MODIFIERS = [
  // speeds
  { type: "set", subType: "innate-speed-walking" },
  { type: "set", subType: "innate-speed-climbing" },
  { type: "set", subType: "innate-speed-swimming" },
  { type: "set", subType: "innate-speed-flying" },
];

const EFFECT_EXCLUDED_SPEED_BONUS_MODIFIERS = [
  { type: "bonus", subType: "speed" },
  { type: "bonus", subType: "speed-walking" },
  { type: "bonus", subType: "speed-climbing" },
  { type: "bonus", subType: "speed-swimming" },
  { type: "bonus", subType: "speed-flying" },
];

const EFFECT_EXCLUDED_GENERAL_SPEED_MODIFIERS = EFFECT_EXCLUDED_SPEED_SET_MODIFIERS.concat(EFFECT_EXCLUDED_SPEED_BONUS_MODIFIERS);

const EFFECT_EXCLUDED_MONK_SPEED_MODIFIERS = [
  { type: "bonus", subType: "unarmored-movement" },
];

const EFFECT_EXCLUDED_ALL_SPEED_MODIFIERS = EFFECT_EXCLUDED_GENERAL_SPEED_MODIFIERS.concat(EFFECT_EXCLUDED_MONK_SPEED_MODIFIERS);

const EFFECT_EXCLUDED_ABILITY_BONUSES = [
  { type: "bonus", subType: "strength-score" },
  { type: "bonus", subType: "dexterity-score" },
  { type: "bonus", subType: "constitution-score" },
  { type: "bonus", subType: "wisdom-score" },
  { type: "bonus", subType: "intelligence-score" },
  { type: "bonus", subType: "charisma-score" },
];

const EFFECT_EXCLUDED_PROFICIENCY_BONUSES = [
  // profs
  { type: "proficiency", subType: null },
];

const EFFECT_EXCLUDED_LANGUAGES_MODIFIERS = [
  // languages - e.g. dwarvish -- lookup from DICTIONARY
  { type: "language", subType: null },
];

const EFFECT_EXCLUDED_DAMAGE_CONDITION_MODIFIERS = [
  // resistances - subType - e.g. poison - lookup from DICTIONARY
  { type: "resistance", subType: null },
  { type: "immunity", subType: null },
  { type: "vulnerability", subType: null },
];

const AC_BONUS_MODIFIERS = [
  { type: "bonus", subType: "unarmored-armor-class" },
  { type: "bonus", subType: "armor-class" },
  { type: "bonus", subType: "armored-armor-class" },
  { type: "bonus", subType: "dual-wield-armor-class" },
];

const AC_EFFECTS = [
  { type: "set", subType: "unarmored-armor-class" },
  { type: "ignore", subType: "unarmored-dex-ac-bonus" },
  { type: "set", subType: "ac-max-dex-modifier" },
];

function getEffectExcludedModifiers(type, features, ac) {
  let modifiers = [];

  if (type !== "item") {
    // these are the effect tweaks, and mostly excessive
    const speedEffect = game.settings.get("ddb-importer", `character-update-policy-effect-${type}-speed`);
    const senseEffect = game.settings.get("ddb-importer", `character-update-policy-effect-${type}-senses`);
    const hpEffect = game.settings.get("ddb-importer", `character-update-policy-effect-${type}-hp`);
    const spellBonusEffect = game.settings.get("ddb-importer", `character-update-policy-effect-${type}-spell-bonus`);
    const damageEffect = game.settings.get("ddb-importer", `character-update-policy-effect-${type}-damages`);

    // features represent core non ac features
    if (features) {
      modifiers = modifiers.concat(EFFECT_EXCLUDED_COMMON_MODIFIERS);
      if (["feat", "background", "race", "class"].includes(type)) {
        if (speedEffect) modifiers = modifiers.concat(EFFECT_EXCLUDED_GENERAL_SPEED_MODIFIERS);
        if (senseEffect) modifiers = modifiers.concat(EFFECT_EXCLUDED_SENSE_MODIFIERS);
        if (hpEffect) modifiers = modifiers.concat(EFFECT_EXCLUDED_HP_MODIFIERS);
        if (spellBonusEffect) modifiers = modifiers.concat(EFFECT_EXCLUDED_SPELL_MODIFIERS);
        if (damageEffect) modifiers = modifiers.concat(EFFECT_EXCLUDED_DAMAGE_CONDITION_MODIFIERS);
      }
      if (["class"].includes(type)) {
        modifiers = modifiers.concat(EFFECT_EXCLUDED_MONK_SPEED_MODIFIERS);
      } else if (["feat", "background", "race"].includes(type)) {
        if (speedEffect) modifiers = modifiers.concat(EFFECT_EXCLUDED_MONK_SPEED_MODIFIERS);
      }
    }
    // here ac represents the more exotic ac effects that set limits and change base
    modifiers = modifiers.concat(AC_BONUS_MODIFIERS);
    if (ac) {
      modifiers = modifiers.concat(AC_EFFECTS);
    }
  }

  // items are basically their own thing, all or nuffin
  if (type === "item") {
    modifiers = modifiers.concat(
      EFFECT_EXCLUDED_COMMON_MODIFIERS,
      EFFECT_EXCLUDED_ABILITY_BONUSES,
      EFFECT_EXCLUDED_DAMAGE_CONDITION_MODIFIERS,
      EFFECT_EXCLUDED_LANGUAGES_MODIFIERS,
      EFFECT_EXCLUDED_PROFICIENCY_BONUSES,
      EFFECT_EXCLUDED_ALL_SPEED_MODIFIERS,
      EFFECT_EXCLUDED_SENSE_MODIFIERS,
      EFFECT_EXCLUDED_HP_MODIFIERS,
      EFFECT_EXCLUDED_SPELL_MODIFIERS,
      AC_EFFECTS,
      AC_BONUS_MODIFIERS,
    );
  }
  return modifiers;
}

/**
 *
 * Generate a base effect for an Item
 *
 * @param {*} formula
 * @param {*} mode
 * @param {*} itemData
 * @param {*} label
 * @param {*} origin
 */

function baseItemEffect(foundryItem, label) {
  return {
    label,
    icon: foundryItem.img,
    changes: [],
    duration: {},
    // duration: {
    //   seconds: null,
    //   startTime: null,
    //   rounds: null,
    //   turns: null,
    //   startRound: null,
    //   startTurn: null,
    // },
    tint: "",
    transfer: true,
    disabled: false,
    // origin: origin,
    flags: {
      dae: {
        transfer: true,
        stackable: "none",
        // armorEffect: true
      },
      ddbimporter: {
        disabled: false,
      },
      "midi-qol": { // by default force CE effect usage to off
        forceCEOff: true,
      },
    },
  };
}

function getMidiCEOnFlags(midiFlags = {}) {
  setProperty(midiFlags, "forceCEOff", false);
  setProperty(midiFlags, "forceCEOn", true);
  return midiFlags;
}

function forceItemEffect(document) {
  if (document.effects.length > 0 || hasProperty(document.flags, "itemacro")) {
    setProperty(document, "flags.ddbimporter.effectsApplied", true);
    setProperty(document, "flags.midi-qol.forceCEOff", true);
  }
  return document;
}

// *
// CONST.ACTIVE_EFFECT_MODES.
// ADD: 2
// CUSTOM: 0
// DOWNGRADE: 3
// MULTIPLY: 1
// OVERRIDE: 5
// UPGRADE: 4
//

function generateBaseSkillEffect(id, label) {
  const mockItem = {
    img: "icons/svg/up.svg",
  };
  let skillEffect = baseItemEffect(mockItem, label);
  skillEffect.flags.dae = {};
  skillEffect.flags.ddbimporter.characterEffect = true;
  skillEffect.origin = `Actor.${id}`;
  delete skillEffect.transfer;
  return skillEffect;
}


function generateStatusEffectChange(statusName, priority = 20, macro = false) {
  const value = macro
    ? statusName
    : CONFIG.statusEffects.find((se) => se.name === statusName)?.id || statusName;
  if (!value) {
    logger/* default.error */.Z.error(`Status effect ${statusName} not found`);
  }
  return {
    key: macro && !value.startsWith("Convenient Effect:") ? "macro.CE" : "StatusEffect",
    mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
    value: macro || value.startsWith("Convenient Effect:") ? value : `Convenient Effect: ${value}`,
    priority: priority,
  };
}

function generateTokenMagicFXChange(macroValue, priority = 20) {
  return {
    key: 'macro.tokenMagic',
    mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
    value: macroValue,
    priority: priority,
  };
}

function generateATLChange(atlKey, mode, value, priority = 20) {
  let key = atlKey;

  switch (atlKey) {
    case 'ATL.dimLight':
      key = 'ATL.light.dim';
      break;
    case 'ATL.brightLight':
      key = 'ATL.light.bright';
      break;
    case 'ATL.lightAnimation':
      key = 'ATL.light.animation';
      break;
    case 'ATL.lightColor':
      key = 'ATL.light.color';
      break;
    case 'ATL.lightAlpha':
      key = 'ATL.light.alpha';
      break;
    case 'ATL.lightAngle':
      key = 'ATL.light.angle';
      break;
    // no default
  }

  return {
    key,
    mode,
    value,
    priority,
  };
}

function generateChange(bonus, priority, key, mode) {
  return {
    key: key,
    value: bonus,
    mode: mode,
    priority: priority,
  };
}

function generateAddChange(bonus, priority, key) {
  const bonusValue = (Number.isInteger(bonus) && bonus >= 0) // if bonus is a positive integer
    || (!Number.isInteger(bonus) && !bonus.trim().startsWith("+") && !bonus.trim().startsWith("-")) // not an int and does not start with + or -
    ? `+${bonus}`
    : bonus;
  return generateChange(bonusValue, priority, key, CONST.ACTIVE_EFFECT_MODES.ADD);
}

function generateCustomChange(bonus, priority, key) {
  return generateChange(bonus, priority, key, CONST.ACTIVE_EFFECT_MODES.CUSTOM);
}

function generateCustomBonusChange(bonus, priority, key) {
  const bonusValue = (Number.isInteger(bonus) && bonus >= 0) // if bonus is a positive integer
    || (!Number.isInteger(bonus) && !bonus.trim().startsWith("+") && !bonus.trim().startsWith("-")) // not an int and does not start with + or -
    ? `+${bonus}`
    : bonus;
  return generateChange(bonusValue, priority, key, CONST.ACTIVE_EFFECT_MODES.CUSTOM);
}

function generateUpgradeChange(bonus, priority, key) {
  return generateChange(bonus, priority, key, CONST.ACTIVE_EFFECT_MODES.UPGRADE);
}

function generateOverrideChange(bonus, priority, key) {
  return generateChange(bonus, priority, key, CONST.ACTIVE_EFFECT_MODES.OVERRIDE);
}

function generateMultiplyChange(bonus, priority, key) {
  return generateChange(bonus, priority, key, CONST.ACTIVE_EFFECT_MODES.MULTIPLY);
}

function generateDowngradeChange(bonus, priority, key) {
  return generateChange(bonus, priority, key, CONST.ACTIVE_EFFECT_MODES.DOWNGRADE);
}


// special effect functions
function attunedItemsBonus(actor, change) {
  // actor is the actor being processed and change a key/value pair
  if (change.key === "system.bonuses.abilities.save" && change.value === "ATTUNED_ITEM_BONUS") {
    // If your active effect spec was
    const bonus = actor.items.filter((item) => item.system.attunement == 2).length;
    // actor.system.bonuses.abilities.save += bonus;
    logger/* default.debug */.Z.debug(`Setting attuned items saving throw bonus for ${actor.name} to ${bonus}`);
    // setProperty(actor, "system.flags.ddbimporter.attundedItems", bonus);
    // this updates the effect value
    change.value = bonus;
    // console.warn(actor);
    // console.warn(change);
    // console.warn(bonus);
  }
}

Hooks.on("applyActiveEffect", attunedItemsBonus);


//
function extractModifierValue(modifier) {
  let value = "";
  let modBonus = "";

  let statBonus = (modifier.statId)
    ? modifier.statId
    : modifier.abilityModifierStatId
      ? modifier.abilityModifierStatId
      : null;

  if (statBonus) {
    const ability = dictionary/* default.character.abilities.find */.Z.character.abilities.find((ability) => ability.id === modifier.statId).value;
    modBonus = modBonus === "" ? `@abilities.${ability}.mod` : `+ @abilities.${ability}.mod`;
  }

  const die = modifier.dice ? modifier.dice : modifier.die ? modifier.die : undefined;

  if (die) {
    const fixedBonus = die.fixedValue ? ` + ${die.fixedValue}` : "";
    if (die.diceString) {
      value = die.diceString + modBonus + fixedBonus;
    } else if (fixedBonus) {
      value = fixedBonus + modBonus;
    }
  } else if (modifier.fixedValue) {
    value = modifier.fixedValue;
  } else if (modifier.value) {
    value = modifier.value;
  } else if (modBonus) {
    value = modBonus;
  }

  if (value === "" && modifier.subType == "saving-throws" && modifier.bonusTypes.includes(2)) {
    // we set the value to zero and when the saving throw is calculated it will
    // be updated by the attunedItemsBonus function above
    value = "ATTUNED_ITEM_BONUS";
  }

  return value;
}


function getValueFromModifiers(modifiers, name, modifierSubType, modifierType = "bonus") {
  let bonuses;
  const bonusEffects = DDBHelper/* default.filterModifiers */.Z.filterModifiers(modifiers, modifierType, modifierSubType, null);

  if (bonusEffects.length > 0) {
    logger/* default.debug */.Z.debug(`Generating ${modifierSubType} ${modifierType} for ${name}`);
    bonuses = "";
    bonusEffects.forEach((modifier) => {
      let bonusParse = extractModifierValue(modifier);
      if (bonuses !== "") bonuses += " + ";
      bonuses += bonusParse;
    });
    if (bonuses === "") {
      bonuses = undefined;
      logger/* default.debug */.Z.debug(`Modifier value 0 for ${modifierSubType} ${modifierType} for ${name}. Reset to undefined`);
    } else {
      logger/* default.debug */.Z.debug(`Modifier value string for ${modifierSubType} ${modifierType} for ${name}`, bonuses);
    }
  }

  return bonuses;
}

/**
 * Generates a global custom bonus for an item with a +
 */
function addCustomBonusEffect(modifiers, name, type, key) {
  let changes = [];
  const bonuses = getValueFromModifiers(modifiers, name, type, "bonus");

  if (bonuses) {
    changes.push(generateCustomChange(`${bonuses}`, 18, key));
    logger/* default.debug */.Z.debug(`Changes for ${type} bonus for ${name}`, changes);
  }

  return changes;
}

//
// Generate saving throw bonuses
//
function addGlobalSavingBonusEffect(modifiers, name) {
  const type = "saving-throws";
  const key = "system.bonuses.abilities.save";
  let changes = [];
  const regularBonuses = modifiers.filter((mod) => !mod.bonusTypes?.includes(2));
  const customBonuses = modifiers.filter((mod) => mod.bonusTypes?.includes(2));

  if (customBonuses.length > 0) {
    let customEffects = addCustomBonusEffect(customBonuses, name, type, key);
    changes = changes.concat(customEffects);
  }

  const regularModifiers = DDBHelper/* default.filterModifiers */.Z.filterModifiers(regularBonuses, "bonus", type);

  if (regularModifiers.length > 0) {
    logger/* default.debug */.Z.debug(`Generating ${type} bonus for ${name}`);
    let bonuses = "";
    regularModifiers.forEach((modifier) => {
      let bonusParse = extractModifierValue(modifier);
      if (bonuses !== "") bonuses += " + ";
      bonuses += bonusParse;
    });
    if (bonuses === "") bonuses = 0;
    changes.push(generateAddChange(`+ ${bonuses}`, 20, key));
    logger/* default.debug */.Z.debug(`Changes for ${type} bonus for ${name}`, changes);
  }

  return changes;
}

/**
 * Generates a global custom bonus for an item
 */
function addCustomEffect(modifiers, name, type, key, extra = "") {
  let changes = [];
  const bonus = DDBHelper/* default.filterModifiers */.Z.filterModifiers(modifiers, "bonus", type).reduce((a, b) => a + b.value, 0);
  if (bonus !== 0) {
    logger/* default.debug */.Z.debug(`Generating ${type} bonus for ${name}`);
    changes.push(generateCustomChange(`${bonus}${(extra) ? extra : ""}`, 18, key));
  }
  return changes;
}

/**
 * Generates a global add for an item
 */
function addAddEffect(modifiers, name, type, key) {
  let changes = [];
  // const bonus = DDBHelper.filterModifiers(modifiers, "bonus", type).reduce((a, b) => a + b.value, 0);
  const bonus = getValueFromModifiers(modifiers, name, type, "bonus");
  if (bonus) {
    logger/* default.debug */.Z.debug(`Generating ${type} bonus for ${name}`, bonus);
    changes.push(generateAddChange(`+ ${bonus}`, 18, key));
  }
  return changes;
}

/**
 * Adds languages, can't handle custom languages
 */
function addLanguages(modifiers, name) {
  let changes = [];

  const ddbCharacter = new DDBCharacter/* default */.Z();
  const languages = ddbCharacter.getLanguagesFromModifiers(modifiers);

  languages.value.forEach((prof) => {
    logger/* default.debug */.Z.debug(`Generating language ${prof} for ${name}`);
    changes.push(generateCustomChange(prof, 0, "system.traits.languages.value"));
  });
  if (languages?.custom != "") {
    logger/* default.debug */.Z.debug(`Generating language ${languages.custom} for ${name}`);
    changes.push(generateCustomChange(languages.custom, 0, "system.traits.languages.custom"));
  }

  return changes;
}


/**
 * Generate global damage bonuses
*/
function addGlobalDamageBonus(modifiers, name) {
  const meleeRestrictions = ["Melee Weapon Attacks"];
  let changes = [];
  const meleeBonus = DDBHelper/* default.filterModifiers */.Z.filterModifiers(modifiers, "damage", null, meleeRestrictions)
    .filter((mod) => mod.dice || mod.die || mod.value)
    .map((mod) => {
      const die = mod.dice ? mod.dice : mod.die ? mod.die : undefined;
      if (die) {
        return utils/* default.parseDiceString */.Z.parseDiceString(die.diceString, null, mod.subType ? `[${mod.subType}]` : null).diceString;
      } else {
        return utils/* default.parseDiceString */.Z.parseDiceString(mod.value, null, mod.subType ? `[${mod.subType}]` : null).diceString;
      }
    });
  if (meleeBonus && meleeBonus.length > 0) {
    logger/* default.debug */.Z.debug(`Generating melee damage for ${name}`);
    changes.push(generateCustomChange(`${meleeBonus.join(" + ")}`, 18, "system.bonuses.mwak.damage"));
  }
  const rangedRestrictions = ["Ranged Weapon Attacks"];
  const rangedBonus = DDBHelper/* default.filterModifiers */.Z.filterModifiers(modifiers, "damage", null, rangedRestrictions)
    .filter((mod) => mod.dice || mod.die || mod.value)
    .map((mod) => {
      const die = mod.dice ? mod.dice : mod.die ? mod.die : undefined;
      if (die) {
        return utils/* default.parseDiceString */.Z.parseDiceString(die.diceString, null, mod.subType ? `[${mod.subType}]` : null).diceString;
      } else {
        return utils/* default.parseDiceString */.Z.parseDiceString(mod.value, null, mod.subType ? `[${mod.subType}]` : null).diceString;
      }
    });
  if (rangedBonus && rangedBonus.length > 0) {
    logger/* default.debug */.Z.debug(`Generating ranged damage for ${name}`);
    changes.push(generateCustomChange(`${rangedBonus.join(" + ")}`, 18, "system.bonuses.rwak.damage"));
  }
  const bonus = DDBHelper/* default.filterModifiers */.Z.filterModifiers(modifiers, "damage", null)
    .filter((mod) => mod.dice || mod.die || mod.value)
    .map((mod) => {
      const die = mod.dice ? mod.dice : mod.die ? mod.die : undefined;
      if (die) {
        return utils/* default.parseDiceString */.Z.parseDiceString(die.diceString, null, mod.subType ? `[${mod.subType}]` : null).diceString;
      } else {
        return utils/* default.parseDiceString */.Z.parseDiceString(mod.value, null, mod.subType ? `[${mod.subType}]` : null).diceString;
      }
    });
  if (bonus && bonus.length > 0) {
    logger/* default.debug */.Z.debug(`Generating all damage for ${name}`);
    changes.push(generateCustomChange(`${bonus.join(" + ")}`, 18, "system.bonuses.mwak.damage"));
    changes.push(generateCustomChange(`${bonus.join(" + ")}`, 18, "system.bonuses.rwak.damage"));
  }
  return changes;
}

// *
// Get list of generic conditions/damages
//
function getGenericConditionAffect(modifiers, condition, typeId) {
  const damageTypes = dictionary/* default.character.damageAdjustments.filter */.Z.character.damageAdjustments.filter((type) => type.kind === condition && type.type === typeId)
    .map((type) => type.value);

  let restrictions = [
    "",
    null,
    "While within 20 feet",
    "Dwarf Only",
    "While Not Incapacitated",
    // "As an Action", this is a timed/limited effect, dealt with elsewhere
    "While Staff is Held",
    "Helm has at least one ruby remaining",
    "while holding",
    "While Held",
  ];
  let result = DDBHelper/* default.filterModifiers */.Z.filterModifiers(modifiers, condition, null, restrictions)
    .filter((modifier) => modifier.isGranted && damageTypes.includes(modifier.subType))
    .map((modifier) => {
      const entry = dictionary/* default.character.damageAdjustments.find */.Z.character.damageAdjustments.find(
        (type) => type.type === typeId && type.kind === modifier.type && type.value === modifier.subType
      );
      return entry ? entry.foundryValue || entry.value : undefined;
    });

  return result;
}

/**
 * Get  Damage Conditions, and Condition Immunities
 * @param {*} ddbItem
 */
function addDamageConditions(modifiers) {
  let charges = [];

  const damageImmunities = getGenericConditionAffect(modifiers, "immunity", 2);
  const damageResistances = getGenericConditionAffect(modifiers, "resistance", 2);
  const damageVulnerability = getGenericConditionAffect(modifiers, "vulnerability", 2);

  damageImmunities.forEach((type) => {
    charges.push(generateCustomChange(type, 1, "system.traits.di.value"));
  });
  damageResistances.forEach((type) => {
    charges.push(generateCustomChange(type, 1, "system.traits.dr.value"));
  });
  damageVulnerability.forEach((type) => {
    charges.push(generateCustomChange(type, 1, "system.traits.dv.value"));
  });

  const conditionImmunities = getGenericConditionAffect(modifiers, "immunity", 1);

  conditionImmunities.forEach((type) => {
    charges.push(generateCustomChange(type, 1, "system.traits.ci.value"));
  });

  // system.traits.di.all
  const allDamageImmunity = DDBHelper/* default.filterModifiers */.Z.filterModifiers(modifiers, "immunity", "all");
  if (allDamageImmunity?.length > 0) {
    charges.push(generateCustomChange(1, 1, "system.traits.di.all"));
  }

  return charges;
}

// *
// Generate stat bonuses
//
function addStatBonusEffect(modifiers, name, subType) {
  const bonuses = modifiers.filter((modifier) => modifier.type === "bonus" && modifier.subType === subType);

  let effects = [];
  if (bonuses.length > 0) {
    bonuses.forEach((bonus) => {
      const maxMatch = /Maximum of (\d*)/;
      const match = bonus.restriction ? bonus.restriction.match(maxMatch) : false;
      logger/* default.debug */.Z.debug(`Generating ${subType} stat bonus for ${name}`);
      const ability = dictionary/* default.character.abilities.find */.Z.character.abilities.find((ability) => ability.long === subType.split("-")[0]);
      const abilityScoreMaxBonus = modifiers
        .filter((modifier) => modifier.type === "bonus" && modifier.subType === "ability-score-maximum")
        .filter((mod) => mod.statId === ability.id)
        .reduce((prev, cur) => prev + cur.value, 0);
      const max = match ? match[1] : 20 + abilityScoreMaxBonus;

      const bonusString = `@abilities.${ability.value}.value + ${bonus.value} > ${max} ? ${max} : @abilities.${ability.value}.value + ${bonus.value}`;
      effects.push(generateOverrideChange(bonusString, 5, `system.abilities.${ability.value}.value`));
    });
  }
  return effects;
}

function addStatBonuses(modifiers, name) {
  let changes = [];
  const stats = [
    "strength-score",
    "dexterity-score",
    "constitution-score",
    "wisdom-score",
    "intelligence-score",
    "charisma-score",
  ];
  stats.forEach((stat) => {
    const result = addStatBonusEffect(modifiers, name, stat);
    changes = changes.concat(result);
  });

  return changes;
}

// *
// Generate stat sets
//
function addStatSetEffect(modifiers, name, subType) {
  const bonuses = modifiers.filter((modifier) => modifier.type === "set" && modifier.subType === subType);

  let effects = [];
  // dwarfen "Maximum of 20"
  if (bonuses.length > 0) {
    bonuses.forEach((bonus) => {
      logger/* default.debug */.Z.debug(`Generating ${subType} stat set for ${name}`);
      const ability = dictionary/* default.character.abilities.find */.Z.character.abilities.find((ability) => ability.long === subType.split("-")[0]).value;
      effects.push(generateUpgradeChange(bonus.value, 3, `system.abilities.${ability}.value`));
    });
  }
  return effects;
}

// requires midi
// does not add advantages with restrictions - which is most of them
function addAbilityAdvantageEffect(modifiers, name, subType, type) {
  const bonuses = DDBHelper/* default.filterModifiers */.Z.filterModifiers(modifiers, "advantage", subType);

  let effects = [];
  if (bonuses.length > 0) {
    logger/* default.debug */.Z.debug(`Generating ${subType} saving throw advantage for ${name}`);
    const ability = dictionary/* default.character.abilities.find */.Z.character.abilities.find((ability) => ability.long === subType.split("-")[0]).value;
    effects.push(generateCustomChange(1, 4, `flags.midi-qol.advantage.ability.${type}.${ability}`));
  }
  return effects;
}

function addStatChanges(modifiers, name) {
  let changes = [];
  const stats = ["strength", "dexterity", "constitution", "wisdom", "intelligence", "charisma"];
  stats.forEach((stat) => {
    const ability = dictionary/* default.character.abilities.find */.Z.character.abilities.find((ab) => ab.long === stat);
    const statEffect = addStatSetEffect(modifiers, name, `${stat}-score`);
    const savingThrowAdvantage = addAbilityAdvantageEffect(modifiers, name, `${stat}-saving-throw`, "save");
    const abilityCheckAdvantage = addAbilityAdvantageEffect(modifiers, name, `${stat}-ability-checks`, "check");
    const abilityBonusesSave = addAddEffect(modifiers, name, `${stat}-saving-throws`, `system.abilities.${ability.value}.bonuses.save`);
    const abilityBonusesCheck = addAddEffect(modifiers, name, `${stat}-ability-checks`, `system.abilities.${ability.value}.bonuses.check`);
    changes = changes.concat(statEffect, savingThrowAdvantage, abilityCheckAdvantage, abilityBonusesSave, abilityBonusesCheck);
  });

  return changes;
}

// *
// Senses
//
function addSenseBonus(modifiers, name) {
  let changes = [];

  const senses = ["darkvision", "blindsight", "tremorsense", "truesight"];

  senses.forEach((sense) => {
    const base = modifiers
      .filter((modifier) => modifier.type === "set-base" && modifier.subType === sense)
      .map((mod) => mod.value);
    if (base.length > 0) {
      logger/* default.debug */.Z.debug(`Generating ${sense} base for ${name}`);
      changes.push(generateUpgradeChange(Math.max(base), 10, `system.attributes.senses.${sense}`));
    }
    const bonus = modifiers
      .filter((modifier) => modifier.type === "sense" && modifier.subType === sense)
      .reduce((a, b) => a + b.value, 0);
    if (bonus > 0) {
      logger/* default.debug */.Z.debug(`Generating ${sense} bonus for ${name}`);
      changes.push(generateAddChange(Math.max(bonus), 15, `system.attributes.senses.${sense}`));
    }
  });
  return changes;
}

/**
 * Proficiency bonus
 */

function addProficiencyBonus(modifiers, name) {
  let changes = [];
  const bonus = DDBHelper/* default.filterModifiers */.Z.filterModifiers(modifiers, "bonus", "proficiency-bonus").reduce((a, b) => a + b.value, 0);
  if (bonus) {
    logger/* default.debug */.Z.debug(`Generating proficiency bonus for ${name}`);
    changes.push(generateAddChange(bonus, 0, "system.attributes.prof"));
  }
  return changes;
}

// *
// Generate set speeds
//
function addSetSpeedEffect(modifiers, name, subType) {
  const bonuses = modifiers.filter((modifier) => modifier.type === "set" && modifier.subType === subType);

  let effects = [];
  // "Equal to Walking Speed"
  if (bonuses.length > 0) {
    bonuses.forEach((bonus) => {
      logger/* default.debug */.Z.debug(`Generating ${subType} speed set for ${name}`);
      const innate = subType.split("-").slice(-1)[0];
      const speedType = dictionary/* default.character.speeds.find */.Z.character.speeds.find((s) => s.innate === innate).type;
      // current assumption if no speed provided, set to walking speed
      const speed = bonus.value ? bonus.value : "@attributes.movement.walk";
      effects.push(generateUpgradeChange(speed, 5, `system.attributes.movement.${speedType}`));
    });
  }
  return effects;
}

/**
 * Innate Speeds
 */
function addSetSpeeds(modifiers, name) {
  let changes = [];
  const speedSets = [
    "innate-speed-walking",
    "innate-speed-climbing",
    "innate-speed-swimming",
    "innate-speed-flying",
    "innate-speed-burrowing",
    "speed-walking",
    "speed-climbing",
    "speed-swimming",
    "speed-flying",
    "speed-burrowing",
  ];
  speedSets.forEach((speedSet) => {
    const result = addSetSpeedEffect(modifiers, name, speedSet);
    changes = changes.concat(result);
  });

  return changes;
}

// *
// Generate speed bonus speeds
//
function addBonusSpeedEffect(modifiers, name, subType, speedType = null) {
  const bonuses = modifiers.filter((modifier) => modifier.type === "bonus" && modifier.subType === subType);

  let effects = [];
  // "Equal to Walking Speed"
  // max(10+(ceil(((@classes.monk.levels)-5)/4))*5,10)
  if (bonuses.length > 0) {
    logger/* default.debug */.Z.debug(`Generating ${subType} speed bonus for ${name}`);
    if (!speedType) {
      const innate = subType.split("-").slice(-1)[0];
      speedType = dictionary/* default.character.speeds.find */.Z.character.speeds.find((s) => s.innate === innate).type;
    }
    const bonusValue = bonuses.reduce((speed, mod) => speed + mod.value, 0);
    if (speedType === "all") {
      effects.push(generateCustomChange(`+ ${bonusValue}`, 9, `system.attributes.movement.${speedType}`));
    } else {
      effects.push(generateAddChange(bonusValue, 9, `system.attributes.movement.${speedType}`));
    }
  }
  return effects;
}

/**
 * Bonus Speeds
 */
function addBonusSpeeds(modifiers, name) {
  let changes = [];
  const speedBonuses = ["speed-walking", "speed-climbing", "speed-swimming", "speed-flying", "speed-burrowing"];
  speedBonuses.forEach((speed) => {
    const result = addBonusSpeedEffect(modifiers, name, speed);
    changes = changes.concat(result);
  });

  changes = changes.concat(addBonusSpeedEffect(modifiers, name, "unarmored-movement", "walk"));
  changes = changes.concat(addBonusSpeedEffect(modifiers, name, "speed", "walk")); // probably all, but doesn't handle cases of where no base speed set, so say fly gets set to 10.

  return changes;
}

function addSkillProficiencies(modifiers) {
  let changes = [];
  const ddbCharacter = new DDBCharacter/* default */.Z();
  dictionary/* default.character.skills.forEach */.Z.character.skills.forEach((skill) => {
    const prof = ddbCharacter.getSkillProficiency(skill, modifiers);
    if (prof != 0) {
      changes.push(generateUpgradeChange(prof, 9, `system.skills.${skill.name}.value`));
    }
  });
  return changes;
}

function addProficiencies(modifiers, name) {
  let changes = [];

  const proficiencies = modifiers
    .filter((mod) => mod.type === "proficiency")
    .map((mod) => {
      return { name: mod.friendlySubtypeName };
    });

  const ddbCharacter = new DDBCharacter/* default */.Z();

  changes = changes.concat(addSkillProficiencies(modifiers));
  const toolProf = ddbCharacter.getToolProficiencies(proficiencies);
  const weaponProf = ddbCharacter.getWeaponProficiencies(proficiencies);
  const armorProf = ddbCharacter.getArmorProficiencies(proficiencies);

  toolProf.value.forEach((prof) => {
    logger/* default.debug */.Z.debug(`Generating tool proficiencies for ${name}`);
    changes.push(generateCustomChange(prof, 8, "system.traits.toolProf.value"));
  });
  weaponProf.value.forEach((prof) => {
    logger/* default.debug */.Z.debug(`Generating weapon proficiencies for ${name}`);
    changes.push(generateCustomChange(prof, 8, "system.traits.weaponProf.value"));
  });
  armorProf.value.forEach((prof) => {
    logger/* default.debug */.Z.debug(`Generating armor proficiencies for ${name}`);
    changes.push(generateCustomChange(prof, 8, "system.traits.armorProf.value"));
  });
  if (toolProf?.custom != "") changes.push(generateCustomChange(toolProf.custom, 8, "system.traits.toolProf.custom"));
  if (weaponProf?.custom != "")
    changes.push(generateCustomChange(weaponProf.custom, 8, "system.traits.weaponProf.custom"));
  if (armorProf?.custom != "") changes.push(generateCustomChange(armorProf.custom, 8, "system.traits.armorProf.custom"));

  return changes;
}

/**
 * Add HP effects
 * @param {*} modifiers
 * @param {*} name
 */
function addHPEffect(ddb, modifiers, name, consumable) {
  let changes = [];

  // HP per level
  DDBHelper/* default.filterModifiers */.Z.filterModifiers(modifiers, "bonus", "hit-points-per-level").forEach((bonus) => {
    const cls = DDBHelper/* default.findClassByFeatureId */.Z.findClassByFeatureId(ddb, bonus.componentId);
    if (cls) {
      logger/* default.debug */.Z.debug(`Generating HP Per Level effects for ${name} for class ${cls.definition.name}`);
      changes.push(generateAddChange(`${bonus.value} * @classes.${cls.definition.name.toLowerCase()}.levels`, 14, "system.attributes.hp.max"));
    } else {
      logger/* default.debug */.Z.debug(`Generating HP Per Level effects for ${name} for all levels`);
      changes.push(generateAddChange(`${bonus.value} * @details.level`, 14, "system.attributes.hp.max"));
    }
  });

  const hpBonusModifiers = DDBHelper/* default.filterModifiers */.Z.filterModifiers(modifiers, "bonus", "hit-points");
  if (hpBonusModifiers.length > 0 && !consumable) {
    let hpBonus = "";
    hpBonusModifiers.forEach((modifier) => {
      let hpParse = extractModifierValue(modifier);
      if (hpBonus !== "") hpBonus += " + ";
      hpBonus += hpParse;
    });
    changes.push(generateCustomChange(`${hpBonus}`, 14, "system.attributes.hp.max"));
  }

  return changes;
}

//
// Generate skill bonuses
//
function addSkillBonusEffect(modifiers, name, skill) {
  const bonus = getValueFromModifiers(modifiers, name, skill.subType, "bonus");

  let changes = [];
  if (bonus) {
    logger/* default.debug */.Z.debug(`Generating ${skill.subType} skill bonus for ${name}`, bonus);
    changes.push(generateAddChange(bonus, 12, `system.skills.${skill.name}.bonuses.check`));
  }
  return changes;
}

//
// generate skill advantages
// requires midi
//
function addSkillMidiEffect(modifiers, name, skill, midiEffect = "advantage") {
  const allowedRestrictions = [
    "",
    null,
    "Sound Only",
    "Sight Only",
    "that rely on smell",
    "While the hood is up, checks made to Hide ",
  ];
  const advantage = DDBHelper/* default.filterModifiers */.Z.filterModifiers(modifiers, midiEffect, skill.subType, allowedRestrictions);

  let effects = [];
  if (advantage.length > 0) {
    logger/* default.debug */.Z.debug(`Generating ${skill.subType} skill ${midiEffect} for ${name}`);
    effects.push(generateCustomChange(1, 5, `flags.midi-qol.${midiEffect}.skill.${skill.name}`));
    // handled by midi already
    // advantage/disadvantage on skill grants +/-5 passive bonus, https://www.dndbeyond.com/sources/phb/using-ability-scores#PassiveChecks
    // if (midiEffect === "advantage") {
    //   effects.push(generateAddChange(5, 5, `system.skills.${skill.name}.bonuses.passive`));
    // } else if (midiEffect === "disadvantage") {
    //   effects.push(generateAddChange(-5, 5, `system.skills.${skill.name}.bonuses.passive`));
    // }
  }
  return effects;
}

function addSkillBonuses(modifiers, name) {
  let changes = [];
  dictionary/* default.character.skills.forEach */.Z.character.skills.forEach((skill) => {
    const skillBonuses = addSkillBonusEffect(modifiers, name, skill);
    const skillAdvantages = addSkillMidiEffect(modifiers, name, skill, "advantage");
    changes = changes.concat(skillBonuses, skillAdvantages);
  });

  return changes;
}

//
// initiative
//
function addInitiativeBonuses(modifiers, name) {
  let changes = [];
  const advantage = DDBHelper/* default.filterModifiers */.Z.filterModifiers(modifiers, "advantage", "initiative");
  if (advantage.length > 0) {
    logger/* default.debug */.Z.debug(`Generating Intiative advantage for ${name}`);
    changes.push(generateCustomChange(1, 20, "flags.dnd5e.initiativeAdv"));
  }
  return changes;
}

//
// attack rolls against you
// midi only
//
function addAttackRollDisadvantage(modifiers, name) {
  let changes = [];
  const disadvantage = DDBHelper/* default.filterModifiers */.Z.filterModifiers(modifiers, "disadvantage", "attack-rolls-against-you", false);
  if (disadvantage.length > 0) {
    logger/* default.debug */.Z.debug(`Generating disadvantage for ${name}`);
    changes.push(generateCustomChange(1, 5, "flags.midi-qol.grants.disadvantage.attack.all"));
  }
  return changes;
}

// midi advantages on saving throws against spells and magical effects
function addMagicalAdvantage(modifiers, name) {
  let changes = [];
  const restrictions = [
    "against spells and magical effects",
    "Against Spells and Magical Effects",
    "Against Spells",
    "against spells",
    "Against spells",
    "Against spells and magical effects within 10 ft. (or 30 ft. at level 17+) while holding the Holy Avenger",
  ];
  const advantage = DDBHelper/* default.filterModifiers */.Z.filterModifiers(modifiers, "advantage", "saving-throws", restrictions);
  if (advantage.length > 0) {
    logger/* default.debug */.Z.debug(`Generating magical advantage on saving throws for ${name}`);
    changes.push(generateCustomChange("magic-resistant", 5, "system.traits.dr.custom"));
  }
  return changes;
}

function generateEffectDuration(foundryItem) {
  let duration = {
    seconds: null,
    startTime: null,
    rounds: null,
    turns: null,
    startRound: null,
    startTurn: null,
  };
  switch (foundryItem.system.duration.units) {
    case "turn":
      duration.turns = foundryItem.system.duration.value;
      break;
    case "round":
      duration.rounds = foundryItem.system.duration.value;
      break;
    case "hour":
      duration.seconds = foundryItem.system.duration.value * 60 * 60;
      break;
    case "minute":
      duration.rounds = foundryItem.system.duration.value * 10;
      break;
    // no default
  }
  return duration;
}

function consumableEffect(effect, ddbItem, foundryItem) {
  effect.label = `${foundryItem.name} - Consumable Effects`;
  effect.disabled = false;
  effect.transfer = false;
  setProperty(effect, "flags.ddbimporter.disabled", false);
  setProperty(effect, "flags.dae.transfer", false);
  effect.duration = generateEffectDuration(foundryItem);
  if (!foundryItem.system.target?.value) {
    foundryItem.system.target = {
      value: 1,
      width: null,
      units: "",
      type: "creature",
    };
  }
  if (!foundryItem.system.range?.units) {
    foundryItem.system.range = {
      value: null,
      long: null,
      units: "touch",
    };
  }
  if (foundryItem.system.uses) {
    foundryItem.system.uses.autoDestroy = true;
    foundryItem.system.uses.autoUse = true;
  }

  return effect;
}

/**
 * This checks attunement status and similar to determine effect state
 * set disabled flags etc
 * @param {*} foundryItem
 * @param {*} effect
 * @param {*} ddbItem
 * @param {*} isCompendiumItem
 */
function addEffectFlags(foundryItem, effect, ddbItem, isCompendiumItem) {
  // check attunement status etc

  if (
    !ddbItem.definition?.canEquip
    && !ddbItem.definition?.canAttune
    && !ddbItem.definition?.isConsumable
    && dictionary/* default.types.inventory.includes */.Z.types.inventory.includes(foundryItem.type)
  ) {
    // if item just gives a thing and not potion/scroll
    effect.disabled = false;
    setProperty(effect, "flags.ddbimporter.disabled", false);
    setProperty(foundryItem, "flags.dae.alwaysActive", true);
  } else if (
    isCompendiumItem
    || foundryItem.type === "feat"
    || (ddbItem.isAttuned && ddbItem.equipped) // if it is attuned and equipped
    || (ddbItem.isAttuned && !ddbItem.definition?.canEquip) // if it is attuned but can't equip
    || (!ddbItem.definition?.canAttune && ddbItem.equipped) // can't attune but is equipped
  ) {
    setProperty(foundryItem, "flags.dae.alwaysActive", false);
    setProperty(effect, "flags.ddbimporter.disabled", false);
    effect.disabled = false;
  } else {
    effect.disabled = true;
    setProperty(effect, "flags.ddbimporter.disabled", true);
    setProperty(foundryItem, "flags.dae.alwaysActive", false);
  }

  setProperty(effect, "flags.ddbimporter.itemId", ddbItem.id);
  setProperty(effect, "flags.ddbimporter.itemEntityTypeId", ddbItem.entityTypeId);
  // set dae flag for active equipped
  if (ddbItem.definition?.canEquip || ddbItem.definitio?.canAttune) {
    setProperty(foundryItem, "flags.dae.activeEquipped", true);
  } else {
    setProperty(foundryItem, "flags.dae.activeEquipped", false);
  }

  if (ddbItem.definition?.filterType === "Potion") {
    effect = consumableEffect(effect, ddbItem, foundryItem);
  }

  return [foundryItem, effect];
}

/**
 * Generate supported effects for items
 * @param {*} ddb
 * @param {*} character
 * @param {*} ddbItem
 * @param {*} foundryItem
 */
function generateGenericEffects(ddb, character, ddbItem, foundryItem, isCompendiumItem, labelOverride) {
  if (!foundryItem.effects) foundryItem.effects = [];

  const label = labelOverride
    ? labelOverride
    : `${foundryItem.name} - Constant Effects`;

  let effect = baseItemEffect(foundryItem, label);

  if (!ddbItem.definition?.grantedModifiers || ddbItem.definition.grantedModifiers.length === 0) return [foundryItem, effect];
  logger/* default.debug */.Z.debug(`Generating Effects for ${foundryItem.name}`, ddbItem);

  const globalSaveBonus = addGlobalSavingBonusEffect(ddbItem.definition.grantedModifiers, foundryItem.name);
  const globalAbilityBonus = addCustomBonusEffect(
    ddbItem.definition.grantedModifiers,
    foundryItem.name,
    "ability-checks",
    "system.bonuses.abilities.check",
  );
  const globalSkillBonus = addCustomBonusEffect(
    ddbItem.definition.grantedModifiers,
    foundryItem.name,
    "skill-checks",
    "system.bonuses.abilities.skill",
  );
  const languages = addLanguages(ddbItem.definition.grantedModifiers, foundryItem.name);
  const conditions = addDamageConditions(ddbItem.definition.grantedModifiers, foundryItem.name);
  const statSets = addStatChanges(ddbItem.definition.grantedModifiers, foundryItem.name);
  const statBonuses = addStatBonuses(ddbItem.definition.grantedModifiers, foundryItem.name);
  const senses = addSenseBonus(ddbItem.definition.grantedModifiers, foundryItem.name);
  const proficiencyBonus = addProficiencyBonus(ddbItem.definition.grantedModifiers, foundryItem.name);
  const speedSets = addSetSpeeds(ddbItem.definition.grantedModifiers, foundryItem.name);
  const spellAttackBonus = addCustomEffect(
    ddbItem.definition.grantedModifiers,
    foundryItem.name,
    "spell-attacks",
    "system.bonuses.spell.attack"
  );
  const spellDCBonus = addAddEffect(
    ddbItem.definition.grantedModifiers,
    foundryItem.name,
    "spell-save-dc",
    "system.bonuses.spell.dc"
  );
  const warlockSpellAttackBonus = addCustomEffect(
    ddbItem.definition.grantedModifiers,
    foundryItem.name,
    "warlock-spell-attacks",
    "system.bonuses.spell.attack"
  );
  const warlockSpellDCBonus = addAddEffect(
    ddbItem.definition.grantedModifiers,
    foundryItem.name,
    "warlock-spell-save-dc",
    "system.bonuses.spell.dc"
  );
  const healingSpellBonus = addCustomEffect(
    ddbItem.definition.grantedModifiers,
    foundryItem.name,
    "spell-group-healing",
    "system.bonuses.heal.damage",
    " + @item.level"
  );

  const profs = addProficiencies(ddbItem.definition.grantedModifiers, foundryItem.name);
  const hp = addHPEffect(ddb, ddbItem.definition.grantedModifiers, foundryItem.name, ddbItem.definition.isConsumable);
  const skillBonus = addSkillBonuses(ddbItem.definition.grantedModifiers, foundryItem.name);
  const initiative = addInitiativeBonuses(ddbItem.definition.grantedModifiers, foundryItem.name);
  const disadvantageAgainst = addAttackRollDisadvantage(ddbItem.definition.grantedModifiers, foundryItem.name);
  const magicalAdvantage = addMagicalAdvantage(ddbItem.definition.grantedModifiers, foundryItem.name);
  const bonusSpeeds = addBonusSpeeds(ddbItem.definition.grantedModifiers, foundryItem.name);

  const meleeAttackBonus = addCustomEffect(
    ddbItem.definition.grantedModifiers,
    foundryItem.name,
    "melee-attacks",
    "system.bonuses.mwak.attack"
  );
  const rangedAttackBonus = addCustomEffect(
    ddbItem.definition.grantedModifiers,
    foundryItem.name,
    "ranged-attacks",
    "system.bonuses.rwak.attack"
  );
  const meleeWeaponAttackBonus = addCustomEffect(
    ddbItem.definition.grantedModifiers,
    foundryItem.name,
    "melee-weapon-attacks",
    "system.bonuses.mwak.attack"
  );
  const rangedWeaponAttackBonus = addCustomEffect(
    ddbItem.definition.grantedModifiers,
    foundryItem.name,
    "ranged-weapon-attacks",
    "system.bonuses.rwak.attack"
  );
  const weaponAttackMeleeBonus = addCustomEffect(
    ddbItem.definition.grantedModifiers,
    foundryItem.name,
    "weapon-attacks",
    "system.bonuses.mwak.attack"
  );
  const weaponAttackRangedBonus = addCustomEffect(
    ddbItem.definition.grantedModifiers,
    foundryItem.name,
    "weapon-attacks",
    "system.bonuses.rwak.attack"
  );

  const globalDamageBonus = addGlobalDamageBonus(ddbItem.definition.grantedModifiers, foundryItem.name);

  effect.changes = [
    ...globalSaveBonus,
    ...globalAbilityBonus,
    ...globalSkillBonus,
    ...languages,
    ...conditions,
    ...statSets,
    ...statBonuses,
    ...senses,
    ...proficiencyBonus,
    ...speedSets,
    ...spellAttackBonus,
    ...warlockSpellAttackBonus,
    ...spellDCBonus,
    ...warlockSpellDCBonus,
    ...profs,
    ...hp,
    ...skillBonus,
    ...initiative,
    ...disadvantageAgainst,
    ...magicalAdvantage,
    ...bonusSpeeds,
    ...healingSpellBonus,
    ...meleeAttackBonus,
    ...rangedAttackBonus,
    ...meleeWeaponAttackBonus,
    ...rangedWeaponAttackBonus,
    ...weaponAttackMeleeBonus,
    ...weaponAttackRangedBonus,
    ...globalDamageBonus,
  ];

  // if we don't have effects, lets return the item
  if (effect.changes?.length === 0) {
    return [foundryItem, effect];
  }

  // generate flags for effect (e.g. checking attunement and equipped status)
  [foundryItem, effect] = addEffectFlags(foundryItem, effect, ddbItem, isCompendiumItem);

  return [foundryItem, effect];
}

function generateEffects(ddb, character, ddbItem, foundryItem, isCompendiumItem, type) {
  let label;

  if (type === "item" && hasProperty(ddbItem, "definition.grantedModifiers")) {
    ddbItem.definition.grantedModifiers = ddbItem.definition.grantedModifiers.filter((modifier) =>
      modifier.type !== "damage" && modifier.subType !== null
    );
  }

  if (type == "infusion") {
    label = `${foundryItem.name} - Infusion Effects`;
  }
  let effect;
  [foundryItem, effect] = generateGenericEffects(ddb, character, ddbItem, foundryItem, isCompendiumItem, label);
  if (type == "infusion") {
    [foundryItem, effect] = (0,acEffects/* generateACEffectChangesForItem */.qI)(ddb, character, ddbItem, foundryItem, isCompendiumItem, effect);
  }
  if (effect.changes?.length > 0) {
    foundryItem.effects.push(effect);
  }
  switch (type) {
    case "infusion": {
      foundryItem = infusionEffectAdjustment(foundryItem);
      break;
    }
    case "equipment":
    case "item": {
      foundryItem = (0,specialEquipment/* equipmentEffectAdjustment */._)(foundryItem);
      break;
    }
    // spells and feats get called from respective parsers for async loading
    // no default
  }

  if (foundryItem.effects?.length > 0 || hasProperty(foundryItem.flags, "itemacro")) {
    logger/* default.debug */.Z.debug(`${type} effect ${foundryItem.name}:`, duplicate(foundryItem));
    setProperty(foundryItem, "flags.ddbimporter.effectsApplied", true);
  }
  return foundryItem;

}


/***/ }),

/***/ 3752:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Kk": () => (/* binding */ createGMMacros),
/* harmony export */   "SI": () => (/* binding */ configureDependencies),
/* harmony export */   "UG": () => (/* binding */ createMacro),
/* harmony export */   "Vw": () => (/* binding */ MACROS),
/* harmony export */   "dp": () => (/* binding */ loadMacroFile),
/* harmony export */   "gL": () => (/* binding */ generateItemMacroFlag),
/* harmony export */   "n4": () => (/* binding */ generateMacroChange),
/* harmony export */   "ob": () => (/* binding */ executeDDBMacro)
/* harmony export */ });
/* unused harmony export checkMacroFolder */
/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5259);
/* harmony import */ var _lib_FileHelper_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2397);
/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(6451);




async function checkMacroFolder() {
  const macroFolder = game.folders.find((folder) => folder.name === "DDB Macros" && folder.type === "Macro");

  if (!macroFolder) {
    await Folder.create({
      color: "#FF0000",
      name: "DDB Macros",
      parent: null,
      type: "Macro"
    });
  }
}

function configureDependencies() {
  // allow item use macros on items
  if (game.modules.get("midi-qol")?.active) {
    let midiQOLSettings = game.settings.get("midi-qol", "ConfigSettings");
    if (!midiQOLSettings.allowUseMacro) {
      midiQOLSettings.allowUseMacro = true;
      game.settings.set("midi-qol", "ConfigSettings", midiQOLSettings);
    }
  } else {
    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].error */ .Z.error("Midi-QOL needs to be installed for effects");
    ui.notifications.warn("Midi-QOL needs to be installed for effects");
  }

  const useCEConditions = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "apply-conditions-with-ce");
  // if dfreds status effects not added, add them
  if (game.modules.get("dfreds-convenient-effects")?.active && useCEConditions) {
    const convenientEffectStatusSettings = game.settings.get("dfreds-convenient-effects", "modifyStatusEffects");
    if (!convenientEffectStatusSettings || convenientEffectStatusSettings === "none") {
      game.settings.set("dfreds-convenient-effects", "modifyStatusEffects", "add");
    }
  } else if (useCEConditions) {
    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].error */ .Z.error("Convenient Effects needs to be installed for effects");
    ui.notifications.warn("Convenient Effects needs to be installed for effects");
  }

  if (game.modules.get("itemacro")?.active) {
    const itemMacroSheet = game.settings.get("itemacro", "charsheet");
    if (itemMacroSheet) {
      game.settings.get("itemacro", "charsheet", false);
    }
  } else {
    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].error */ .Z.error("Item Macro needs to be installed for effects");
    ui.notifications.warn("Item Macro needs to be installed for effects");
  }

  return true;
}

async function loadMacroFile(type, fileName, forceLoad = false, forceDDB = false) {
  const embedMacros = game.settings.get("ddb-importer", "embed-macros");
  _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug(`Getting macro for ${type} ${fileName}`);
  const fileExists = forceLoad || (typeof ForgeVTT !== "undefined" && ForgeVTT?.usingTheForge)
    ? true
    : await _lib_FileHelper_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].fileExists */ .Z.fileExists(`[data] modules/ddb-importer/macros/${type}s`, fileName);

  let data;
  if (fileExists && (forceLoad || embedMacros) && !forceDDB) {
    const url = await _lib_FileHelper_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].getFileUrl */ .Z.getFileUrl(`[data] modules/ddb-importer/macros/${type}s`, fileName);
    const response = await fetch(url, { method: "GET" });
    data = await response.text();
  } else if (fileExists && (!embedMacros || forceDDB)) {
    data = `// Execute DDB Importer dynamic macro\nreturn game.modules.get("ddb-importer")?.api.executeDDBMacro("${type}", "${fileName}", ...args);`;
  } else if (!fileExists) {
    data = "// Unable to load the macro file";
  }
  return data;
}

function generateItemMacroFlag(document, macroText) {
  return {
    macro: {
      data: {
        name: document.name,
        type: "script",
        scope: "global",
        command: macroText,
      },
      options: {},
      apps: {},
      compendium: null,
    },
  };
}

function generateMacroChange(macroValues, priority = 20, local = false) {
  const macroKey = local ? "macro.itemMacro.local" : "macro.itemMacro";
  return {
    key: macroKey,
    value: macroValues,
    mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
    priority: priority,
  };
}

async function createMacro({ name, content, img, isGM, isTemp }) {
  const macroFolder = isTemp
    ? undefined
    : game.folders.find((folder) => folder.name === "DDB Macros" && folder.type === "Macro");

  const data = {
    "name": name,
    "type": "script",
    "img": img ? img : "icons/svg/dice-target.svg",
    "scope": "global",
    "command": content,
    "folder": macroFolder ? macroFolder.id : undefined,
    "flags": {
      "advanced-macros": {
        "runAsGM": isGM
      },
    }
  };

  const existingMacro = game.macros.find((m) => m.name == name);
  if (existingMacro) data._id = existingMacro.id;
  const macro = existingMacro
    ? existingMacro.update(data)
    : Macro.create(data, {
      temporary: isTemp,
      displaySheet: false,
    });

  return macro;

}

const MACROS = {
  AA_ONLY: {
    name: "Active Aura Only (Generic)",
    type: "generic",
    file: "activeAuraConditionOnEntry.js",
    isGM: false,
    img: null,
    world: true,
  },
  AA_ON_ENTRY: {
    name: "Active Aura Damage and Condition On Entry (Generic)",
    type: "generic",
    file: "activeAuraDamageAndConditionOnEntry.js",
    isGM: false,
    img: null,
    world: true,
  },
  AA_CONDITION_ON_ENTRY: {
    name: "Active Aura Condition On Entry (Generic)",
    type: "generic",
    file: "activeAuraConditionOnEntry.js",
    isGM: false,
    img: null,
    world: true,
  },
  AA_DAMAGE_ON_ENTRY: {
    name: "Active Aura Damage On Entry (Generic)",
    type: "generic",
    file: "activeAuraDamageOnEntry.js",
    isGM: false,
    img: null,
    world: true,
  },
  DARKNESS_GM: {
    name: "Darkness (DDB - GM)",
    type: "gm",
    file: "darkness.js",
    isGM: true,
    img: "icons/magic/unholy/orb-glowing-yellow-purple.webp",
    world: true,
  },
  CHILL_TOUCH: {
    name: "Chill Touch (Target effect)",
    type: "spell",
    file: "chillTouchWorld.js",
    isGM: false,
    img: "icons/magic/fire/flame-burning-hand-purple.webp",
    world: true,
  }
};

async function createGMMacros() {
  if (game.user.isGM) {
    await checkMacroFolder();

    for (const macro of Object.values(MACROS).filter((m) => m.world)) {
      // eslint-disable-next-line no-await-in-loop
      const macroFile = await loadMacroFile(macro.type, macro.file, true);
      if (macroFile) {
        // eslint-disable-next-line no-await-in-loop
        await createMacro({ name: macro.name, content: macroFile, img: macro.img, isGM: macro.isGM, isTemp: false });
      }
    }
  }
}

async function executeDDBMacro(type, fileName, ...params) {
  if (!fileName.endsWith(".js")) fileName = `${fileName}.js`;
  const strippedName = fileName.split(".js")[0];
  let macro = CONFIG.DDBI.MACROS[type]?.[strippedName];
  if (!macro) {
    const macroText = await loadMacroFile(type, fileName, true);
    if (!macroText) {
      ui.notifications.error(`Unable to load macro (${type}) ${fileName}`);
      _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].warn */ .Z.warn(`Unable to load macro (${type}) ${fileName}`);
      throw new Error(`Unable to load macro (${type}) ${fileName}`);
    }

    // eslint-disable-next-line require-atomic-updates
    macro = await createMacro({ name: `${type} ${fileName}`, content: macroText, img: null, isGM: false, isTemp: true });
    // eslint-disable-next-line require-atomic-updates
    setProperty(CONFIG.DDBI.MACROS, `${type}.${strippedName}`, macro);
    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug(`Macro (${type}) ${fileName} loaded from file into cache`, macro);
  }

  _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug(`Calling (${type}) ${fileName} with params`, ...params);
  return macro.execute(...params);
}


/***/ }),

/***/ 2340:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "_": () => (/* binding */ equipmentEffectAdjustment),
  "i": () => (/* binding */ midiItemEffects)
});

// EXTERNAL MODULE: ./src/effects/effects.js + 1 modules
var effects = __webpack_require__(5751);
// EXTERNAL MODULE: ./src/effects/specialFeats.js + 51 modules
var specialFeats = __webpack_require__(9038);
;// CONCATENATED MODULE: ./src/effects/items/bootsOfSpeed.js


function bootsOfSpeedEffect(document) {
  let effect = (0,effects/* baseItemEffect */.uT)(document, `${document.name}`);
  effect.changes.push((0,effects/* generateMultiplyChange */.zs)(2, 20, "system.attributes.movement.walk"));
  effect.duration = {
    startTime: null,
    seconds: 600,
    rounds: null,
    turns: null,
    startRound: null,
    startTurn: null,
  };
  effect.transfer = true;
  effect.disabled = true;
  effect.flags.dae.transfer = true;
  effect.flags.dae.stackable = true;
  document.system.target = {
    value: null,
    width: null,
    units: "",
    type: "self",
  };
  document.system.range = {
    value: null,
    long: null,
    units: "self",
  };
  document.system.activation.type = "bonus";
  document.effects.push(effect);

  return document;
}

// EXTERNAL MODULE: ./src/effects/macros.js
var macros = __webpack_require__(3752);
;// CONCATENATED MODULE: ./src/effects/items/cloakOfDisplacement.js



async function cloakOfDisplacementEffect(document) {
  let effect = (0,effects/* baseItemEffect */.uT)(document, `${document.name} - Check`);
  setProperty(effect, "flags.dae.macroRepeat", "startEveryTurn");
  const itemMacroText = await (0,macros/* loadMacroFile */.dp)("item", "cloakOfDisplacement.js");
  document.flags["itemacro"] = (0,macros/* generateItemMacroFlag */.gL)(document, itemMacroText);
  effect.changes.push((0,macros/* generateMacroChange */.n4)(""));
  document.effects[0] = effect;

  // setProperty(document.effects[0], "flags.dae.specialDuration", ["isDamaged"]);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/items/javelinOfLightning.js



async function javelinOfLightningEffect(document) {
  let effect = (0,effects/* baseItemEffect */.uT)(document, `${document.name}: Used Effect Tracker`);
  const itemMacroText = await (0,macros/* loadMacroFile */.dp)("item", "javelinOfLightning.js");
  document.flags["itemacro"] = (0,macros/* generateItemMacroFlag */.gL)(document, itemMacroText);
  effect.changes.push((0,macros/* generateMacroChange */.n4)(`"${document.name}"`));
  effect.transfer = false;
  setProperty(effect, "flags.dae.specialDuration", ["newDay", "longRest"]);
  setProperty(effect, "flags.dae.selfTarget", true);
  setProperty(effect, "flags.dae.selfTargetAlways", true);
  document.effects.push(effect);

  setProperty(document, "flags.midi-qol.onUseMacroName", "[postActiveEffects]ItemMacro,[postDamageRoll]ItemMacro,[preAttackRoll]ItemMacro");

  // setProperty(document.effects[0], "flags.dae.specialDuration", ["isDamaged"]);
  document.system.uses = {
    value: null,
    max: "",
    per: "",
  };

  return document;
}

;// CONCATENATED MODULE: ./src/effects/items/moonSickle.js
function moonSickleEffect(document) {
  document.effects[0].changes.push(
    {
      key: "system.bonuses.heal.damage",
      mode: CONST.ACTIVE_EFFECT_MODES.ADD,
      value: "+ d4",
      priority: "20",
    },
  );

  return document;
}

;// CONCATENATED MODULE: ./src/effects/items/pearlOfPower.js



async function pearlOfPowerEffect(document) {
  let effect = (0,effects/* baseItemEffect */.uT)(document, document.name);
  const itemMacroText = await (0,macros/* loadMacroFile */.dp)("item", "pearlOfPower.js");
  document.flags["itemacro"] = (0,macros/* generateItemMacroFlag */.gL)(document, itemMacroText);
  effect.changes.push((0,macros/* generateMacroChange */.n4)(`"${document.name}"`));
  effect.transfer = false;
  setProperty(effect, "flags.dae.selfTarget", true);
  setProperty(effect, "flags.dae.selfTargetAlways", true);
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/specialEquipment.js


// load item effects







async function midiItemEffects(document) {
  if (!(0,specialFeats/* featEffectModules */.wU)().hasCore) return document;
  const name = document.flags.ddbimporter.originalName || document.name;
  switch (name) {
    case "Cloak of Displacement": {
      document = await cloakOfDisplacementEffect(document);
      break;
    }
    case "Javelin of Lightning":
    case "Tempus Javelin": {
      document = await javelinOfLightningEffect(document);
      break;
    }
    case "Pearl of Power": {
      document = await pearlOfPowerEffect(document);
      break;
    }
    // no default
  }

  return (0,effects/* forceItemEffect */.Wk)(document);
}

/**
 * This function is mainly for effects that can't be dynamically generated
 * @param {*} document
 */
function equipmentEffectAdjustment(document) {
  const name = document.flags.ddbimporter.originalName || document.name;
  switch (name) {
    case "Armor of Invulnerability": {
      // this effect is 1/day, we have to add it
      let effect = (0,effects/* baseItemEffect */.uT)(document, `${document.name} - Invulnerability`);
      effect.changes.push((0,effects/* generateAddChange */.R5)("physical", 20, "system.traits.di.value"));
      effect.duration = {
        startTime: null,
        seconds: 600,
        rounds: null,
        turns: null,
        startRound: null,
        startTurn: null,
      };
      effect.transfer = false;
      effect.disabled = false;
      effect.flags.dae.transfer = false;
      effect.flags.dae.stackable = false;
      document.system.uses = {
        value: 1,
        max: "1",
        per: "day",
      };
      document.system.target = {
        value: null,
        width: null,
        units: "",
        type: "self",
      };
      document.system.range = {
        value: null,
        long: null,
        units: "self",
      };
      document.effects.push(effect);
      break;
    }
    case "Bracers of Archery": {
      // +2 damage to longbows/shortbows translates to +2 ranged weapon damage
      document.effects[0].changes.push({
        key: "system.bonuses.rwak.damage",
        value: "+2",
        mode: 0,
        priority: 20,
      });
      break;
    }
    case "Demon Armor": {
      // Unarmed strikes bonus/weapons
      document.effects[0].changes.push(
        {
          key: "items.Unarmed Strike.system.attackBonus",
          value: "1",
          mode: 2,
          priority: 20,
        },
        {
          key: "items.Unarmed Strike.system.damage.parts.0.0",
          value: "1d8+@mod+1",
          mode: 5,
          priority: 20,
        },
        {
          key: "items.Unarmed Strike.system.properties.mgc",
          value: "true",
          mode: 5,
          priority: 20,
        }
      );
      break;
    }
    case "Belashyrraâ€™s Beholder Crown": {
      let effect = (0,effects/* baseItemEffect */.uT)(document, `${document.name} - Constant Effects`);
      effect.changes.push((0,effects/* generateUpgradeChange */.OY)(120, 10, "system.attributes.senses.darkvision"));
      document.effects.push(effect);
      break;
    }
    case "Boots of Speed": {
      document = bootsOfSpeedEffect(document);
      break;
    }
    case "Moon Sickle, +1":
    case "Moon Sickle, +2":
    case "Moon Sickle, +3":
    case "Moon Sickle": {
      document = moonSickleEffect(document);
      break;
    }
    case "Spellguard Shield": {
      document.effects[0].changes.push(
        (0,effects/* generateCustomChange */.wv)(1, 20, "flags.midi-qol.grants.disadvantage.attack.msak"),
        (0,effects/* generateCustomChange */.wv)(1, 20, "flags.midi-qol.grants.disadvantage.attack.rsak")
      );
      break;
    }
    // no default
  }

  if (document.effects.length > 0 || hasProperty(document.flags, "itemacro")) {
    setProperty(document, "flags.ddbimporter.effectsApplied", true);
  }

  return document;
}


/***/ }),

/***/ 9038:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "zd": () => (/* binding */ baseFeatEffect),
  "wU": () => (/* binding */ featEffectModules),
  "MD": () => (/* binding */ featureEffectAdjustment)
});

// EXTERNAL MODULE: ./src/effects/macros.js
var macros = __webpack_require__(3752);
// EXTERNAL MODULE: ./src/effects/effects.js + 1 modules
var effects = __webpack_require__(5751);
;// CONCATENATED MODULE: ./src/effects/feats/ancestralProtectors.js



async function ancestralProtectorsEffect(document) {
  const itemMacroText = await (0,macros/* loadMacroFile */.dp)("feat", "ancestralProtectors.js");
  document.flags["itemacro"] = (0,macros/* generateItemMacroFlag */.gL)(document, itemMacroText);

  let effect = baseFeatEffect(document, document.name);
  effect.changes.push({
    key: "flags.midi-qol.onUseMacroName",
    value: "ItemMacro.Ancestral Protectors,postAttackRoll",
    mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
    priority: "20",
  });


  effect.transfer = true;
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/arcaneWard.js



async function arcaneWardEffect(document) {
  let detectionEffect = (0,effects/* baseItemEffect */.uT)(document, `${document.name}: Spell Detection`);
  const itemMacroText = await (0,macros/* loadMacroFile */.dp)("feat", "arcaneWard.js");
  document.flags["itemacro"] = (0,macros/* generateItemMacroFlag */.gL)(document, itemMacroText);

  detectionEffect.changes.push({
    key: "flags.midi-qol.onUseMacroName",
    value: `ItemMacro.${document.name}, preActiveEffects`,
    mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
    priority: "20",
  });

  document.effects.push(detectionEffect);
  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/bardicInspiration.js


function bardicInspirationEffect(document) {
  document.system.damage.parts = [];
  let inspiredEffect = (0,effects/* baseItemEffect */.uT)(document, "Inspired");

  const diceString = "@scale.bard.bardic-inspiration";
  inspiredEffect.changes.push(
    {
      key: "flags.midi-qol.optional.bardicInspiration.attack.all",
      mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
      value: diceString,
      priority: "20",
    },
    {
      key: "flags.midi-qol.optional.bardicInspiration.save.all",
      mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
      value: diceString,
      priority: "20",
    },
    {
      key: "flags.midi-qol.optional.bardicInspiration.check.all",
      mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
      value: diceString,
      priority: "20",
    },
    {
      key: "flags.midi-qol.optional.bardicInspiration.skill.all",
      mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
      value: diceString,
      priority: "20",
    },
    {
      key: "flags.midi-qol.optional.bardicInspiration.label",
      mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
      value: "Bardic Inspiration",
      priority: "20",
    }
  );
  inspiredEffect.transfer = false;
  inspiredEffect.disabled = false;
  setProperty(inspiredEffect, "flags.dae.transfer", false);
  setProperty(inspiredEffect, "flags.dae.stackable", false);
  setProperty(inspiredEffect, "flags.dae.macroRepeat", "none");
  setProperty(inspiredEffect, "flags.dae.specialDuration", []);

  if (document.flags.ddbimporter.subclass === "College of Valor") {
    inspiredEffect.changes.push(
      {
        key: "flags.midi-qol.optional.bardicInspiration.damage.all",
        mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
        value: diceString,
        priority: "20",
      },
      {
        key: "flags.midi-qol.optional.bardicInspiration.ac.all",
        mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
        value: diceString,
        priority: "20",
      }
    );
  }

  document.effects.push(inspiredEffect);

  setProperty(document, "flags.midi-qol.effectActivation", false);
  return document;
}


;// CONCATENATED MODULE: ./src/effects/feats/bladesong.js


function bladesongEffect(document) {
  let effect = baseFeatEffect(document, `${document.name}`);

  setProperty(document, "system.range", { value: null, units: "self", long: null });
  setProperty(document, "system.range.value", null);
  setProperty(document, "system.target.type", "self");
  setProperty(effect, "flags.dae.selfTarget", true);
  setProperty(effect, "flags.dae.selfTargetAlways", true);

  effect.changes.push(
    {
      key: "system.attributes.ac.bonus",
      value: "max(@abilities.int.mod,1)",
      mode: CONST.ACTIVE_EFFECT_MODES.ADD,
      priority: 20,
    },
    {
      key: "flags.midi-qol.advantage.skill.acr",
      value: "1",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      priority: 20,
    },
    {
      key: "flags.midi-qol.concentrationSaveBonus",
      value: "max(@abilities.int.mod,1)",
      mode: CONST.ACTIVE_EFFECT_MODES.ADD,
      priority: 20,
    },
    {
      key: "system.attributes.movement.walk",
      mode: CONST.ACTIVE_EFFECT_MODES.ADD,
      value: "10",
      priority: "20",
    },
  );
  effect.duration = {
    startTime: null,
    seconds: 60,
    rounds: null,
    turns: null,
    startRound: null,
    startTurn: null,
  };
  document.effects.push(effect);
  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/blessedHealer.js



async function blessedHealerEffect(document) {
  let effect = (0,effects/* baseItemEffect */.uT)(document, document.name);
  const itemMacroText = await (0,macros/* loadMacroFile */.dp)("feat", "blessedHealer.js");
  document.flags["itemacro"] = (0,macros/* generateItemMacroFlag */.gL)(document, itemMacroText);

  effect.changes.push({
    key: "flags.midi-qol.onUseMacroName",
    value: "ItemMacro.Blessed Healer, postActiveEffects",
    mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
    priority: "20",
  });
  setProperty(document, "flags.midi-qol.onUseMacroName", "[postActiveEffects]ItemMacro");

  document.effects.push(effect);
  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/blessedStrikes.js


function blessedStrikesEffect(document) {
  if (document.system.actionType === null) return document;
  let effect = baseFeatEffect(document, document.name);

  effect.changes.push(
    {
      key: "flags.midi-qol.optional.blessedstrikes.label",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: `${document.name} Bonus Damage`,
      priority: "5",
    },
    {
      key: "flags.midi-qol.optional.blessedstrikes.count",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: "each-round",
      priority: "5",
    },
    {
      key: "flags.midi-qol.optional.blessedstrikes.damage.all",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: `${document.system.damage.parts[0][0]}`,
      priority: "5",
    },
  );

  document.system.damage.parts = [];
  document.system.actionType = null;
  effect.transfer = true;

  document.effects.push(effect);
  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/cloudRune.js
function cloudRuneEffect(document) {
  // Missing: reaction effect to transfer attack
  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/crossbowExpert.js


function crossbowExpertEffect(document) {
  let effect = baseFeatEffect(document, document.name);
  effect.changes.push({
    key: "flags.midi-qol.ignoreNearbyFoes",
    value: "1",
    mode: CONST.ACTIVE_EFFECT_MODES.ADD,
    priority: 20,
  });
  effect.transfer = true;
  document.effects.push(effect);
  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/defensiveDuelist.js


function defensiveDuelistEffect(document) {
  let effect = baseFeatEffect(document, document.name);
  effect.changes.push(
    {
      key: "system.attributes.ac.bonus",
      mode: CONST.ACTIVE_EFFECT_MODES.ADD,
      value: "@system.attributes.prof",
      priority: "20",
    },
  );
  setProperty(effect, "duration.turns", 1);
  setProperty(effect, "flags.dae.specialDuration", ["isAttacked"]);
  setProperty(effect, "flags.dae.selfTarget", true);
  setProperty(effect, "flags.dae.selfTargetAlways", true);
  document.system.target = {
    value: null,
    width: null,
    units: "",
    type: "self",
  };
  document.system.range = {
    value: null,
    long: null,
    units: "self",
  };
  document.system.duration = {
    value: null,
    units: "inst",
  };
  document.system.actionType = null;
  document.effects.push(effect);
  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/deflectMissiles.js


function deflectMissilesEffect(document) {
  let effect = baseFeatEffect(document, document.name);
  effect.changes.push({
    key: "flags.midi-qol.DR.rwak",
    value: "[[1d10 + @mod + @classes.monk.levels]]",
    mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
    priority: 0,
  });
  effect.flags.dae.specialDuration = ["1Reaction"];
  setProperty(effect, "flags.dae.selfTarget", true);
  setProperty(effect, "flags.dae.selfTargetAlways", true);
  setProperty(document, "system.activation.type", "reactiondamage");

  document.system["target"]["type"] = "self";
  document.system.range = { value: null, units: "self", long: null };

  document.effects.push(effect);
  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/favoredFoe.js



// this one is a bit different, the macro is triggered by midi-qol and applies effects to the actor
// the Marked effect gets applied to the target
async function favoredFoeEffect(document) {
  let effect = baseFeatEffect(document, `Marked by ${document.name}`);
  effect.changes.push(
    {
      key: "flags.dae.onUpdateSource",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: document.name,
      priority: 20,
    },
  );
  effect.transfer = false;
  effect.duration.seconds = 60;
  document.effects.push(effect);

  let damageBonusEffect = baseFeatEffect(document, document.name);
  damageBonusEffect.changes.push({
    key: "flags.dnd5e.DamageBonusMacro",
    value: "ItemMacro",
    mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
    priority: 20,
  });
  damageBonusEffect.transfer = true;

  setProperty(damageBonusEffect, "flags.dae.transfer", true);
  document.effects.push(damageBonusEffect);

  const itemMacroText = await (0,macros/* loadMacroFile */.dp)("feat", "favoredFoe.js");
  setProperty(document, "flags.itemacro", (0,macros/* generateItemMacroFlag */.gL)(document, itemMacroText));
  setProperty(document, "flags.midi-qol.onUseMacroName", "[postActiveEffects]ItemMacro");

  setProperty(document, "system.actionType", "util");
  document.system.damage.parts = [];
  document.system.target = {
    value: 1,
    width: null,
    units: "",
    type: "creature",
  };
  document.system.range = {
    value: null,
    long: null,
    units: "",
  };

  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/fightingStyles.js


function fightingStyleInterceptionEffect(document) {
  let effect = baseFeatEffect(document, document.name);
  effect.changes.push(
    {
      key: "flags.midi-qol.DR.rwak",
      mode: 0,
      value: "1d10 + @system.attributes.prof",
      priority: "20",
    },
    {
      key: "flags.midi-qol.DR.mwak",
      mode: 2,
      value: "1d10 + @system.attributes.prof",
      priority: "20",
    },
    {
      key: "flags.midi-qol.DR.msak",
      mode: 2,
      value: "1d10 + @system.attributes.prof",
      priority: "20",
    },
    {
      key: "flags.midi-qol.DR.rsak",
      mode: 2,
      value: "1d10 + @system.attributes.prof",
      priority: "20",
    }
  );
  setProperty(effect, "duration.turns", 1);
  setProperty(effect, "flags.dae.specialDuration", ["isDamaged"]);
  document.system.target = {
    value: 1,
    width: null,
    units: "",
    type: "creature",
  };
  document.system.damage.parts = [];
  document.system.duration = {
    value: null,
    units: "inst",
  };
  document.effects.push(effect);
  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/fireRune.js



function fireRuneEffect(document) {
  setProperty(document, "system.range.units", "");
  setProperty(document, "system.target.value", 1);
  setProperty(document, "system.target.type", "creature");

  let baseEffect = baseFeatEffect(document, document.name);
  setProperty(baseEffect, "duration.seconds", 60);

  baseEffect.changes.push((0,effects/* generateStatusEffectChange */.f6)("Restrained", 20, true));
  baseEffect.changes.push(
    {
      key: "flags.midi-qol.OverTime",
      mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
      value: `label=${document.name} (Start of Turn Damage),turn=start,savingThrow=false,damageRoll=${document.system.damage.parts[0][0]}, damageType=${document.system.damage.parts[0][1]}`,
      priority: "20",
    },
    {
      key: "flags.midi-qol.OverTime",
      mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
      value: `label=${document.name} (End of Turn Save),turn=end,saveDC=@attributes.spelldc,saveAbility=${document.system.save.ability},savingThrow=true,saveMagic=true,saveRemove=true`,
      priority: "20",
    }
  );

  document.effects.push(baseEffect);
  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/fontOfMagic.js



async function fontOfMagicEffect(document) {
  let effect = (0,effects/* baseItemEffect */.uT)(document, document.name);
  const itemMacroText = await (0,macros/* loadMacroFile */.dp)("feat", "fontOfMagic.js");
  document.flags["itemacro"] = (0,macros/* generateItemMacroFlag */.gL)(document, itemMacroText);
  setProperty(document, "flags.midi-qol.onUseMacroName", "[preItemRoll]ItemMacro");

  document.effects.push(effect);
  document.system.activation.type = "bonus";
  document.system["target"]["type"] = "self";
  document.system.range = { value: null, units: "self", long: null };

  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/frostRune.js


function frostRuneEffect(document) {
  setProperty(document, "system.target.type", "self");
  setProperty(document, "system.range.units", "self");
  setProperty(document, "system.range.value", "");
  setProperty(document, "system.actionType", null);

  let bonusEffect = baseFeatEffect(document, `${document.name} (Sturdiness)`);
  bonusEffect.changes.push(
    {
      key: "system.abilities.con.bonuses.check",
      mode: CONST.ACTIVE_EFFECT_MODES.ADD,
      value: "+2",
      priority: "20",
    },
    {
      key: "system.abilities.con.bonuses.save",
      mode: CONST.ACTIVE_EFFECT_MODES.ADD,
      value: "+2",
      priority: "20",
    },
    {
      key: "system.abilities.str.bonuses.check",
      mode: CONST.ACTIVE_EFFECT_MODES.ADD,
      value: "+2",
      priority: "20",
    },
    {
      key: "system.abilities.str.bonuses.save",
      mode: CONST.ACTIVE_EFFECT_MODES.ADD,
      value: "+2",
      priority: "20",
    },
  );
  setProperty(bonusEffect, "duration.seconds", 600);
  document.effects.push(bonusEffect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/giantsMight.js



function giantsMightEffect(document) {
  let effect = baseFeatEffect(document, document.name);

  if (featEffectModules().atlInstalled) {
    effect.changes.push((0,effects/* generateATLChange */.Ci)("ATL.width", CONST.ACTIVE_EFFECT_MODES.UPGRADE, 2, 5));
    effect.changes.push((0,effects/* generateATLChange */.Ci)("ATL.height", CONST.ACTIVE_EFFECT_MODES.UPGRADE, 2, 5));
  }

  effect.changes.push({
    key: "flags.midi-qol.advantage.ability.save.str",
    mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
    value: "1",
    priority: "5",
  },
  {
    key: "flags.midi-qol.advantage.ability.check.str",
    mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
    value: "1",
    priority: "5",
  },
  {
    key: "flags.midi-qol.optional.giantsmight.label",
    mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
    value: "Giant's Might Bonus Damage",
    priority: "5",
  },
  {
    key: "flags.midi-qol.optional.giantsmight.count",
    mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
    value: "each-round",
    priority: "5",
  },
  {
    key: "flags.midi-qol.optional.giantsmight.damage.all",
    mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
    value: `${document.system.damage.parts[0][0]}`,
    priority: "5",
  });

  document.system.damage.parts = [];

  document.effects.push(effect);
  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/heavyArmorMaster.js


function heavyArmorMasterEffect(document) {
  let effect = baseFeatEffect(document, `${document.name}`);
  effect.changes.push(
    {
      key: "flags.midi-qol.DR.non-magical",
      mode: CONST.ACTIVE_EFFECT_MODES.ADD,
      value: "3",
      priority: "20",
    },
  );
  effect.transfer = true;
  document.effects.push(effect);
  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/hillRune.js


function hillRuneEffect(document) {
  setProperty(document, "system.target.type", "self");
  setProperty(document, "system.range.units", "self");
  setProperty(document, "system.range.value", "");
  setProperty(document, "system.actionType", null);

  let bonusEffect = baseFeatEffect(document, `${document.name} (Temporary)`);
  bonusEffect.changes.push(
    {
      key: "system.traits.dr.value",
      mode: CONST.ACTIVE_EFFECT_MODES.ADD,
      value: "bludgeoning",
      priority: "20",
    },
    {
      key: "system.traits.dr.value",
      mode: CONST.ACTIVE_EFFECT_MODES.ADD,
      value: "slashing",
      priority: "20",
    },
    {
      key: "system.traits.dr.value",
      mode: CONST.ACTIVE_EFFECT_MODES.ADD,
      value: "piercing",
      priority: "20",
    },
  );
  setProperty(bonusEffect, "duration.seconds", 60);

  document.effects.push(bonusEffect);
  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/indomitable.js


function indomitableEffect(document) {
  let effect = (0,effects/* baseItemEffect */.uT)(document, document.name);
  effect.changes.push(
    {
      key: "flags.midi-qol.optional.Indomitable.save.fail",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: "reroll",
      priority: "20",
    },
    {
      key: "flags.midi-qol.optional.Indomitable.count",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: "ItemUses.Indomitable",
      priority: "20",
    },
    {
      key: "flags.midi-qol.optional.Indomitable.label",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: "Use Indomitable to Succeed?",
      priority: "20",
    }
  );
  document.effects.push(effect);
  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/kiEmptyBody.js



function kiEmptyBodyEffect(document) {
  let effect = baseFeatEffect(document, document.name);
  effect.changes.push(
    { key: "system.traits.dr.all", value: "", mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM, priority: 0 },
    { key: "system.traits.dv.value", value: "force", mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM, priority: 0 },
    (0,effects/* generateStatusEffectChange */.f6)("invisible"),
  );

  document.system["target"]["type"] = "self";
  document.system.range = { value: null, units: "self", long: null };
  document.system.duration = { value: 1, units: "min" };
  document.system.actionType = null;

  document.effects.push(effect);
  return document;
}

// EXTERNAL MODULE: ./src/logger.js
var logger = __webpack_require__(5259);
;// CONCATENATED MODULE: ./src/effects/feats/maneuvers.js





// eslint-disable-next-line complexity
async function maneuversEffect(ddb, character, document) {
  const fighterClass = ddb.character.classes.find((klass) => klass.definition.name === "Fighter");
  if (!fighterClass) return document;
  const combatSuperiority = fighterClass.classFeatures.find((feat) => feat.definition.name === "Combat Superiority");
  if (!combatSuperiority) return document;
  const diceString = "@scale.battle-master.combat-superiority-die";

  logger/* default.debug */.Z.debug(`Generating effect for ${document.name}`);

  const characterAbilities = character.flags.ddbimporter.dndbeyond.effectAbilities;
  const ability = characterAbilities.str?.value > characterAbilities.dex?.value ? "str" : "dex";

  const name = document.flags.ddbimporter.originalName || document.name;
  let effect = baseFeatEffect(document, document.name);
  setProperty(document, "system.range.units", "");
  setProperty(document, "system.range.value", null);
  setProperty(document, "system.target.type", "self");

  // special durations
  switch (name) {
    case "Maneuvers: Rally": {
      setProperty(effect, "duration.seconds", 86400);
      setProperty(effect, "flags.dae.specialDuration", ["longRest"]);
      break;
    }
    case "Maneuvers: Brace":
    case "Maneuvers: Riposte": {
      setProperty(effect, "flags.dae.specialDuration", ["1Attack:mwak"]);
      setProperty(effect, "duration.turns", 2);
      break;
    }
    case "Maneuvers: Lunging Attack":
    case "Maneuvers: Sweeping Attack": {
      setProperty(effect, "duration.turns", 1);
      setProperty(effect, "flags.dae.specialDuration", ["1Attack:mwak"]);
      break;
    }
    case "Maneuvers: Quick Toss": {
      setProperty(effect, "duration.turns", 1);
      setProperty(effect, "flags.dae.specialDuration", ["1Attack:rwak"]);
      break;
    }
    case "Maneuvers: Tactical Assessment": {
      setProperty(effect, "flags.dae.specialDuration", ["isSkill.inv", "isSkill.his", "isSkill.ins"]);
      break;
    }
    case "Maneuvers: Commanding Presence": {
      setProperty(effect, "flags.dae.specialDuration", ["isSkill.itm", "isSkill.per", "isSkill.prf"]);
      break;
    }
    case "Maneuvers: Ambush": {
      setProperty(effect, "duration.turns", 1);
      setProperty(effect, "flags.dae.specialDuration", ["isSkill.ste"]);
      break;
    }
    case "Maneuvers: Distracting Strike": {
      setProperty(effect, "flags.dae.specialDuration", ["isAttacked", "turnStartSource"]);
      break;
    }
    case "Maneuvers: Bait and Switch": {
      setProperty(effect, "flags.dae.specialDuration", ["turnStartSource"]);
      break;
    }
    case "Maneuvers: Feinting Attack": {
      setProperty(effect, "duration.turns", 1);
      setProperty(effect, "flags.dae.specialDuration", ["1Attack"]);
      break;
    }
    case "Maneuvers: Trip Attack": {
      setProperty(document, "system.duration.units", "inst");
      break;
    }
    case "Maneuvers: Menacing Attack":
    case "Maneuvers: Goading Attack": {
      setProperty(effect, "flags.dae.specialDuration", ["turnEndSource"]);
      break;
    }
    case "Maneuvers: Grappling Strike": {
      setProperty(effect, "duration.turns", 1);
      setProperty(effect, "flags.dae.specialDuration", ["isSkill.ath"]);
      break;
    }
    case "Maneuvers: Parry": {
      setProperty(document, "system.duration.units", "inst");
      setProperty(effect, "flags.dae.specialDuration", ["isDamaged"]);
      break;
    }
    // no default
  }

  const damageEffect = {
    "key": "system.bonuses.mwak.damage",
    "mode": CONST.ACTIVE_EFFECT_MODES.ADD,
    "value": `+ ${diceString}`,
    "priority": "20"
  };
  // damage effect
  switch (name) {
    case "Maneuvers: Riposte":
    case "Maneuvers: Brace": {
      // manual reaction types
      setProperty(document, "system.activation.type", "reactionmanual");
      effect.changes.push(damageEffect);
      document.effects.push(effect);
      break;
    }
    case "Maneuvers: Quick Toss":
    case "Maneuvers: Lunging Attack":
    case "Maneuvers: Feinting Attack": {
      effect.changes.push(damageEffect);
      document.effects.push(effect);
      break;
    }
    // no default
  }

  const rangedDamageEffect = {
    "key": "system.bonuses.rwak.damage",
    "mode": CONST.ACTIVE_EFFECT_MODES.ADD,
    "value": `+ ${diceString}`,
    "priority": "20"
  };
  // damage effect
  switch (name) {
    case "Maneuvers: Commanderâ€™s Strike":
    case "Maneuvers: Commander's Strike": {
      effect.changes.push(damageEffect);
      effect.changes.push(rangedDamageEffect);
      document.effects.push(effect);
      break;
    }
    // no default
  }

  // other effects
  switch (name) {
    // advantage effect
    case "Maneuvers: Distracting Strike":
    case "Maneuvers: Feinting Attack": {
      effect.changes.push(
        {
          "key": "flags.midi-qol.advantage.attack.all",
          "mode": CONST.ACTIVE_EFFECT_MODES.ADD,
          "value": "1",
          "priority": "20"
        }
      );
      document.effects.push(effect);
      break;
    }
    // skill bonus
    case "Maneuvers: Commanding Presence": {
      ["per", "itm", "prf"].forEach((skill) => {
        effect.changes.push(
          {
            "key": `system.skills.${skill}.value`,
            "mode": CONST.ACTIVE_EFFECT_MODES.ADD,
            "value": `+ ${diceString}`,
            "priority": "20"
          }
        );
      });
      document.effects.push(effect);
      break;
    }
    case "Maneuvers: Tactical Assessment": {
      ["inv", "his", "ins"].forEach((skill) => {
        effect.changes.push(
          {
            "key": `system.skills.${skill}.value`,
            "mode": CONST.ACTIVE_EFFECT_MODES.ADD,
            "value": `+ ${diceString}`,
            "priority": "20"
          }
        );
      });
      document.effects.push(effect);
      break;
    }
    case "Maneuvers: Ambush": {
      effect.changes.push(
        {
          "key": "system.skills.ste.value",
          "mode": CONST.ACTIVE_EFFECT_MODES.ADD,
          "value": `+ ${diceString}`,
          "priority": "20"
        },
        {
          "key": "system.attributes.init.bonus",
          "mode": CONST.ACTIVE_EFFECT_MODES.ADD,
          "value": `+ ${diceString}`,
          "priority": "20"
        }
      );
      document.effects.push(effect);
      break;
    }
    case "Maneuvers: Evasive Footwork":
    case "Maneuvers: Bait and Switch": {
      effect.changes.push(
        {
          "key": "system.attributes.ac.bonus",
          "mode": CONST.ACTIVE_EFFECT_MODES.ADD,
          "value": `+ ${diceString}`,
          "priority": "20"
        }
      );
      document.effects.push(effect);
      break;
    }
    case "Maneuvers: Grappling Strike": {
      effect.changes.push(
        {
          "key": "system.skills.ath.value",
          "mode": CONST.ACTIVE_EFFECT_MODES.ADD,
          "value": `+ ${diceString}`,
          "priority": "20"
        },
      );
      document.effects.push(effect);
      break;
    }
    case "Maneuvers: Menacing Attack": {
      effect.changes.push((0,effects/* generateStatusEffectChange */.f6)("Frightened"));
      break;
    }
    case "Maneuvers: Trip Attack": {
      effect.changes.push((0,effects/* generateStatusEffectChange */.f6)("Prone"));
      break;
    }
    case "Maneuvers: Parry": {
      setProperty(document, "system.activation.type", "reactiondamage");
      effect.changes.push(
        {
          "key": "flags.midi-qol.DR.all",
          "mode": CONST.ACTIVE_EFFECT_MODES.ADD,
          "value": "1",
          "priority": "20"
        }
      );
      break;
    }
    case "Maneuvers: Rally": {
      const itemMacroText = await (0,macros/* loadMacroFile */.dp)("feat", "maneuversRally.js");
      document.flags["itemacro"] = (0,macros/* generateItemMacroFlag */.gL)(document, itemMacroText);
      effect.changes.push((0,macros/* generateMacroChange */.n4)(`${diceString} @abilities.cha.mod`, 20));
      document.effects.push(effect);
      break;
    }
    // no default
  }
  // flags.dnd5e.initiativeAdv

  // set target
  switch (name) {
    case "Maneuvers: Trip Attack":
    case "Maneuvers: Maneuvering Attack":
    case "Maneuvers: Goading Attack":
    case "Maneuvers: Distracting Strike":
    case "Maneuvers: Menacing Attack":
    case "Maneuvers: Sweeping Attack":
    case "Maneuvers: Disarming Attack":
    case "Maneuvers: Pushing Attack":
    case "Maneuvers: Rally":
    case "Maneuvers: Bait and Switch":
    case "Maneuvers: Commanderâ€™s Strike":
    case "Maneuvers: Commander's Strike": {
      setProperty(document, "system.target.value", 1);
      setProperty(document, "system.target.type", "creature");
      break;
    }
    // no default
  }

  // set regular damage
  switch (name) {
    case "Maneuvers: Parry":
    case "Maneuvers: Trip Attack":
    case "Maneuvers: Maneuvering Attack":
    case "Maneuvers: Goading Attack":
    case "Maneuvers: Distracting Strike":
    case "Maneuvers: Menacing Attack":
    case "Maneuvers: Sweeping Attack":
    case "Maneuvers: Disarming Attack":
    case "Maneuvers: Pushing Attack": {
      setProperty(document, "system.damage.parts", [[diceString]]);
      break;
    }
    // no default
  }

  switch (name) {
    case "Maneuvers: Precision Attack": {
      setProperty(document, "system.damage.parts", [[diceString, "midi-none"]]);
      break;
    }
    // no default
  }

  // saves
  switch (name) {
    case "Maneuvers: Trip Attack":
    case "Maneuvers: Disarming Attack":
    case "Maneuvers: Pushing Attack": {
      setProperty(effect, "flags.midiProperties.fulldam", true);
      setProperty(document, "system.damage.parts", [[diceString]]);
      setProperty(document, "system.save", { ability: "str", dc: null, "scaling": ability });
      break;
    }
    case "Maneuvers: Menacing Attack":
    case "Maneuvers: Goading Attack": {
      setProperty(effect, "flags.midiProperties.fulldam", true);
      setProperty(document, "system.damage.parts", [[diceString]]);
      setProperty(document, "system.save", { ability: "wis", dc: null, "scaling": ability });
      break;
    }
    // no default
  }

  return document;
}


// EXTERNAL MODULE: ./src/effects/specialSpells.js + 114 modules
var specialSpells = __webpack_require__(7980);
;// CONCATENATED MODULE: ./src/effects/feats/momentaryStasis.js


function momentaryStasis(document) {
  let effect = (0,specialSpells/* baseSpellEffect */.fD)(document, document.name);
  effect.changes.push((0,specialSpells/* generateStatusEffectChange */.f6)("Incapacitated"));
  setProperty(effect, "flags.dae.specialDuration", ["isDamaged", "turnEndSource"]);
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/paladinDefaultAura.js
function paladinDefaultAuraEffect(document) {
  document.effects.forEach((effect) => {
    if (effect.label.includes("Constant Effects")) {
      const distance = document.flags.ddbimporter?.dndbeyond?.levelScale?.fixedValue ?? 10;
      effect.flags.ActiveAuras = {
        aura: "Allies",
        radius: distance,
        isAura: true,
        inactive: false,
        hidden: false,
        displayTemp: true,
      };
      setProperty(effect, "flags.core.statusId", "1");
      setProperty(effect, "flags.dae.stackable", "noneName");
    }
  });
  return document;
}


;// CONCATENATED MODULE: ./src/effects/feats/piercer.js




async function commonPiercer(document) {
  const itemMacroText = await (0,macros/* loadMacroFile */.dp)("feat", "piercer.js");
  setProperty(document, "flags.itemacro", (0,macros/* generateItemMacroFlag */.gL)(document, itemMacroText));
  document.system.target = {
    value: null,
    width: null,
    units: "",
    type: "self",
  };
  document.system.range = {
    value: null,
    long: null,
    units: "self",
  };
  return document;
};

async function piercerCriticalEffect(document) {
  const effect = baseFeatEffect(document, document.name);
  effect.changes.push(
    {
      key: "flags.dnd5e.DamageBonusMacro",
      value: "ItemMacro",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      priority: 20,
    },
  );
  effect.transfer = true;

  setProperty(effect, "flags.dae.transfer", true);
  document.effects.push(effect);

  await commonPiercer(document);

  return document;
}


async function piercerRerollEffect(document) {
  const effect = baseFeatEffect(document, document.name);

  effect.changes.push(
    {
      key: "flags.midi-qol.onUseMacroName",
      value: `ItemMacro.${document.name},postDamageRoll`,
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      priority: 20,
    },
  );
  effect.transfer = true;

  setProperty(effect, "flags.dae.transfer", true);
  document.effects.push(effect);

  await commonPiercer(document);
  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/planarWarrior.js



async function planarWarriorEffect(document) {
  const itemMacroText = await (0,macros/* loadMacroFile */.dp)("feat", "planarWarrior.js");
  document.flags["itemacro"] = (0,macros/* generateItemMacroFlag */.gL)(document, itemMacroText);

  let effect = baseFeatEffect(document, "Marked by Planar Warrior");

  setProperty(effect, "duration.turns", 1);
  setProperty(document, "flags.midi-qol.onUseMacroName", "[preItemRoll]ItemMacro,[preActiveEffects]ItemMacro");

  document.effects.push(effect);

  document.system.target = {
    value: 1,
    width: null,
    units: "",
    type: "creature",
  };
  document.system.range = {
    value: 30,
    long: null,
    units: "ft",
  };
  document.system.damage = {
    parts: [],
    versatile: "",
    value: "",
  };

  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/potentCantrip.js


function potentCantripEffect(document) {
  let effect = (0,effects/* baseItemEffect */.uT)(document, document.name);
  effect.changes.push(
    { key: "flags.midi-qol.potentCantrip", value: "1", mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM, priority: 20 },
  );
  document.effects.push(effect);
  return document;
}


;// CONCATENATED MODULE: ./src/effects/feats/radiantSoul.js



async function radiantSoulEffect(document) {

  if (document.flags.ddbimporter.type == "race") {
    let effect = baseFeatEffect(document, document.name);

    effect.changes.push(
      {
        key: "data.attributes.movement.fly",
        mode: 4,
        value: "30",
        priority: "20",
      },
      {
        key: "flags.midi-qol.optional.radiantsoul.label",
        mode: 0,
        value: `${document.name} Bonus Damage`,
        priority: "20",
      },
      {
        key: "flags.midi-qol.optional.radiantsoul.count",
        mode: 0,
        value: "each-round",
        priority: "20",
      },
      {
        key: "flags.midi-qol.optional.radiantsoul.damage.all",
        mode: 0,
        value: document.name === "Celestial Revelation (Radiant Soul)" ? "+@prof[radiant]" : "+@details.level[radiant]",
        priority: "20",
      }
    );
    effect.duration = {
      startTime: null,
      seconds: null,
      rounds: 10,
      turns: null,
      startRound: null,
      startTurn: null,
    };

    document.effects.push(effect);

    document.system["target"]["type"] = "self";
    document.system.range = { value: null, units: "self", long: null };
    document.system.actionType = "other";

  } else if (document.flags.ddbimporter.type == "class") {
    let effect = baseFeatEffect(document, document.name);
    effect.changes.push(
      {
        key: "flags.dnd5e.DamageBonusMacro",
        value: `ItemMacro.${document.name}`,
        mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
        priority: "20",
      },
    );
    effect.transfer = true;

    const itemMacroText = await (0,macros/* loadMacroFile */.dp)("feat", "radiantSoul.js");
    document.flags["itemacro"] = (0,macros/* generateItemMacroFlag */.gL)(document, itemMacroText);
    setProperty(document, "system.activation.type", "special");

    document.effects.push(effect);
  }

  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/rage.js


function rageEffect(document) {
  let effect = baseFeatEffect(document, `${document.name}`);

  const useScale = game.settings.get("ddb-importer", "character-update-policy-use-scalevalue");
  const extraDamage = useScale
    ? "@scale.barbarian.rage"
    : document.flags?.ddbimporter?.dndbeyond?.levelScale?.fixedValue
      ? document.flags.ddbimporter.dndbeyond.levelScale.fixedValue
      : 2;
  effect.changes.push(
    {
      key: "system.bonuses.mwak.damage",
      value: `${extraDamage}`,
      mode: CONST.ACTIVE_EFFECT_MODES.ADD,
      priority: 0,
    },
    {
      key: "system.traits.dr.value",
      value: "piercing",
      mode: CONST.ACTIVE_EFFECT_MODES.ADD,
      priority: 0,
    },
    {
      key: "system.traits.dr.value",
      value: "slashing",
      mode: CONST.ACTIVE_EFFECT_MODES.ADD,
      priority: 20,
    },
    {
      key: "system.traits.dr.value",
      value: "bludgeoning",
      mode: CONST.ACTIVE_EFFECT_MODES.ADD,
      priority: 20,
    },
    {
      key: "flags.midi-qol.advantage.ability.save.str",
      value: "1",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      priority: 20,
    },
    {
      key: "flags.midi-qol.advantage.ability.check.str",
      value: "1",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      priority: 20,
    }
  );
  effect.duration = {
    startTime: null,
    seconds: 60,
    rounds: null,
    turns: null,
    startRound: null,
    startTurn: null,
  };
  document.system.damage = {
    parts: [],
    versatile: "",
    value: "",
  };
  document.system.target = {
    value: null,
    width: null,
    units: "",
    type: "self",
  };
  document.system.range = { value: null, units: "self", long: null };
  document.effects.push(effect);
  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/recklessAttack.js


function recklessAttackEffect(document) {
  let attackEffect = baseFeatEffect(document, `${document.name} (Attack)`);

  attackEffect.changes.push(
    {
      key: "flags.midi-qol.advantage.attack.str",
      value: `1`,
      mode: CONST.ACTIVE_EFFECT_MODES.ADD,
      priority: 20,
    },
  );
  attackEffect.duration = {
    startTime: null,
    seconds: null,
    rounds: 1,
    turns: null,
    startRound: null,
    startTurn: null,
  };

  document.effects.push(attackEffect);

  let defenseEffect = baseFeatEffect(document, `${document.name} (Defense)`);

  defenseEffect.changes.push(
    {
      key: "flags.midi-qol.grants.advantage.attack.all",
      value: `1`,
      mode: CONST.ACTIVE_EFFECT_MODES.ADD,
      priority: 20,
    },
  );
  setProperty(defenseEffect, "flags.dae.specialDuration", ["turnStartSource"]);
  setProperty(defenseEffect, "flags.core.statusId", "Reckless");

  document.effects.push(defenseEffect);

  document.system["target"]["type"] = "self";
  document.system.range = { value: null, units: "self", long: null };
  document.system.actionType = null;
  document.system.activation = { type: "none", cost: null, condition: "" };

  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/runeCarver.js




async function runeCarverEffect(document) {

  let baseEffect = baseFeatEffect(document, document.name);
  baseEffect.transfer = true;

  switch (document.name) {
    case "Rune Carver: Cloud Rune": {
      baseEffect.changes.push(
        {
          key: "flags.midi-qol.advantage.skill.dec",
          mode: CONST.ACTIVE_EFFECT_MODES.ADD,
          value: "1",
          priority: "20",
        },
        {
          key: "flags.midi-qol.advantage.skill.slt",
          mode: CONST.ACTIVE_EFFECT_MODES.ADD,
          value: "1",
          priority: "20",
        },
      );
      break;
    }
    case "Rune Carver: Fire Rune": {
      // Missing: prof bonus expertise for tool
      break;
    }
    case "Rune Carver: Frost Rune": {
      baseEffect.changes.push(
        {
          key: "flags.midi-qol.advantage.skill.ani",
          mode: CONST.ACTIVE_EFFECT_MODES.ADD,
          value: "1",
          priority: "20",
        },
        {
          key: "flags.midi-qol.advantage.skill.itm",
          mode: CONST.ACTIVE_EFFECT_MODES.ADD,
          value: "1",
          priority: "20",
        },
      );
      break;
    }
    case "Rune Carver: Stone Rune": {
      baseEffect.changes.push(
        {
          key: "flags.midi-qol.advantage.skill.ins",
          mode: CONST.ACTIVE_EFFECT_MODES.ADD,
          value: "1",
          priority: "20",
        },
        {
          key: "system.attributes.senses.darkvision",
          value: "120",
          mode: CONST.ACTIVE_EFFECT_MODES.UPGRADE,
          priority: 20,
        },
      );
      if (featEffectModules().atlInstalled) {
        baseEffect.changes.push((0,effects/* generateATLChange */.Ci)("ATL.dimSight", CONST.ACTIVE_EFFECT_MODES.UPGRADE, 120, 5));
      } else {
        const itemMacroText = await (0,macros/* loadMacroFile */.dp)("spell", "darkvision.js");
        document.flags["itemacro"] = (0,macros/* generateItemMacroFlag */.gL)(document, itemMacroText);
        baseEffect.changes.push((0,macros/* generateMacroChange */.n4)(""));
      }
      break;
    }
    case "Rune Carver: Hill Rune": {
      baseEffect.changes.push(
        {
          key: "system.traits.dr.value",
          mode: CONST.ACTIVE_EFFECT_MODES.ADD,
          value: "poison",
          priority: "20",
        },
      );
      // Missing : advantage of saving throws against being poisoned
      break;
    }
    case "Rune Carver: Storm Rune": {
      baseEffect.changes.push(
        {
          key: "flags.midi-qol.advantage.skill.arc",
          mode: CONST.ACTIVE_EFFECT_MODES.ADD,
          value: "1",
          priority: "20",
        },
      );
      // Missing : can't be surprised

      break;
    }
    // no default
  }

  if (baseEffect.changes.length > 0) {
    setProperty(document, "system.target.type", "self");
    setProperty(document, "system.range.units", "self");
    setProperty(document, "system.range.value", "");
    setProperty(document, "system.actionType", null);
    document.effects.push(baseEffect);
  }
  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/sacredWeapon.js




async function sacredWeaponEffect(document) {
  if (document.system.actionType === null) return document;
  let effect = baseFeatEffect(document, document.name);

  const itemMacroText = await (0,macros/* loadMacroFile */.dp)("feat", "sacredWeapon.js");
  document.flags["itemacro"] = (0,macros/* generateItemMacroFlag */.gL)(document, itemMacroText);
  effect.changes.push((0,macros/* generateMacroChange */.n4)("@abilities.cha.mod", 0));

  // effect.changes.push(
  //   {
  //     key: "system.bonuses.weapon.attack",
  //     mode: CONST.ACTIVE_EFFECT_MODES.ADD,
  //     value: "+ @abilities.cha.mod",
  //     priority: "20",
  //   },
  // );

  if (CONFIG.DDBI.EFFECT_CONFIG.FEATS.installedModules.atlInstalled) {
    effect.changes.push((0,effects/* generateATLChange */.Ci)("ATL.dimLight", CONST.ACTIVE_EFFECT_MODES.UPGRADE, '5'));
    effect.changes.push((0,effects/* generateATLChange */.Ci)("ATL.lightColor", CONST.ACTIVE_EFFECT_MODES.OVERRIDE, '#ffffff'));
    effect.changes.push((0,effects/* generateATLChange */.Ci)("ATL.lightAlpha", CONST.ACTIVE_EFFECT_MODES.OVERRIDE, '0.25'));
    const lightAnimation = '{"type": "sunburst", "speed": 2,"intensity": 4}';
    effect.changes.push((0,effects/* generateATLChange */.Ci)("ATL.lightAnimation", CONST.ACTIVE_EFFECT_MODES.OVERRIDE, lightAnimation));
  }
  setProperty(effect, "flags.dae.selfTarget", true);
  setProperty(effect, "flags.dae.selfTargetAlways", true);
  setProperty(effect, "duration.turns", 10);
  document.effects.push(effect);
  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/savageAttacker.js


function savageAttackerEffect(document) {
  if (document.system.actionType === null) return document;
  let effect = baseFeatEffect(document, document.name);

  effect.changes.push(
    {
      key: "flags.midi-qol.optional.savageAttacker.label",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: `${document.name} - Weapon Damage Reroll`,
      priority: "5",
    },
    {
      key: "flags.midi-qol.optional.savageAttacker.count",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: "turn",
      priority: "5",
    },
    {
      key: "flags.midi-qol.optional.savageAttacker.damage.mwak",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: "reroll-kh",
      priority: "5",
    },
  );

  effect.transfer = true;

  document.effects.push(effect);
  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/sculptSpells.js


function sculptSpellsEffect(document) {
  let effect = (0,effects/* baseItemEffect */.uT)(document, document.name);
  effect.changes.push(
    { key: "flags.midi-qol.sculptSpell", value: "1", mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM, priority: 10 },
  );
  document.effects.push(effect);
  return document;
}


;// CONCATENATED MODULE: ./src/effects/feats/sharpShooter.js


function sharpShooterEffect(document) {
  let effect = baseFeatEffect(document, `${document.name} - Range Adjustment`);

  effect.changes.push(
    // changes range
    {
      key: "flags.midi-qol.sharpShooter",
      value: "1",
      mode: CONST.ACTIVE_EFFECT_MODES.ADD,
      priority: 30,
    },
    {
      key: "flags.dnd5e.helpersIgnoreCover",
      value: "2",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      priority: 30,
    },
  );

  effect.transfer = true;
  // effect.flags.dae.selfTarget = true;
  effect.flags.dae.transfer = true;
  // setProperty(effect, "flags.core.statusId", true);

  document.effects.push(effect);
  document.system.activation = {
    "type": "none",
    "cost": 1,
    "condition": ""
  };

  document.system["target"]["type"] = "self";
  document.system.range = { value: null, units: "self", long: null };
  document.system.actionType = "other";

  const midiFlags = {
    "effectActivation": false,
    "forceCEOff": false,
    "forceCEOn": true
  };

  setProperty(document, "flags.midi-qol", midiFlags);

  const midiProperties = {
    "toggleEffect": true,
  };

  setProperty(document, "flags.midiProperties", midiProperties);

  return document;
}

// EXTERNAL MODULE: ./src/lib/DDBTemplateStrings.js
var DDBTemplateStrings = __webpack_require__(258);
;// CONCATENATED MODULE: ./src/effects/feats/shift.js



function shiftEffect(ddb, character, document) {
  const isBeasthide = ddb.character.options.race.find((trait) => trait.definition.name === "Beasthide");
  const isSwiftstride = ddb.character.options.race.find((trait) => trait.definition.name === "Swiftstride");
  const isWildhunt = ddb.character.options.race.find((trait) => trait.definition.name === "Wildhunt");
  const isLongtooth = ddb.character.options.race.find((trait) => trait.definition.name === "Longtooth");

  let effect = baseFeatEffect(document, `${document.name}`);

  if (isBeasthide) {
    document.system.damage.parts[0][0] = `1d6 + ${document.system.damage.parts[0][0]}`;
    effect.changes.push(
      {
        key: "system.attributes.ac.bonus",
        value: "+ 1",
        mode: CONST.ACTIVE_EFFECT_MODES.ADD,
        priority: 20,
      },
    );
    setProperty(effect, "flags.dae.selfTarget", true);
    setProperty(effect, "flags.dae.selfTargetAlways", true);
    const description = (0,DDBTemplateStrings/* default */.ZP)(ddb, character, isBeasthide.definition.description, isBeasthide.definition).text;
    document.system.description.value += `<h2>Beasthide</h2>\n${description}`;
    document.effects.push(effect);
  } else if (isSwiftstride) {
    effect.changes.push(
      {
        key: "system.attributes.movement.walk",
        mode: CONST.ACTIVE_EFFECT_MODES.ADD,
        value: "+ 10",
        priority: "20",
      },
    );
    setProperty(effect, "flags.dae.selfTarget", true);
    setProperty(effect, "flags.dae.selfTargetAlways", true);
    const description = (0,DDBTemplateStrings/* default */.ZP)(ddb, character, isSwiftstride.definition.description, isSwiftstride.definition).text;
    document.system.description.value += `<h2>Swiftstride</h2>\n${description}`;
    document.effects.push(effect);
  } else if (isWildhunt) {
    effect.changes.push(
      {
        key: "flags.midi-qol.advantage.ability.check.wis",
        mode: CONST.ACTIVE_EFFECT_MODES.ADD,
        value: "1",
        priority: "20",
      },
    );
    setProperty(effect, "flags.dae.selfTarget", true);
    setProperty(effect, "flags.dae.selfTargetAlways", true);
    const description = (0,DDBTemplateStrings/* default */.ZP)(ddb, character, isWildhunt.definition.description, isWildhunt.definition).text;
    document.system.description.value += `<h2>Wildhunt</h2>\n${description}`;
    document.effects.push(effect);
  } else if (isLongtooth) {
    const description = (0,DDBTemplateStrings/* default */.ZP)(ddb, character, isLongtooth.definition.description, isLongtooth.definition).text;
    document.system.description.value += `<h2>Longtooth</h2>\n${description}`;
  }

  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/slayersPrey.js



// this one is a bit different, the macro is triggered by midi-qol and applies effects to the actor
// the Marked effect gets applied to the target
async function slayersPreyEffect(document) {
  let effect = baseFeatEffect(document, `Marked by ${document.name}`);
  effect.changes.push(
    {
      key: "flags.dae.onUpdateSource",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: document.name,
      priority: 20,
    },
  );
  effect.transfer = false;
  effect.duration.seconds = 60;
  document.effects.push(effect);

  let damageBonusEffect = baseFeatEffect(document, document.name);
  damageBonusEffect.changes.push({
    key: "flags.dnd5e.DamageBonusMacro",
    value: "ItemMacro",
    mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
    priority: 20,
  });
  damageBonusEffect.transfer = true;

  setProperty(damageBonusEffect, "flags.dae.transfer", true);
  document.effects.push(damageBonusEffect);

  const itemMacroText = await (0,macros/* loadMacroFile */.dp)("feat", "slayersPrey.js");
  setProperty(document, "flags.itemacro", (0,macros/* generateItemMacroFlag */.gL)(document, itemMacroText));
  setProperty(document, "flags.midi-qol.onUseMacroName", "[postActiveEffects]ItemMacro");

  setProperty(document, "system.actionType", "util");
  document.system.damage.parts = [];
  document.system.target = {
    value: 1,
    width: null,
    units: "",
    type: "creature",
  };
  document.system.range = {
    value: null,
    long: null,
    units: "",
  };

  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/steadyAim.js


function steadyAimEffect(document) {
  let effect = baseFeatEffect(document, document.name);
  effect.changes.push(
    {
      key: "flags.midi-qol.advantage.attack.all",
      value: "1",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      priority: 30,
    },
  );
  effect.flags.dae.specialDuration = ["1Attack"];
  setProperty(effect, "duration.turns", 1);

  document.system["target"]["type"] = "self";
  document.system.range = { value: null, units: "self", long: null };
  document.system.actionType = null;
  document.system.duration = {
    value: 1,
    units: "turn",
  };
  document.effects.push(effect);

  let moveEffect = baseFeatEffect(document, `${document.name} Movement Restriction`);
  moveEffect.changes.push(
    {
      key: 'data.attributes.movement.all',
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: '0',
      priority: "40",
    },
  );
  moveEffect.flags.dae.specialDuration = ["turnStartSource"];
  setProperty(moveEffect, "duration.turns", 1);
  document.effects.push(moveEffect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/stoneRune.js



function stoneRuneEffect(document) {
  setProperty(document, "system.target.value", 1);
  setProperty(document, "system.target.type", "creature");
  setProperty(document, "system.range.units", "ft");
  setProperty(document, "system.range.value", 30);

  let bonusEffect = baseFeatEffect(document, `${document.name} (Charm Effect)`);
  setProperty(bonusEffect, "flags.core.statusId", `${document.name} (Charm Effect)`);
  setProperty(bonusEffect, "duration.seconds", 60);
  bonusEffect.changes.push((0,effects/* generateStatusEffectChange */.f6)("Charmed", 20, true));
  bonusEffect.changes.push((0,effects/* generateStatusEffectChange */.f6)("Incapacitated", 20, true));
  bonusEffect.changes.push(
    {
      key: "flags.midi-qol.OverTime",
      mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
      value: `label=${document.name} (End of Turn Save),turn=end,saveDC=@attributes.spelldc,saveAbility=${document.system.save.ability},savingThrow=true,saveMagic=true,saveRemove=true`,
      priority: "20",
    }
  );

  document.effects.push(bonusEffect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/stonesEndurance.js



function stonesEnduranceEffect(document) {
  let effect = baseFeatEffect(document, document.name);
  effect.changes.push({
    key: "flags.midi-qol.DR.all",
    value: "[[1d10 + @abilities.con.mod]]",
    mode: CONST.ACTIVE_EFFECT_MODES.ADD,
    priority: 20,
  });
  effect.flags.dae.specialDuration = ["1Reaction"];
  setProperty(effect, "flags.dae.selfTarget", true);
  setProperty(effect, "flags.dae.selfTargetAlways", true);
  setProperty(document, "system.activation.type", "reactiondamage");

  document.system["target"]["type"] = "self";
  document.system.range = { value: null, units: "self", long: null };
  document.system.damage.parts = [];
  document.system.ability = null;

  document.effects.push(effect);
  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/stormRune.js


function stormRuneEffect(document) {

  let baseEffect = baseFeatEffect(document, document.name);
  setProperty(document, "system.target.type", "self");
  setProperty(document, "system.range.units", "self");
  setProperty(document, "system.range.value", "");
  setProperty(document, "system.actionType", null);

  document.effects.push(baseEffect);

  let bonusEffect = baseFeatEffect(document, `${document.name} (Prophetic State)`);
  setProperty(bonusEffect, "duration.seconds", 60);
  setProperty(bonusEffect, "flags.core.statusId", "Prophetic State");

  // Missing effect for Prophetic State to enforce adv or disvantage

  document.effects.push(bonusEffect);


  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/unarmoredMovement.js
function unarmoredMovementEffect(document) {
  document.effects.forEach((effect) => {
    if (effect.label.includes("Constant Effects")) {
      effect.changes = [
        {
          key: "system.attributes.movement.walk",
          value: "max(10+(ceil(((@classes.monk.levels)-5)/4))*5,10)",
          mode: CONST.ACTIVE_EFFECT_MODES.ADD,
          priority: 20,
        },
      ];
    }
  });
  return document;
}


;// CONCATENATED MODULE: ./src/effects/feats/uncannyDodge.js


function uncannyDodgeEffect(document) {
  let effect = baseFeatEffect(document, "1/2 Damage");
  effect.changes.push({
    key: "flags.midi-qol.uncanny-dodge",
    value: "1",
    mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
    priority: 10,
  });
  effect.flags.dae.specialDuration = ["1Reaction"];
  document.system["target"]["type"] = "self";
  document.system.range = { value: null, units: "self", long: null };
  document.system.actionType = null;
  document.system.activation.type = "reactiondamage";
  document.effects.push(effect);
  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/vigilantBlessing.js


function vigilantBlessingEffect(document) {
  let effect = baseFeatEffect(document, document.name);
  effect.changes.push({
    key: "flags.dnd5e.initiativeAdv",
    value: "1",
    mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
    priority: 30,
  });
  effect.flags.dae.specialDuration = ["Initiative"];
  document.system["target"]["type"] = "creature";
  document.system.actionType = null;
  document.effects.push(effect);
  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/visageOfTheAstralSelf.js


function visageOfTheAstralSelfEffect(document) {
  let effect = baseFeatEffect(document, `${document.name}`);

  effect.changes.push(
    {
      key: "flags.midi-qol.advantage.skill.itm",
      value: `1`,
      mode: CONST.ACTIVE_EFFECT_MODES.ADD,
      priority: 20,
    },
    {
      key: "flags.midi-qol.advantage.skill.ins",
      value: `1`,
      mode: CONST.ACTIVE_EFFECT_MODES.ADD,
      priority: 20,
    },
    {
      key: "ATL.sight.visionMode",
      value: `basic`,
      mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
      priority: 20,
    },
    {
      key: "ATL.sight.range",
      value: `120`,
      mode: CONST.ACTIVE_EFFECT_MODES.UPGRADE,
      priority: 20,
    },
  );
  effect.duration = {
    startTime: null,
    seconds: 360,
    rounds: null,
    turns: null,
    startRound: null,
    startTurn: null,
  };
  setProperty(effect, "flags.dae.selfTarget", true);
  setProperty(effect, "flags.dae.selfTargetAlways", true);

  document.effects.push(effect);

  document.system["target"]["type"] = "self";
  document.system.range = { value: null, units: "self", long: null };
  document.system.actionType = null;
  document.system.duration = {
    value: 10,
    units: "minute",
  };


  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/warCaster.js


function warCasterEffect(document) {
  let effect = (0,effects/* baseItemEffect */.uT)(document, document.name);
  effect.changes.push(
    { key: "flags.midi-qol.advantage.concentration", value: "1", mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM, priority: 10 },
  );
  document.effects.push(effect);
  return document;
}


;// CONCATENATED MODULE: ./src/effects/feats/crusher.js




async function crusherEffect(document) {
  const effect = baseFeatEffect(document, document.name);
  effect.changes.push(
    {
      key: "flags.dnd5e.DamageBonusMacro",
      value: "ItemMacro",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      priority: 20,
    },
  );
  effect.transfer = true;

  setProperty(effect, "flags.dae.transfer", true);
  document.effects.push(effect);

  const itemMacroText = await (0,macros/* loadMacroFile */.dp)("feat", "crusher.js");
  setProperty(document, "flags.itemacro", (0,macros/* generateItemMacroFlag */.gL)(document, itemMacroText));
  document.system.actionType = null;
  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/crusherCritical.js




async function crusherCriticalEffect(document) {
  const effect = baseFeatEffect(document, document.name);
  effect.changes.push(
    {
      key: "flags.dnd5e.DamageBonusMacro",
      value: "ItemMacro",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      priority: 20,
    },
  );
  effect.transfer = true;

  setProperty(effect, "flags.dae.transfer", true);
  document.effects.push(effect);

  const itemMacroText = await (0,macros/* loadMacroFile */.dp)("feat", "crusherCritical.js");
  setProperty(document, "flags.itemacro", (0,macros/* generateItemMacroFlag */.gL)(document, itemMacroText));
  document.system.actionType = null;

  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/slasherReduceSpeed.js




async function slasherReduceSpeedEffect(document) {
  const effect = baseFeatEffect(document, document.name);
  effect.changes.push(
    {
      key: "flags.dnd5e.DamageBonusMacro",
      value: "ItemMacro",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      priority: 20,
    },
  );
  effect.transfer = true;

  setProperty(effect, "flags.dae.transfer", true);
  document.effects.push(effect);

  const itemMacroText = await (0,macros/* loadMacroFile */.dp)("feat", "slasherReduceSpeed.js");
  setProperty(document, "flags.itemacro", (0,macros/* generateItemMacroFlag */.gL)(document, itemMacroText));
  document.system.actionType = null;
  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/slasherCritical.js




async function slasherCriticalEffect(document) {
  const effect = baseFeatEffect(document, document.name);
  effect.changes.push(
    {
      key: "flags.dnd5e.DamageBonusMacro",
      value: "ItemMacro",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      priority: 20,
    },
  );
  effect.transfer = true;

  setProperty(effect, "flags.dae.transfer", true);
  document.effects.push(effect);

  const itemMacroText = await (0,macros/* loadMacroFile */.dp)("feat", "slasherCritical.js");
  setProperty(document, "flags.itemacro", (0,macros/* generateItemMacroFlag */.gL)(document, itemMacroText));
  document.system.actionType = null;

  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/squireOfSolamnia.js



async function squireOfSolamniaEffect(document) {
  let effect = (0,effects/* baseItemEffect */.uT)(document, document.name);
  const itemMacroText = await (0,macros/* loadMacroFile */.dp)("feat", "squireOfSolamnia.js");
  document.flags["itemacro"] = (0,macros/* generateItemMacroFlag */.gL)(document, itemMacroText);
  effect.changes.push((0,macros/* generateMacroChange */.n4)(`"${document.name}"`));
  effect.transfer = false;

  effect.changes.push(
    {
      key: "flags.midi-qol.advantage.attack.mwak",
      mode: CONST.ACTIVE_EFFECT_MODES.ADD,
      value: "1",
      priority: "20",
    },
    {
      key: "flags.midi-qol.advantage.attack.rwak",
      mode: CONST.ACTIVE_EFFECT_MODES.ADD,
      value: "1",
      priority: "20",
    },
    {
      key: "flags.dnd5e.DamageBonusMacro",
      value: "ItemMacro",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      priority: 20,
    }
  );
  setProperty(effect, "flags.dae.specialDuration", ["1Attack"]);
  setProperty(effect, "flags.dae.selfTarget", true);
  setProperty(effect, "flags.dae.selfTargetAlways", true);
  document.effects.push(effect);

  document.system.damage.parts = [];
  document.system.actionType = null;

  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/arcaneRecovery.js



async function arcaneRecoveryEffect(document) {
  let effect = baseFeatEffect(document, document.name);
  const itemMacroText = await (0,macros/* loadMacroFile */.dp)("feat", "arcaneRecovery.js");
  document.flags["itemacro"] = (0,macros/* generateItemMacroFlag */.gL)(document, itemMacroText);
  effect.changes.push((0,macros/* generateMacroChange */.n4)(""));
  setProperty(effect, "flags.dae.selfTarget", true);
  setProperty(effect, "flags.dae.selfTargetAlways", true);
  document.effects.push(effect);
  document.system.actionType = "";

  return document;
}

;// CONCATENATED MODULE: ./src/effects/specialFeats.js



// effect loads




















































function baseFeatEffect(document, label) {
  return {
    label,
    icon: document.img,
    changes: [],
    duration: {},
    tint: "",
    transfer: false,
    disabled: false,
    flags: {
      dae: {
        transfer: false,
        stackable: "none",
      },
      ddbimporter: {
        disabled: false,
      },
      "midi-qol": { // by default force CE effect usage to off
        forceCEOff: true,
      },
    },
  };
}

function featEffectModules() {
  if (CONFIG.DDBI.EFFECT_CONFIG.FEATS.installedModules) {
    return CONFIG.DDBI.EFFECT_CONFIG.FEATS.installedModules;
  }
  const midiQolInstalled = game.modules.get("midi-qol")?.active;
  const advancedMacrosInstalled = game.modules.get("advanced-macros")?.active;
  const itemMacroInstalled = game.modules.get("itemacro")?.active;
  const timesUp = game.modules.get("times-up")?.active;
  const daeInstalled = game.modules.get("dae")?.active;
  const convenientEffectsInstalled = game.modules.get("dfreds-convenient-effects")?.active;

  const activeAurasInstalled = game.modules.get("ActiveAuras")?.active;
  const atlInstalled = game.modules.get("ATL")?.active;
  const tokenAurasInstalled = game.modules.get("token-auras")?.active;
  const tokenMagicInstalled = game.modules.get("tokenmagic")?.active;
  const autoAnimationsInstalled = game.modules.get("autoanimations")?.active;
  CONFIG.DDBI.EFFECT_CONFIG.FEATS.installedModules = {
    hasCore:
      itemMacroInstalled
      && midiQolInstalled
      && advancedMacrosInstalled
      && timesUp
      && daeInstalled
      && convenientEffectsInstalled,
    midiQolInstalled,
    itemMacroInstalled,
    advancedMacrosInstalled,
    timesUp,
    daeInstalled,
    convenientEffectsInstalled,
    atlInstalled,
    tokenAurasInstalled,
    tokenMagicInstalled,
    activeAurasInstalled,
    autoAnimationsInstalled,
  };
  return CONFIG.DDBI.EFFECT_CONFIG.FEATS.installedModules;
}


/**
 * These are effects that can't be generated dynamically and have extra requirements
 */
// eslint-disable-next-line complexity
async function featureEffectAdjustment(ddb, character, document) {
  if (!document.effects) document.effects = [];

  const name = document.flags.ddbimporter.originalName || document.name;

  // check that we can gen effects
  const deps = featEffectModules();

  if (deps.daeInstalled) {
    switch (name) {
      // if using active auras add the aura effect
      case "Aura of Courage":
      case "Aura of Protection": {
        document = paladinDefaultAuraEffect(document);
        break;
      }
      case "Defensive Duelist": {
        document = defensiveDuelistEffect(document);
        break;
      }
      case "Frost Rune": {
        document = frostRuneEffect(document);
        break;
      }
      case "Hill Rune": {
        document = hillRuneEffect(document);
        break;
      }
      case "Momentary Stasis": {
        document = momentaryStasis(document);
        break;
      }
      case "Rage": {
        document = rageEffect(document);
        break;
      }
      case "Unarmored Movement": {
        document = unarmoredMovementEffect(document);
        break;
      }
      case "Uncanny Dodge": {
        document = uncannyDodgeEffect(document);
        break;
      }
      case "Vigilant Blessing": {
        document = vigilantBlessingEffect(document);
        break;
      }
      // no default
    }
  }

  if (deps.daeInstalled && deps.midiQolInstalled) {
    switch (name) {
      case "Arcane Recovery": {
        document = await arcaneRecoveryEffect(document);
        break;
      }
      case "Bladesong": {
        document = bladesongEffect(document);
        break;
      }
      case "Bardic Inspiration": {
        document = bardicInspirationEffect(document);
        break;
      }
      case "Blessed Strikes": {
        document = blessedStrikesEffect(document);
        break;
      }
      case "Cloud Rune": {
        document = cloudRuneEffect(document);
        break;
      }
      case "Crossbow Expert": {
        document = crossbowExpertEffect(document);
        break;
      }
      case "Deflect Missiles": {
        document = deflectMissilesEffect(document);
        break;
      }
      case "Empty Body":
      case "Ki: Empty Body": {
        document = kiEmptyBodyEffect(document);
        break;
      }
      case "Fighting Style: Interception": {
        document = fightingStyleInterceptionEffect(document);
        break;
      }
      case "Fire Rune": {
        document = fireRuneEffect(document);
        break;
      }
      case "Giant's Might": {
        document = giantsMightEffect(document);
        break;
      }
      case "Heavy Armor Master": {
        document = heavyArmorMasterEffect(document);
        break;
      }
      case "Indomitable": {
        document = indomitableEffect(document);
        break;
      }
      case "Potent Cantrip": {
        document = potentCantripEffect(document);
        break;
      }
      case "Celestial Revelation (Radiant Soul)":
      case "Radiant Soul": {
        document = await radiantSoulEffect(document);
        break;
      }
      case "Reckless Attack": {
        document = recklessAttackEffect(document);
        break;
      }
      case "Channel Divinity: Sacred Weapon":
      case "Sacred Weapon": {
        document = await sacredWeaponEffect(document);
        break;
      }
      case "Sculpt Spells": {
        document = sculptSpellsEffect(document);
        break;
      }
      case "Sharpshooter": {
        document = sharpShooterEffect(document);
        break;
      }
      case "Savage Attacker": {
        document = savageAttackerEffect(document);
        break;
      }
      case "Shift": {
        document = shiftEffect(ddb, character, document);
        break;
      }
      case "Squire of Solamnia: Precise Strike": {
        document = await squireOfSolamniaEffect(document);
        break;
      }
      case "Steady Aim": {
        document = steadyAimEffect(document);
        break;
      }
      case "Stone Rune": {
        document = stoneRuneEffect(document);
        break;
      }
      case "Stone's Endurance":
      case "Stoneâ€™s Endurance": {
        document = stonesEnduranceEffect(document);
        break;
      }
      case "Storm Rune": {
        document = stormRuneEffect(document);
        break;
      }
      case "Visage of the Astral Self": {
        document = visageOfTheAstralSelfEffect(document);
        break;
      }
      case "War Caster":
      case "Warcaster": {
        document = warCasterEffect(document);
        break;
      }
      // no default
    }
  }

  if (!deps.hasCore) {
    return (0,effects/* forceItemEffect */.Wk)(document);
  }
  if (!CONFIG.DDBI.EFFECT_CONFIG.FEATS.configured) {
    CONFIG.DDBI.EFFECT_CONFIG.FEATS.configured = (0,macros/* configureDependencies */.SI)();
  }


  if (name.startsWith("Maneuvers: ")) {
    document = await maneuversEffect(ddb, character, document);
  }
  if (name.startsWith("Rune Carver: ")) {
    document = await runeCarverEffect(document);
  }
  switch (name) {
    case "Ancestral Protectors": {
      document = await ancestralProtectorsEffect(document);
      break;
    }
    case "Arcane Ward": {
      document = await arcaneWardEffect(document);
      break;
    }
    case "Blessed Healer": {
      document = await blessedHealerEffect(document);
      break;
    }
    case "Convert Sorcery Points":
    case "Font of Magic": {
      document = await fontOfMagicEffect(document);
      break;
    }
    case "Crusher": {
      document = await crusherEffect(document);
      break;
    }
    case "Crusher: Critical": {
      document = await crusherCriticalEffect(document);
      break;
    }
    case "Favored Foe": {
      document = await favoredFoeEffect(document);
      break;
    }
    case "Piercer": {
      document = await piercerCriticalEffect(document);
      document = await piercerRerollEffect(document);
      break;
    }
    case "Piercer: Reroll Damage": {
      document = await piercerRerollEffect(document);
      break;
    }
    case "Piercer: Critical Hit": {
      document = await piercerCriticalEffect(document);
      break;
    }
    case "Planar Warrior": {
      document = await planarWarriorEffect(document);
      break;
    }
    case "Slasher: Reduce Speed": {
      document = await slasherReduceSpeedEffect(document);
      break;
    }
    case "Slasher: Critical Hit": {
      document = await slasherCriticalEffect(document);
      break;
    }
    case "Slayer's Prey": {
      document = await slayersPreyEffect(document);
      break;
    }
    // no default
  }

  return (0,effects/* forceItemEffect */.Wk)(document);
}


/***/ }),

/***/ 7980:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "fD": () => (/* binding */ baseSpellEffect),
  "Ci": () => (/* binding */ generateATLChange),
  "f6": () => (/* binding */ generateStatusEffectChange),
  "UY": () => (/* binding */ generateTokenMagicFXChange),
  "xo": () => (/* binding */ spellEffectAdjustment),
  "fM": () => (/* binding */ spellEffectModules)
});

// EXTERNAL MODULE: ./src/logger.js
var logger = __webpack_require__(5259);
// EXTERNAL MODULE: ./src/effects/effects.js + 1 modules
var effects = __webpack_require__(5751);
// EXTERNAL MODULE: ./src/effects/macros.js
var macros = __webpack_require__(3752);
;// CONCATENATED MODULE: ./src/effects/spells/absorbElements.js



function absorbElementsEffect(document) {
  const effect = baseSpellEffect(document, `${document.name} - Extra Damage`);
  effect.changes.push({
    key: "system.bonuses.mwak.damage",
    value: `(@item.level)d6`,
    mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
    priority: 0,
  });
  effect.flags.dae.specialDuration = ["1Hit"];
  effect.duration = {
    startTime: null,
    seconds: null,
    rounds: 1,
    turns: null,
    startRound: null,
    startTurn: null,
  };
  document.system.damage = {
    parts: [["", ""]],
    versatile: "",
    value: "",
  };
  document.system.target = {
    value: null,
    width: null,
    units: "",
    type: "self",
  };
  document.system.range = {
    value: null,
    long: null,
    units: "self",
  };
  document.effects.push(effect);

  return document;
}



;// CONCATENATED MODULE: ./src/effects/spells/acidArrow.js


function acidArrowEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push({
    key: "flags.midi-qol.OverTime",
    mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
    value: `label=${document.name} (End of Turn),turn=end,damageRoll=(@spellLevel)d4[acid],damageType=acid`,
    priority: "20",
  });
  effect.flags.dae.specialDuration = ["turnEnd"];
  effect.duration.rounds = 1;
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/aid.js



async function aidEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push({
    key: "system.attributes.hp.tempmax",
    value: "5 * (@spellLevel - 1)",
    mode: CONST.ACTIVE_EFFECT_MODES.ADD,
    priority: 20,
  });
  const itemMacroText = await (0,macros/* loadMacroFile */.dp)("spell", "aid.js");
  document.flags["itemacro"] = (0,macros/* generateItemMacroFlag */.gL)(document, itemMacroText);
  effect.changes.push((0,macros/* generateMacroChange */.n4)("@spellLevel", 0));
  document.effects.push(effect);
  document.system.damage = { parts: [], versatile: "", value: "" };

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/alterSelf.js


function alterSelfEffect(document) {
  let effectAquaticAdaptation = baseSpellEffect(document, document.name);
  effectAquaticAdaptation.changes.push({
    key: "system.attributes.movement.swim",
    value: "@attributes.movement.walk",
    mode: 4,
    priority: 20,
  });
  document.effects.push(effectAquaticAdaptation);

  let effectNaturalWeapons = baseSpellEffect(document, document.name);
  effectNaturalWeapons.changes.push(
    { key: "items.Unarmed Strike.system.damage.parts.0.0", value: "1d6+@mod+1", mode: 5, priority: 20 },
    { key: "items.Unarmed Strike.system.properties.mgc", value: "true", mode: 5, priority: 20 },
    { key: "items.Unarmed Strike.system.proficient", value: "true", mode: 5, priority: 20 },
    { key: "items.Unarmed Strike.system.attackBonus", value: "1", mode: 2, priority: 20 }
  );
  document.effects.push(effectNaturalWeapons);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/animalFriendship.js


function animalFriendshipEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push(generateStatusEffectChange("Charmed"));
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/arcaneSword.js



async function arcaneSwordEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  const itemMacroText = await (0,macros/* loadMacroFile */.dp)("spell", "arcaneSword.js");
  document.flags["itemacro"] = (0,macros/* generateItemMacroFlag */.gL)(document, itemMacroText);
  effect.changes.push((0,macros/* generateMacroChange */.n4)(""));

  setProperty(effect, "flags.dae.selfTarget", true);
  setProperty(effect, "flags.dae.selfTargetAlways", true);
  document.system.damage = { parts: [], versatile: "", value: "" };
  document.system.actionType = "other";

  document.effects.push(effect);
  setProperty(document, "flags.midi-qol.onUseMacroName", "[preTargeting]ItemMacro");

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/armorOfAgathys.js



async function armorOfAgathysEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push(
    {
      key: "flags.dae.onUpdateTarget",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: "Armor of Agathys,ItemMacro,system.attributes.hp.temp,@item.level",
      priority: 20,
    },
  );
  effect.duration.seconds = 3600;
  setProperty(effect, "flags.dae.selfTarget", true);
  setProperty(effect, "flags.dae.selfTargetAlways", true);
  document.effects.push(effect);

  const itemMacroText = await (0,macros/* loadMacroFile */.dp)("spell", "armorOfAgathys.js");
  setProperty(document, "flags.itemacro", (0,macros/* generateItemMacroFlag */.gL)(document, itemMacroText));
  setProperty(document, "system.actionType", "util");

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/auraOfLife.js



async function auraOfLifeEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push(
    {
      key: "system.traits.dr.value",
      mode: CONST.ACTIVE_EFFECT_MODES.ADD,
      value: "necrotic",
      priority: "20",
    },
    // {
    //   key: "flags.midi-qol.OverTime",
    //   mode: CONST.ACTIVE_EFFECT_MODES.ADD,
    //   value: "turn=start,label=Aura of Life (Start of Turn),damageRoll=1,damageType=heal,killAnim=true,applyCondition=##attributes.hp.value <= 0",
    //   priority: "20",
    // }
  );

  const itemMacroText = await (0,macros/* loadMacroFile */.dp)("spell", "auraOfLife.js");
  document.flags["itemacro"] = (0,macros/* generateItemMacroFlag */.gL)(document, itemMacroText);
  effect.flags["ActiveAuras"] = {
    isAura: true,
    aura: "Allies",
    radius: 30,
    alignment: "",
    type: "",
    ignoreSelf: false,
    height: false,
    hidden: false,
    onlyOnce: false,
    save: false,
    savedc: null,
    displayTemp: true,
  };
  // setProperty(effect, "duration.seconds", 600);
  setProperty(effect, "flags.dae.macroRepeat", "startEveryTurn");
  effect.changes.push((0,macros/* generateMacroChange */.n4)("@token"));
  document.system.actionType = "other";
  document.system.damage.parts = [];
  document.system.range = { value: null, units: "self", long: null };
  document.system['target']['type'] = "self";

  document.effects.push(effect);
  return document;

}

;// CONCATENATED MODULE: ./src/effects/spells/bane.js


function baneEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push(
    { key: "system.bonuses.All-Attacks", value: "-1d4", mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM, priority: 0 },
    { key: "system.bonuses.abilities.save", value: "-1d4", mode: CONST.ACTIVE_EFFECT_MODES.ADD, priority: 20 }
  );
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/banishment.js



async function banishmentEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  const itemMacroText = await (0,macros/* loadMacroFile */.dp)("spell", "banishment.js");
  document.flags["itemacro"] = (0,macros/* generateItemMacroFlag */.gL)(document, itemMacroText);
  effect.changes.push((0,macros/* generateMacroChange */.n4)("", 0));
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/barkskin.js


function barkskinEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push({
    key: "system.attributes.ac.value",
    mode: CONST.ACTIVE_EFFECT_MODES.UPGRADE,
    value: "16",
    priority: "100",
  });
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/beaconofHope.js


function beaconofHopeEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push(
    {
      key: "flags.midi-qol.advantage.ability.save.wis",
      value: "1",
      mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
      priority: 20,
    },
    { key: "flags.midi-qol.advantage.deathSave", value: "1", mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE, priority: 20 }
  );
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/blackTentacles.js



async function blackTentaclesEffect(document) {
  if (!spellEffectModules().activeAurasInstalled) {
    let effect = baseSpellEffect(document, document.name);
    effect.changes.push(generateStatusEffectChange("Restrained"));
    document.effects.push(effect);

    return document;
  }


  let effect = baseSpellEffect(document, document.name);
  const itemMacroText = await (0,macros/* loadMacroFile */.dp)(macros/* MACROS.AA_ON_ENTRY.type */.Vw.AA_ON_ENTRY.type, macros/* MACROS.AA_ON_ENTRY.file */.Vw.AA_ON_ENTRY.file);
  document.flags["itemacro"] = (0,macros/* generateItemMacroFlag */.gL)(document, itemMacroText);
  effect.flags["ActiveAuras"] = {
    isAura: true,
    aura: "All",
    radius: null,
    alignment: "",
    type: "",
    ignoreSelf: false,
    height: false,
    hidden: false,
    // hostile: true,
    onlyOnce: false,
    save: "str",
    savedc: null,
    displayTemp: true,
  };
  setProperty(effect, "duration.seconds", 60);
  setProperty(effect, "flags.dae.macroRepeat", "startEveryTurn");
  effect.changes.push((0,macros/* generateMacroChange */.n4)(""));
  setProperty(document, "flags.midi-qol.onUseMacroName", "[preActiveEffects]ItemMacro");

  const aaMacroFlags = {
    applyStart: true,
    handleStartRoll: true,
    autoDamageIfCondition: true,
    applyEnd: false,
    applyEntry: true,
    applyImmediate: true,
    everyEntry: false,
    conditionEffect: true,
    damageEffect: true,
    removeOnOff: true,
    allowVsRemoveCondition: true,
    removalCheck: ["str", "dex"],
    removalSave: null,
    saveRemoves: false,
    condition: "Restrained",
    dice: document.system.damage.parts[0][0],
    damageType: document.system.damage.parts[0][1],
    save: document.system.save.ability,
    sequencerFile: "jb2a.black_tentacles.dark_purple",
  };
  setProperty(document, "flags.ddbimporter.effect", aaMacroFlags);
  setProperty(effect, "flags.ddbimporter.effect", aaMacroFlags);
  setProperty(document, "flags.midiProperties.nodam", true);

  document.effects.push(effect);
  return document;

}

;// CONCATENATED MODULE: ./src/effects/spells/bless.js


function blessEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push(
    { key: "system.bonuses.abilities.save", value: "+1d4", mode: CONST.ACTIVE_EFFECT_MODES.ADD, priority: 20 },
    { key: "system.bonuses.All-Attacks", value: "+1d4", mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM, priority: 0 }
  );
  document.effects.push(effect);

  if (spellEffectModules().tokenMagicInstalled) {
    effect.changes.push(generateTokenMagicFXChange("bloom"));
  }

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/blindnessDeafness.js



async function blindnessDeafnessEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push({
    key: "flags.midi-qol.OverTime",
    mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
    value: "label=Blindness/Deafness (End of Turn),turn=end,saveDC=@attributes.spelldc,saveAbility=con,savingThrow=true,saveMagic=true",
    priority: "20",
  });
  const itemMacroText = await (0,macros/* loadMacroFile */.dp)("spell", "blindnessDeafness.js");
  document.flags["itemacro"] = (0,macros/* generateItemMacroFlag */.gL)(document, itemMacroText);
  effect.changes.push((0,macros/* generateMacroChange */.n4)(""));
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/blur.js


function blurEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push(
    {
      key: 'flags.midi-qol.grants.disadvantage.attack.all',
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: '1',
      priority: "20",
    }
  );

  if (spellEffectModules().tokenMagicInstalled) {
    effect.changes.push(generateTokenMagicFXChange("blur"));
  }

  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/boomingBlade.js


async function boomingBladeEffect(document) {
  const itemMacroText = await (0,macros/* loadMacroFile */.dp)("spell", "boomingBlade.js");
  setProperty(document, "flags.itemacro", (0,macros/* generateItemMacroFlag */.gL)(document, itemMacroText));
  document.system.damage = { parts: [], versatile: "", value: "" };
  document.system['target']['type'] = "self";
  document.system.range = { value: null, units: "self", long: null };
  setProperty(document, "flags.midi-qol.onUseMacroName", "[postActiveEffects]ItemMacro");
  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/brandingSmite.js



async function brandingSmiteEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push(
    {
      key: "flags.dnd5e.DamageBonusMacro",
      value: "ItemMacro.Branding Smite",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      priority: "20",
    },
    {
      key: "flags.midi-qol.brandingSmite.level",
      value: "@item.level",
      mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
      priority: "20",
    },
  );
  setProperty(effect, "flags.dae.specialDuration", ["1Hit:rwak", "1Hit:mwak"]);

  const itemMacroText = await (0,macros/* loadMacroFile */.dp)("spell", "brandingSmite.js");
  document.flags["itemacro"] = (0,macros/* generateItemMacroFlag */.gL)(document, itemMacroText);

  document.system.actionType = "other";
  document.system.target.type = "self";
  document.system.damage.parts = [];
  document.effects.push(effect);
  setProperty(document, "flags.midi-qol.onUseMacroName", "[postActiveEffects]ItemMacro");

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/callLightning.js



async function callLightningEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  const itemMacroText = await (0,macros/* loadMacroFile */.dp)("spell", "callLightning.js");
  document.flags["itemacro"] = (0,macros/* generateItemMacroFlag */.gL)(document, itemMacroText);
  effect.changes.push((0,macros/* generateMacroChange */.n4)("@spellLevel"));
  setProperty(effect, "flags.dae.selfTarget", true);
  setProperty(effect, "flags.dae.selfTargetAlways", true);
  document.effects.push(effect);
  setProperty(document, "system.actionType", "other");
  document.system.save.ability = "";
  setProperty(document, "flags.midi-qol.onUseMacroName", "[preTargeting]ItemMacro");

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/charmPerson.js


function charmPersonEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push(generateStatusEffectChange("Charmed"));
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/chillTouch.js

// import { loadMacroFile, generateMacroChange, generateItemMacroFlag } from "../macros.js";

async function chillTouchEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push({
    key: "system.traits.di.value",
    mode: CONST.ACTIVE_EFFECT_MODES.ADD,
    value: "healing",
    priority: "30",
  }, {
    key: "flags.midi-qol.onUseMacroName",
    mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
    value: "Chill Touch (Target effect),preAttackRoll",
    priority: "30",
  });
  // const itemMacroText = await loadMacroFile("spell", "chillTouch.js");
  // document.flags["itemacro"] = generateItemMacroFlag(document, itemMacroText);
  // effect.changes.push(generateMacroChange(""));
  setProperty(effect, "flags.dae.specialDuration", ["turnEndSource"]);
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/chromaticOrb.js


async function chromaticOrbEffect(document) {
  const itemMacroText = await (0,macros/* loadMacroFile */.dp)("spell", "chromaticOrb.js");
  setProperty(document, "flags.itemacro", (0,macros/* generateItemMacroFlag */.gL)(document, itemMacroText));
  setProperty(document, "flags.midi-qol.onUseMacroName", "[postDamageRoll]ItemMacro");

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/cloudkill.js



async function cloudkillEffect(document) {
  // we require active auras for this effect
  if (!spellEffectModules().activeAurasInstalled) return document;

  const itemMacroText = await (0,macros/* loadMacroFile */.dp)("generic", macros/* MACROS.AA_DAMAGE_ON_ENTRY.file */.Vw.AA_DAMAGE_ON_ENTRY.file);
  document.flags["itemacro"] = (0,macros/* generateItemMacroFlag */.gL)(document, itemMacroText);

  let effect = baseSpellEffect(document, document.name);
  effect.changes.push(
    {
      key: "flags.midi-qol.OverTime",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value:
        `label=${document.name} (Start of Turn),turn=start, saveAbility=${document.system.save.ability}, saveDC=@attributes.spelldc, saveDamage=halfdamage, rollType=save, saveMagic=true, damageBeforeSave=false, damageRoll=(@item.level)d8, damageType=${document.system.damage.parts[0][1]}`,
      priority: "20",
    },
  );
  effect.changes.push((0,macros/* generateMacroChange */.n4)("@item.level"));
  effect.flags["ActiveAuras"] = {
    isAura: true,
    aura: "All",
    radius: 20,
    alignment: "",
    type: "",
    ignoreSelf: false,
    height: false,
    hidden: false,
    // hostile: true,
    onlyOnce: false,
    save: "str",
    savedc: null,
    displayTemp: true,
  };
  setProperty(effect, "duration.seconds", 600);
  // setProperty(effect, "flags.dae.macroRepeat", "startEveryTurn");
  setProperty(document, "flags.midi-qol.onUseMacroName", "[preActiveEffects]ItemMacro");
  setProperty(document, "flags.ddbimporter.effect", {
    dice: document.system.damage.parts[0][0],
    damageType: document.system.damage.parts[0][1],
    save: document.system.save.ability,
    sequencerFile: "jb2a.fog_cloud.2.green",
  });

  document.effects.push(effect);
  document.system.damage = { parts: [], versatile: "", value: "" };
  document.system.actionType = "other";
  document.system.save.ability = "";

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/colorSpray.js


async function colorSprayEffect(document) {

  const itemMacroText = await (0,macros/* loadMacroFile */.dp)("spell", "colorSpray.js");
  document.flags["itemacro"] = (0,macros/* generateItemMacroFlag */.gL)(document, itemMacroText);
  setProperty(document, "flags.midi-qol.onUseMacroName", "[postActiveEffects]ItemMacro");
  document.system.damage = { parts: [["6d10", "midi-none"]], versatile: "", value: "" };

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/command.js


function commandEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/comprehendLanguages.js


function comprehendLanguagesEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push(
    {
      key: 'system.traits.languages.all',
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: '1',
      priority: "20",
    }
  );

  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/confusion.js



async function confusionEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push({
    key: "flags.midi-qol.OverTime",
    mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
    value: "label=Confusion (End of Turn),turn=end,saveAbility=wis,saveDC=@attributes.spelldc,saveMagic=true",
    priority: "20",
  });
  effect.flags.dae.macroRepeat = "startEveryTurn";
  const itemMacroText = await (0,macros/* loadMacroFile */.dp)("spell", "confusion.js");
  document.flags["itemacro"] = (0,macros/* generateItemMacroFlag */.gL)(document, itemMacroText);
  effect.changes.push((0,macros/* generateMacroChange */.n4)(""));
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/contagion.js



async function contagionEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.flags.dae.macroRepeat = "endEveryTurn";
  effect.changes.push(generateStatusEffectChange("Poisoned"));
  const itemMacroText = await (0,macros/* loadMacroFile */.dp)("spell", "contagion.js");
  document.flags["itemacro"] = (0,macros/* generateItemMacroFlag */.gL)(document, itemMacroText);
  effect.changes.push((0,macros/* generateMacroChange */.n4)(""));
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/createBonfire.js



async function createBonfireEffect(document) {
  // we require active auras for this effect
  if (!spellEffectModules().activeAurasInstalled) return document;

  const itemMacroText = await (0,macros/* loadMacroFile */.dp)("generic", macros/* MACROS.AA_DAMAGE_ON_ENTRY.file */.Vw.AA_DAMAGE_ON_ENTRY.file);
  document.flags["itemacro"] = (0,macros/* generateItemMacroFlag */.gL)(document, itemMacroText);

  let effect = baseSpellEffect(document, document.name);
  effect.changes.push(
    {
      key: "flags.midi-qol.OverTime",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value:
        "turn=end,label=Create Bonfire (End of Turn),damageRoll=(@cantripDice)d8,damageType=fire,saveRemove=false,saveDC=@attributes.spelldc,saveAbility=dex,saveDamage=nodamage,killAnim=true",
      priority: "20",
    },
  );
  effect.flags["ActiveAuras"] = {
    isAura: true,
    aura: "All",
    radius: null,
    alignment: "",
    type: "",
    ignoreSelf: false,
    height: false,
    hidden: false,
    // hostile: true,
    onlyOnce: false,
    save: "dex",
    savedc: null,
    displayTemp: true,
  };
  setProperty(effect, "duration.seconds", 60);
  effect.changes.push((0,macros/* generateMacroChange */.n4)(""));
  setProperty(document, "flags.midi-qol.onUseMacroName", "[preActiveEffects]ItemMacro");

  document.effects.push(effect);

  setProperty(document, "flags.ddbimporter.effect", {
    dice: document.system.damage.parts[0][0],
    damageType: document.system.damage.parts[0][1],
    save: document.system.save.ability,
    sequencerFile: "jb2a.flames.01.orange",
    isCantrip: true,
    saveOnEntry: true,
  });

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/crownofMadness.js


function crownofMadnessEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push(generateStatusEffectChange("Charmed"));
  effect.changes.push({
    key: "flags.midi-qol.OverTime",
    mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
    value: "label=Crown of Madness (End of Turn),turn=end,saveDC=@attributes.spelldc,saveAbility=wis,saveMagic=true",
    priority: "20",
  });
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/crownofStars.js




async function crownofStarsEffect(document) {
  let effect = baseSpellEffect(document, document.name);

  if (spellEffectModules().atlInstalled) {
    effect.changes.push((0,effects/* generateATLChange */.Ci)("ATL.dimLight", CONST.ACTIVE_EFFECT_MODES.UPGRADE, '60'));
    effect.changes.push((0,effects/* generateATLChange */.Ci)("ATL.brightLight", CONST.ACTIVE_EFFECT_MODES.UPGRADE, '30'));
  }
  setProperty(effect, "flags.dae.selfTarget", true);
  setProperty(effect, "flags.dae.selfTargetAlways", true);

  const itemMacroText = await (0,macros/* loadMacroFile */.dp)("spell", "crownofStars.js");
  document.flags["itemacro"] = (0,macros/* generateItemMacroFlag */.gL)(document, itemMacroText);
  effect.changes.push((0,macros/* generateMacroChange */.n4)("@spellLevel"));
  document.system.damage = { parts: [], versatile: "", value: "" };
  document.system.actionType = "other";
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/darkness.js



async function darknessEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  setProperty(effect, "flags.dae.selfTarget", true);
  setProperty(effect, "flags.dae.selfTargetAlways", true);
  const itemMacroText = await (0,macros/* loadMacroFile */.dp)("spell", "darkness.js");
  document.flags["itemacro"] = (0,macros/* generateItemMacroFlag */.gL)(document, itemMacroText);
  effect.changes.push((0,macros/* generateMacroChange */.n4)(""));
  document.effects.push(effect);
  setProperty(document, "flags.midi-qol.onUseMacroName", "[preTargeting]ItemMacro");
  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/darkvision.js



async function darkvisionEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push({
    key: "system.attributes.senses.darkvision",
    value: "60",
    mode: CONST.ACTIVE_EFFECT_MODES.UPGRADE,
    priority: 20,
  });

  if (spellEffectModules().atlInstalled) {
    effect.changes.push(generateATLChange("ATL.dimSight", CONST.ACTIVE_EFFECT_MODES.UPGRADE, 60, 5));
  } else {
    const itemMacroText = await (0,macros/* loadMacroFile */.dp)("spell", "darkvision.js");
    document.flags["itemacro"] = (0,macros/* generateItemMacroFlag */.gL)(document, itemMacroText);
    effect.changes.push((0,macros/* generateMacroChange */.n4)(""));
  }

  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/divineFavor.js


function divineFavorEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push(
    { key: "system.bonuses.mwak.damage", value: "1d4[Radiant]", mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM, priority: 0 },
    { key: "system.bonuses.rwak.damage", value: "1d4[Radiant]", mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM, priority: 0 }
  );
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/divineWord.js



async function divineWordEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  const itemMacroText = await (0,macros/* loadMacroFile */.dp)("spell", "divineWord.js");
  document.flags["itemacro"] = (0,macros/* generateItemMacroFlag */.gL)(document, itemMacroText);
  effect.changes.push((0,macros/* generateMacroChange */.n4)(""));
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/dominateBeast.js


function dominateBeastEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push(generateStatusEffectChange("Charmed"));
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/dominateMonster.js


function dominateMonsterEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push(generateStatusEffectChange("Charmed"));
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/dominatePerson.js


function dominatePersonEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push(generateStatusEffectChange("Charmed"));
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/elementalWeapon.js



async function elementalWeaponEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  const itemMacroText = await (0,macros/* loadMacroFile */.dp)("spell", "elementalWeapon.js");
  document.flags["itemacro"] = (0,macros/* generateItemMacroFlag */.gL)(document, itemMacroText);
  effect.changes.push((0,macros/* generateMacroChange */.n4)("@item.level", 0));
  document.effects.push(effect);

  document.system.damage.parts = [];
  document.system.actionType = "other";
  document.system.chatFlavor = "";

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/enhanceAbility.js



async function enhanceAbilityEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  const itemMacroText = await (0,macros/* loadMacroFile */.dp)("spell", "enhanceAbility.js");
  document.flags["itemacro"] = (0,macros/* generateItemMacroFlag */.gL)(document, itemMacroText);
  effect.changes.push((0,macros/* generateMacroChange */.n4)("", 20));
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/enlargeReduce.js



async function enlargeReduceEffect(document) {
  if (!spellEffectModules().atlInstalled) return document;

  let effect = baseSpellEffect(document, document.name);
  const itemMacroText = await (0,macros/* loadMacroFile */.dp)("spell", "enlargeReduce.js");
  document.flags["itemacro"] = (0,macros/* generateItemMacroFlag */.gL)(document, itemMacroText);
  effect.changes.push((0,macros/* generateMacroChange */.n4)("", 0));
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/ensnaringStrike.js



async function ensnaringStrikeEffect(document) {
  let effect = baseSpellEffect(document, document.name);

  const itemMacroText = await (0,macros/* loadMacroFile */.dp)("spell", "ensnaringStrike.js");
  setProperty(document, "flags.itemacro", (0,macros/* generateItemMacroFlag */.gL)(document, itemMacroText));
  effect.changes.push({
    key: "flags.midi-qol.onUseMacroName",
    value: `ItemMacro.${document.name},postActiveEffects`,
    mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
    priority: "20",
  });
  setProperty(effect, "flags.dae.selfTarget", true);
  setProperty(effect, "flags.dae.selfTargetAlways", true);

  document.effects.push(effect);
  document.system.damage = { parts: [], versatile: "", value: "" };
  document.system.actionType = null;
  document.system.save.ability = "";
  setProperty(document, "flags.midi-qol.onUseMacroName", "[preTargeting]ItemMacro");

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/entangle.js


function entangleEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push(generateStatusEffectChange("Restrained"));

  // not implemented as the target can choose to escape with it's action
  // effect.changes.push(
  //   {
  //     key: "flags.midi-qol.OverTime",
  //     mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
  //     value:
  //       `label=${document.name} (Start of Turn),turn=start, saveAbility=${document.system.save.ability}, saveDC=@attributes.spelldc, rollType=save, saveMagic=true, saveRemove=true`,
  //     priority: "20",
  //   },
  // );
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/eyebite.js



async function eyebiteEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  const itemMacroText = await (0,macros/* loadMacroFile */.dp)("spell", "eyebite.js");
  document.flags["itemacro"] = (0,macros/* generateItemMacroFlag */.gL)(document, itemMacroText);
  effect.flags.dae.macroRepeat = "startEveryTurn";
  effect.changes.push((0,macros/* generateMacroChange */.n4)(""));
  document.effects.push(effect);
  setProperty(document, "system.actionType", "other");
  setProperty(document, "system.save.ability", "");

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/faerieFire.js



async function faerieFireEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push({
    key: "flags.midi-qol.grants.advantage.attack.all",
    mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
    value: "1",
    priority: "20",
  });

  if (game.modules.get("ATL")?.active) {
    const itemMacroText = await (0,macros/* loadMacroFile */.dp)("spell", "faerieFire.js");
    document.flags["itemacro"] = (0,macros/* generateItemMacroFlag */.gL)(document, itemMacroText);
    effect.changes.push((0,macros/* generateMacroChange */.n4)("", 20));
  }

  if (spellEffectModules().tokenMagicInstalled) {
    effect.changes.push(generateTokenMagicFXChange("glow"));
  }

  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/fear.js


function fearEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push(generateStatusEffectChange("Frightened"));
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/feeblemind.js


function feeblemindEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push(
    { key: "system.abilities.cha.value", value: "1", mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE, priority: 50 },
    { key: "system.abilities.int.value", value: "1", mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE, priority: 50 },
    { key: "flags.midi-qol.fail.spell.all", value: "1", mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE, priority: 20 }
  );
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/fireShield.js



async function fireShieldEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  const itemMacroText = await (0,macros/* loadMacroFile */.dp)("spell", "fireShield.js");
  document.flags["itemacro"] = (0,macros/* generateItemMacroFlag */.gL)(document, itemMacroText);
  effect.changes.push((0,macros/* generateMacroChange */.n4)("", 0));
  document.system.damage = { parts: [], versatile: "", value: "" };
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/flameBlade.js



async function flameBladeEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  const itemMacroText = await (0,macros/* loadMacroFile */.dp)("spell", "flameBlade.js");
  document.flags["itemacro"] = (0,macros/* generateItemMacroFlag */.gL)(document, itemMacroText);
  effect.changes.push((0,macros/* generateMacroChange */.n4)("@spellLevel"));
  setProperty(effect, "flags.dae.selfTarget", true);
  setProperty(effect, "flags.dae.selfTargetAlways", true);
  document.system.actionType = "other";
  document.effects.push(effect);
  document.system.damage = { parts: [], versatile: "", value: "" };
  setProperty(document, "flags.midi-qol.onUseMacroName", "[preTargeting]ItemMacro");

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/fleshtoStone.js



async function fleshtoStoneEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push(generateStatusEffectChange("Restrained"));
  const itemMacroText = await (0,macros/* loadMacroFile */.dp)("spell", "fleshtoStone.js");
  document.flags["itemacro"] = (0,macros/* generateItemMacroFlag */.gL)(document, itemMacroText);
  effect.flags.dae.macroRepeat = "endEveryTurn";
  effect.changes.push((0,macros/* generateMacroChange */.n4)(""));
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/fly.js


function flyEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push({
    key: "system.attributes.movement.fly",
    value: "60",
    mode: CONST.ACTIVE_EFFECT_MODES.UPGRADE,
    priority: 20,
  });
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/frostbite.js


function frostbiteEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push(
    { key: "flags.midi-qol.disadvantage.attack.mwak", value: "1", mode: CONST.ACTIVE_EFFECT_MODES.ADD, priority: 50 },
    { key: "flags.midi-qol.disadvantage.attack.rwak", value: "1", mode: CONST.ACTIVE_EFFECT_MODES.ADD, priority: 50 },
  );
  setProperty(effect, "duration.turns", 1);
  setProperty(effect, "flags.dae.specialDuration", ["1Attack:rwak", "1Attack:mwak"]);
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/geas.js


function geasEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push(generateStatusEffectChange("Charmed"));
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/grease.js



async function greaseEffect(document) {

  if (!spellEffectModules().activeAurasInstalled) {
    let effect = baseSpellEffect(document, document.name);
    effect.changes.push(generateStatusEffectChange("Prone"));
    document.effects.push(effect);

    return document;
  }

  // if we have active auras use a more advanced macro
  let effect = baseSpellEffect(document, document.name);
  // effect.changes.push(generateStatusEffectChange("Prone", 20, true));
  effect.changes.push(
    {
      key: "flags.midi-qol.OverTime",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: `turn=end,label=${document.name},saveRemove=false,saveDC=@attributes.spelldc,saveAbility=${document.system.save.ability},saveDamage=nodamage,killAnim=true,macro=${macros/* MACROS.AA_CONDITION_ON_ENTRY.name */.Vw.AA_CONDITION_ON_ENTRY.name}`,
      priority: "20",
    },
  );

  const itemMacroText = await (0,macros/* loadMacroFile */.dp)(macros/* MACROS.AA_CONDITION_ON_ENTRY.type */.Vw.AA_CONDITION_ON_ENTRY.type, macros/* MACROS.AA_CONDITION_ON_ENTRY.file */.Vw.AA_CONDITION_ON_ENTRY.file);
  document.flags["itemacro"] = (0,macros/* generateItemMacroFlag */.gL)(document, itemMacroText);
  setProperty(document, "flags.midi-qol.onUseMacroName", "[preActiveEffects]ItemMacro");
  effect.changes.push((0,macros/* generateMacroChange */.n4)("@item.level @attributes.spelldc"));

  // effect.changes.push(generateMacroChange("@item.level @attributes.spelldc"));
  effect.flags["ActiveAuras"] = {
    isAura: true,
    aura: "All",
    radius: null,
    alignment: "",
    type: "",
    ignoreSelf: false,
    height: false,
    hidden: false,
    // hostile: true,
    onlyOnce: false,
    save: "dex",
    savedc: null,
    displayTemp: true,
  };
  setProperty(effect, "duration.seconds", 60);
  // setProperty(effect, "flags.dae.macroRepeat", "startEveryTurn");
  const aaMacroFlags = {
    applyStart: true,
    applyEnd: true,
    applyEntry: true,
    applyImmediate: true,
    everyEntry: true,
    removeOnOff: false,
    allowVsRemoveCondition: false,
    removalCheck: null,
    removalSave: null,
    saveRemoves: false,
    condition: "Prone",
    save: document.system.save.ability,
    sequencerFile: "jb2a.grease.dark_green.loop",
  };
  setProperty(document, "flags.ddbimporter.effect", aaMacroFlags);
  setProperty(effect, "flags.ddbimporter.effect", aaMacroFlags);

  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/greenFlameBlade.js


async function greenFlameBladeEffect(document) {
  const itemMacroText = await (0,macros/* loadMacroFile */.dp)("spell", "greenFlameBlade.js");
  setProperty(document, "flags.itemacro", (0,macros/* generateItemMacroFlag */.gL)(document, itemMacroText));
  document.system.damage = { parts: [], versatile: "", value: "" };
  document.system['target']['type'] = "self";
  document.system.range = { value: null, units: "self", long: null };
  document.system.actionType = "other";
  document.system.save.ability = "";
  setProperty(document, "flags.midi-qol.onUseMacroName", "[postActiveEffects]ItemMacro");
  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/guidance.js


function guidanceEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push(
    {
      key: 'flags.midi-qol.optional.guidance.label',
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: 'Guidance',
      priority: "20",
    },
    {
      key: 'flags.midi-qol.optional.guidance.check.all',
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: '+ 1d4',
      priority: "20",
    },
    {
      key: 'flags.midi-qol.optional.guidance.skill.all',
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: '+ 1d4',
      priority: "20",
    },
  );
  setProperty(effect, "flags.dae.specialDuration", ["isSkill", "isCheck"]);

  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/guidingBolt.js


function guidingBoltEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push({
    key: "flags.midi-qol.grants.advantage.attack.all",
    value: "1",
    mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
    priority: 20,
  });
  effect.flags.dae.specialDuration = ["isAttacked"];
  effect.duration = {
    startTime: null,
    seconds: null,
    rounds: 1,
    turns: 1,
    startRound: null,
    startTurn: null,
  };
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/haste.js


function hasteEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push(
    { key: "system.attributes.ac.bonus", mode: CONST.ACTIVE_EFFECT_MODES.ADD, value: "+2", priority: "20" },
    {
      key: "flags.midi-qol.advantage.ability.save.dex",
      mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
      value: "1",
      priority: "20",
    },
    { key: "system.attributes.movement.all", mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM, value: "*2", priority: "30" }
  );
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/heroesFeast.js



async function heroesFeastEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push(
    { key: "system.traits.di.value", value: "poison", mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM, priority: 20 },
    { key: "system.traits.ci.value", value: "frightened", mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM, priority: 20 }
  );
  const itemMacroText = await (0,macros/* loadMacroFile */.dp)("spell", "heroesFeast.js");
  document.flags["itemacro"] = (0,macros/* generateItemMacroFlag */.gL)(document, itemMacroText);
  effect.changes.push((0,macros/* generateMacroChange */.n4)("@damage", 0));
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/heroism.js



async function heroismEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push({
    key: "system.traits.ci.value",
    value: "frightened",
    mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
    priority: 20,
  });
  effect.flags.dae.macroRepeat = "startEveryTurn";
  const itemMacroText = await (0,macros/* loadMacroFile */.dp)("spell", "heroism.js");
  document.flags["itemacro"] = (0,macros/* generateItemMacroFlag */.gL)(document, itemMacroText);
  effect.changes.push((0,macros/* generateMacroChange */.n4)("@damage", 0));
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/hex.js



// this one is a bit different, the macro is triggered by midi-qol and applies effects to the actor
// the Marked effect gets applied to the target
async function hexEffect(document) {
  let effect = baseSpellEffect(document, "Marked");

  const itemMacroText = await (0,macros/* loadMacroFile */.dp)("spell", "hex.js");

  setProperty(document, "flags.itemacro", (0,macros/* generateItemMacroFlag */.gL)(document, itemMacroText));
  setProperty(document, "flags.midi-qol.onUseMacroName", "[postActiveEffects]ItemMacro");
  setProperty(document, "system.actionType", "util");

  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/hideousLaughter.js



async function hideousLaughterEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push(
    generateStatusEffectChange("Incapacitated"),
    generateStatusEffectChange("Prone"),
  );

  effect.changes.push({
    key: "flags.midi-qol.OverTime",
    mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
    value: "label=Hideous Laughter (End of Turn),turn=end,saveDC=@attributes.spelldc,saveAbility=wis,saveMagic=true",
    priority: "20",
  });

  const itemMacroText = await (0,macros/* loadMacroFile */.dp)("spell", "hideousLaughter.js");

  document.flags["itemacro"] = (0,macros/* generateItemMacroFlag */.gL)(document, itemMacroText);
  effect.changes.push((0,macros/* generateMacroChange */.n4)(""));
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/holdMonster.js


function holdMonsterEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push(generateStatusEffectChange("Paralyzed"));
  effect.changes.push({
    key: "flags.midi-qol.OverTime",
    mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
    value: `label=${document.name} (End of Turn),turn=end,saveDC=@attributes.spelldc,saveAbility=wis,savingThrow=true,saveMagic=true`,
    priority: "20",
  });
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/holdPerson.js


function holdPersonEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push(generateStatusEffectChange("Paralyzed"));
  effect.changes.push({
    key: "flags.midi-qol.OverTime",
    mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
    value: `label=${document.name} (End of Turn),turn=end,saveDC=@attributes.spelldc,saveAbility=wis,savingThrow=true,saveMagic=true`,
    priority: "20",
  });
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/holyAura.js


function holyAuraEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push(
    {
      key: "flags.midi-qol.advantage.ability.save.all",
      mode: CONST.ACTIVE_EFFECT_MODES.ADD,
      value: "1",
      priority: "20",
    },
    {
      key: "flags.midi-qol.grants.disadvantage.attack.all",
      mode: CONST.ACTIVE_EFFECT_MODES.ADD,
      value: "1",
      priority: "20",
    },
  );

  if (CONFIG.DDBI.EFFECT_CONFIG.SPELLS.installedModules.atlInstalled) {
    effect.changes.push(generateATLChange("ATL.dimLight", CONST.ACTIVE_EFFECT_MODES.UPGRADE, '5'));
    effect.changes.push(generateATLChange("ATL.lightColor", CONST.ACTIVE_EFFECT_MODES.OVERRIDE, '#ffffff'));
    effect.changes.push(generateATLChange("ATL.lightAlpha", CONST.ACTIVE_EFFECT_MODES.OVERRIDE, '0.25'));
    const lightAnimation = '{"type": "sunburst", "speed": 2,"intensity": 4}';
    effect.changes.push(generateATLChange("ATL.lightAnimation", CONST.ACTIVE_EFFECT_MODES.OVERRIDE, lightAnimation));
  }

  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/huntersMark.js



// this one is a bit different, the macro is triggered by midi-qol and applies effects to the actor
// the Marked effect gets applied to the target
async function huntersMarkEffect(document) {
  let effect = baseSpellEffect(document, "Marked");
  effect.changes.push(
    {
      key: "flags.dae.onUpdateSource",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: "Hunter's Mark",
      priority: 20,
    },
  );
  effect.duration.seconds = 3600;
  document.effects.push(effect);

  let damageBonusEffect = baseSpellEffect(document, "Hunter's Mark");
  damageBonusEffect.changes.push({
    key: "flags.dnd5e.DamageBonusMacro",
    value: "ItemMacro",
    mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
    priority: 20,
  });
  damageBonusEffect.transfer = true;

  setProperty(damageBonusEffect, "flags.dae.transfer", true);
  document.effects.push(damageBonusEffect);

  const itemMacroText = await (0,macros/* loadMacroFile */.dp)("spell", "huntersMark.js");
  setProperty(document, "flags.itemacro", (0,macros/* generateItemMacroFlag */.gL)(document, itemMacroText));
  setProperty(document, "system.actionType", "util");

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/hypnoticPattern.js


function hypnoticPatternEffect(document) {
  let effectHypnoticPatternCharmed = baseSpellEffect(document, document.name);
  effectHypnoticPatternCharmed.changes.push(generateStatusEffectChange("Charmed"));
  document.effects.push(effectHypnoticPatternCharmed);

  let effectHypnoticPatternIncapacitated = baseSpellEffect(document, document.name);
  effectHypnoticPatternIncapacitated.changes.push(generateStatusEffectChange("Incapacitated"));
  document.effects.push(effectHypnoticPatternIncapacitated);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/iceKnife.js


async function iceKnifeEffect(document) {
  const itemMacroText = await (0,macros/* loadMacroFile */.dp)("spell", "iceKnife.js");
  setProperty(document, "flags.itemacro", (0,macros/* generateItemMacroFlag */.gL)(document, itemMacroText));
  setProperty(document, "flags.midi-qol.onUseMacroName", "[postActiveEffects]ItemMacro");
  document.system.damage = { parts: [["1d10", "piercing"]], versatile: "", value: "" };
  document.system.scaling = { mode: "none", formula: "" };
  document.system.target = {
    value: 1,
    width: null,
    units: "",
    type: "creature",
  };
  document.system.save.ability = "";
  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/incendiaryCloud.js



async function incendiaryCloudEffect(document) {
  // we require active auras for this effect
  if (!spellEffectModules().activeAurasInstalled) return document;

  const itemMacroText = await (0,macros/* loadMacroFile */.dp)("generic", macros/* MACROS.AA_DAMAGE_ON_ENTRY.file */.Vw.AA_DAMAGE_ON_ENTRY.file);
  document.flags["itemacro"] = (0,macros/* generateItemMacroFlag */.gL)(document, itemMacroText);

  let effect = baseSpellEffect(document, document.name);
  effect.changes.push(
    {
      key: "flags.midi-qol.OverTime",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value:
        `label=${document.name} Turn End,turn=end, saveAbility=${document.system.save.ability}, saveDC=@attributes.spelldc, saveDamage=halfdamage, rollType=save, saveMagic=true, damageBeforeSave=false, damageRoll=(@item.level)d8, damageType=${document.system.damage.parts[0][1]}`,
      priority: "20",
    },
  );
  effect.changes.push((0,macros/* generateMacroChange */.n4)("@item.level"));
  effect.flags["ActiveAuras"] = {
    isAura: true,
    aura: "All",
    radius: 20,
    alignment: "",
    type: "",
    ignoreSelf: false,
    height: false,
    hidden: false,
    // hostile: true,
    onlyOnce: false,
    save: "dex",
    savedc: null,
    displayTemp: true,
  };
  setProperty(effect, "duration.seconds", 60);
  // setProperty(effect, "flags.dae.macroRepeat", "startEveryTurn");
  setProperty(document, "flags.midi-qol.onUseMacroName", "[preActiveEffects]ItemMacro");
  setProperty(document, "flags.ddbimporter.effect", {
    dice: document.system.damage.parts[0][0],
    damageType: document.system.damage.parts[0][1],
    save: document.system.save.ability,
    sequencerFile: "jb2a.fumes.fire.orange",
  });

  document.effects.push(effect);
  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/insectPlague.js



async function insectPlagueEffect(document) {
  // we require active auras for this effect
  if (!spellEffectModules().activeAurasInstalled) return document;

  const itemMacroText = await (0,macros/* loadMacroFile */.dp)("generic", macros/* MACROS.AA_DAMAGE_ON_ENTRY.file */.Vw.AA_DAMAGE_ON_ENTRY.file);
  document.flags["itemacro"] = (0,macros/* generateItemMacroFlag */.gL)(document, itemMacroText);

  let effect = baseSpellEffect(document, document.name);
  effect.changes.push(
    {
      key: "flags.midi-qol.OverTime",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value:
        `label=${document.name} Turn End,turn=end, saveAbility=${document.system.save.ability}, saveDC=@attributes.spelldc, saveDamage=halfdamage, rollType=save, saveMagic=true, damageBeforeSave=false, damageRoll=(@item.level)d10, damageType=${document.system.damage.parts[0][1]}`,
      priority: "20",
    },
  );
  effect.changes.push((0,macros/* generateMacroChange */.n4)("@item.level"));
  effect.flags["ActiveAuras"] = {
    isAura: true,
    aura: "All",
    radius: 20,
    alignment: "",
    type: "",
    ignoreSelf: false,
    height: false,
    hidden: false,
    // hostile: true,
    onlyOnce: false,
    save: "dex",
    savedc: null,
    displayTemp: true,
  };
  setProperty(effect, "duration.seconds", 600);
  // setProperty(effect, "flags.dae.macroRepeat", "startEveryTurn");
  setProperty(document, "flags.midi-qol.onUseMacroName", "[preActiveEffects]ItemMacro");
  setProperty(document, "flags.ddbimporter.effect", {
    dice: document.system.damage.parts[0][0],
    damageType: document.system.damage.parts[0][1],
    save: document.system.save.ability,
    sequencerFile: "jb2a.butterflies.many.orange",
  });

  document.effects.push(effect);
  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/invisibility.js


async function invisibilityEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push(generateStatusEffectChange("Convenient Effect: Invisible"));

  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/irresistibleDance.js



async function irresistibleDanceEffect(document) {
  let effect = baseSpellEffect(document, document.name);

  effect.changes.push({
    key: "flags.midi-qol.disadvantage.ability.save.str",
    mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
    value: "1",
    priority: "20",
  });
  effect.changes.push({
    key: "flags.midi-qol.disadvantage.attack.all",
    mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
    value: "1",
    priority: "20",
  });
  effect.changes.push({
    key: "flags.midi-qol.grants.advantage.attack.all ",
    mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
    value: "1",
    priority: "20",
  });

  effect.flags.dae.macroRepeat = "startEveryTurn";
  const itemMacroText = await (0,macros/* loadMacroFile */.dp)("spell", "irresistibleDance.js");
  document.flags["itemacro"] = (0,macros/* generateItemMacroFlag */.gL)(document, itemMacroText);
  effect.changes.push((0,macros/* generateMacroChange */.n4)(""));
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/light.js


function lightEffect(document) {
  let effect = baseSpellEffect(document, document.name);

  if (spellEffectModules().atlInstalled) {
    effect.changes.push(generateATLChange("ATL.dimLight", CONST.ACTIVE_EFFECT_MODES.OVERRIDE, '40'));
    effect.changes.push(generateATLChange("ATL.brightLight", CONST.ACTIVE_EFFECT_MODES.OVERRIDE, '20'));
    effect.changes.push(generateATLChange("ATL.lightColor", CONST.ACTIVE_EFFECT_MODES.OVERRIDE, '#ffffff'));
    effect.changes.push(generateATLChange("ATL.lightAlpha", CONST.ACTIVE_EFFECT_MODES.OVERRIDE, '0.25'));
    const lightAnimation = '{"type": "pulse", "speed": 3,"intensity": 1}';
    effect.changes.push(generateATLChange("ATL.lightAnimation", CONST.ACTIVE_EFFECT_MODES.OVERRIDE, lightAnimation));
  }

  setProperty(document, "flags.midiProperties.autoFailFriendly", true);
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/longstrider.js


function longstriderEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push(
    { key: "system.attributes.movement.walk", value: "10", mode: CONST.ACTIVE_EFFECT_MODES.ADD, priority: 20 },
    { key: "system.attributes.movement.fly", value: "10", mode: CONST.ACTIVE_EFFECT_MODES.ADD, priority: 20 },
    { key: "system.attributes.movement.burrow", value: "10", mode: CONST.ACTIVE_EFFECT_MODES.ADD, priority: 20 },
    { key: "system.attributes.movement.climb", value: "10", mode: CONST.ACTIVE_EFFECT_MODES.ADD, priority: 20 },
    { key: "system.attributes.movement.swim", value: "10", mode: CONST.ACTIVE_EFFECT_MODES.ADD, priority: 20 }
  );
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/mageArmor.js


function mageArmorEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push({
    key: "system.attributes.ac.calc",
    mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
    value: "mage",
    priority: "5",
  });
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/magicWeapon.js



async function magicWeaponEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  const itemMacroText = await (0,macros/* loadMacroFile */.dp)("spell", "magicWeapon.js");
  document.flags["itemacro"] = (0,macros/* generateItemMacroFlag */.gL)(document, itemMacroText);
  effect.changes.push((0,macros/* generateMacroChange */.n4)("@item.level", 0));
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/massSuggestion.js


function massSuggestionEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push(generateStatusEffectChange("Charmed"));
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/mindBlank.js


function mindBlankEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push(
    {
      key: 'system.traits.di.value',
      mode: CONST.ACTIVE_EFFECT_MODES.ADD,
      value: 'psychic',
      priority: "20",
    }
  );

  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/mirrorImage.js


function mirrorImageEffect(document) {
  let effect = baseSpellEffect(document, document.name);

  if (spellEffectModules().tokenMagicInstalled) {
    effect.changes.push(generateTokenMagicFXChange("images"));
  }

  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/mistyStep.js



async function mistyStepEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  const itemMacroText = await (0,macros/* loadMacroFile */.dp)("spell", "mistyStep.js");
  document.flags["itemacro"] = (0,macros/* generateItemMacroFlag */.gL)(document, itemMacroText);
  effect.changes.push((0,macros/* generateMacroChange */.n4)("@target"));
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/moonbeam.js



async function moonbeamEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.flags.dae.macroRepeat = "startEveryTurn";
  const itemMacroText = await (0,macros/* loadMacroFile */.dp)("spell", "moonbeam.js");
  document.flags["itemacro"] = (0,macros/* generateItemMacroFlag */.gL)(document, itemMacroText);
  effect.changes.push((0,macros/* generateMacroChange */.n4)("@spellLevel"));
  setProperty(effect, "flags.dae.selfTarget", true);
  setProperty(effect, "flags.dae.selfTargetAlways", true);
  document.effects.push(effect);
  document.system.damage = { parts: [], versatile: "", value: "" };
  document.system.actionType = "other";
  document.system.save.ability = "";

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/passWithoutTrace.js


function passWithoutTraceEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push(
    {
      key: 'system.skills.ste.bonuses.check',
      mode: CONST.ACTIVE_EFFECT_MODES.ADD,
      value: '+ 10',
      priority: "20",
    }
  );

  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/phantasmalKiller.js


function phantasmalKillerEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push({
    key: "flags.midi-qol.OverTime",
    mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
    value:
      "label=Phantasmal Killer (Start of Turn),turn=end,saveAbility=wis,saveDC=@attributes.spelldc,saveMagic=true,damageRoll=(@item.level)d10,damageType=psychic,savingThrow=true,damageBeforeSave=false",
    priority: "20",
  });
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/polymorph.js
function polymorphEffect(document) {

  setProperty(document, "flags.midiProperties.autoFailFriendly", true);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/protectionfromEnergy.js



async function protectionfromEnergyEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  const itemMacroText = await (0,macros/* loadMacroFile */.dp)("spell", "protectionfromEnergy.js");
  document.flags["itemacro"] = (0,macros/* generateItemMacroFlag */.gL)(document, itemMacroText);
  effect.changes.push((0,macros/* generateMacroChange */.n4)("", 0));
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/protectionfromPoison.js


function protectionfromPoisonEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push({
    key: "system.traits.dr.value",
    value: "poison",
    mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
    priority: 0,
  });
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/rayofEnfeeblement.js



async function rayofEnfeeblementEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push({
    key: "flags.midi-qol.OverTime",
    mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
    value: `label=${document.name} (End of Turn),turn=end,saveDC=@attributes.spelldc,saveAbility=con,savingThrow=true,saveMagic=true`,
    priority: "20",
  });
  const itemMacroText = await (0,macros/* loadMacroFile */.dp)("spell", "rayofEnfeeblement.js");
  document.flags["itemacro"] = (0,macros/* generateItemMacroFlag */.gL)(document, itemMacroText);
  effect.changes.push((0,macros/* generateMacroChange */.n4)(""));
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/rayofFrost.js


function rayofFrostEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push({
    key: "system.attributes.movement.walk",
    value: "-10",
    mode: CONST.ACTIVE_EFFECT_MODES.ADD,
    priority: 20,
  });
  effect.flags.dae.specialDuration = ["turnStart"];
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/regenerate.js


function regenerateEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push(
    {
      key: "flags.midi-qol.OverTime",
      mode: 5,
      value: `label=${document.name} (Start of Turn),turn=end,damageRoll=1,damageType=healing,condition=@attributes.hp.value > 0 && @attributes.hp.value < @attributes.hp.max`,
      priority: "20",
    }
  );
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/resilientSphere.js


function resilientSphereEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push(
    {
      key: 'system.attributes.movement.all',
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: '* 0.5',
      priority: "20",
    },
    {
      key: 'system.traits.di.all',
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: '1',
      priority: "20",
    },
  );

  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/resistance.js


function resistanceEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push(
    {
      key: 'flags.midi-qol.optional.resistance.label',
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: 'Resistance',
      priority: "20",
    },
    {
      key: 'flags.midi-qol.optional.resistance.save.all',
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: '+ 1d4',
      priority: "20",
    },
  );
  setProperty(effect, "flags.dae.specialDuration", ["isSave"]);

  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/shield.js


function shieldEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push({
    key: "system.attributes.ac.bonus",
    mode: CONST.ACTIVE_EFFECT_MODES.ADD,
    value: "+5",
    priority: "20",
  });
  effect.flags.dae.specialDuration = ["turnStart"];

  if (spellEffectModules().tokenMagicInstalled) {
    effect.changes.push(generateTokenMagicFXChange("water-field"));
  }

  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/shieldofFaith.js


function shieldofFaithEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push({
    key: "system.attributes.ac.bonus",
    mode: CONST.ACTIVE_EFFECT_MODES.ADD,
    value: "+2",
    priority: "20",
  });

  if (spellEffectModules().tokenMagicInstalled) {
    effect.changes.push(generateTokenMagicFXChange("bloom"));
  }

  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/shillelagh.js



async function shillelaghEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  const itemMacroText = await (0,macros/* loadMacroFile */.dp)("spell", "shillelagh.js");
  document.flags["itemacro"] = (0,macros/* generateItemMacroFlag */.gL)(document, itemMacroText);
  effect.changes.push((0,macros/* generateMacroChange */.n4)("", 0));
  setProperty(effect, "flags.dae.selfTarget", true);
  setProperty(effect, "flags.dae.selfTargetAlways", true);
  document.system.actionType = "other";
  document.effects.push(effect);
  document.system.damage = { parts: [], versatile: "", value: "" };
  setProperty(document, "flags.midi-qol.onUseMacroName", "[preTargeting]ItemMacro");

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/silence.js



async function silenceEffect(document) {

  if (!spellEffectModules().activeAurasInstalled) {
    return document;
  }

  // if we have active auras use a more advanced macro
  const itemMacroText = await (0,macros/* loadMacroFile */.dp)("generic", "activeAuraOnly.js");
  document.flags["itemacro"] = (0,macros/* generateItemMacroFlag */.gL)(document, itemMacroText);

  let effect = baseSpellEffect(document, document.name);
  effect.changes.push(generateStatusEffectChange("Deafened", 20, true));
  effect.changes.push(
    {
      key: "flags.midi-qol.fail.spell.vocal",
      mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
      value: "1",
      priority: "50",
    },
    {
      key: "system.traits.di.value",
      mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
      value: "thunder",
      priority: "50",
    }
  );
  effect.flags["ActiveAuras"] = {
    isAura: true,
    aura: "All",
    radius: 20,
    alignment: "",
    type: "",
    ignoreSelf: false,
    height: false,
    hidden: false,
    // hostile: true,
    onlyOnce: false,
    save: "",
    savedc: null,
    displayTemp: true,
  };
  setProperty(effect, "duration.seconds", 600);
  setProperty(document, "flags.midi-qol.onUseMacroName", "[preActiveEffects]ItemMacro");

  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/sleep.js


async function sleepEffect(document) {

  const itemMacroText = await (0,macros/* loadMacroFile */.dp)("spell", "sleep.js");
  document.flags["itemacro"] = (0,macros/* generateItemMacroFlag */.gL)(document, itemMacroText);
  setProperty(document, "flags.midi-qol.onUseMacroName", "[postActiveEffects]ItemMacro");
  document.system.damage = { parts: [["5d8", "midi-none"]], versatile: "", value: "" };

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/slow.js


function slowEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push(
    { key: "system.attributes.ac.bonus", mode: CONST.ACTIVE_EFFECT_MODES.ADD, value: "-2", priority: "20" },
    { key: "system.attributes.movement.all", mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM, value: "/2", priority: "20" },
    { key: "system.abilities.dex.save", mode: CONST.ACTIVE_EFFECT_MODES.ADD, value: "-2", priority: "20" }
  );
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/spiderClimb.js


function spiderClimbEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push({
    key: "system.attributes.movement.climb",
    value: "@attributes.movement.walk",
    mode: CONST.ACTIVE_EFFECT_MODES.UPGRADE,
    priority: 20,
  });
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/spikeGrowth.js



async function spikeGrowthEffect(document) {
  // we require active auras for this effect
  if (!spellEffectModules().activeAurasInstalled) return document;

  const itemMacroText = await (0,macros/* loadMacroFile */.dp)("spell", "spikeGrowth.js");
  document.flags["itemacro"] = (0,macros/* generateItemMacroFlag */.gL)(document, itemMacroText);

  let effect = baseSpellEffect(document, document.name);
  effect.changes.push(
    {
      key: "system.attributes.movement.walk",
      value: "0.5",
      mode: CONST.ACTIVE_EFFECT_MODES.MULTIPLY,
      priority: 30,
    },
  );
  effect.changes.push((0,macros/* generateMacroChange */.n4)(""));
  effect.flags["ActiveAuras"] = {
    isAura: true,
    aura: "All",
    radius: 20,
    alignment: "",
    type: "",
    ignoreSelf: false,
    height: false,
    hidden: false,
    // hostile: true,
    onlyOnce: false,
    // save: "dex",
    savedc: null,
    displayTemp: true,
  };
  setProperty(effect, "duration.seconds", 600);
  setProperty(effect, "flags.dae.specialDuration", ["isMoved"]);
  setProperty(document, "flags.midi-qol.onUseMacroName", "[preActiveEffects]ItemMacro");

  document.effects.push(effect);
  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/spiritGuardians.js



async function spiritGuardiansEffect(document) {
  // we require active auras for this effect
  if (!spellEffectModules().activeAurasInstalled) return document;

  let effect = baseSpellEffect(document, document.name);
  effect.changes.push(
    {
      key: "system.attributes.movement.all",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: "/2",
      priority: "20",
    },
    {
      key: "flags.midi-qol.OverTime",
      mode: CONST.ACTIVE_EFFECT_MODES.ADD,
      value:
        "turn=start,label=Spirit Guardians (Start of Turn),damageRoll=(@spellLevel)d8,damageType=radiant,saveRemove=false,saveDC=@attributes.spelldc,saveAbility=wis,saveDamage=halfdamage,killAnim=true",
      priority: "20",
    }
  );
  const itemMacroText = await (0,macros/* loadMacroFile */.dp)("spell", "spiritGuardians.js");
  document.flags["itemacro"] = (0,macros/* generateItemMacroFlag */.gL)(document, itemMacroText);
  effect.flags["ActiveAuras"] = {
    isAura: true,
    aura: "Enemy",
    radius: 15,
    alignment: "",
    type: "",
    ignoreSelf: true,
    height: false,
    hidden: false,
    hostile: false,
    onlyOnce: false,
    displayTemp: true,
  };
  effect.changes.push((0,macros/* generateMacroChange */.n4)("@token @spellLevel @attributes.spelldc"));
  setProperty(effect, "flags.dae.selfTarget", true);
  setProperty(effect, "flags.dae.selfTargetAlways", true);
  document.effects.push(effect);

  document.system.damage = { parts: [], versatile: "", value: "" };
  document.system['target']['type'] = "self";
  document.system.range = { value: 15, units: "ft", long: null };
  document.system.actionType = "";
  document.system.save.ability = "";

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/spiritShroud.js



async function spiritShroudEffect(document) {
  if (!spellEffectModules().activeAurasInstalled) return document;
  let effect = baseSpellEffect(document, document.name);

  effect.changes.push(
    {
      key: "flags.midi-qol.spiritShroud",
      mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
      value: "@uuid",
      priority: 20
    },
    {
      key: "system.attributes.movement.all",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: "-10",
      priority: "15",
    });
  effect.flags["ActiveAuras"] = {
    isAura: true,
    aura: "Enemy",
    radius: 10,
    alignment: "",
    type: "",
    ignoreSelf: true,
    height: false,
    hidden: false,
    hostile: false,
    onlyOnce: false,
    displayTemp: true,
  };
  setProperty(effect, "flags.dae.selfTarget", true);
  setProperty(effect, "flags.dae.selfTargetAlways", true);

  const itemMacroText = await (0,macros/* loadMacroFile */.dp)("spell", "spiritShroud.js");
  setProperty(document, "flags.itemacro", (0,macros/* generateItemMacroFlag */.gL)(document, itemMacroText));
  setProperty(document, "flags.midi-qol.onUseMacroName", "[preActiveEffects]ItemMacro");

  document.system.damage = { parts: [], versatile: "", value: "" };
  document.system['target']['type'] = "self";
  document.system.range = { value: null, units: "self", long: null };
  document.system.actionType = "other";
  document.system.save.ability = "";

  document.effects.push(effect);
  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/spiritualWeapon.js



async function spiritualWeaponEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  const itemMacroText = await (0,macros/* loadMacroFile */.dp)("spell", "spiritualWeapon.js");
  document.flags["itemacro"] = (0,macros/* generateItemMacroFlag */.gL)(document, itemMacroText);
  effect.changes.push((0,macros/* generateMacroChange */.n4)("@item.level"));
  setProperty(effect, "flags.dae.selfTarget", true);
  setProperty(effect, "flags.dae.selfTargetAlways", true);
  document.effects.push(effect);

  document.system.damage = { parts: [], versatile: "", value: "" };
  document.system.actionType = "other";

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/stoneskin.js


function stoneskinEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push({
    key: "system.traits.dr.value",
    value: "physical",
    mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
    priority: 0,
  });
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/stormSphere.js



async function stormSphereEffect(document) {
  // we require active auras for this effect
  if (!spellEffectModules().activeAurasInstalled) return document;

  let effect = baseSpellEffect(document, document.name);
  effect.changes.push(
    {
      key: "flags.midi-qol.disadvantage.skill.prc",
      mode: CONST.ACTIVE_EFFECT_MODES.ADD,
      value: "0",
      priority: "20",
    },
    {
      key: "flags.midi-qol.OverTime",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value:
        "turn=end,label=Storm Sphere (End of Turn),damageRoll=(@item.level - 2)d6,damageType=bludgeoning,saveRemove=false,saveDC=@attributes.spelldc,saveAbility=str,saveDamage=nodamage,killAnim=true",
      priority: "20",
    }
  );
  const itemMacroText = await (0,macros/* loadMacroFile */.dp)("spell", "stormSphere.js");
  document.flags["itemacro"] = (0,macros/* generateItemMacroFlag */.gL)(document, itemMacroText);
  effect.flags["ActiveAuras"] = {
    isAura: true,
    aura: "All",
    radius: 20,
    alignment: "",
    type: "",
    ignoreSelf: false,
    height: false,
    hidden: false,
    // hostile: true,
    onlyOnce: false,
    save: "str",
    savedc: null,
    displayTemp: true,
  };
  setProperty(effect, "duration.seconds", 60);
  setProperty(effect, "flags.dae.macroRepeat", "startEveryTurn");
  effect.changes.push((0,macros/* generateMacroChange */.n4)(""));
  setProperty(document, "flags.midi-qol.onUseMacroName", "[preActiveEffects]ItemMacro");

  document.effects.push(effect);

  const damageOne = duplicate(document.system.damage.parts[0]);
  const damageTwo = duplicate(document.system.damage.parts[1]);
  document.system.damage = { parts: [damageOne], versatile: "", value: "" };
  document.system.formula = damageTwo[0];
  document.system.actionType = "save";

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/sunbeam.js


function sunbeamEffect(document) {
  let effectSunbeamBlinded = baseSpellEffect(document, document.name);
  effectSunbeamBlinded.changes.push(generateStatusEffectChange("Blinded"));
  document.effects.push(effectSunbeamBlinded);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/thunderousSmite.js



async function thunderousSmiteEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push(
    {
      key: "flags.dnd5e.DamageBonusMacro",
      value: "ItemMacro.Thunderous Smite",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      priority: "20",
    },
    {
      key: "flags.midi-qol.thunderousSmite.dc",
      value: "@attributes.spelldc",
      mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
      priority: "20",
    },
  );
  setProperty(effect, "flags.dae.specialDuration", ["1Hit:mwak"]);
  setProperty(effect, "flags.dae.selfTarget", true);
  setProperty(effect, "flags.dae.selfTargetAlways", true);

  const itemMacroText = await (0,macros/* loadMacroFile */.dp)("spell", "thunderousSmite.js");
  document.flags["itemacro"] = (0,macros/* generateItemMacroFlag */.gL)(document, itemMacroText);
  document.system.damage.parts = [];
  document.system.save.ability = "";
  document.system.actionType = "other";
  document.effects.push(effect);
  setProperty(document, "flags.midi-qol.onUseMacroName", "[postActiveEffects]ItemMacro,[preTargeting]ItemMacro");

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/tolltheDead.js


async function tolltheDeadEffect(document) {
  const itemMacroText = await (0,macros/* loadMacroFile */.dp)("spell", "tolltheDead.js");
  setProperty(document, "flags.itemacro", (0,macros/* generateItemMacroFlag */.gL)(document, itemMacroText));
  setProperty(document, "flags.midi-qol.onUseMacroName", "[postActiveEffects]ItemMacro");

  document.system.damage = { parts: [], versatile: "", value: "" };
  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/trueStrike.js


function trueStrikeEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push({
    key: "flags.midi-qol.advantage.attack.all",
    value: "1",
    mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
    priority: 20,
  });
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/viciousMockery.js


function viciousMockeryEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push({
    key: "flags.midi-qol.disadvantage.attack.all",
    value: "1",
    mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
    priority: 20,
  });
  setProperty(effect, "duration.turns", 1);
  setProperty(effect, "flags.dae.specialDuration", ["1Attack", "turnEnd"]);
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/vitriolicSphere.js
// Vitriolic Sphere




function vitriolicSphereEffect(document) {

  let effect = baseSpellEffect(document, document.name);
  effect.changes.push(
    {
      key: "flags.midi-qol.OverTime",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: `turn=end,label=${document.name} (End of Turn),damageRoll=5d4,damageType=acid,removeCondition=true`,
      priority: "20",
    }
  );
  setProperty(effect, "flags.dae.specialDuration", ["turnEnd"]);
  setProperty(effect, "duration.rounds", 1);
  document.effects.push(effect);

  const damageOne = duplicate(document.system.damage.parts[0]);
  const damageTwo = duplicate(document.system.damage.parts[1]);
  document.system.damage = { parts: [damageOne], versatile: "", value: "" };
  document.system.formula = damageTwo[0];
  document.system.actionType = "save";

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/wardingBond.js



async function wardingBondEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push(
    { key: "system.attributes.ac.bonus", mode: CONST.ACTIVE_EFFECT_MODES.ADD, value: "1", priority: "20" },
    { key: "system.traits.dr.all", mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM, value: "1", priority: "20" },
    { key: "system.bonuses.abilities.save", mode: CONST.ACTIVE_EFFECT_MODES.ADD, value: "1", priority: "20" }
  );
  const itemMacroText = await (0,macros/* loadMacroFile */.dp)("spell", "wardingBond.js");
  document.flags["itemacro"] = (0,macros/* generateItemMacroFlag */.gL)(document, itemMacroText);
  effect.changes.push((0,macros/* generateMacroChange */.n4)(""));
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/web.js



async function webEffect(document) {

  if (!spellEffectModules().activeAurasInstalled) {
    let effectWebRestrained = baseSpellEffect(document, document.name);
    effectWebRestrained.changes.push(generateStatusEffectChange("Restrained"));
    document.effects.push(effectWebRestrained);
    return document;
  }

  // if we have active auras use a more advanced macro
  const itemMacroText = await (0,macros/* loadMacroFile */.dp)(macros/* MACROS.AA_CONDITION_ON_ENTRY.type */.Vw.AA_CONDITION_ON_ENTRY.type, macros/* MACROS.AA_CONDITION_ON_ENTRY.file */.Vw.AA_CONDITION_ON_ENTRY.file);
  document.flags["itemacro"] = (0,macros/* generateItemMacroFlag */.gL)(document, itemMacroText);

  let effect = baseSpellEffect(document, document.name);
  effect.changes.push((0,macros/* generateMacroChange */.n4)("@item.level @attributes.spelldc"));
  effect.flags["ActiveAuras"] = {
    isAura: true,
    aura: "All",
    radius: null,
    alignment: "",
    type: "",
    ignoreSelf: false,
    height: false,
    hidden: false,
    // hostile: true,
    onlyOnce: false,
    save: "dex",
    savedc: null,
    displayTemp: true,
  };
  setProperty(effect, "duration.seconds", 3600);
  setProperty(effect, "flags.dae.macroRepeat", "startEveryTurn");
  setProperty(document, "flags.midi-qol.onUseMacroName", "[preActiveEffects]ItemMacro");
  setProperty(document, "flags.ddbimporter.effect", {
    applyStart: true,
    applyEntry: true,
    applyImmediate: false,
    everyEntry: false,
    allowVsRemoveCondition: true,
    removalCheck: "str",
    removalSave: null,
    saveRemoves: false,
    condition: "Restrained",
    save: document.system.save.ability,
    // sequencerFile: "jb2a.web.02",
  });

  document.effects.push(effect);
  document.system.actionType = "other";
  document.system.save.ability = "";

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/witchBolt.js



async function witchBoltEffect(document) {
  let effect = baseSpellEffect(document, document.name);

  const itemMacroText = await (0,macros/* loadMacroFile */.dp)("spell", "witchBolt.js");
  document.flags["itemacro"] = (0,macros/* generateItemMacroFlag */.gL)(document, itemMacroText);
  setProperty(document, "flags.midi-qol.onUseMacroName", "[postActiveEffects]ItemMacro");
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/zephyrStrike.js



async function zephyrStrikeEffect(document) {
  let effect = baseSpellEffect(document, `${document.name}`);

  // macroToCall
  effect.changes.push(
    {
      key: "flags.midi-qol.optional.ZepyrStrike.macroToCall",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: "ItemMacro.Zephyr Strike",
      priority: "20",
    },
    {
      key: "flags.midi-qol.optional.ZepyrStrike.damage.mwak",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: `${document.system.damage.parts[0][0]}`,
      priority: "20",
    },
    {
      key: "flags.midi-qol.optional.ZepyrStrike.damage.rwak",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: `${document.system.damage.parts[0][0]}`,
      priority: "20",
    },
    {
      key: "flags.midi-qol.optional.ZepyrStrike.count",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: "1",
      priority: "20",
    },
    {
      key: "flags.midi-qol.optional.ZepyrStrike.label",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: "Gain Zephyr Strike damage bonus?",
      priority: "20",
    },
  );

  setProperty(effect, "flags.dae.selfTarget", true);
  setProperty(effect, "flags.dae.selfTargetAlways", true);
  setProperty(document, "system.actionType", "other");

  document.effects.push(effect);
  document.system.damage.parts = [];

  const itemMacroText = await (0,macros/* loadMacroFile */.dp)("spell", "zephyrStrike.js");
  setProperty(document, "flags.itemacro", (0,macros/* generateItemMacroFlag */.gL)(document, itemMacroText));

  return document;
}

;// CONCATENATED MODULE: ./src/effects/specialSpells.js




// spell effects load start




















































































































function spellEffectModules() {
  if (CONFIG.DDBI.EFFECT_CONFIG.SPELLS.installedModules) {
    return CONFIG.DDBI.EFFECT_CONFIG.SPELLS.installedModules;
  }
  const midiQolInstalled = game.modules.get("midi-qol")?.active;
  const advancedMacrosInstalled = game.modules.get("advanced-macros")?.active;
  const itemMacroInstalled = game.modules.get("itemacro")?.active;
  const timesUp = game.modules.get("times-up")?.active;
  const daeInstalled = game.modules.get("dae")?.active;
  const convenientEffectsInstalled = game.modules.get("dfreds-convenient-effects")?.active;

  const activeAurasInstalled = game.modules.get("ActiveAuras")?.active;
  const atlInstalled = game.modules.get("ATL")?.active;
  const tokenAurasInstalled = game.modules.get("token-auras")?.active;
  const tokenMagicInstalled = game.modules.get("tokenmagic")?.active;
  const autoAnimationsInstalled = game.modules.get("autoanimations")?.active;
  CONFIG.DDBI.EFFECT_CONFIG.SPELLS.installedModules = {
    hasCore: itemMacroInstalled && midiQolInstalled && advancedMacrosInstalled && timesUp && daeInstalled && convenientEffectsInstalled,
    midiQolInstalled,
    itemMacroInstalled,
    advancedMacrosInstalled,
    timesUp,
    daeInstalled,
    convenientEffectsInstalled,
    atlInstalled,
    tokenAurasInstalled,
    tokenMagicInstalled,
    activeAurasInstalled,
    autoAnimationsInstalled,
  };
  return CONFIG.DDBI.EFFECT_CONFIG.SPELLS.installedModules;
}

function baseSpellEffect(document, label) {
  return {
    label,
    icon: document.img,
    changes: [],
    duration: {},
    tint: "",
    transfer: false,
    disabled: false,
    flags: {
      dae: {
        transfer: false,
        stackable: "none",
      },
      ddbimporter: {
        disabled: false,
      },
      "midi-qol": { // by default force CE effect usage to off
        forceCEOff: true,
      },
    },
  };
}

function generateStatusEffectChange(statusName, priority = 20, macro = false) {
  return (0,effects/* generateStatusEffectChange */.f6)(statusName, priority, macro);
}

function generateTokenMagicFXChange(macroValue, priority = 20) {
  return (0,effects/* generateTokenMagicFXChange */.UY)(macroValue, priority);
}

function generateATLChange(atlKey, mode, value, priority = 20) {
  return (0,effects/* generateATLChange */.Ci)(atlKey, mode, value, priority);
}

/**
 * This function is mainly for effects that can't be dynamically generated
 * @param {*} document
 */
// eslint-disable-next-line complexity
async function spellEffectAdjustment(document) {
  if (!document.effects) document.effects = [];

  // check that we can gen effects
  const deps = spellEffectModules();
  if (!deps.hasCore) {
    logger/* default.warn */.Z.warn("Sorry, you're missing some required modules for spell effects. Please install them and try again.", deps);
    return document;
  }
  if (!CONFIG.DDBI.EFFECT_CONFIG.SPELLS.configured) {
    CONFIG.DDBI.EFFECT_CONFIG.SPELLS.configured = (0,macros/* configureDependencies */.SI)();
  }

  const name = document.flags.ddbimporter.originalName ?? document.name;
  logger/* default.debug */.Z.debug(`Adding effects to ${name}`);
  switch (name) {
    case "Absorb Elements": {
      document = absorbElementsEffect(document);
      break;
    }
    case "Melf's Acid Arrow":
    case "Acid Arrow": {
      document = acidArrowEffect(document);
      break;
    }
    case "Aid": {
      document = await aidEffect(document);
      break;
    }
    case "Alter Self": {
      document = alterSelfEffect(document);
      break;
    }
    case "Animal Friendship": {
      document = animalFriendshipEffect(document);
      break;
    }
    case "Mordenkainen's Sword":
    case "Arcane Sword": {
      document = await arcaneSwordEffect(document);
      break;
    }
    case "Armor of Agathys": {
      document = await armorOfAgathysEffect(document);
      break;
    }
    case "Aura of Life": {
      document = await auraOfLifeEffect(document);
      break;
    }
    case "Bane": {
      document = baneEffect(document);
      break;
    }
    case "Banishment": {
      document = await banishmentEffect(document);
      break;
    }
    case "Barkskin": {
      document = barkskinEffect(document);
      break;
    }
    case "Beacon of Hope": {
      document = beaconofHopeEffect(document);
      break;
    }
    case "Evard's Black Tentacles":
    case "Black Tentacles": {
      document = await blackTentaclesEffect(document);
      break;
    }
    case "Bless": {
      document = blessEffect(document);
      break;
    }
    case "Blur": {
      document = blurEffect(document);
      break;
    }
    case "Blindness/Deafness": {
      document = await blindnessDeafnessEffect(document);
      break;
    }
    case "Booming Blade": {
      document = await boomingBladeEffect(document);
      break;
    }
    case "Branding Smite": {
      document = await brandingSmiteEffect(document);
      break;
    }
    case "Call Lightning": {
      document = await callLightningEffect(document);
      break;
    }
    case "Charm Person": {
      document = charmPersonEffect(document);
      break;
    }
    case "Chill Touch": {
      document = await chillTouchEffect(document);
      break;
    }
    case "Chromatic Orb": {
      document = await chromaticOrbEffect(document);
      break;
    }
    case "Cloudkill": {
      document = await cloudkillEffect(document);
      break;
    }
    case "Color Spray": {
      document = await colorSprayEffect(document);
      break;
    }
    case "Command": {
      document = commandEffect(document);
      break;
    }
    case "Comprehend Languages": {
      document = comprehendLanguagesEffect(document);
      break;
    }
    case "Confusion": {
      document = await confusionEffect(document);
      break;
    }
    case "Contagion": {
      document = await contagionEffect(document);
      break;
    }
    case "Crown of Stars": {
      document = await crownofStarsEffect(document);
      break;
    }
    case "Crown of Madness": {
      document = crownofMadnessEffect(document);
      break;
    }
    case "Create Bonfire": {
      document = await createBonfireEffect(document);
      break;
    }
    case "Darkness": {
      document = await darknessEffect(document);
      break;
    }
    case "Darkvision": {
      document = await darkvisionEffect(document);
      break;
    }
    case "Divine Favor": {
      document = divineFavorEffect(document);
      break;
    }
    case "Divine Word": {
      document = await divineWordEffect(document);
      break;
    }
    case "Dominate Beast": {
      document = dominateBeastEffect(document);
      break;
    }
    case "Dominate Monster": {
      document = dominateMonsterEffect(document);
      break;
    }
    case "Dominate Person": {
      document = dominatePersonEffect(document);
      break;
    }
    case "Elemental Weapon": {
      document = await elementalWeaponEffect(document);
      break;
    }
    case "Enhance Ability": {
      document = await enhanceAbilityEffect(document);
      break;
    }
    case "Enlarge/Reduce": {
      document = await enlargeReduceEffect(document);
      break;
    }
    case "Ensnaring Strike": {
      document = await ensnaringStrikeEffect(document);
      break;
    }
    case "Entangle": {
      document = entangleEffect(document);
      break;
    }
    case "Eyebite": {
      document = await eyebiteEffect(document);
      break;
    }
    case "Faerie Fire": {
      document = await faerieFireEffect(document);
      break;
    }
    case "Fear": {
      document = fearEffect(document);
      break;
    }
    case "Feeblemind": {
      document = feeblemindEffect(document);
      break;
    }
    case "Fire Shield": {
      document = await fireShieldEffect(document);
      break;
    }
    case "Flame Blade": {
      document = await flameBladeEffect(document);
      break;
    }
    case "Flesh to Stone": {
      document = await fleshtoStoneEffect(document);
      break;
    }
    case "Fly": {
      document = flyEffect(document);
      break;
    }
    case "Frostbite": {
      document = frostbiteEffect(document);
      break;
    }
    case "Geas": {
      document = geasEffect(document);
      break;
    }
    case "Grease": {
      document = await greaseEffect(document);
      break;
    }
    case "Greater Invisibility": {
      document = await invisibilityEffect(document);
      break;
    }
    case "Green-Flame Blade": {
      document = await greenFlameBladeEffect(document);
      break;
    }
    case "Guidance": {
      document = guidanceEffect(document);
      break;
    }
    case "Guiding Bolt": {
      document = guidingBoltEffect(document);
      break;
    }
    case "Haste": {
      document = hasteEffect(document);
      break;
    }
    case "Heroes' Feast": {
      document = await heroesFeastEffect(document);
      break;
    }
    case "Heroism": {
      document = await heroismEffect(document);
      break;
    }
    case "Hex": {
      document = await hexEffect(document);
      break;
    }
    case "Tasha's Hideous Laughter":
    case "Hideous Laughter": {
      document = await hideousLaughterEffect(document);
      break;
    }
    case "Hold Monster": {
      document = holdMonsterEffect(document);
      break;
    }
    case "Hold Person": {
      document = holdPersonEffect(document);
      break;
    }
    case "Holy Aura": {
      document = holyAuraEffect(document);
      break;
    }
    case "Hunter's Mark": {
      document = await huntersMarkEffect(document);
      break;
    }
    case "Hypnotic Pattern": {
      document = hypnoticPatternEffect(document);
      break;
    }
    case "Ice Knife": {
      document = await iceKnifeEffect(document);
      break;
    }
    case "Incendiary Cloud": {
      document = await incendiaryCloudEffect(document);
      break;
    }
    case "Insect Plague": {
      document = await insectPlagueEffect(document);
      break;
    }
    case "Invisibility": {
      document = await invisibilityEffect(document);
      break;
    }
    case "Otto's Irresistible Dance":
    case "Irresistible Dance": {
      document = await irresistibleDanceEffect(document);
      break;
    }
    case "Light": {
      document = lightEffect(document);
      break;
    }
    case "Longstrider": {
      document = longstriderEffect(document);
      break;
    }
    case "Mage Armor": {
      document = mageArmorEffect(document);
      break;
    }
    case "Magic Weapon": {
      document = await magicWeaponEffect(document);
      break;
    }
    case "Mass Suggestion": {
      document = massSuggestionEffect(document);
      break;
    }
    case "Mind Blank": {
      document = mindBlankEffect(document);
      break;
    }
    case "Mirror Image": {
      document = mirrorImageEffect(document);
      break;
    }
    case "Misty Step": {
      document = await mistyStepEffect(document);
      break;
    }
    case "Moonbeam": {
      document = await moonbeamEffect(document);
      break;
    }
    case "Pass Without Trace": {
      document = passWithoutTraceEffect(document);
      break;
    }
    case "Phantasmal Killer": {
      document = phantasmalKillerEffect(document);
      break;
    }
    case "Polymorph": {
      document = polymorphEffect(document);
      break;
    }
    case "Protection from Energy": {
      document = await protectionfromEnergyEffect(document);
      break;
    }
    case "Protection from Poison": {
      document = protectionfromPoisonEffect(document);
      break;
    }
    case "Ray of Enfeeblement": {
      document = await rayofEnfeeblementEffect(document);
      break;
    }
    case "Ray of Frost": {
      document = rayofFrostEffect(document);
      break;
    }
    case "Regenerate": {
      document = regenerateEffect(document);
      break;
    }
    case "Otiluke's Resilient Sphere":
    case "Resilient Sphere": {
      document = resilientSphereEffect(document);
      break;
    }
    case "Resistance": {
      document = resistanceEffect(document);
      break;
    }
    case "Shield": {
      document = shieldEffect(document);
      break;
    }
    case "Shield of Faith": {
      document = shieldofFaithEffect(document);
      break;
    }
    case "Shillelagh": {
      document = await shillelaghEffect(document);
      break;
    }
    case "Silence": {
      document = await silenceEffect(document);
      break;
    }
    case "Sleep": {
      document = await sleepEffect(document);
      break;
    }
    case "Slow": {
      document = slowEffect(document);
      break;
    }
    case "Spider Climb": {
      document = spiderClimbEffect(document);
      break;
    }
    case "Spike Growth": {
      document = await spikeGrowthEffect(document);
      break;
    }
    case "Spirit Guardians": {
      document = await spiritGuardiansEffect(document);
      break;
    }
    case "Spirit Shroud": {
      document = await spiritShroudEffect(document);
      break;
    }
    case "Spiritual Weapon": {
      document = await spiritualWeaponEffect(document);
      break;
    }
    case "Storm Sphere": {
      document = await stormSphereEffect(document);
      break;
    }
    case "Stoneskin": {
      document = stoneskinEffect(document);
      break;
    }
    case "Sunbeam": {
      document = sunbeamEffect(document);
      break;
    }
    case "Toll the Dead": {
      document = await tolltheDeadEffect(document);
      break;
    }
    case "Thunderous Smite": {
      document = await thunderousSmiteEffect(document);
      break;
    }
    case "True Strike": {
      document = trueStrikeEffect(document);
      break;
    }
    case "Vicious Mockery": {
      document = viciousMockeryEffect(document);
      break;
    }
    case "Vitriolic Sphere": {
      document = await vitriolicSphereEffect(document);
      break;
    }
    case "Warding Bond": {
      document = await wardingBondEffect(document);
      break;
    }
    case "Web": {
      document = await webEffect(document);
      break;
    }
    case "Witch Bolt": {
      document = await witchBoltEffect(document);
      break;
    }
    case "Zephyr Strike": {
      document = await zephyrStrikeEffect(document);
      break;
    }
    // no default
  }
  try {
    document = (0,effects/* forceItemEffect */.Wk)(document);
  } catch (err) {
    await Promise.all(document);
    logger/* default.error */.Z.error("Error applying effects: ", { err, document });
  }
  return document;
}


/***/ }),

/***/ 6547:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "H": () => (/* binding */ iconPath),
/* harmony export */   "b": () => (/* binding */ copyInbuiltIcons)
/* harmony export */ });
/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5259);
/* harmony import */ var _lib_FileHelper_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2397);



// const BASE_PATH = ROUTE_PREFIX ? `/${ROUTE_PREFIX}` : "";

const TYPE_MAP = {
  items: "items",
  weapons: "items",
  weapon: "items",
  item: "items",
  equipment: "items",
  consumable: "items",
  tool: "items",
  loot: "items",
  backpack: "items",
  inventory: "items",
  spells: "spells",
  spell: "spells",
  feats: "feats",
  feat: "feats",
  classes: "classes",
  class: "classes",
  subclass: "classes",
  monster: "monster",
  backgrounds: "backgrounds",
  background: "backgrounds",
  traits: "traits",
  races: "races",
  race: "races",
};

const FILE_MAP = {
  items: ["items.json", "class-features.json", "races.json"],
  traits: ["class-features.json", "races.json", "general.json", "items.json"],
  spells: ["spells.json"],
  races: ["races.json"],
  feats: ["feats.json", "class-features.json", "races.json", "general.json"],
  classes: ["classes.json"],
  monster: ["named-monster-features.json", "generic-monster-features.json"],
  backgrounds: ["backgrounds.json", "feats.json", "class-features.json", "races.json", "general.json"],
};

function sanitiseName(name) {
  return name.replace("â€™", "'").toLowerCase();
}

async function loadDataFile(fileName) {
  _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug(`Getting icon mapping for ${fileName}`);
  const fileExists = await _lib_FileHelper_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].fileExists */ .Z.fileExists("[data] modules/ddb-importer/data", fileName);

  const url = await _lib_FileHelper_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].getFileUrl */ .Z.getFileUrl("[data] modules/ddb-importer/data", fileName);
  if (!fileExists) {
    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].warn */ .Z.warn(`Possible missing file, icon load may fail. Fetching ${url}`);
  }

  const data = await fetchJsonWithTimeout(url);
  return data;
}

async function loadIconMap(type) {
  // check to see if dictionary is loaded
  if (CONFIG.DDBI.ICONS[type]) return;

  _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug(`Loading Inbuilt Icon Map for ${type}`);
  let data = [];
  for (const fileName of FILE_MAP[type]) {
    // eslint-disable-next-line no-await-in-loop
    const dataLoad = await loadDataFile(fileName);
    data = data.concat(dataLoad);
  }

  CONFIG.DDBI.ICONS[type] = data;
  // console.warn(iconMap);
}

function looseMatch(item, typeValue) {
  const originalName = item.flags?.ddbimporter?.originalName;
  if (originalName) {
    const originalMatch = CONFIG.DDBI.ICONS[typeValue].find((entry) => sanitiseName(entry.name) === sanitiseName(originalName));
    if (originalMatch) return originalMatch.path;
  }

  const sanitisedName = sanitiseName(item.name);
  if (item.name.includes(":")) {
    const nameArray = sanitisedName.split(":");
    const postMatch = CONFIG.DDBI.ICONS[typeValue].find((entry) => sanitiseName(entry.name) === nameArray[1].trim());
    if (postMatch) return postMatch.path;
    const subMatch = CONFIG.DDBI.ICONS[typeValue].find((entry) => sanitiseName(entry.name) === nameArray[0].trim());
    if (subMatch) return subMatch.path;
  }

  const startsMatchEntry = CONFIG.DDBI.ICONS[typeValue].find((entry) => sanitisedName.split(":")[0].trim().startsWith(sanitiseName(entry.name).split(":")[0].trim()));
  if (startsMatchEntry) return startsMatchEntry.path;
  const startsMatchItem = CONFIG.DDBI.ICONS[typeValue].find((entry) => sanitiseName(entry.name).split(":")[0].trim().startsWith(sanitisedName.split(":")[0].trim()));
  if (startsMatchItem) return startsMatchItem.path;

  if (item.type === "subclass" && item.system.classIdentifier) {
    const sanitisedClassName = sanitiseName(item.system.classIdentifier);
    const subClassMatch = CONFIG.DDBI.ICONS[typeValue].find((entry) => sanitiseName(entry.name).startsWith(sanitisedClassName));
    if (subClassMatch) return subClassMatch.path;
  }

  return null;
}

function getIconPath(item, type, monsterName) {
  // check to see if we are able to load a dic for that type
  const typeValue = TYPE_MAP[type];
  if (!typeValue || !CONFIG.DDBI.ICONS[typeValue]) return null;

  const iconMatch = CONFIG.DDBI.ICONS[typeValue].find((entry) => {
    const sanitisedName = sanitiseName(entry.name);
    const sanitisedItemName = sanitiseName(item.name);
    if (type === "monster") {
      return sanitisedName === sanitisedItemName.split("(")[0].trim() && entry.monster && sanitiseName(entry.monster) == sanitiseName(monsterName);
    }
    return sanitisedName === sanitisedItemName;
  });

  if (!iconMatch && type === "monster") {
    const genericMonsterIconMatch = CONFIG.DDBI.ICONS[typeValue].find((entry) => {
      const sanitisedName = sanitiseName(entry.name);
      const sanitisedItemName = sanitiseName(item.name);
      return sanitisedName === sanitisedItemName;
    });
    if (genericMonsterIconMatch) return genericMonsterIconMatch.path;
  }

  if (iconMatch) {
    return iconMatch.path;
  } else {
    return looseMatch(item, typeValue);
  }
}


async function loadIconMaps(types) {
  let promises = [];

  const mapTypes = types
    .filter((type) => TYPE_MAP[type])
    .map((type) => TYPE_MAP[type]).filter((type, i, ar) => ar.indexOf(type) === i);

  mapTypes.forEach((type) => {
    // logger.debug(`Loading ${type}`);
    promises.push(loadIconMap(type));
  });

  return Promise.all(promises);
}

async function iconPath(item, monster = false, monsterName = "") {
  const itemTypes = [item.type];
  if (monster) itemTypes.push("monster");
  await loadIconMaps(itemTypes);

  let iconPath;
  // logger.debug(`Inbuilt icon match started for ${item.name} [${item.type}]`);
  // if we have a monster lets check the monster dict first
  if (monster) {
    const monsterPath = getIconPath(item, "monster", monsterName);
    if (monsterPath) {
      iconPath = monsterPath;
    }
  }
  if (!iconPath) iconPath = getIconPath(item, item.type);
  return iconPath;
}

async function copyInbuiltIcons(items, monster = false, monsterName = "") {
  // get unique array of item types to be matching
  const itemTypes = items.map((item) => item.type).filter((item, i, ar) => ar.indexOf(item) === i);

  if (monster) itemTypes.push("monster");
  await loadIconMaps(itemTypes);

  return new Promise((resolve) => {
    const iconItems = items.map((item) => {
      if (getProperty(item, "flags.ddbimporter.keepIcon") !== true) {
        // logger.debug(`Inbuilt icon match started for ${item.name} [${item.type}]`);
        // if we have a monster lets check the monster dict first
        if (monster) {
          const monsterPath = getIconPath(item, "monster", monsterName);
          if (monsterPath) {
            item.img = monsterPath;
            return item;
          }
        }
        const pathMatched = getIconPath(item, item.type);
        if (pathMatched) {
          item.img = pathMatched;
          if (item.effects) {
            item.effects.forEach((effect) => {
              if (!effect.icon || effect.icon === "") {
                effect.icon = pathMatched;
              }
            });
          }
        }
      }
      return item;
    });
    resolve(iconItems);
  });
}


/***/ }),

/***/ 3893:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5259);
/* harmony import */ var _muncher_import_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9193);
/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(6451);
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(7669);





const CompendiumHelper = {

  // a mapping of compendiums with content type
  LOOKUP: [
    { type: "spells", compendium: "entity-spell-compendium" },
    { type: "spell", compendium: "entity-spell-compendium" },
    { type: "feats", compendium: "entity-feat-compendium" },
    { type: "features", compendium: "entity-feature-compendium" },
    { type: "feature", compendium: "entity-feature-compendium" },
    { type: "feat", compendium: "entity-feature-compendium" },
    { type: "classes", compendium: "entity-class-compendium" },
    { type: "class", compendium: "entity-class-compendium" },
    { type: "subclasses", compendium: "entity-subclass-compendium" },
    { type: "subclass", compendium: "entity-subclass-compendium" },
    { type: "races", compendium: "entity-race-compendium" },
    { type: "race", compendium: "entity-race-compendium" },
    { type: "traits", compendium: "entity-trait-compendium" },
    { type: "trait", compendium: "entity-trait-compendium" },
    { type: "npc", compendium: "entity-monster-compendium" },
    { type: "monsters", compendium: "entity-monster-compendium" },
    { type: "monster", compendium: "entity-monster-compendium" },
    { type: "custom", compendium: "entity-override-compendium" },
    { type: "override", compendium: "entity-override-compendium" },
    { type: "inventory", compendium: "entity-item-compendium" },
    { type: "item", compendium: "entity-item-compendium" },
    { type: "items", compendium: "entity-item-compendium" },
    { type: "magicitem", compendium: "entity-item-compendium" },
    { type: "weapon", compendium: "entity-item-compendium" },
    { type: "consumable", compendium: "entity-item-compendium" },
    { type: "tool", compendium: "entity-item-compendium" },
    { type: "loot", compendium: "entity-item-compendium" },
    { type: "backpack", compendium: "entity-item-compendium" },
    { type: "spell", compendium: "entity-spell-compendium" },
    { type: "equipment", compendium: "entity-item-compendium" },
    { type: "table", compendium: "entity-table-compendium" },
    { type: "tables", compendium: "entity-table-compendium" },
    { type: "background", compendium: "entity-background-compendium" },
    { type: "backgrounds", compendium: "entity-background-compendium" },
    { type: "vehicle", compendium: "entity-vehicle-compendium" },
    { type: "vehicles", compendium: "entity-vehicle-compendium" },
    { type: "adventure", compendium: "entity-adventure-compendium" },
    { type: "adventures", compendium: "entity-adventure-compendium" },
  ],

  getCompendiumLabel: (type) => {
    const compendiumName = CompendiumHelper.LOOKUP.find((c) => c.type == type).compendium;
    const compendiumLabel = game.settings.get("ddb-importer", compendiumName);
    return compendiumLabel;
  },

  getCompendium: (label, fail = true) => {
    const compendium = game.packs.get(label);
    if (compendium) {
      return compendium;
    } else {
      if (fail) {
        _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].error */ .Z.error(`Unable to find compendium ${label}`);
        ui.notifications.error(`Unable to open the Compendium ${label}. Check the compendium exists and is set in "Module Settings > DDB Importer > Compendiums"`);
        throw new Error(`Unable to open the Compendium ${label}. Check the compendium exists and is set in "Module Settings > DDB Importer > Compendiums".`);
      }
      return undefined;
    }
  },

  getCompendiumType: (type, fail = true) => {
    const compendiumLabel = CompendiumHelper.getCompendiumLabel(type);
    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug(`Getting compendium ${compendiumLabel} for update of ${type}`);
    const compendium = CompendiumHelper.getCompendium(compendiumLabel, false);
    if (compendium) {
      return compendium;
    } else {
      _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].error */ .Z.error(`Unable to find compendium ${compendiumLabel} for ${type} documents`);
      ui.notifications.error(`Unable to open the Compendium ${compendiumLabel}. Check the compendium exists and is set in "Module Settings > DDB Importer > Compendiums"`);
      if (fail) {
        throw new Error(`Unable to open the Compendium ${compendiumLabel}. Check the compendium exists and is set in "Module Settings > DDB Importer > Compendiums"`);
      }
      return undefined;
    }
  },

  loadCompendiumIndex: async (type, indexOptions = {}) => {
    const compendiumLabel = CompendiumHelper.getCompendiumLabel(type);
    setProperty(CONFIG.DDBI, `compendium.label.${type}`, compendiumLabel);
    const compendium = await CompendiumHelper.getCompendium(compendiumLabel);

    if (compendium) {
      const index = await compendium.getIndex(indexOptions);
      setProperty(CONFIG.DDBI, `compendium.index.${type}`, index);
      return index;
    } else {
      return undefined;
    }
  },

  /* eslint-disable require-atomic-updates */
  copyExistingActorProperties: async (type, foundryActor) => {
    const compendium = CompendiumHelper.getCompendiumType(type);

    if (game.settings.get("ddb-importer", "munching-policy-update-existing")) {
      const existingNPC = await compendium.getDocument(foundryActor._id);

      const updateImages = game.settings.get("ddb-importer", "munching-policy-update-images");
      if (!updateImages && existingNPC.system.img !== CONST.DEFAULT_TOKEN) {
        foundryActor.img = existingNPC.system.img;
      }
      if (!updateImages && getProperty(existingNPC, "prototypeToken.texture.src") !== CONST.DEFAULT_TOKEN) {
        foundryActor.prototypeToken.texture.src = existingNPC.prototypeToken.texture.src;
        foundryActor.prototypeToken.scale = existingNPC.prototypeToken.scale;
        foundryActor.prototypeToken.randomImg = existingNPC.prototypeToken.randomImg;
        foundryActor.prototypeToken.mirrorX = existingNPC.prototypeToken.mirrorX;
        foundryActor.prototypeToken.mirrorY = existingNPC.prototypeToken.mirrorY;
        foundryActor.prototypeToken.lockRotation = existingNPC.prototypeToken.lockRotation;
        foundryActor.prototypeToken.rotation = existingNPC.prototypeToken.rotation;
        foundryActor.prototypeToken.alpha = existingNPC.prototypeToken.alpha;
        foundryActor.prototypeToken.lightAlpha = existingNPC.prototypeToken.lightAlpha;
        foundryActor.prototypeToken.lightAnimation = existingNPC.prototypeToken.lightAnimation;
        foundryActor.prototypeToken.tint = existingNPC.prototypeToken.tint;
        foundryActor.prototypeToken.lightColor = existingNPC.prototypeToken.lightColor;
      }

      const retainBiography = game.settings.get("ddb-importer", "munching-policy-monster-retain-biography");
      if (retainBiography) {
        foundryActor.system.details.biography = existingNPC.system.details.biography;
      }

      await (0,_muncher_import_js__WEBPACK_IMPORTED_MODULE_1__/* .copySupportedItemFlags */ .uf)(existingNPC.toObject(), foundryActor);
    }

    return foundryActor;

  },
  /* eslint-enable require-atomic-updates */

  getActorIndexActor: async (type, npc) => {
    const monsterIndexFields = ["name", "flags.ddbimporter.id"];
    const legacyName = game.settings.get("ddb-importer", "munching-policy-legacy-postfix");
    const index = await CompendiumHelper.loadCompendiumIndex(type, { fields: monsterIndexFields });
    const npcMatch = index.contents.find((entity) =>
      hasProperty(entity, "flags.ddbimporter.id")
      && entity.flags.ddbimporter.id == npc.flags.ddbimporter.id
      && ((!legacyName && entity.name.toLowerCase() === npc.name.toLowerCase())
        || (legacyName && npc.flags.ddbimporter.isLegacy && npc.name.toLowerCase().startsWith(entity.name.toLowerCase()))
        || (legacyName && entity.name.toLowerCase() === npc.name.toLowerCase()))
    );
    return npcMatch;
  },

  existingActorCheck: async (type, foundryActor) => {
    const matchingActor = await CompendiumHelper.getActorIndexActor(type, foundryActor);
    if (matchingActor) {
      _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug(`Found existing ${type}, updating: ${matchingActor.name}`);
      // eslint-disable-next-line require-atomic-updates
      foundryActor._id = matchingActor._id;
      foundryActor = await CompendiumHelper.copyExistingActorProperties(type, foundryActor);
    } else {
      _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug(`No existing compendium match for ${foundryActor.name}`);
    }
    return foundryActor;
  },

  sanitize: (text) => {
    if (text && typeof text === "string") {
      return text.replace(/\s|\./g, '-').toLowerCase();
    }
    return text;
  },

  getDefaultCompendiumName: (compendiumLabel) => {
    const sanitizedLabel = CompendiumHelper.sanitize(compendiumLabel);
    const name = `ddb-${game.world.id}-${sanitizedLabel}`;
    return name;
  },

  /**
   * Attempts to find a compendium pack by name, if not found, create a new one based on item type
   * @param  {string} label - Label of compendium to find
   * @param  {string} type - Name of compendium
   * @param  {string} id - Id of compendium, optional, used in place of label to find compendium
   * @param  {string} packageType - package type of compendium, defaults to world
   * @returns {object} - Object consisting of compendium and creation result
   */
  createIfNotExists: async ({ label, type, id = undefined, packageType = "world" } = {}) => {
    if (id) _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug(`Checking if Compendium with id ${id} exists for ${_settings_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].MODULE_ID */ .Z.MODULE_ID}`);
    else if (label) _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug(`Checking if Compendium with label ${label} exists for ${_settings_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].MODULE_ID */ .Z.MODULE_ID}`);
    const compendium = await game.packs.get(id) ?? game.packs.find((p) => p.metadata.label === label);
    if (compendium) {
      _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug(`Compendium '${id}' (${compendium.metadata.label}) found, will not create compendium.`);
      return {
        compendium,
        created: false
      };
    } else {
      _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].info */ .Z.info(`Compendium for ${label}, was not found, creating it now.`);
      const name = CompendiumHelper.getDefaultCompendiumName(label);
      const defaultCompendium = await game.packs.get(`${packageType}.${name}`);
      if (defaultCompendium) {
        _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].error */ .Z.error(`Could not load Compendium '${id}', and could not create default Compendium '${name}' as it already exists. Please check your DDB Importer Compendium setup.`);
        return {
          compendium: null,
          created: false,
        };
      } else {
        // create a compendium for the user
        const newCompendium = await CompendiumCollection.createCompendium({
          type,
          label,
          name,
          package: packageType,
        });
        return {
          compendium: newCompendium,
          created: true
        };
      }
    }
  },

  getCompendiumNames: () => {
    return _settings_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].COMPENDIUMS.map */ .Z.COMPENDIUMS.map((ddbCompendium) => {
      return game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].MODULE_ID */ .Z.MODULE_ID, ddbCompendium.setting);
    });
  },

  deleteDefaultCompendiums: (force = true) => {
    if (!force) {
      _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].warn */ .Z.warn("Pass 'true' to this function to force deletion.");
    }
    game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "auto-create-compendium", false);

    const clone = foundry.utils.deepClone(_settings_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].DEFAULT_SETTINGS */ .Z.DEFAULT_SETTINGS);
    const compendiumSettings = _settings_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].APPLY_GLOBAL_DEFAULTS */ .Z.APPLY_GLOBAL_DEFAULTS(clone.READY.COMPENDIUMS);

    for (const [name, data] of Object.entries(compendiumSettings)) {
      const compendiumName = CompendiumHelper.getDefaultCompendiumName(data.default);

      _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].warn */ .Z.warn(`Setting: ${name} : Deleting compendium ${data.name} with key world.${compendiumName}}`);
      game.packs.delete(`world.${compendiumName}`);
    }
  },

  /**
   * Queries a compendium for a single document
   * Returns either the entry from the index, or the complete document from the compendium
   */
  queryCompendiumEntry: async (compendiumName, documentName, getDocument = false) => {
    // normalize the entity name for comparison
    documentName = _utils_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].normalizeString */ .Z.normalizeString(documentName);

    // get the compendium
    const compendium = game.packs.get(compendiumName);
    if (!compendium) return null;

    // retrieve the compendium index
    const index = await compendium.getIndex();

    let id = index.find((entity) => _utils_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].normalizeString */ .Z.normalizeString(entity.name) === documentName);
    if (id && getDocument) {
      let entity = await compendium.getDocument(id._id);
      return entity;
    }
    return id ? id : null;
  },

  /**
   * Queries a compendium for a single document
   * Returns either the entry from the index, or the complete document from the compendium
   */
  queryCompendiumEntries: async (compendiumName, documentNames, getDocuments = false) => {
    // get the compendium
    let compendium = game.packs.get(compendiumName);
    if (!compendium) return null;

    // retrieve the compendium index
    let index = await compendium.getIndex();
    index = index.map((entry) => {
      entry.normalizedName = _utils_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].normalizeString */ .Z.normalizeString(entry.name);
      return entry;
    });

    // get the indices of all the entitynames, filter un
    let indices = documentNames
      .map((entityName) => {
        // sometimes spells do have restricted use in paranthesis after the name. Let's try to find those restrictions and add them later
        if (entityName.search(/(.+)\(([^()]+)\)*/) !== -1) {
          const match = entityName.match(/(.+)\(([^()]+)\)*/);
          return {
            name: _utils_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].normalizeString */ .Z.normalizeString(match[1].trim()),
            restriction: match[2].trim(),
          };
        } else {
          return {
            name: _utils_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].normalizeString */ .Z.normalizeString(entityName),
            restriction: null,
          };
        }
      })
      .map((data) => {
        let entry = index.find((entity) => entity.normalizedName === data.name);
        if (entry) {
          return {
            _id: entry._id,
            name: data.restriction ? `${entry.name} (${data.restriction})` : entry.name,
          };
        } else {
          return null;
        }
      });

    if (getDocuments) {
      // replace non-null values with the complete entity from the compendium
      let entities = await Promise.all(
        indices.map((entry) => {
          return new Promise((resolve) => {
            if (entry) {
              compendium.getDocument(entry._id).then((entity) => {
                entity.name = entry.name; // transfer restrictions over, if any
                // remove redudant info
                delete entity.id;
                delete entity.ownership;
                resolve(entity);
              });
            } else {
              resolve(null);
            }
          });
        })
      );
      return entities;
    }
    return indices;
  },

  /**
   * Queries a compendium for a given document name
   * @returns the index entries of all matches, otherwise an empty array
   */
  queryCompendium: async (compendiumName, documentName, getDocument = false) => {
    documentName = _utils_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].normalizeString */ .Z.normalizeString(documentName);

    let compendium = game.packs.get(compendiumName);
    if (!compendium) return null;
    let index = await compendium.getIndex();
    let id = index.find((entity) => _utils_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].normalizeString */ .Z.normalizeString(entity.name) === documentName);
    if (id && getDocument) {
      let entity = await compendium.getEntity(id._id);
      return entity;
    }
    return id ? id : null;
  },

  /**
   *
   * @param {[string]} items Array of Strings or
   */
  async retrieveMatchingCompendiumItems(items, compendiumName) {
    const GET_ENTITY = true;

    const itemNames = items.map((item) => {
      if (typeof item === "string") return item;
      if (typeof item === "object" && Object.prototype.hasOwnProperty.call(item, "name")) return item.name;
      return "";
    });

    const results = await CompendiumHelper.queryCompendiumEntries(compendiumName, itemNames, GET_ENTITY);
    const cleanResults = results.filter((item) => item !== null);

    return cleanResults;
  }


};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CompendiumHelper);


/***/ }),

/***/ 1438:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _dictionary_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(37);
/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5259);
/* harmony import */ var _effects_effects_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5751);




const DDBHelper = {

  getDamageType: (data) => {
    if (data.definition.damageType) {
      const damageTypeReplace = data.definition.grantedModifiers.find((mod) =>
        mod.type === "replace-damage-type"
        && (!mod.restriction || mod.restriction === "")
      );

      const damageType = damageTypeReplace
        ? damageTypeReplace.subType.toLowerCase()
        : data.definition.damageType.toLowerCase();
      return damageType;
    } else {
      return undefined;
    }
  },

  globalDamageTagInfo: (mod) => {
    const globalDamageHints = game.settings.get("ddb-importer", "use-damage-hints");
    const midiInstalled = game.modules.get("midi-qol")?.active;
    const damageRestrictionHints = game.settings.get("ddb-importer", "add-damage-restrictions-to-hints") && !midiInstalled;
    const hintOrRestriction = globalDamageHints || damageRestrictionHints;
    const restriction = damageRestrictionHints && mod.restriction && mod.restriction !== "" ? mod.restriction : "";
    const hintAndRestriction = globalDamageHints && restriction !== "" ? " - " : "";

    return {
      globalDamageHints,
      damageRestrictionHints,
      hintOrRestriction,
      hintAndRestriction,
      restriction,
    };
  },

  getDamageTag(mod, overrideDamageType) {
    const damageTagData = DDBHelper.globalDamageTagInfo(mod);
    const damageType = overrideDamageType
      ? overrideDamageType
      : mod.subType && damageTagData.globalDamageHints ? mod.subType : "";
    const damageHint = damageTagData.hintOrRestriction
      ? `${damageType}${damageTagData.hintAndRestriction}${damageTagData.restriction}`
      : "";
    const damageTag = damageTagData.hintOrRestriction ? `[${damageHint}]` : "";
    return {
      globalDamageHints: damageTagData.globalDamageHints,
      damageRestrictionHints: damageTagData.damageRestrictionHints,
      hintOrRestriction: damageTagData.hintOrRestriction,
      hintAndRestriction: damageTagData.hintAndRestriction,
      restriction: damageTagData.restriction,
      damageType,
      damageHint,
      damageTag,
    };
  },

  getDamageTagForMod: (mod) => {
    const damageTagData = DDBHelper.getDamageTag(mod);
    return damageTagData;
  },

  getDamageTagForItem(data) {
    const damageType = DDBHelper.getDamageType(data);
    const damageTagData = DDBHelper.getDamageTag({}, damageType);
    return damageTagData;
  },

  hasChosenCharacterOption: (ddb, optionName) => {
    const hasClassOptions = [ddb.character.options.race, ddb.character.options.class, ddb.character.options.feat]
      .flat()
      .some((option) => option.definition.name === optionName);
    return hasClassOptions;
  },

  getClassFromOptionID: (ddb, optionId) => {
    // Use case class spell - which class?
    // componentId on spells.class[0].componentId = options.class[0].definition.id
    // options.class[0].definition.componentId = classes[0].classFeatures[0].definition.id
    const option = ddb.character.options.class.find((option) => option.definition.id === optionId);

    if (option) {
      const klass = ddb.character.classes.find((klass) =>
        klass.classFeatures.some((feature) => feature.definition.id === option.componentId)
      );
      return klass;
    }
    return undefined;
  },

  /**
   * Look up a component by id
   * For now we assume that most features we are going to want to get a scaling value
   * from are character options
   * @param {*} ddb
   * @param {*} featureId
   */

  findComponentByComponentId: (ddb, componentId) => {
    let result;

    ddb.character.classes.forEach((cls) => {
      const feature = cls.classFeatures.find((component) => component.definition.id === componentId);
      if (feature) result = feature;
    });

    const optionalClassFeature = ddb.classOptions.find((option) => option.id == componentId);
    if (optionalClassFeature && !result) {
      result = optionalClassFeature;
      const optionalLevelScales = optionalClassFeature.levelScales && optionalClassFeature.levelScales.length > 0;
      if (result && !result.levelScale && optionalLevelScales) {
        const klass = ddb.character.classes.find((cls) => cls.definition.id === optionalClassFeature.classId);
        const klassLevel = klass ? klass.level : undefined;
        if (klassLevel) {
          const levelFilteredScales = optionalClassFeature.levelScales.filter((scale) => scale.level <= klassLevel);
          if (levelFilteredScales.length > 0) {
            result.levelScale = levelFilteredScales
              .reduce((previous, current) => {
                if (previous.level > current.level) return previous;
                return current;
              });
          }
        }
      }
    }

    return result;
  },

  /**
 * Gets the levelscaling value for a feature
 * @param {*} feature
 */
  getExactScalingValue: (feature) => {
    const die = feature.levelScale?.dice ? feature.levelScale.dice : feature.levelScale?.die ? feature.levelScale.die : undefined;
    if (feature && feature.levelScale && feature.levelScale.fixedValue) {
      return feature.levelScale.fixedValue;
    } else if (die) {
      return die.diceString;
    } else {
      return "{{scalevalue-unknown}}";
    }
  },

  getScaleValueLink: (ddb, feature) => {
    const featDefinition = feature.definition ? feature.definition : feature;

    const klass = ddb.character.classes.find((cls) =>
      (cls.definition.id === featDefinition.classId
      || cls.subclassDefinition?.id === featDefinition.classId)
      && featDefinition.levelScales?.length > 0
    );

    if (klass) {
      const featureName = featDefinition.name.toLowerCase().replace(/\s|'|â€™/g, '-');
      const klassName = klass.subclassDefinition?.id === featDefinition.classId
        ? klass.subclassDefinition.name.toLowerCase().replace(/\s|'|â€™/g, '-')
        : klass.definition.name.toLowerCase().replace(/\s|'|â€™/g, '-');
      return `@scale.${klassName}.${featureName}`;
    }

    return undefined;

  },

  getScaleValueString: (ddb, feature) => {
    const classOption = [ddb.character.options.race, ddb.character.options.class, ddb.character.options.feat]
      .flat()
      .find((option) => option.definition.id === feature.componentId);

    let feat = feature.levelScale ? feature : DDBHelper.findComponentByComponentId(ddb, feature.componentId);
    if (!feat && hasProperty(feature, "flags.ddbimporter.dndbeyond.choice")) {
      feat = DDBHelper.findComponentByComponentId(ddb, feature.flags.ddbimporter.dndbeyond.choice.componentId);
    }
    if (!feat && classOption) {
      feat = DDBHelper.findComponentByComponentId(ddb, classOption.componentId);
    }
    if (!feat) {
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug("no scale value for ", feature);
      return { name: undefined, value: undefined };
    }
    const scaleValue = game.settings.get("ddb-importer", "character-update-policy-use-scalevalue")
      ? DDBHelper.getScaleValueLink(ddb, feat)
      : DDBHelper.getExactScalingValue(feat);

    if (scaleValue) {
      return {
        name: feat.definition?.name ? feat.definition?.name : feat.name,
        value: scaleValue,
      };
    }
    // final fallback if scale value extraction fails
    return {
      name: feat.definition?.name ? feat.definition?.name : feat.name,
      value: DDBHelper.getExactScalingValue(feat),
    };
  },

  /**
   *
   * Gets the sourcebook for a subset of dndbeyond sources
   * @param {obj} definition item definition
   */
  getSourceData: (definition) => {
    const fullSource = game.settings.get("ddb-importer", "use-full-source");
    const result = {
      name: null,
      page: null,
    };
    if (definition.sources?.length > 0) {
      result.name = CONFIG.DDB.sources
        .filter((source) => definition.sources.some((ds) => source.id === ds.sourceId))
        .map((source) => {
          const dSource = definition.sources.find((ds) => source.id === ds.sourceId);
          const page = dSource.pageNumber ? ` pg ${dSource.pageNumber}` : "";
          const sourceBook = dSource ? (fullSource ? source.description : source.name) : "Homebrew";
          return `${sourceBook}${page}`;
        })
        .join(", ");
    } else {
      if (definition.sourceIds) {
        result.name = CONFIG.DDB.sources
          .filter((source) => definition.sourceIds.includes(source.id))
          .map((source) => source.description ?? "Homebrew")
          .join();
      } else if (definition.sourceId) {
        result.name = CONFIG.DDB.sources
          .filter((source) => source.id === definition.sourceId)
          .map(
            fullSource
              ? ({ description }) => description ?? "Homebrew"
              : ({ name }) => name ?? "Homebrew"
          );
      }

      // add a page num if available
      if (definition.sourcePageNumber) result.page = definition.sourcePageNumber;
    }
    return result;
  },

  /**
   * Fetches the sources and pages for a definition
   * @param {obj} data item
   */
  parseSource: (definition) => {
    const sourceData = DDBHelper.getSourceData(definition);

    let source = sourceData.name;
    if (sourceData.page) source += ` (pg. ${sourceData.page})`;

    return source;
  },

  getActiveItemModifiers: (ddb, includeExcludedEffects = false) => {
    // are we adding effects to items?
    const addEffects = game.settings.get("ddb-importer", "character-update-policy-add-item-effects");
    const daeInstalled = game.modules.get("dae")?.active;
    const excludedModifiers = (addEffects && daeInstalled && !includeExcludedEffects) ? (0,_effects_effects_js__WEBPACK_IMPORTED_MODULE_2__/* .getEffectExcludedModifiers */ .qk)("item", true, true) : [];
    // get items we are going to interact on
    const modifiers = ddb.character.inventory
      .filter(
        (item) =>
          ((!item.definition.canEquip && !item.definition.canAttune && !item.definition.isConsumable) // if item just gives a thing and not potion/scroll
          || (item.isAttuned && item.equipped) // if it is attuned and equipped
          || (item.isAttuned && !item.definition.canEquip) // if it is attuned but can't equip
            || (!item.definition.canAttune && item.equipped)) // can't attune but is equipped
          && item.definition.grantedModifiers.length > 0
      )
      .flatMap((item) => item.definition.grantedModifiers)
      .filter((mod) => !excludedModifiers.some((exMod) =>
        mod.type === exMod.type
        && (mod.subType === exMod.subType || !exMod.subType))
      );

    return modifiers;
  },

  getActiveItemEffectModifiers: (ddb) => {
    return DDBHelper.getActiveItemModifiers(ddb, true).filter((mod) =>
      (0,_effects_effects_js__WEBPACK_IMPORTED_MODULE_2__/* .getEffectExcludedModifiers */ .qk)("item", true, true).some((exMod) => mod.type === exMod.type
      && (mod.subType === exMod.subType || !exMod.subType))
    );
  },

  getModifiers: (ddb, type, includeExcludedEffects = false, effectOnly = false) => {
    // are we adding effects to items?
    const featureEffects = game.settings.get("ddb-importer", "character-update-policy-add-character-effects");
    const acEffects = game.settings.get("ddb-importer", "character-update-policy-generate-ac-feature-effects");
    const daeInstalled = game.modules.get("dae")?.active;
    const excludedModifiers = ((featureEffects || acEffects) && daeInstalled
      && (!includeExcludedEffects || (includeExcludedEffects && effectOnly)))
      ? (0,_effects_effects_js__WEBPACK_IMPORTED_MODULE_2__/* .getEffectExcludedModifiers */ .qk)(type, featureEffects, acEffects)
      : (0,_effects_effects_js__WEBPACK_IMPORTED_MODULE_2__/* .getEffectExcludedModifiers */ .qk)(type, false, false);
    // get items we are going to interact on
    let modifiers = [];
    if (effectOnly) {
      modifiers = ddb.character.modifiers[type]
        .filter((mod) => excludedModifiers.some((exMod) =>
          mod.type === exMod.type
        && (mod.subType === exMod.subType || !exMod.subType))
        );
    } else {
      modifiers = ddb.character.modifiers[type]
        .filter((mod) => !excludedModifiers.some((exMod) =>
          mod.type === exMod.type
        && (mod.subType === exMod.subType || !exMod.subType))
        );
    }

    return modifiers;
  },

  filterModifiers: (modifiers, type, subType = null, restriction = ["", null]) => {
    return modifiers
      .flat()
      .filter(
        (modifier) =>
          modifier.type === type
          && (subType !== null ? modifier.subType === subType : true)
          && (!restriction ? true : restriction.includes(modifier.restriction))
      );
  },

  getChosenClassModifiers: (ddb, includeExcludedEffects = false, effectOnly = false) => {
    // get items we are going to interact on
    const modifiers = DDBHelper.getModifiers(ddb, 'class', includeExcludedEffects, effectOnly).filter((mod) => {
      const isClassFeature = ddb.character.classes.some((klass) => klass.classFeatures.some((feat) =>
        feat.definition.id == mod.componentId && feat.definition.entityTypeId == mod.componentTypeId
        // make sure this class feature is not replaced
        && !ddb.character.optionalClassFeatures.some((f) => f.affectedClassFeatureId == feat.definition.id)
      ));
      // generate a list to check in option check
      const classFeatureIds = ddb.character.classes.map((klass) => klass.classFeatures.map((feat) => feat.definition.id)).flat();
      const isClassOption = ddb.character.options.class.some((option) =>
        // does this class option match a modifier?
        ((option.componentTypeId == mod.componentTypeId && option.componentId == mod.componentId)
        || (option.definition.entityTypeId == mod.componentTypeId && option.definition.id == mod.componentId))
        // has this feature set been replacd by an optional class feature?
        && !ddb.character.optionalClassFeatures.some((f) => f.affectedClassFeatureId == option.componentId)
        // has it been chosen?
        && ddb.character.choices.class.some((choice) =>
          choice.componentId == option.componentId && choice.componentTypeId == option.componentTypeId && choice.optionValue
        )
        // is this option actually part of the class list?
        && classFeatureIds.includes(option.componentId)
      );
      // if it's been replaced by a class feature lets check that
      const isOptionalClassOption = ddb.character.options.class.some((option) =>
        ((option.componentTypeId == mod.componentTypeId && option.componentId == mod.componentId)
        || (option.definition.entityTypeId == mod.componentTypeId && option.definition.id == mod.componentId))
        // !data.character.optionalClassFeatures.some((f) => f.affectedClassFeatureId == option.definition.id) &&
        && (
          ddb.character.choices.class.some((choice) =>
            choice.componentId == option.componentId && choice.componentTypeId == option.componentTypeId && choice.optionValue
          )
          || ddb.classOptions?.some((classOption) =>
            classOption.id == option.componentId && classOption.entityTypeId == option.componentTypeId
          )
        )
        && ddb.character.optionalClassFeatures?.some((f) => f.classFeatureId == option.componentId)
      );

      // new class feature choice
      const isOptionalClassChoice = ddb.character.choices.class.some((choice) =>
        choice.componentTypeId == mod.componentTypeId
        && choice.componentId == mod.componentId
        && ddb.character.optionalClassFeatures?.some((f) => f.classFeatureId == choice.componentId)
      );

      return isClassFeature || isClassOption || isOptionalClassOption || isOptionalClassChoice;
    });

    return modifiers;
  },

  filterBaseCharacterModifiers: (ddb, type, subType = null, restriction = ["", null], includeExcludedEffects = false, effectOnly = false) => {
    const modifiers = [
      DDBHelper.getChosenClassModifiers(ddb, includeExcludedEffects, effectOnly),
      DDBHelper.getModifiers(ddb, "race", includeExcludedEffects, effectOnly),
      DDBHelper.getModifiers(ddb, "background", includeExcludedEffects, effectOnly),
      DDBHelper.getModifiers(ddb, "feat", includeExcludedEffects, effectOnly),
    ];

    return DDBHelper.filterModifiers(modifiers, type, subType, restriction);
  },

  // I need to getChosenOriginFeatures from data.optionalOriginFeatures

  filterBaseModifiers: (ddb, type, subType = null, restriction = ["", null], includeExcludedEffects = false, effectOnly = false) => {
    const modifiers = [
      DDBHelper.getChosenClassModifiers(ddb, includeExcludedEffects, effectOnly),
      DDBHelper.getModifiers(ddb, "race", includeExcludedEffects, effectOnly),
      DDBHelper.getModifiers(ddb, "background", includeExcludedEffects, effectOnly),
      DDBHelper.getModifiers(ddb, "feat", includeExcludedEffects, effectOnly),
      DDBHelper.getActiveItemModifiers(ddb, includeExcludedEffects),
    ];

    return DDBHelper.filterModifiers(modifiers, type, subType, restriction);
  },

  stringIntAdder(one, two) {
    const oneInt = `${one}`.trim().replace(/^[+-]\s*/, "");
    const twoInt = `${two}`.trim().replace(/^[+-]\s*/, "");
    if (Number.isInteger(parseInt(oneInt)) && Number.isInteger(parseInt(twoInt))) {
      const num = parseInt(oneInt) + parseInt(twoInt);
      return `${num}`;
    } else {
      const twoAdjusted = (/^[+-]/).test(`${two}`.trim()) ? two : `+ ${two}`;
      return `${one} ${twoAdjusted}`;
    }
  },

  /**
   * Checks the list of modifiers provided for a matching bonus type
   * and returns a sum of it's value. May include a dice string.
   * @param {*} modifiers
   * @param {*} character
   * @param {*} bonusSubType
   */
  getModifierSum: (modifiers, character) => {
    let sum = "";
    let diceString = "";
    let modBonus = 0;
    modifiers.forEach((modifier) => {
      const die = modifier.dice ?? modifier.die ?? undefined;
      const fixedBonus = die?.fixedValue ?? 0;
      const statBonus = (Number.isInteger(modifier.statId))
        ? modifier.statId
        : Number.isInteger(modifier.abilityModifierStatId)
          ? modifier.abilityModifierStatId
          : null;
      if (Number.isInteger(statBonus)) {
        const ability = _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].character.abilities.find */ .Z.character.abilities.find((ability) => ability.id === modifier.statId);
        modBonus += character.system.abilities[ability.value].mod;
      }
      if (die) {
        const mod = die.diceString;
        diceString += diceString === "" ? mod : " + " + mod;
        if (die.diceString) {
          const mod = die.diceString + modBonus + fixedBonus;
          diceString += diceString === "" ? mod : " + " + mod;
        } else if (fixedBonus) {
          sum = DDBHelper.stringIntAdder(sum, fixedBonus + modBonus);
        }
      } else if (modifier.fixedValue) {
        sum = DDBHelper.stringIntAdder(sum, modifier.fixedValue);
      } else if (modifier.value) {
        sum = DDBHelper.stringIntAdder(sum, modifier.value);
      } else if (modBonus !== 0) {
        sum = DDBHelper.stringIntAdder(sum, modBonus);
      } else if (modifier.modifierTypeId === 1 && modifier.modifierSubTypeId === 218) {
        // prof bonus
        sum = DDBHelper.stringIntAdder(sum, character.system.attributes.prof);
      }
    });
    if (diceString !== "") {
      sum = diceString + " + " + sum;
    }

    sum = `${sum}`.trim().replace(/\+\s*\+/, "+");

    return sum !== "" ? sum : 0;
  },

  /**
   * Searches for selected options if a given feature provides choices to the user
   * @param {string} type character property: "class", "race" etc.
   * @param {object} feat options to search for
   */
  getChoices: (ddb, type, feat) => {
    const id = feat.id ? feat.id : feat.definition.id ? feat.definition.id : null;
    const featDefinition = feat.definition ? feat.definition : feat;

    if (ddb.character.choices[type] && Array.isArray(ddb.character.choices[type])) {
      // find a choice in the related choices-array
      const choices = ddb.character.choices[type].filter(
        (characterChoice) => characterChoice.componentId && characterChoice.componentId === id
      );

      if (choices) {
        const choiceDefinitions = ddb.character.choices.choiceDefinitions;

        const options = choices
          .filter(
            (choice) => {
              const optionChoice = choiceDefinitions.find((selection) => selection.id === `${choice.componentTypeId}-${choice.type}`);
              const validOption = optionChoice && optionChoice.options.find((option) => option.id === choice.optionValue);
              return validOption;
            })
          .map((choice) => {
            // console.warn(choice);
            const optionChoice = choiceDefinitions.find((selection) => selection.id === `${choice.componentTypeId}-${choice.type}`);
            let result = optionChoice.options.find((option) => option.id === choice.optionValue);
            result.componentId = choice.componentId;
            result.componentTypeId = choice.componentTypeId;
            result.choiceId = choice.id;
            result.parentChoiceId = choice.parentChoiceId;
            result.subType = choice.subType;
            result.type = type;
            result.wasOption = false;
            return result;
          });

        if (options.length > 0) return options;

        if (ddb.character.options[type]?.length > 0) {
          // if it is a choice option, try and see if the mod matches
          const optionMatch = ddb.character.options[type]
            .filter(
              (option) =>
                // id match
                !featDefinition.componentTypeId
                && !featDefinition.entityTypeId
                && id == option.componentId // && // the choice id matches the option componentID
                // (featDefinition.componentTypeId == option.componentTypeId || // either the choice componenttype and optiontype match or
                //   featDefinition.componentTypeId == option.definition.entityTypeId) && // the choice componentID matches the option definition entitytypeid
                // option.componentTypeId == featDefinition.entityTypeId
            )
            .map((option) => {
              return {
                id: option.definition.id,
                entityTypeId: option.definition.entityTypeId,
                label: option.definition.name,
                description: option.definition.description,
                componentId: option.componentId,
                componentTypeId: option.componentTypeId,
                choiceId: null,
                sourceId: option.definition.sourceId,
                parentChoiceId: null,
                subType: `${type}-option`,
                type: type,
                wasOption: true,
              };
            });
          if (optionMatch.length > 0) return optionMatch;
        }
      }
    }
    // we could not determine if there are any choices left
    return [];
  },

  getComponentIdFromOptionValue: (ddb, type, optionId) => {
    if (ddb.character?.choices && ddb.character.choices[type] && Array.isArray(ddb.character.choices[type])) {
      // find a choice in the related choices-array
      const choice = ddb.character.choices[type].find(
        (characterChoice) => characterChoice.optionValue && characterChoice.optionValue === optionId
      );
      if (choice) return choice.componentId;
    }
    // we could not determine if there are any choices left
    return undefined;
  },

  determineActualFeatureId: (ddb, featureId, type = "class") => {
    const optionalFeatureReplacement = ddb.character?.optionalClassFeatures
      ? ddb.character.optionalClassFeatures
        .filter((f) => f.classFeatureId === featureId)
        .map((f) => f.affectedClassFeatureId)
      : [];
    // are we dealing with an optional class feature?
    const choiceFeature = DDBHelper.getComponentIdFromOptionValue(ddb, type, featureId);

    if (choiceFeature) {
      const choiceOptionalFeature = ddb.character.optionalClassFeatures
        .filter((f) => f.classFeatureId === choiceFeature)
        .map((f) => f.affectedClassFeatureId);
      if (choiceOptionalFeature && choiceOptionalFeature.length > 0) {
        return choiceOptionalFeature[0];
      }
    } else if (optionalFeatureReplacement && optionalFeatureReplacement.length > 0) {
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Feature ${featureId} is replacing ${optionalFeatureReplacement[0]}`);
      return optionalFeatureReplacement[0];
    }
    return featureId;
  },

  findClassByFeatureId: (ddb, featureId) => {
    // optional class features need this filter, as they replace existing features
    const featId = DDBHelper.determineActualFeatureId(ddb, featureId);
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Finding featureId ${featureId} with featId ${featId}`);

    let klass = ddb.character.classes.find((cls) => {
      let classFeatures = cls.classFeatures;
      let featureMatch = classFeatures.find((feature) => feature.definition.id === featId);

      if (featureMatch) {
        return true;
      } else {
        // if not in global class feature list lets dig down
        classFeatures = cls.definition.classFeatures;
        if (cls.subclassDefinition && cls.subclassDefinition.classFeatures) {
          classFeatures = classFeatures.concat(cls.subclassDefinition.classFeatures);
        }
        return classFeatures.some((feature) => feature.id === featId);
      }
    });
    // try class option lookup
    if (!klass) {
      const option = ddb.character.options.class.find((option) => option.definition.id == featureId);
      if (option) {
        klass = ddb.character.classes.find((cls) => cls.classFeatures.find((feature) => feature.definition.id == option.componentId));
      }
      if (option && !klass && ddb.classOptions) {
        const classOption = ddb.classOptions.find((cOption) => cOption.id == option.componentId);
        if (classOption) {
          klass = ddb.character.classes.find((cls) => cls.definition.id === classOption.classId);
        }
      }
    }
    // class option lookups
    if (!klass && ddb.classOptions) {
      const classOption = ddb.classOptions.find((option) => option.id == featureId);
      if (classOption) {
        klass = ddb.character.classes.find((cls) => cls.definition.id == classOption.classId);
      }
    }
    if (klass) {
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Class ${klass.definition.name} found for ${featureId} with featId ${featId}`);
    } else {
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Class not found for ${featureId}`);
    }

    return klass;
  },

  getCustomValueFromCharacter(ddbItem, character, type) {
    if (!character) return null;
    const characterValues = character.flags.ddbimporter.dndbeyond.characterValues;
    const customValue = characterValues.filter((value) =>
      value.valueId == ddbItem.id
      && value.valueTypeId == ddbItem.entityTypeId
    );

    if (customValue) {
      const value = customValue.find((value) => value.typeId == type);
      if (value) return value.value;
    }
    return null;
  },

  getCustomValue(foundryItem, ddb, type) {
    const characterValues = ddb.character?.characterValues;
    if (!characterValues) return null;
    const customValue = characterValues.filter(
      (value) =>
        (value.valueId == foundryItem.flags.ddbimporter.dndbeyond?.id
          && value.valueTypeId == foundryItem.flags.ddbimporter.dndbeyond?.entityTypeId)
        || (value.valueId == foundryItem.flags.ddbimporter.id
          && value.valueTypeId == foundryItem.flags.ddbimporter.entityTypeId)
    );

    if (customValue) {
      const customName = customValue.find((value) => value.typeId == type);
      if (customName) return customName.value;
    }
    return null;
  },

  addCustomValues(ddb, foundryItem) {
    // to hit override requires a lot of crunching
    // const toHitOverride = DDBHelper.getCustomValue(item, character, 13);
    const toHitBonus = DDBHelper.getCustomValue(foundryItem, ddb, 12);
    const damageBonus = DDBHelper.getCustomValue(foundryItem, ddb, 10);
    // const displayAsAttack = DDBHelper.getCustomValue(item, character, 16);
    const costOverride = DDBHelper.getCustomValue(foundryItem, ddb, 19);
    const weightOverride = DDBHelper.getCustomValue(foundryItem, ddb, 22);
    // dual wield 18
    // silvered
    const silvered = DDBHelper.getCustomValue(foundryItem, ddb, 20);
    // adamantine
    const adamantine = DDBHelper.getCustomValue(foundryItem, ddb, 21);
    // off-hand
    // const offHand = DDBHelper.getCustomValue(ddbItem, character, 18);
    const dcOverride = DDBHelper.getCustomValue(foundryItem, ddb, 15);
    const dcBonus = DDBHelper.getCustomValue(foundryItem, ddb, 14);

    if (toHitBonus) {
      if (hasProperty(foundryItem, "system.attackBonus") && parseInt(foundryItem.system.attackBonus) === 0) {
        foundryItem.system.attackBonus = toHitBonus;
      } else {
        foundryItem.system.attackBonus += ` + ${toHitBonus}`;
      }
    }
    if (damageBonus && foundryItem.system?.damage?.parts && foundryItem.system?.damage?.parts.length !== 0) {
      foundryItem.system.damage.parts[0][0] = foundryItem.system.damage.parts[0][0].concat(` +${damageBonus}`);
    } else if (damageBonus && foundryItem.system?.damage?.parts) {
      const part = [`+${damageBonus}`, ""];
      foundryItem.system.damage.parts.push(part);
    }
    if (costOverride) foundryItem.system.cost = costOverride;
    if (weightOverride) foundryItem.system.weight = weightOverride;
    if (silvered) foundryItem.system.properties['sil'] = true;
    if (adamantine) foundryItem.system.properties['ada'] = true;
    if (dcBonus) {
      if (foundryItem.flags.ddbimporter.dndbeyond.dc) {
        foundryItem.system.save.dc = parseInt(foundryItem.flags.ddbimporter.dndbeyond.dc) + dcBonus;
        foundryItem.system.save.scaling = "flat";
      }
    }
    if (dcOverride) {
      foundryItem.system.save.dc = dcOverride;
      foundryItem.system.save.scaling = "flat";
    }
    return foundryItem;
  },

  getName(ddb, item, character = null, allowCustom = true) {
    // spell name
    const customName = character
      ? DDBHelper.getCustomValueFromCharacter(item, character, 8)
      : DDBHelper.getCustomValue(item, ddb, 8);
    if (customName && allowCustom) {
      return customName.replace("â€™", "'").trim();
    } else if (item.definition?.name) {
      return item.definition.name.replace("â€™", "'").trim();
    } else if (item.name) {
      return item.name.replace("â€™", "'").trim();
    } else {
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].error */ .Z.error("Unable to determine name for:", item);
      return "Unknown thing.";
    }
  },

  displayAsAttack(ddb, item, character = null) {
    const customDisplay = character
      ? DDBHelper.getCustomValueFromCharacter(item, character, 16)
      : DDBHelper.getCustomValue(item, ddb, 16);
    if (typeof customDisplay == "boolean") {
      return customDisplay;
    } else if (hasProperty(item, "displayAsAttack")) {
      return item.displayAsAttack;
    } else {
      return false;
    }
  },

};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DDBHelper);


/***/ }),

/***/ 546:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6451);


const DDBProxy = {

  isCustom: () => {
    return game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "custom-proxy");
  },

  resetProxy: () => {
    game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "api-endpoint", _settings_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].DEFAULT_SETTINGS.READY.PROXY["api-endpoint"]["default"] */ .Z.DEFAULT_SETTINGS.READY.PROXY["api-endpoint"]["default"]);
    game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "custom-proxy", false);
  },

  getProxy: () => {
    if (DDBProxy.isCustom() || CONFIG.DDBI.DEV.enabled) return game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "api-endpoint");
    else return _settings_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].URLS.PROXY */ .Z.URLS.PROXY;
  },

  getDynamicProxy: () => {
    if (CONFIG.DDBI.DEV.enabled) return game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "dynamic-api-endpoint");
    else return _settings_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].URLS.DYNAMIC */ .Z.URLS.DYNAMIC;
  },

  getCORSProxy: () => {
    if (DDBProxy.isCustom() || CONFIG.DDBI.DEV.enabled) return game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "cors-endpoint");
    return _settings_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].URLS.CORS */ .Z.URLS.CORS;
  },


};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DDBProxy);


/***/ }),

/***/ 5817:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ DDBSources)
/* harmony export */ });
/* harmony import */ var _muncher_DDBMuncher_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1475);


class DDBSources extends FormApplication {
  static get defaultOptions() {
    const options = super.defaultOptions;
    options.id = "ddb-importer-sources";
    options.template = "modules/ddb-importer/handlebars/sources.hbs";
    options.width = 500;
    return options;
  }

  static getSourcesLookups(selected) {
    const selections = CONFIG.DDB.sources
      .filter((source) => source.isReleased && source.sourceCategoryId !== 9 && source.sourceCategoryId !== 3)
      .map((source) => {
        const details = {
          id: source.id,
          acronym: source.name,
          label: source.description,
          selected: selected.includes(source.id),
        };
        return details;
      });

    return selections;
  }

  get title() { // eslint-disable-line class-methods-use-this
    // improve localisation
    // game.i18n.localize("")
    return "Monster Muncher Sauce Selection";
  }

  activateListeners(html) {
    super.activateListeners(html);

    html.find("#toggle-sources").click(async (event) => {
      event.preventDefault();
      if ($('.munching-sources input:checked').length && $('.munching-sources input').not(':checked').length) {
        $('.munching-sources input').prop('checked', false);
      } else {
        $('.munching-sources input').each(function() {
          // eslint-disable-next-line no-invalid-this
          $(this).prop('checked', !$(this).prop('checked'));
        });
      }
    });
  }

  /** @override */
  async getData() { // eslint-disable-line class-methods-use-this
    const existingSelection = game.settings.get("ddb-importer", "munching-policy-muncher-sources").flat();
    const sources = DDBSources.getSourcesLookups(existingSelection);

    return {
      sources: sources.sort((a, b) => {
        return (a.label > b.label) ? 1 : ((b.label > a.label) ? -1 : 0);
      }),
    };
  }

  /** @override */
  // eslint-disable-next-line class-methods-use-this
  async _updateObject(event, formData) {
    event.preventDefault();
    let sources = [];
    for (const [key, value] of Object.entries(formData)) {
      if (value) sources.push(parseInt(key));
    }
    await game.settings.set("ddb-importer", "munching-policy-muncher-sources", sources);
    // eslint-disable-next-line no-use-before-define
    new _muncher_DDBMuncher_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z().render(true);
  }
}


/***/ }),

/***/ 258:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RN": () => (/* binding */ parseTags),
/* harmony export */   "ZP": () => (/* binding */ parseTemplateString),
/* harmony export */   "uB": () => (/* binding */ importCacheLoad),
/* harmony export */   "xz": () => (/* binding */ loadSRDRules)
/* harmony export */ });
/* unused harmony export loadDDBCompendiumIndexes */
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7669);
/* harmony import */ var _DDBHelper_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1438);
/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5259);
/* harmony import */ var _CompendiumHelper_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(3893);
/* harmony import */ var _muncher_adventure_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(9441);






const INDEX_COMPENDIUMS = [
  "spell",
  "item",
  "magicitem",
];

function evaluateMath(obj) {
  // eslint-disable-next-line no-new-func
  return Function('"use strict";return ' + obj.replace(/\+\s*\+/g, "+"))();
}

async function loadDDBCompendiumIndexes() {
  for (const i of INDEX_COMPENDIUMS) {
    // eslint-disable-next-line no-await-in-loop
    await _CompendiumHelper_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].loadCompendiumIndex */ .Z.loadCompendiumIndex(i);
  }
}

async function loadSRDRules() {
  if (hasProperty(CONFIG, "DDBI.SRD_LOOKUP.index")) return;
  try {
    // eslint-disable-next-line require-atomic-updates
    CONFIG.DDBI.SRD_LOOKUP = await (0,_muncher_adventure_js__WEBPACK_IMPORTED_MODULE_4__/* .generateAdventureConfig */ .k)(false, false, true);
    // eslint-disable-next-line require-atomic-updates
    CONFIG.DDBI.SRD_LOOKUP.linkMap = {};
    for (const [key, value] of Object.entries(CONFIG.DDBI.SRD_LOOKUP.lookups)) {
      value.forEach((thing) => {
        thing.type = key;
        CONFIG.DDBI.SRD_LOOKUP.linkMap[thing.name] = thing;
      });
    }
  } catch (err) {
    _logger_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].error */ .Z.error("5e SRD Rules compendium failed to load", err);
    // eslint-disable-next-line require-atomic-updates
    // setProperty(CONFIG, "DDBI.SRD_LOOKUP.index", {});
  }
}

async function importCacheLoad() {
  await loadDDBCompendiumIndexes();
  await loadSRDRules();
}

/**
 * Parse a match and replace template values ready for evaluation
 * @param {*} ddb
 * @param {*} character
 * @param {*} match
 * @param {*} feature
 */
// eslint-disable-next-line complexity
function parseMatch(ddb, character, match, feature) {
  const useScaleAll = foundry.utils.isNewerVersion(game.system.version, "2.0.3");
  const splitMatchAt = match.split("@");
  let result = splitMatchAt[0];
  const characterAbilities = character.flags.ddbimporter.dndbeyond.effectAbilities;
  const classOption = [ddb.character.options.race, ddb.character.options.class, ddb.character.options.feat]
    .flat()
    .find((option) => option.definition.id === feature.componentId);
  let linktext = `${result}`;

  // scalevalue
  if (result.includes("scalevalue")) {
    let scaleValue = _DDBHelper_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].getScaleValueString */ .Z.getScaleValueString(ddb, feature);
    // if (scaleValue.value.startsWith("@")) scaleValue.value = `[[${scaleValue.value}]]{${scaleValue.name}}`;
    result = result.replace("scalevalue", scaleValue.value);
    linktext = result.replace("scalevalue", " (Scaled Value) ");
  }

  // savedc:int
  // savedc:str,dex
  if (result.includes("savedc")) {
    const regexp = /savedc:([a-z]{3})(?:,)?([a-z]{3})?/g;
    const matches = [...result.matchAll(regexp)];

    matches.forEach((match) => {
      const saves = match.slice(1);
      const saveDCs = saves
        .filter((save) => save)
        .map((save) => {
          const abilityModifier = _utils_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].calculateModifier */ .Z.calculateModifier(characterAbilities[save].value);
          // not sure if we should add this, probably not.
          // const bonus = DDBHelper.getModifierSum(DDBHelper.filterBaseModifiers(ddb, "bonus", "spell-save-dc"), character);
          const dc = 8 + character.system.attributes.prof + abilityModifier;
          return useScaleAll
            ? `8 + @abilities.${save}.mod + @prof`
            : dc;
        });
      const saveRegexp = RegExp(match[0], "g");
      result = result.replace(saveRegexp, useScaleAll ? `max(${saveDCs.join(", ")})` : Math.max(...saveDCs));
      linktext = result.replace(saveRegexp, " (Save DC) ");
    });
  }

  // modifier:int@min:1
  // (modifier:cha)+1
  if (result.includes("modifier")) {
    const regexp = /modifier:([a-z]{3})/g;
    // creates array from match groups and dedups
    const ability = [...new Set(Array.from(result.matchAll(regexp), (m) => m[1]))];

    ability.forEach((ab) => {
      const abilityModifier = useScaleAll ? ` + @abilities.${ab}.mod` : `+ ${characterAbilities[ab].mod}`;
      const abRegexp = RegExp(`modifier:${ab}`, "g");
      result = result.replace(abRegexp, abilityModifier);
      linktext = result.replace(abRegexp, ` (${_utils_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].capitalize */ .Z.capitalize(ab)} Modifier) `);
    });
  }

  // classlevel*5
  // (classlevel/2)@roundup
  if (result.includes("classlevel")) {
    const cls = feature.classId
      ? ddb.character.classes.find((cls) => cls.definition.id == feature.classId)
      : _DDBHelper_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].findClassByFeatureId */ .Z.findClassByFeatureId(ddb, feature.componentId);
    if (cls) {
      const clsLevel = useScaleAll ? ` + @classes.${cls.definition.name.toLowerCase()}.levels` : cls.level;
      result = result.replace("classlevel", clsLevel);
      linktext = result.replace("classlevel", ` (${cls.definition.name} Level) `);
    } else if (classOption) {
      // still not found a cls? could be an option
      const optionCls = _DDBHelper_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].findClassByFeatureId */ .Z.findClassByFeatureId(ddb, classOption.componentId);
      if (optionCls) {
        const clsLevel = useScaleAll ? ` + @classes.${optionCls.definition.name.toLowerCase()}.levels` : optionCls.level;
        result = result.replace("classlevel", clsLevel);
        linktext = result.replace("classlevel", ` (${optionCls.definition.name} Level) `);
      } else {
        _logger_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].error */ .Z.error(
          `Unable to parse option class info. classOption ComponentId is: ${classOption.componentId}.  ComponentId is ${feature.componentId}`
        );
      }
    } else {
      if (!feature.componentId) {
        _logger_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].debug */ .Z.debug("Feature failed componentID parse", feature);
      }
      _logger_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].error */ .Z.error(`Unable to parse option class info. ComponentId is ${feature.componentId}`);
    }
  }

  if (result.includes("characterlevel")) {
    const characterLevel = useScaleAll ? " + @details.level" : character.flags.ddbimporter.dndbeyond.totalLevels;
    result = result.replace("characterlevel", characterLevel);
    linktext = result.replace("characterlevel", ` (Character Level) `);
  }

  if (result.includes("proficiency")) {
    const profBonus = useScaleAll ? " + @prof" : character.system.attributes.prof;
    result = result.replace("proficiency", profBonus);
    linktext = result.replace("proficiency", ` (Proficiency Bonus) `);
  }

  // abilityscore:int
  if (result.includes("spellattack")) {
    const regexp = /spellattack:([a-z]{3})/g;
    // creates array from match groups and dedups
    const ability = [...new Set(Array.from(result.matchAll(regexp), (m) => m[1]))];

    ability.forEach((ab) => {
      const rollString = useScaleAll
        ? ` + @abilities.${ab}.mod + @prof + @bonus.rsak.attack`
        : `${characterAbilities[ab].mod} + ${character.system.attributes.prof}`;
      const abRegexp = RegExp(`spellattack:${ab}`, "g");
      result = result.replace(abRegexp, rollString);
      linktext = result.replace(abRegexp, ` (${_utils_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].capitalize */ .Z.capitalize(ab)} Spell Attack) `);
    });
  }

  // abilityscore:int
  if (result.includes("abilityscore")) {
    const regexp = /abilityscore:([a-z]{3})/g;
    // creates array from match groups and dedups
    const ability = [...new Set(Array.from(result.matchAll(regexp), (m) => m[1]))];

    ability.forEach((ab) => {
      const abilityScore = useScaleAll ? ` + @abilities.${ab}.value` : characterAbilities[ab].value;
      const abRegexp = RegExp(`abilityscore:${ab}`, "g");
      result = result.replace(abRegexp, abilityScore);
      linktext = result.replace(abRegexp, ` (${_utils_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].capitalize */ .Z.capitalize(ab)} Score) `);
    });
  }

  // limiteduse
  if (result.includes("limiteduse")) {
    const limitedUse = feature.limitedUse?.maxUses || "";
    result = result.replace("limiteduse", limitedUse);
    linktext = result.replace("limiteduse", ` (Has limited uses) `);
  }

  return {
    parsed: result,
    linktext,
  };
}

/**
 * Apply the expression constraint
 * @param {*} value
 * @param {*} constraint
 */
const applyConstraint = (value, constraint) => {
  // {{(classlevel/2)@rounddown#unsigned}}
  // @ features
  // @roundup
  // @roundown
  // min:1
  // max:3
  const splitConstraint = constraint.split(":");
  const multiConstraint = splitConstraint[0].split("*");
  const match = multiConstraint[0];

  let result = value;

  switch (match) {
    case "max": {
      result = Math.min(splitConstraint[1], result);
      break;
    }
    case "min": {
      result = Math.max(splitConstraint[1], result);
      break;
    }
    case "roundup": {
      result = Math.ceil(result);
      break;
    }
    case "rounddown":
    case "roundown": {
      result = Math.floor(result);
      break;
    }
    default: {
      _logger_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].debug */ .Z.debug(`Missed match is ${match}`);
      _logger_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].warn */ .Z.warn(`ddb-importer does not know about template constraint {{@${constraint}}}. Please log a bug.`); // eslint-disable-line no-console
    }
  }

  if (multiConstraint.length > 1) {
    const evalStatement = `${result}*${multiConstraint[1]}`;
    result = evaluateMath(evalStatement.replace(")", ""));
  }

  if (match == "unsigned") {
    result = `${result}`.trim().replace(/^\+\s*/, "");
  } else if (match == "signed") {
    if (!`${result}`.trim().startsWith("+") && !`${result}`.trim().startsWith("-")) {
      result = `+ ${result}`;
    }
  }

  return result;
};


/**
 * Apply the expression constraint
 * @param {*} value
 * @param {*} constraint
 */
const addConstraintEvaluations = (value, constraint) => {
  // {{(classlevel/2)@rounddown#unsigned}}
  // @ features
  // @roundup
  // @roundown
  // min:1
  // max:3
  const splitConstraint = constraint.split(":");
  const multiConstraint = splitConstraint[0].split("*");
  const match = multiConstraint[0];

  let result = value;

  switch (match) {
    case "max": {
      result = `min(${value}, ${splitConstraint[1]})`;
      break;
    }
    case "min": {
      result = `max(${value}, ${splitConstraint[1]})`;
      break;
    }
    case "roundup": {
      result = `ceil(${value})`;
      break;
    }
    case "rounddown":
    case "roundown": {
      result = `floor(${value})`;
      break;
    }
    default: {
      _logger_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].debug */ .Z.debug(`Missed match is ${match}`);
      _logger_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].warn */ .Z.warn(`ddb-importer does not know about template constraint {{@${constraint}}}. Please log a bug.`); // eslint-disable-line no-console
    }
  }

  if (multiConstraint.length > 1) {
    result = `${result}*${multiConstraint[1].replace(")", "")}`;
  }

  if (typeof result === 'string') result = result.trim().replace(/^\+\s*/, "");

  return result;
};

const escapeRegExp = (string) => {
  return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"); // $& means the whole matched string
};

const getNumber = (theNumber, signed) => {
  if (signed == "unsigned") {
    theNumber = `${theNumber}`.trim().replace(/^\+\s*/, "");
  } else if (signed == "signed" && !`${theNumber}`.trim().startsWith("+") && !`${theNumber}`.trim().startsWith("-")) {
    theNumber = `+ ${theNumber}`;
  }

  return theNumber.toString();
};

function findMatchingTagInIndex(type, tag) {
  const index = hasProperty(CONFIG.DDBI, `compendium.index.${type}`)
    ? getProperty(CONFIG.DDBI, `compendium.index.${type}`)
    : undefined;
  if (!index) {
    _logger_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].warn */ .Z.warn(`Unable to load compendium ${type}s`);
    return tag;
  }
  const strippedTag = _utils_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].stripHtml */ .Z.stripHtml(tag);
  const match = index.find((entry) => entry.name.replace("â€™", "'").toLowerCase() === strippedTag.replace("â€™", "'").replace("&nbsp;", " ").toLowerCase());
  if (match) {
    const label = getProperty(CONFIG.DDBI, `compendium.label.${type}`);
    return `@Compendium[${label}.${match._id}]{${tag}}`;
  } else if (strippedTag.includes(";")) {
    const tagSplit = strippedTag.replace("&nbsp;", " ").replace("â€™", "'").split(";")[0];
    const splitMatch = index.find((entry) => entry.name.replace("â€™", "'").toLowerCase() === tagSplit.toLowerCase());
    if (splitMatch) {
      const label = getProperty(CONFIG.DDBI, `compendium.label.${type}`);
      return `@Compendium[${label}.${splitMatch._id}]{${tagSplit}}`;
    }
  }
  _logger_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].info */ .Z.info(`Unable to find tag parse compendium match in ${type} for ${tag}`);
  return tag;
}

// eslint-disable-next-line no-unused-vars
function replaceTag(match, p1, p2, p3, offset, string) {
  if (!p2) {
    _logger_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].warn */ .Z.warn(`Unable to tag parse ${match}`);
    return match;
  }
  const strippedP2 = _utils_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].stripHtml */ .Z.stripHtml(p2);

  if (INDEX_COMPENDIUMS.includes(p1)) {
    return findMatchingTagInIndex(p1, p2);
  } else if (["total cover", "half cover", "three-quaters cover"].includes(strippedP2.toLowerCase())) {
    const coverMatch = CONFIG.DDBI.SRD_LOOKUP.fullPageMap.find((entry) => entry.name === "Cover");
    if (coverMatch) {
      return `@Compendium[dnd5e.rules.${coverMatch._id}.JournalEntryPage.${coverMatch.pageId}]{${p2}}`;
    }
  } else if (hasProperty(CONFIG.DDBI.SRD_LOOKUP, strippedP2.split(";")[0])) {
    const lookup = getProperty(CONFIG.DDBI.SRD_LOOKUP, strippedP2);
    const pageLink = lookup.pageId ? `.JournalEntryPage.${lookup.pageId}` : "";
    const linkStub = lookup.headerLink ? `#${lookup.headerLink}` : "";
    return `@Compendium[dnd5e.rules.${lookup._id}${pageLink}${linkStub}]{${p2}}`;
  } else {
    const srdMatch = CONFIG.DDBI.SRD_LOOKUP.fullPageMap.find((page) => page.name.toLowerCase() === strippedP2.toLowerCase().split(";")[0]
      || page.name.replace("â€™", "'").toLowerCase() === strippedP2.replace("â€™", "'").toLowerCase().split("ing")[0].split(";")[0]
    );
    if (srdMatch) {
      const pageLink = srdMatch.pageId ? `.JournalEntryPage.${srdMatch.pageId}` : "";
      const linkStub = srdMatch.headerLink ? `#${srdMatch.headerLink}` : "";
      return `@Compendium[dnd5e.rules.${srdMatch._id}${pageLink}${linkStub}]{${p2}}`;
    } else {
      _logger_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].info */ .Z.info(`Unable to tag parse compendium match for ${match}`);
    }
  }

  return p2;
}

function parseSRDLinks(text) {
  if (!CONFIG.DDBI.SRD_LOOKUP?.lookups) return text;
  [
    CONFIG.DDBI.SRD_LOOKUP.lookups.conditions,
    CONFIG.DDBI.SRD_LOOKUP.lookups.skills,
    CONFIG.DDBI.SRD_LOOKUP.lookups.senses,
    // CONFIG.DDBI.SRD_LOOKUP.lookups.weaponproperties,
  ]
    .flat()
    .forEach((entry) => {
      const linkRegEx = new RegExp(`(^| |\\(|\\[|>)(${entry.name})( |\\)|\\]|\\.|,|$|\n|<)`, "ig");
      function replaceRule(match, p1, p2, p3) {
        return `${p1}@Compendium[${entry.compendium}.${entry._id}]{${p2}}${p3}`;
      }
      text = text.replaceAll(linkRegEx, replaceRule);
    });
  return text;
}

function parseTags(text) {
  // if (!CONFIG.DDBI.SRD_LOOKUP.index || !CONFIG.DDBI.SRD_LOOKUP.lookups) return text;
  const tagRegEx = /\[([^\]]+)]([^[]+)\[\/([^\]]+)]/g;
  const matches = text.match(tagRegEx);
  if (matches) {
    return text.replaceAll(tagRegEx, replaceTag);
  }
  text = parseSRDLinks(text);
  return text;
}

function replaceRoll(match, p1, p2) {
  if (!p2) {
    _logger_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].warn */ .Z.warn(`Unable to roll parse ${match}`);
    return match;
  }
  const isRollRegex = /([0-9]*d[0-9]+)|(@scale\.)/g;
  const isRollMatches = p2.match(isRollRegex);
  if (isRollMatches) {
    return match;
  } else if (Number.isInteger(parseInt(p2))) {
    return p2;
  } else {
    const prefix = p2.trim().startsWith("+") ? "+ " : "";
    return `${prefix}[[${p2}]]`;
  }
}

function fixRollables(text) {
  const diceMatchRegex = /<strong>\+*\s*(\d*d\d\d*\s*\+*)\s*<\/strong>\+*\s*\[\[\/roll/g;
  const matches = text.match(diceMatchRegex);
  if (matches) {
    text = text.replaceAll(diceMatchRegex, "[[/roll $1 ");
  }

  const noRollRegex = /(\[\[\/roll)([\w\s.,@\d+\\*/()]*(?![0-9]*d[0-9]+)(?!@scale\.)[\w\s.,@\d+\\*/()]*)(\]\](?:{Scaled Roll})*)/g;
  // const noRollMatches = text.match(noRollRegex);
  // console.warn("noRollMatches", {text: duplicate(text), noRollMatches});
  text = text.replaceAll(noRollRegex, replaceRoll);

  return text;
}

/**
 * This will parse a snippet/description with template boilerplate in from DDB.
 * e.g. Each creature in the area must make a DC {{savedc:con}} saving throw.
 * @param {*} ddb
 * @param {*} text
 */
function parseTemplateString(ddb, character, text, feature) {
  if (!text) return text;

  text = text.replace(/\r\nâ€¢/g, "</p>\r\n<p>&bull;");
  let result = {
    id: feature.id,
    entityTypeId: feature.entityTypeId,
    componentId: feature.componentId ? feature.componentId : null,
    componentTypeId: feature.componentTypeId ? feature.componentTypeId : null,
    damageTypeId: feature.damageTypeId ? feature.damageTypeId : null,
    text: text,
    resultStrings: [],
    displayStrings: [],
    definitions: [],
  };

  const useScaleAll = foundry.utils.isNewerVersion(game.system.version, "2.0.3");
  const useScaleText = game.settings.get("ddb-importer", "character-update-policy-use-scalevalue-description") && !useScaleAll
    ? "{Scaled Roll}"
    : "";
  const fullMatchRegex = /(?:^|[ "'(+>])(\d*d\d\d*\s)?({{.*?}})(?:$|[., "')+<])/g;
  const fullMatches = [...new Set(Array.from(result.text.matchAll(fullMatchRegex), (m) => `${m[1] !== undefined ? m[1] : ""}${m[2]}`))];
  fullMatches.forEach((match) => {
    const scaledText = match.includes("scalevalue") ? useScaleText : "";
    result.text = result.text.replace(match, `[[/roll ${match}]]${scaledText}`);
  });

  const regexp = /{{(.*?)}}/g;
  // creates array from match groups and dedups
  const matches = [...new Set(Array.from(result.text.matchAll(regexp), (m) => m[1]))];

  // eslint-disable-next-line complexity
  matches.forEach((match) => {
    let entry = {
      parsed: null,
      match: match,
      replacePattern: new RegExp(`{{${escapeRegExp(match)}}}`, "g"),
      type: null,
      subType: null,
    };

    const splitSigned = match.split("#");
    const splitRemoveUnsigned = splitSigned[0];
    const signed = splitSigned.length > 1
      ? splitSigned[1]
      : match.includes("modifier")
        ? "signed"
        : null;
    const splitMatchAt = splitRemoveUnsigned.split("@");
    const parsedMatchData = parseMatch(ddb, character, splitRemoveUnsigned, feature);
    const parsedMatch = parsedMatchData.parsed;
    result.displayStrings.push(parsedMatchData.displayString);
    const dicePattern = /\d*d\d\d*/;
    const typeSplit = splitMatchAt[0].split(":");
    entry.type = typeSplit[0];

    if (typeSplit.length > 1) entry.subType = typeSplit[1];
    // do we have a dice string, e.g. sneak attack?
    if (parsedMatch.match(dicePattern) || parsedMatch.includes("@scale")) {
      if (parsedMatch.match(dicePattern)) entry.type = "dice";
      entry.parsed = parsedMatch;
      if (splitMatchAt.length > 1) {
        for (let i = 1; i < splitMatchAt.length; i++) {
          if (splitMatchAt[i].includes(")")) entry.parsed = entry.parsed.replace("(", "");
          entry.parsed = addConstraintEvaluations(entry.parsed, splitMatchAt[i]);
        }
      }
      result.text = result.text.replace(entry.replacePattern, entry.parsed);
    } else {
      // we try and eval the expression!
      try {
        const openExpression = (parsedMatch.match(/\(/g) || []).length;
        const closeExpression = (parsedMatch.match(/\)/g) || []).length;

        let evalString = parsedMatch;
        if (openExpression != closeExpression) {
          for (let i = 0; i < openExpression - closeExpression; i++) {
            evalString = evalString.replace("(", "").trim();
          }
        }

        for (let start = evalString.startsWith("("), end = evalString.endsWith(")"); start && end; start = evalString.startsWith("("), end = evalString.endsWith(")")) {
          evalString = evalString.replace(/^\(/, "").replace(/\)$/, "");
        }
        const evalMatch = useScaleAll ? evalString : evaluateMath(evalString);
        if (splitMatchAt.length > 1) {
          let evalConstraint = evalMatch;
          for (let i = 1; i < splitMatchAt.length; i++) {
            evalConstraint = Number.isInteger(Number.parseInt(evalConstraint))
              ? applyConstraint(evalConstraint, splitMatchAt[i])
              : addConstraintEvaluations(evalConstraint, splitMatchAt[i]);
          }
          entry.parsed = getNumber(evalConstraint, signed);
        } else {
          entry.parsed = getNumber(evalMatch, signed);
        }
        entry.parsed = entry.parsed.replace("+ +", "+");
        const isRoll = result.text.includes("[[/roll");
        // there are some edge cases here where some template string matches do not get the correct [[]] boxes because
        // they are not all [[/roll ]] boxes
        // I need to move the [[]] box addition to outside this process loop
        if (useScaleAll && !isRoll && (/^\+\s/).test(entry.parsed.trim())) {
          entry.parsed = `${entry.parsed.trim().replace(/^\+\s/, "+ [[")}]]`;
        } else if (useScaleAll && !isRoll && [undefined, "unsigned"].includes(signed)) {
          entry.parsed = `[[${entry.parsed.trim()}]]`;
        }
        result.text = result.text.replace(entry.replacePattern, entry.parsed);
      } catch (err) {
        result.text = result.text.replace(entry.replacePattern, `{{${match}}}`);
        _logger_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].warn */ .Z.warn(`ddb-importer does not know about template value {{${match}}}. Please log a bug.`, err);
        _logger_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].warn */ .Z.warn(err.stack);
      }
    }
    if (entry.parsed) result.resultStrings.push(entry.parsed);
    result.definitions.push(entry);
  });

  result.text = fixRollables(result.text);
  result.text = result.text.replace(/\+\s*\+/g, "+").replace(/\+\s*\+/g, "+");
  result.text = result.text.replace(/\+<\/strong>\+/g, "+</strong>");

  result.text = parseTags(result.text);
  character.flags.ddbimporter.dndbeyond.templateStrings.push(result);

  return result;
}


/***/ }),

/***/ 4222:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "B": () => (/* binding */ DirectoryPicker)
/* harmony export */ });
/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5259);
/**
 * Game Settings: Directory
 */



class DirectoryPicker extends FilePicker {
  constructor(options = {}) {
    super(options);
  }

  _onSubmit(event) {
    event.preventDefault();
    const path = event.target.target.value;
    const activeSource = this.activeSource;
    const bucket = event.target.bucket ? event.target.bucket.value : null;
    this.field.value = DirectoryPicker.format({
      activeSource,
      bucket,
      path,
    });
    this.close();
  }

  static async uploadToPath(path, file) {
    const options = DirectoryPicker.parse(path);
    return FilePicker.upload(options.activeSource, options.current, file, { bucket: options.bucket }, { notify: false });
  }

  // returns the type "Directory" for rendering the SettingsConfig
  static Directory(val) {
    return val;
  }

  // formats the data into a string for saving it as a GameSetting
  static format(value) {
    return value.bucket !== null
      ? `[${value.activeSource}:${value.bucket}] ${value.path}`
      : `[${value.activeSource}] ${value.path}`;
  }

  // parses the string back to something the FilePicker can understand as an option
  static parse(str) {
    let matches = str.match(/\[(.+)\]\s*(.+)/);
    if (matches) {
      let source = matches[1];
      const current = matches[2].trim();
      const [s3, bucket] = source.split(":");
      if (bucket !== undefined) {
        return {
          activeSource: s3,
          bucket: bucket,
          current: current,
        };
      } else {
        return {
          activeSource: s3,
          bucket: null,
          current: current,
        };
      }
    }
    // failsave, try it at least
    return {
      activeSource: "data",
      bucket: null,
      current: str,
    };
  }

  // Adds a FilePicker-Simulator-Button next to the input fields
  static processHtml(html) {
    $(html)
      .find(`input[data-dtype="Directory"], .ddb-directory`)
      .each((index, element) => {
        // disable the input field raw editing
        $(element).prop("readonly", true);

        // if there is no button next to this input element yet, we add it
        if (!$(element).next().length) {
          let picker = new DirectoryPicker({
            field: $(element)[0],
            ...DirectoryPicker.parse($(element).val()),
          });
          let pickerButton = $(
            '<button type="button" class="file-picker" data-type="imagevideo" data-target="img" title="Pick directory"><i class="fas fa-file-import fa-fw"></i></button>'
          );
          pickerButton.on("click", () => {
            picker.render(true);
          });
          $(element).parent().append(pickerButton);
        }
      });
  }

  /** @override */
  activateListeners(html) {
    super.activateListeners(html);

    // remove unnecessary elements
    $(html).find("ol.files-list").remove();
    $(html).find("footer div").remove();
    $(html).find("footer button").text("Select Directory");
  }

  static async forgeCreateDirectory(target) {
    if (!target) return undefined;
    const response = await ForgeAPI.call('assets/new-folder', { path: target });
    if (!response || response.error) {
      throw new Error(response ? response.error : "Unknown error while creating directory.");
    }
    return response;
  }

  /**
   * @param  {string} source
   * @param  {string} target
   * @param  {object} options={}
   */
  static async createDirectory(source, target, options = {}) {
    if (!target) {
      throw new Error("No directory name provided");
    }
    if (typeof ForgeVTT !== "undefined" && ForgeVTT?.usingTheForge) {
      return DirectoryPicker.forgeCreateDirectory(target);
    }
    return FilePicker.createDirectory(source, target, options);
  }

  /**
   * Verifies server path exists, and if it doesn't creates it.
   *
   * @param  {object} parsedPath - output from DirectoryPicker,parse
   * @param  {string} targetPath - if set will check this path, else check parsedPath.current
   * @returns {boolean} - true if verfied, false if unable to create/verify
   */
  static async verifyPath(parsedPath, targetPath = null) {
    try {
      const paths = (targetPath) ? targetPath.split("/") : parsedPath.current.split("/");
      let currentSource = paths[0];

      for (let i = 0; i < paths.length; i += 1) {
        try {
          if (currentSource !== paths[i]) {
            currentSource = `${currentSource}/${paths[i]}`;
          }
          // eslint-disable-next-line no-await-in-loop
          await DirectoryPicker.createDirectory(parsedPath.activeSource, `${currentSource}`, { bucket: parsedPath.bucket });

        } catch (err) {
          if (!err.startsWith("EEXIST") && !err.startsWith("The S3 key")) {
            _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].error */ .Z.error(`Error trying to verify path [${parsedPath.activeSource}], ${parsedPath.current}`, err);
            _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].error */ .Z.error("parsedPath", parsedPath);
            _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].error */ .Z.error("targetPath", targetPath);
          }
        }
      }
    } catch (err) {
      return false;
    }

    return true;
  }
}

// this s hooked in, we don't use all the data, so lets stop eslint complaining
// eslint-disable-next-line no-unused-vars
// Hooks.on("renderSettingsConfig", (app, html, user) => {
//   DirectoryPicker.processHtml(html);
// });


/***/ }),

/***/ 2397:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_DirectoryPicker_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4222);
/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5259);
/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(6451);
/* harmony import */ var _DDBProxy_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(546);
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(7669);






const FileHelper = {
  BAD_DIRS: ["[data]", "[data] ", "", null],

  removeFileExtension: (name) => {
    let nameArray = name.split(".");
    nameArray.pop();
    return nameArray.join(".");
  },


  /**
   * Read data from a user provided File object
   * @param {File} file           A File object
   * @return {Promise.<String>}   A Promise which resolves to the loaded text data
   */
  readBlobFromFile: (file) => {
    const reader = new FileReader();
    return new Promise((resolve, reject) => {
      reader.onload = () => {
        resolve(reader.result);
      };
      reader.onerror = () => {
        reader.abort();
        reject();
      };
      reader.readAsBinaryString(file);
    });
  },

  download: (content, fileName, contentType) => {
    let a = document.createElement("a");
    let file = new Blob([content], { type: contentType });
    a.href = URL.createObjectURL(file);
    a.download = fileName;
    a.click();
  },

  fileExistsUpdate: (fileList) => {
    const targetFiles = fileList.filter((f) => !CONFIG.DDBI.KNOWN.FILES.has(f));
    for (const file of targetFiles) {
      CONFIG.DDBI.KNOWN.FILES.add(file);
    }
  },

  generateCurrentFiles: async (directoryPath) => {
    if (!CONFIG.DDBI.KNOWN.CHECKED_DIRS.has(directoryPath)) {
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Checking for files in ${directoryPath}...`);
      const dir = _lib_DirectoryPicker_js__WEBPACK_IMPORTED_MODULE_0__/* .DirectoryPicker.parse */ .B.parse(directoryPath);
      const fileList = await _lib_DirectoryPicker_js__WEBPACK_IMPORTED_MODULE_0__/* .DirectoryPicker.browse */ .B.browse(dir.activeSource, dir.current, {
        bucket: dir.bucket,
      });
      FileHelper.fileExistsUpdate(fileList.files);
      // lets do some forge fun because
      if (typeof ForgeVTT !== "undefined" && ForgeVTT?.usingTheForge) {
        if (fileList.bazaar) {
          // eslint-disable-next-line require-atomic-updates
          CONFIG.DDBI.KNOWN.FORGE.TARGETS[directoryPath] = {};
          fileList.files.forEach((file) => {
            const fileName = file.split("/").pop();
            CONFIG.DDBI.KNOWN.FORGE.TARGETS[directoryPath][fileName] = file;
            CONFIG.DDBI.KNOWN.FILES.add(file);
          });
        } else {
          const status = ForgeAPI.lastStatus || (await ForgeAPI.status());
          const userId = status.user;
          // eslint-disable-next-line require-atomic-updates
          CONFIG.DDBI.KNOWN.FORGE.TARGET_URL_PREFIX[directoryPath] = `https://assets.forge-vtt.com/${userId}/${dir.current}`;
        }
      }

      CONFIG.DDBI.KNOWN.CHECKED_DIRS.add(directoryPath);
    } else {
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Skipping full dir scan for ${directoryPath}...`);
    }
  },

  fileExists: async (directoryPath, filename) => {
    const fileUrl = await FileHelper.getFileUrl(directoryPath, filename);
    let existingFile = CONFIG.DDBI.KNOWN.FILES.has(fileUrl);
    if (existingFile) return true;

    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Checking for ${filename} at ${fileUrl}...`);
    await FileHelper.generateCurrentFiles(directoryPath);

    const filePresent = CONFIG.DDBI.KNOWN.FILES.has(fileUrl);

    if (filePresent) {
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Found ${fileUrl} after directory scan.`);
    } else {
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Could not find ${fileUrl}`, {
        directoryPath,
        filename,
        fileUrl,
      });
    }

    return filePresent;
  },

  convertImageToWebp: async function (file, filename) {
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].info */ .Z.info(`Converting file ${filename} to webp`);

    // Load the data into an image
    const result = new Promise((resolve) => {
      let rawImage = new Image();

      rawImage.addEventListener("load", () => {
        resolve(rawImage);
      });

      rawImage.src = URL.createObjectURL(file);
    })
      .then((rawImage) => {
        // Convert image to webp ObjectURL via a canvas blob
        return new Promise((resolve) => {
          let canvas = document.createElement("canvas");
          let ctx = canvas.getContext("2d");
          const quality = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "webp-quality");

          canvas.width = rawImage.width;
          canvas.height = rawImage.height;
          ctx.drawImage(rawImage, 0, 0);

          canvas.toBlob((blob) => {
            resolve(blob);
          }, "image/webp", quality);
        });
      }).then((blob) => {
        return blob;
      });

    return result;
  },

  uploadFile: async function (data, path, filename, forceWebp = false) {
    const useWebP = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "use-webp");
    const file = new File([data], filename, { type: data.type });
    const imageType = data.type.startsWith("image") && data.type !== "image/webp";
    const uploadFile = useWebP && (imageType || forceWebp)
      ? new File([await FileHelper.convertImageToWebp(file, filename)], filename, { type: "image/webp" })
      : file;

    const result = await _lib_DirectoryPicker_js__WEBPACK_IMPORTED_MODULE_0__/* .DirectoryPicker.uploadToPath */ .B.uploadToPath(path, uploadFile);
    return result;
  },

  uploadImage: async function (data, path, filename, forceWebp = false) {
    return new Promise((resolve, reject) => {
      FileHelper.uploadFile(data, path, filename, forceWebp)
        .then((result) => {
          resolve(result.path);
        })
        .catch((error) => {
          _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].error */ .Z.error("error uploading file: ", error);
          reject(error);
        });
    });
  },

  downloadImage: async function (url) {
    return new Promise((resolve, reject) => {
      fetch(url, {
        method: "GET",
        headers: {
          "x-requested-with": "foundry"
        },
      })
        .then((response) => {
          if (!response.ok) {
            reject("Could not retrieve image");
          }
          return response.blob();
        })
        .then((blob) => resolve(blob))
        .catch((error) => reject(error.message));
    });
  },

  uploadRemoteImage: async function (url, targetDirectory, baseFilename, useProxy = true) {
    // prepare filenames
    const filename = baseFilename;
    const useWebP = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "use-webp");
    const ext = useWebP
      ? "webp"
      : url
        .split(".")
        .pop()
        .split(/#|\?|&/)[0];

    try {
      const proxyEndpoint = _DDBProxy_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].getCORSProxy */ .Z.getCORSProxy();
      const urlEncode = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "cors-encode");
      const target = urlEncode ? encodeURIComponent(url) : url;
      url = useProxy ? proxyEndpoint + target : url;
      const data = await FileHelper.downloadImage(url);
      // hack as proxy returns ddb access denied as application/xml
      if (data.type === "application/xml") return null;
      const result = await FileHelper.uploadImage(data, targetDirectory, filename + "." + ext);
      CONFIG.DDBI.KNOWN.FILES.add(result);
      return result;
    } catch (error) {
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].error */ .Z.error("Image upload error", error);
      ui.notifications.warn(`Image upload failed. Please check your ddb-importer upload folder setting. ${url}`);
      return null;
    }
  },

  getForgeUrl: async (directoryPath, filename) => {
    let uri;
    if (!CONFIG.DDBI.KNOWN.CHECKED_DIRS.has(directoryPath)) {
      await FileHelper.generateCurrentFiles(directoryPath);
    }
    const prefix = CONFIG.DDBI.KNOWN.FORGE.TARGET_URL_PREFIX[directoryPath];
    const bazaarTargetPath = CONFIG.DDBI.KNOWN.FORGE.TARGETS[directoryPath];
    const bazaarTarget = bazaarTargetPath ? bazaarTargetPath[filename] : undefined;
    if (bazaarTarget) {
      uri = bazaarTarget;
    } else if (prefix) {
      uri = `${prefix}/${filename}`;
    } else {
      // we can't find the directory path for some reason, final fallback, try and guess the url
      const dir = _lib_DirectoryPicker_js__WEBPACK_IMPORTED_MODULE_0__/* .DirectoryPicker.parse */ .B.parse(directoryPath);
      if (dir.activeSource == "data") {
        // Local on-server file system
        uri = `https://assets.forge-vtt.com/bazaar/${dir.current}/${filename}`;
      } else if (dir.activeSource == "forgevtt") {
        const status = ForgeAPI.lastStatus || (await ForgeAPI.status());
        const userId = status.user;
        uri = `https://assets.forge-vtt.com/${userId}/${dir.current}/${filename}`;
      }
    }
    return uri;
  },

  getFileUrl: async (directoryPath, filename) => {
    let uri;
    try {
      if (typeof ForgeVTT !== "undefined" && ForgeVTT?.usingTheForge) {
        uri = await FileHelper.getForgeUrl(directoryPath, filename);
        return uri;
      } else {
        const dir = _lib_DirectoryPicker_js__WEBPACK_IMPORTED_MODULE_0__/* .DirectoryPicker.parse */ .B.parse(directoryPath);
        if (dir.activeSource == "data") {
          // Local on-server file system
          uri = dir.current + "/" + filename;
        } else if (dir.activeSource == "forgevtt") {
          const status = ForgeAPI.lastStatus || (await ForgeAPI.status());
          const userId = status.user;
          uri = `https://assets.forge-vtt.com/${userId}/${dir.current}/${filename}`;
        } else if (dir.activeSource == "s3") {
          // S3 Bucket
          uri = `https://${dir.bucket}.${game.data.files.s3.endpoint.hostname}/${dir.current}/${filename}`;
        } else {
          _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].error */ .Z.error("DDB Importer cannot handle files stored in that location", dir);
        }
      }
    } catch (exception) {
      throw new Error(
        'Unable to determine file URL for directoryPath"' + directoryPath + '" and filename"' + filename + '"'
      );
    }
    return encodeURI(uri);
  },

  // const options = { type: "frame", name: `DDB ${frame.name}`, download: true, remoteImages: false, force: false };
  getImagePath: async (imageUrl, { type = "ddb", name = "", download = false, remoteImages = false, force = false } = {}) => {
    const frameDirectory = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "frame-image-upload-directory").replace(/^\/|\/$/g, "");
    const otherDirectory = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "other-image-upload-directory").replace(/^\/|\/$/g, "");
    const uploadDirectory = type === "frame" ? frameDirectory : otherDirectory;
    const downloadImage = (download) ? download : game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-download-images");
    const remoteImage = (remoteImages) ? remoteImages : game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-remote-images");
    const useWebP = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "use-webp");

    if (imageUrl && downloadImage) {
      const ext = useWebP
        ? "webp"
        : imageUrl.split(".").pop().split(/#|\?|&/)[0];
      if (!name) name = imageUrl.split("/").pop();

      // image upload
      const filename = type + "-" + _utils_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].referenceNameString */ .Z.referenceNameString(name);
      const imageExists = await FileHelper.fileExists(uploadDirectory, filename + "." + ext);

      if (imageExists && !force) {
        // eslint-disable-next-line require-atomic-updates
        const image = await FileHelper.getFileUrl(uploadDirectory, filename + "." + ext);
        return image.trim();
      } else {
        // eslint-disable-next-line require-atomic-updates
        const image = await FileHelper.uploadRemoteImage(imageUrl, uploadDirectory, filename);
        // did upload succeed? if not fall back to remote image path
        if (image) {
          return image.trim();
        } else {
          return null;
        }

      }
    } else if (imageUrl && remoteImage) {
      try {
        return imageUrl.trim();
      } catch (ignored) {
        return null;
      }
    }
    return null;
  },

};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FileHelper);


/***/ }),

/***/ 8636:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _muncher_DDBMuncher_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1475);
/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6451);
/* harmony import */ var _DDBProxy_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(546);




const PatreonHelper = {

  getPatreonTier: async () => {
    if (_DDBProxy_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].isCustom */ .Z.isCustom()) return { success: true, message: "custom proxy", data: "CUSTOM" };
    const key = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "beta-key");
    const parsingApi = _DDBProxy_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].getProxy */ .Z.getProxy();
    const body = { betaKey: key };

    return new Promise((resolve, reject) => {
      fetch(`${parsingApi}/patreon/tier`, {
        method: "POST",
        mode: "cors",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(body),
      })
        .then((response) => response.json())
        .then((data) => {
          if (!data.success) {
            _muncher_DDBMuncher_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].munchNote */ .Z.munchNote(`API Failure: ${data.message}`);
            reject(data.message);
          }
          let currentEmail = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "patreon-user");
          if (data.email !== currentEmail) {
            game.settings.set("ddb-importer", "patreon-user", data.email).then(() => {
              resolve(data.data);
            });
          } else {
            resolve(data.data);
          }
        })
        .catch((error) => reject(error));
    });
  },

  getPatreonValidity: async (betaKey) => {
    if (_DDBProxy_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].isCustom */ .Z.isCustom()) return { success: true, message: "custom proxy", data: true };
    const parsingApi = _DDBProxy_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].getProxy */ .Z.getProxy();
    const body = { betaKey: betaKey };

    return new Promise((resolve, reject) => {
      fetch(`${parsingApi}/patreon/valid`, {
        method: "POST",
        mode: "cors",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(body), // body data type must match "Content-Type" header
      })
        .then((response) => response.json())
        .then((data) => {
          resolve(data);
        })
        .catch((error) => reject(error));
    });
  },

  getPatreonTiers: (tier) => {
    const godTier = tier === "GOD";
    const undyingTier = tier === "UNDYING";
    const coffeeTier = tier === "COFFEE";
    const custom = tier === "CUSTOM" || _DDBProxy_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].isCustom */ .Z.isCustom();

    const tiers = {
      god: godTier,
      undying: undyingTier,
      custom: custom,
      coffee: coffeeTier,
      source: godTier || undyingTier || coffeeTier || custom,
      experimentalMid: godTier || undyingTier,
      homebrew: godTier || undyingTier || coffeeTier || custom,
      all: godTier || undyingTier || coffeeTier || custom,
      supporter: godTier || undyingTier || coffeeTier,
      not: !godTier && !undyingTier && !coffeeTier && !custom,
    };

    return tiers;
  },

  checkPatreon: async () => {
    const tier = await PatreonHelper.getPatreonTier();
    const tiers = PatreonHelper.getPatreonTiers(tier);
    return tiers;
  },

  setPatreonTier: async () => {
    const tier = await PatreonHelper.getPatreonTier();
    game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "patreon-tier", tier);
  },

};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PatreonHelper);


/***/ }),

/***/ 2048:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "B": () => (/* binding */ checkCobalt),
/* harmony export */   "HF": () => (/* binding */ getCobalt),
/* harmony export */   "Mi": () => (/* binding */ isLocalCobalt),
/* harmony export */   "Nr": () => (/* binding */ moveCobaltToLocal),
/* harmony export */   "Tl": () => (/* binding */ deleteLocalCobalt),
/* harmony export */   "hc": () => (/* binding */ setCobalt),
/* harmony export */   "pC": () => (/* binding */ moveCobaltToSettings)
/* harmony export */ });
/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5259);
/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6451);
/* harmony import */ var _DDBProxy_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(546);




function isJSON(str) {
  try {
    return (JSON.parse(str) && !!str && str !== null);
  } catch (e) {
    return false;
  }
}

function isLocalCobalt(keyPostfix) {
  return keyPostfix && keyPostfix !== "" && localStorage.getItem(`ddb-cobalt-cookie-${keyPostfix}`) !== null;
}

function getCobalt(keyPostfix = "") {
  let cobalt;
  const localCookie = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "cobalt-cookie-local");
  const characterCookie = isLocalCobalt(keyPostfix);

  _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug(`Getting Cookie: Key postfix? "${keyPostfix}" -  Local? ${localCookie} - Character? ${characterCookie}`);
  if (characterCookie) {
    cobalt = localStorage.getItem(`ddb-cobalt-cookie-${keyPostfix}`);
  } else if (localCookie) {
    cobalt = localStorage.getItem("ddb-cobalt-cookie");
  } else {
    cobalt = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "cobalt-cookie");
  }

  return cobalt;
}

async function setCobalt(value, keyPostfix = "") {
  const localCookie = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "cobalt-cookie-local");
  const characterCookie = keyPostfix && keyPostfix !== "";

  let cobaltValue = value;
  if (isJSON(value)) {
    cobaltValue = JSON.parse(value).cbt;
  }

  _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug(`Setting Cookie: Key postfix? "${keyPostfix}" -  Local? ${localCookie} - Character? ${characterCookie}`);
  if (characterCookie) {
    localStorage.setItem(`ddb-cobalt-cookie-${keyPostfix}`, cobaltValue);
  } else if (localCookie) {
    localStorage.setItem("ddb-cobalt-cookie", cobaltValue);
  } else {
    await game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "cobalt-cookie", cobaltValue);
  }
}

function deleteLocalCobalt(keyPostfix) {
  const localCookie = isLocalCobalt(keyPostfix);

  if (localCookie) {
    localStorage.removeItem(`ddb-cobalt-cookie-${keyPostfix}`);
  }
}

async function moveCobaltToLocal() {
  localStorage.setItem('ddb-cobalt-cookie', game.settings.get("ddb-importer", "cobalt-cookie"));
  await game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "cobalt-cookie", "");
  game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "cobalt-cookie-local", true);
}

async function moveCobaltToSettings() {
  game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "cobalt-cookie", localStorage.getItem('ddb-cobalt-cookie'));
  game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "cobalt-cookie-local", false);
}

async function checkCobalt(keyPostfix = "", alternativeKey = null) {
  const cobaltCookie = alternativeKey
    ? isJSON(alternativeKey)
      ? JSON.parse(alternativeKey).cbt
      : alternativeKey
    : getCobalt(keyPostfix);
  const parsingApi = _DDBProxy_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].getProxy */ .Z.getProxy();
  const betaKey = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "beta-key");
  const body = { cobalt: cobaltCookie, betaKey: betaKey };

  return new Promise((resolve, reject) => {
    fetch(`${parsingApi}/proxy/auth`, {
      method: "POST",
      cache: "no-cache",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(body),
    })
      .then((response) => response.json())
      .then((data) => resolve(data))
      .catch((error) => {
        _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].error */ .Z.error(`Cobalt cookie check error`);
        _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].error */ .Z.error(error);
        _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].error */ .Z.error(error.stack);
        reject(error);
      });
  });
}


/***/ }),

/***/ 5406:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Bp": () => (/* binding */ DDBCookie),
/* harmony export */   "F9": () => (/* binding */ getCampaignId),
/* harmony export */   "HI": () => (/* binding */ DDBLocationSetup),
/* harmony export */   "L0": () => (/* binding */ DDBCompendiumSetup),
/* harmony export */   "Vj": () => (/* binding */ isValidKey),
/* harmony export */   "lR": () => (/* binding */ DDBSetup),
/* harmony export */   "pV": () => (/* binding */ isSetupComplete),
/* harmony export */   "s1": () => (/* binding */ getAvailableCampaigns),
/* harmony export */   "wW": () => (/* binding */ DDBDynamicUpdateSetup)
/* harmony export */ });
/* unused harmony export DDBKeyChange */
/* harmony import */ var _DirectoryPicker_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4222);
/* harmony import */ var _lib_PatreonHelper_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8636);
/* harmony import */ var _muncher_DDBMuncher_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1475);
/* harmony import */ var _Secrets_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(2048);
/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(5259);
/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(6451);
/* harmony import */ var _lib_FileHelper_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(2397);
/* harmony import */ var _DDBProxy_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(546);









const POPUPS = {
  json: null,
  web: null,
};

function getCampaignId() {
  const campaignId = game.settings.get("ddb-importer", "campaign-id").split("/").pop();

  if (campaignId && campaignId !== "" && !Number.isInteger(parseInt(campaignId))) {
    _muncher_DDBMuncher_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].munchNote */ .Z.munchNote(`Campaign Id is invalid! Set to "${campaignId}", using empty string`, true);
    _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].error */ .Z.error(`Campaign Id is invalid! Set to "${campaignId}", using empty string`);
    return "";
  } else if (campaignId.includes("join")) {
    _muncher_DDBMuncher_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].munchNote */ .Z.munchNote(`Campaign URL is a join campaign link, using empty string! Set to "${campaignId}"`, true);
    _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].error */ .Z.error(`Campaign URL is a join campaign link, using empty string! Set to "${campaignId}"`);
    return "";
  }
  return campaignId;
}


function renderPopup(type, url) {
  if (POPUPS[type] && !POPUPS[type].close) {
    POPUPS[type].focus();
    POPUPS[type].location.href = url;
  } else {
    const ratio = window.innerWidth / window.innerHeight;
    const width = Math.round(window.innerWidth * 0.5);
    const height = Math.round(window.innerWidth * 0.5 * ratio);
    POPUPS[type] = window.open(
      url,
      "ddb_sheet_popup",
      `resizeable,scrollbars,location=no,width=${width},height=${height},toolbar=1`
    );
  }
  return true;
}

function isSetupComplete(needsCobalt = true) {
  const uploadDir = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "image-upload-directory");
  const dataDirSet = !_lib_FileHelper_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].BAD_DIRS.includes */ .Z.BAD_DIRS.includes(uploadDir);
  const cobalt = (0,_Secrets_js__WEBPACK_IMPORTED_MODULE_3__/* .getCobalt */ .HF)() != "";
  const setupComplete = dataDirSet && (cobalt || !needsCobalt);
  return setupComplete;
}

async function linkToPatreon() {

  const proxy = _DDBProxy_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"].getProxy */ .Z.getProxy();
  const patreonId = "oXQUxnRAbV6mq2DXlsXY2uDYQpU-Ea2ds0G_5hIdi0Bou33ZRJgvV8Ub3zsEQcHp";
  const patreonAuthUrl = `${proxy}/patreon/auth`;
  const patreonScopes = encodeURI("identity identity[email]");

  const socketOptions = {
    transports: ['websocket', 'polling', 'flashsocket'],
    // reconnection: false,
    // reconnectionAttempts: 10,
  };
  const socket = io(`${proxy}/`, socketOptions);

  socket.on("connect", () => {
    _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].debug */ .Z.debug("DDB Muncher socketID", socket.id);
    const serverDetails = {
      id: socket.id,
      world: game.world.title,
      userId: game.userId,
    };
    socket.emit("register", serverDetails);

  });

  socket.on('registered', (data) => {
    _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].info */ .Z.info(`Foundry instance registered with DDB Muncher Proxy`);
    _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].debug */ .Z.debug(data);
    renderPopup("web", `https://www.patreon.com/oauth2/authorize?response_type=code&client_id=${patreonId}&redirect_uri=${patreonAuthUrl}&state=${data.userHash}&scope=${patreonScopes}`);
  });

  socket.on('auth', (data) => {
    _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].debug */ .Z.debug(`Response from auth socket!`, data);

    POPUPS["web"].close();

    game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "beta-key", data.key);
    game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "patreon-user", data.email);
    game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "patreon-tier", data.tier);

    $('#ddb-patreon-user').text(data.email);
    $('#ddb-patreon-tier').text(data.tier);
    $('#ddb-patreon-valid').text("True");
    $('#ddb-beta-key').val(data.key);

    socket.disconnect();
  });

  socket.on('error', (data) => {
    _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].error */ .Z.error(`Error Response from socket!`, data);
    socket.disconnect();
  });
}

function getDDBCampaigns(cobalt = null) {
  const cobaltCookie = cobalt ? cobalt : (0,_Secrets_js__WEBPACK_IMPORTED_MODULE_3__/* .getCobalt */ .HF)();
  const parsingApi = _DDBProxy_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"].getProxy */ .Z.getProxy();
  const betaKey = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "beta-key");
  const body = { cobalt: cobaltCookie, betaKey: betaKey };

  return new Promise((resolve, reject) => {
    fetch(`${parsingApi}/proxy/campaigns`, {
      method: "POST",
      cache: "no-cache",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(body), // body data type must match "Content-Type" header
    })
      .then((response) => response.json())
      .then((data) => resolve(data.data))
      .catch((error) => {
        _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].error */ .Z.error(`Cobalt cookie check error`);
        _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].error */ .Z.error(error);
        _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].error */ .Z.error(error.stack);
        reject(error);
      });
  });

}

async function checkCobaltCookie(value) {
  const cookieStatus = await (0,_Secrets_js__WEBPACK_IMPORTED_MODULE_3__/* .checkCobalt */ .B)("", value);
  if (value !== "" && !cookieStatus.success) {
    $('#munching-task-setup').text(`Your Cobalt Cookie is invalid, please check that you pasted the right information.`);
    $('#ddb-importer-settings').css("height", "auto");
    throw new Error(`Your Cobalt Cookie is invalid, please check that you pasted the right information.`);
  }
  return cookieStatus;
}

async function refreshCampaigns(cobalt = null) {
  await checkCobaltCookie(cobalt);
  CONFIG.DDBI.CAMPAIGNS = await getDDBCampaigns(cobalt);
  return CONFIG.DDBI.CAMPAIGNS;
}

async function getAvailableCampaigns() {
  if (CONFIG.DDBI.CAMPAIGNS) return CONFIG.DDBI.CAMPAIGNS;
  const campaignId = getCampaignId();
  // eslint-disable-next-line require-atomic-updates
  CONFIG.DDBI.CAMPAIGNS = await getDDBCampaigns();

  if (!CONFIG.DDBI.CAMPAIGNS) return [];

  CONFIG.DDBI.CAMPAIGNS.forEach((campaign) => {
    const selected = campaign.id == campaignId;
    campaign.selected = selected;
  });
  return CONFIG.DDBI.CAMPAIGNS;
}

async function setCobaltCookie(value, local) {
  await checkCobaltCookie(value);
  await (0,_Secrets_js__WEBPACK_IMPORTED_MODULE_3__/* .setCobalt */ .hc)(value);
  await game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "cobalt-cookie-local", local);
  const runCookieMigrate = local != game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "cobalt-cookie-local");
  if (runCookieMigrate && local) {
    (0,_Secrets_js__WEBPACK_IMPORTED_MODULE_3__/* .moveCobaltToLocal */ .Nr)();
  } else if (runCookieMigrate && !local) {
    (0,_Secrets_js__WEBPACK_IMPORTED_MODULE_3__/* .moveCobaltToSettings */ .pC)();
  }

}

class DDBKeyChange extends FormApplication {
  static get defaultOptions() {
    const options = super.defaultOptions;
    options.id = "ddb-importer-key-change";
    options.template = "modules/ddb-importer/handlebars/key-change.hbs";
    options.width = 500;
    return options;
  }

  get title() { // eslint-disable-line class-methods-use-this
    // improve localisation
    // game.i18n.localize("")
    return "DDB Importer Key Expiry";
  }

  activateListeners(html) {
    super.activateListeners(html);
    html.find("#patreon-button").click(async (event) => {
      event.preventDefault();
      linkToPatreon();
    });
  }

  /** @override */
  async getData() { // eslint-disable-line class-methods-use-this
    const key = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "beta-key");
    const setupConfig = {
      "beta-key": key,
    };
    const patreonUser = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "patreon-user");
    const check = await _lib_PatreonHelper_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].getPatreonValidity */ .Z.getPatreonValidity(key);

    return {
      success: (check && check.success) ? check.success : false,
      message: (check && check.message) ? check.message : "Unable to check patreon key status",
      setupConfig: setupConfig,
      patreonLinked: patreonUser && patreonUser != "",
      patreonUser: patreonUser,
    };
  }

  /** @override */
  // eslint-disable-next-line no-unused-vars
  async _updateObject(event, formData) { // eslint-disable-line class-methods-use-this
    event.preventDefault();
    const currentKey = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "beta-key");
    if (currentKey !== formData['beta-key']) {
      await game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "beta-key", formData['beta-key']);
      await _lib_PatreonHelper_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].setPatreonTier */ .Z.setPatreonTier();
    }

    const callMuncher = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "settings-call-muncher");

    if (callMuncher) {
      game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "settings-call-muncher", false);
      new _muncher_DDBMuncher_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z().render(true);
    }

  }
}

async function isValidKey() {
  let validKey = false;

  const key = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "beta-key");
  if (key === "") {
    validKey = true;
  } else {
    const check = await _lib_PatreonHelper_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].getPatreonValidity */ .Z.getPatreonValidity(key);
    if (check.success && check.data) {
      validKey = true;
    } else {
      validKey = false;
      game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "settings-call-muncher", true);
      new DDBKeyChange().render(true);
    }
  }
  return validKey;
}

class DDBCookie extends FormApplication {

  constructor(options, actor = null, localCobalt = false) {
    super(options);
    this.localCobalt = localCobalt;
    this.actor = actor;
  }

  static get defaultOptions() {
    const options = super.defaultOptions;
    options.id = "ddb-importer-cobalt-change";
    options.template = "modules/ddb-importer/handlebars/cobalt.hbs";
    options.width = 500;
    return options;
  }

  get title() { // eslint-disable-line class-methods-use-this
    // improve localisation
    // game.i18n.localize("")
    return "DDB Importer Cobalt Cookie";
  }

  /** @override */
  async getData() {
    const keyPostFix = this.localCobalt && this.actor ? this.actor.id : null;
    const cobalt = (0,_Secrets_js__WEBPACK_IMPORTED_MODULE_3__/* .getCobalt */ .HF)(keyPostFix);
    const cobaltStatus = cobalt == "" ? { success: true } : await (0,_Secrets_js__WEBPACK_IMPORTED_MODULE_3__/* .checkCobalt */ .B)();
    const expired = !cobaltStatus.success;

    return {
      expired: expired,
      cobaltCookie: cobalt,
      localCobalt: this.localCobalt && this.actor,
      actor: this.actor,
    };
  }

  /** @override */
  async _updateObject(event, formData) {
    event.preventDefault();
    const keyPostFix = this.localCobalt && this.actor ? this.actor.id : null;
    await (0,_Secrets_js__WEBPACK_IMPORTED_MODULE_3__/* .setCobalt */ .hc)(formData['cobalt-cookie'], keyPostFix);

    const cobaltStatus = await (0,_Secrets_js__WEBPACK_IMPORTED_MODULE_3__/* .checkCobalt */ .B)();
    if (!cobaltStatus.success) {
      new DDBCookie().render(true);
    } else {
      const callMuncher = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "settings-call-muncher");

      if (callMuncher) {
        game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "settings-call-muncher", false);
        new _muncher_DDBMuncher_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z().render(true);
      }
    }
  }
}


// eslint-disable-next-line no-unused-vars
Hooks.on("renderma", (app, html, user) => {
  _DirectoryPicker_js__WEBPACK_IMPORTED_MODULE_0__/* .DirectoryPicker.processHtml */ .B.processHtml(html);
});

class DDBSetup extends FormApplication {
  static get defaultOptions() {
    const options = super.defaultOptions;
    options.id = "ddb-importer-settings";
    options.template = "modules/ddb-importer/handlebars/settings.hbs";
    options.width = 500;
    return options;
  }

  get title() { // eslint-disable-line class-methods-use-this
    // improve localisation
    // game.i18n.localize("")
    return "DDB Importer Settings";
  }

  /** @override */
  async getData() { // eslint-disable-line class-methods-use-this
    const cobalt = (0,_Secrets_js__WEBPACK_IMPORTED_MODULE_3__/* .getCobalt */ .HF)();
    const isCobalt = cobalt != "";
    const cobaltStatus = await (0,_Secrets_js__WEBPACK_IMPORTED_MODULE_3__/* .checkCobalt */ .B)("", cobalt);
    const cobaltLocal = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "cobalt-cookie-local");
    const hasKey = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "beta-key") != "";
    const key = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "beta-key");
    const campaignId = getCampaignId();
    const tier = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "patreon-tier");
    const patreonUser = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "patreon-user");
    const validKeyObject = hasKey ? await _lib_PatreonHelper_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].getPatreonValidity */ .Z.getPatreonValidity(key) : false;
    const validKey = validKeyObject && validKeyObject.success && validKeyObject.data;
    const availableCampaigns = isCobalt && cobaltStatus.success ? await getAvailableCampaigns() : [];

    availableCampaigns.forEach((campaign) => {
      const selected = campaign.id == campaignId;
      campaign.selected = selected;
    });

    const setupConfig = {
      "cobalt-cookie": cobalt,
      "available-campaigns": availableCampaigns,
      "campaign-id": campaignId,
      "beta-key": key,
    };

    const setupComplete = isCobalt;

    return {
      cobalt: isCobalt,
      cobaltLocal,
      setupConfig,
      setupComplete,
      tier,
      patreonLinked: patreonUser && patreonUser != "",
      patreonUser,
      validKey,
    };
  }

  activateListeners(html) {
    super.activateListeners(html);
    html.find("#patreon-button").click(async (event) => {
      event.preventDefault();
      linkToPatreon();
    });
    html.find("#campaign-button").click(async (event) => {
      event.preventDefault();
      const cookie = html.find("#cobalt-cookie-input");
      const campaigns = await refreshCampaigns(cookie[0].value);
      let campaignList = `<option value="">Select campaign:</option>`;
      if (Array.isArray(campaigns)) {
        campaigns.forEach((campaign) => {
          campaignList += `<option value="${campaign.id}">${campaign.name} (${campaign.dmUsername}) - ${campaign.id}</option>\n`;
        });
      } else {
        _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].warn */ .Z.warn("Unable to fetch campaigns", campaigns);
      }
      const list = html.find("#campaign-select");
      list[0].innerHTML = campaignList;
    });
    html.find("#check-cobalt-button").click(async (event) => {
      event.preventDefault();
      const cookie = html.find("#cobalt-cookie-input");
      if (cookie[0].value === undefined) throw new Error("undefined");
      const cobaltStatus = await (0,_Secrets_js__WEBPACK_IMPORTED_MODULE_3__/* .checkCobalt */ .B)("", cookie[0].value);
      const button = html.find("#check-cobalt-button");
      if (cobaltStatus.success) {
        button[0].innerHTML = "Check Cobalt Cookie - Success!";
      } else {
        button[0].innerHTML = "Check Cobalt Cookie - Failure!";
      }
    });


  }

  /** @override */
  async _updateObject(event, formData) { // eslint-disable-line class-methods-use-this
    event.preventDefault();
    const campaignSelect = formData['campaign-select'];
    const campaignId = campaignSelect == 0 ? "" : campaignSelect;
    const cobaltCookie = formData['cobalt-cookie'];
    const cobaltCookieLocal = formData['cobalt-cookie-local'];
    const currentKey = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "beta-key");

    if (currentKey !== formData['beta-key']) {
      await game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "beta-key", formData['beta-key']);
      await _lib_PatreonHelper_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].setPatreonTier */ .Z.setPatreonTier();
    }

    await game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "campaign-id", campaignId);
    await setCobaltCookie(cobaltCookie, cobaltCookieLocal);

    const callMuncher = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "settings-call-muncher");

    if (callMuncher && cobaltCookie === "") {
      $('#munching-task-setup').text(`To use Muncher you need to set a Cobalt Cookie value!`);
      $('#ddb-importer-settings').css("height", "auto");
      throw new Error(`To use Muncher you need to set a Cobalt Cookie value!`);
    } else if (callMuncher) {
      game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "settings-call-muncher", false);
      new _muncher_DDBMuncher_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z().render(true);
    }
  }
}

function getCompendiumLookups(type, selected) {
  const excludedCompendiumPackages = [
    "dnd5e", "dae", "midiqol", "magicitems", "midi-srd", "dae-srd", "midi-qol",
  ];

  const selections = game.packs
    .filter((pack) =>
      pack.documentName === type
    && !excludedCompendiumPackages.includes(pack.metadata.packageName)
    )
    .reduce((choices, pack) => {
      choices[pack.collection] = {
        label: `[${pack.metadata.packageName}] ${pack.metadata.label}`,
        selected: pack.collection === selected,
      };
      return choices;
    }, {});

  return selections;
}


class DDBCompendiumSetup extends FormApplication {
  static get defaultOptions() {
    const options = super.defaultOptions;
    options.id = "ddb-importer-settings-compendium";
    options.template = "modules/ddb-importer/handlebars/compendium.hbs";
    options.width = 500;
    return options;
  }

  get title() { // eslint-disable-line class-methods-use-this
    // improve localisation
    // game.i18n.localize("")
    return "DDB Importer Compendium Settings";
  }

  /** @override */
  async getData() { // eslint-disable-line class-methods-use-this
    const settings = [
      {
        name: "auto-create-compendium",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "auto-create-compendium"),
        description: "Create default compendiums if missing?",
        enabled: true,
      },
    ];

    const compendiums = _settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].COMPENDIUMS.map */ .Z.COMPENDIUMS.map((comp) => ({
      setting: comp.setting,
      name: comp.title,
      current: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, comp.setting),
      compendiums: getCompendiumLookups(comp.type, game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, comp.setting)),
    }));

    return {
      settings,
      compendiums,
    };
  }

  /** @override */
  // eslint-disable-next-line no-unused-vars
  async _updateObject(event, formData) { // eslint-disable-line class-methods-use-this
    event.preventDefault();
    for (const [key, value] of Object.entries(formData)) {
      game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, key, value);
    }
  }
}


function getGMUsers() {
  const updateUser = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "dynamic-sync-user");

  const gmUsers = game.users
    .filter((user) => user.isGM)
    .reduce((choices, user) => {
      choices.push({
        userId: user.id,
        userName: user.name,
        selected: user.id === updateUser,
      });
      return choices;
    }, []);

  return gmUsers;
}


class DDBDynamicUpdateSetup extends FormApplication {
  static get defaultOptions() {
    const options = super.defaultOptions;
    options.id = "ddb-importer-settings-dynamic-updates";
    options.template = "modules/ddb-importer/handlebars/dynamic-updates.hbs";
    options.width = 500;
    return options;
  }

  get title() { // eslint-disable-line class-methods-use-this
    // improve localisation
    // game.i18n.localize("")
    return "DDB Importer Dynamic Update Settings";
  }

  /** @override */
  async getData() { // eslint-disable-line class-methods-use-this
    const tier = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "patreon-tier");
    const tiers = _lib_PatreonHelper_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].getPatreonTiers */ .Z.getPatreonTiers(tier);
    const enabled = tiers.experimentalMid;

    const policySettings = Object.keys(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].DEFAULT_SETTINGS.READY.CHARACTER.DYNAMIC_SYNC */ .Z.DEFAULT_SETTINGS.READY.CHARACTER.DYNAMIC_SYNC)
      .map((key) => {
        return {
          name: key,
          isChecked: enabled && game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, key),
          description: game.i18n.localize(`${_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID}.settings.dynamic-sync.${key}`),
          enabled,
        };
      });
    const settings = [
      {
        name: "dynamic-sync",
        isChecked: enabled && game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "dynamic-sync"),
        description: game.i18n.localize(`${_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID}.settings.dynamic-sync.dynamic-sync`),
        enabled,
      },
    ].concat(policySettings);
    const gmUsers = getGMUsers();

    return {
      settings,
      gmUsers,
    };
  }

  /** @override */
  // eslint-disable-next-line class-methods-use-this
  async _updateObject(event, formData) {
    event.preventDefault();
    const initial = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "dynamic-sync");
    for (const [key, value] of Object.entries(formData)) {
      // eslint-disable-next-line no-await-in-loop
      await game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, key, value);
    }
    const post = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "dynamic-sync");

    if (initial != post) {
      _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].warn */ .Z.warn("RELOADING!");
      foundry.utils.debounce(window.location.reload(), 100);
    }
  }
}

class DDBLocationSetup extends FormApplication {
  static get defaultOptions() {
    const options = super.defaultOptions;
    options.id = "ddb-importer-folders";
    options.template = "modules/ddb-importer/handlebars/filePaths.hbs";
    options.width = 500;
    return options;
  }

  get title() { // eslint-disable-line class-methods-use-this
    // improve localisation
    // game.i18n.localize("")
    return "DDB Importer Location Settings";
  }

  // in foundry v10 we no longer get read only form elements back
  /** @override */
  _getSubmitData(updateData = {}) {
    let data = super._getSubmitData(updateData);

    for (const element of this.form.elements) {
      if (element.readOnly) {
        const name = element.name;
        const field = this.form.elements[name];
        setProperty(data, name, field.value);
      }
    }

    return data;
  }

  /** @override */
  async getData() { // eslint-disable-line class-methods-use-this
    const useWebP = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "use-webp");
    const directories = [];

    for (const [key, value] of Object.entries(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].DEFAULT_SETTINGS.READY.DIRECTORIES */ .Z.DEFAULT_SETTINGS.READY.DIRECTORIES)) {
      directories.push({
        key,
        value: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, key),
        name: game.i18n.localize(value.name),
        description: game.i18n.localize(value.hint),
      });
    }

    return {
      directories,
      useWebP,
    };
  }

  /** @override */
  async _updateObject(event, formData) { // eslint-disable-line class-methods-use-this
    event.preventDefault();

    const useWebP = formData['image-use-webp'];

    await game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "use-webp", useWebP);

    const directoryStatus = [];

    for (const key of Object.keys(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].DEFAULT_SETTINGS.READY.DIRECTORIES */ .Z.DEFAULT_SETTINGS.READY.DIRECTORIES)) {
      const value = formData[key];
      // eslint-disable-next-line no-await-in-loop
      await game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, key, value);
      directoryStatus.push({
        key,
        value,
        isBad: _lib_FileHelper_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].BAD_DIRS.includes */ .Z.BAD_DIRS.includes(value),
        // eslint-disable-next-line no-await-in-loop
        isValid: await _DirectoryPicker_js__WEBPACK_IMPORTED_MODULE_0__/* .DirectoryPicker.verifyPath */ .B.verifyPath(_DirectoryPicker_js__WEBPACK_IMPORTED_MODULE_0__/* .DirectoryPicker.parse */ .B.parse(value)),
      });
    }

    if (directoryStatus.some((dir) => dir.isBad)) {
      $('#munching-folder-setup').text(`Please set the image upload directory(s) to something other than the root.`);
      $('#ddb-importer-folders').css("height", "auto");
      _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].error */ .Z.error("Error setting Image directory", {
        directoryStatus,
      });
      throw new Error(`Please set the image upload directory to something other than the root.`);
    } else if (directoryStatus.some((dir) => !dir.isValid)) {
      $('#munching-folder-setup').text(`Directory Validation Failed.`);
      $('#ddb-importer-folders').css("height", "auto");
      _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].error */ .Z.error("Error validating Image directory", {
        directoryStatus,
      });
      throw new Error(`Directory Validation Failed.`);
    }
  }
}

// eslint-disable-next-line no-unused-vars
Hooks.on("renderDDBLocationSetup", (app, html, user) => {
  _DirectoryPicker_js__WEBPACK_IMPORTED_MODULE_0__/* .DirectoryPicker.processHtml */ .B.processHtml(html);
});


/***/ }),

/***/ 9460:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "g": () => (/* binding */ base64Check)
/* harmony export */ });
/* unused harmony export checkScenes */
/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5259);


function occurrences(string, subString, allowOverlapping) {
  string += "";
  subString += "";
  if (subString.length <= 0) return (string.length + 1);

  let n = 0,
    pos = 0,
    step = allowOverlapping ? 1 : subString.length;

  // eslint-disable-next-line no-constant-condition
  while (true) {
    pos = string.indexOf(subString, pos);
    if (pos >= 0) {
      ++n;
      pos += step;
    } else break;
  }
  return n;
}

function checkBase64(string) {
  let count = occurrences(JSON.stringify(string), "base64");

  return count > 0;
}

function checkScenes() {
  let fixedScenes = [];
  let badScenes = [];
  game.scenes.forEach((scene) => {
    if (checkBase64(scene.thumb)) {
      _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].warn */ .Z.warn(`Scene ${scene.name} has base 64 thumb data - fixing!`);
      scene.createThumbnail().then((data) => {
        scene.update({ thumb: data.thumb }, { diff: false });
        ui.notifications.info(`Regenerated thumbnail image for ${scene.name} background image`);
      });
      fixedScenes.push(scene.name);
    }
    if (checkBase64(scene.img)) {
      _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].warn */ .Z.warn(`Scene ${scene.name} has base 64 Image data!`);
      ui.notifications.warn(`${scene.name} has a base64 encoded scene image - please fix`);
      badScenes.push(scene.name);
    } else if (checkBase64(scene) && !checkBase64(scene.thumb)) {
      _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].warn */ .Z.warn(`Scene ${scene.name} has unknown location base 64 data!`);
      _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].warn */ .Z.warn(scene);
      badScenes.push(scene.name);
    }
  });
  if (badScenes.length > 0) _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].warn */ .Z.warn("Please fix the following scenes with base64 data:", badScenes);
  return {
    fixedScenes,
    badScenes,
  };
}

function base64Check() {
  return checkScenes();
}


/***/ }),

/***/ 3716:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "r": () => (/* binding */ generateIcon)
/* harmony export */ });
/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5259);
/* harmony import */ var _muncher_adventure_AdventureMunchHelpers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7801);



const STUBS = {
  1: `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" style="shape-rendering:geometricPrecision; text-rendering:geometricPrecision; image-rendering:optimizeQuality; fill-rule:evenodd; clip-rule:evenodd"
  viewBox="0 0 512 512" width="512" height="512">
    <g>
      <circle style="fill:#ffffff;stroke:#010101;stroke-width:30;stroke-miterlimit:10;" cx="250" cy="250" r="220">
      </circle>
      <text font-family='-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"' font-size="300" font-weight="400" fill="black" x="50%" y="52%" text-anchor="middle" stroke="#000000" dy=".3em">REPLACEME</text>
    </g>
  </svg>`,
  2: `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" style="shape-rendering:geometricPrecision; text-rendering:geometricPrecision; image-rendering:optimizeQuality; fill-rule:evenodd; clip-rule:evenodd"
  viewBox="0 0 512 512" width="512" height="512">
    <g>
      <circle style="fill:#ffffff;stroke:#010101;stroke-width:30;stroke-miterlimit:10;" cx="250" cy="250" r="220">
      </circle>
      <text font-family='-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"' font-size="230" font-weight="400" fill="black" x="50%" y="52%" text-anchor="middle" stroke="#000000" dy=".3em">REPLACEME</text>
    </g>
  </svg>`,
  3: `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" style="shape-rendering:geometricPrecision; text-rendering:geometricPrecision; image-rendering:optimizeQuality; fill-rule:evenodd; clip-rule:evenodd"
  viewBox="0 0 512 512" width="512" height="512">
    <g>
      <circle style="fill:#ffffff;stroke:#010101;stroke-width:30;stroke-miterlimit:10;" cx="250" cy="250" r="220">
      </circle>
      <text font-family='-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"' font-size="170" font-weight="400" fill="black" x="50%" y="52%" text-anchor="middle" stroke="#000000" dy=".3em">REPLACEME</text>
    </g>
  </svg>`,
  4: `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" style="shape-rendering:geometricPrecision; text-rendering:geometricPrecision; image-rendering:optimizeQuality; fill-rule:evenodd; clip-rule:evenodd"
  viewBox="0 0 512 512" width="512" height="512">
    <g>
      <circle style="fill:#ffffff;stroke:#010101;stroke-width:30;stroke-miterlimit:10;" cx="250" cy="250" r="220">
      </circle>
      <text font-family='-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"' font-size="140" font-weight="400" fill="black" x="50%" y="52%" text-anchor="middle" stroke="#000000" dy=".3em">REPLACEME</text>
    </g>
  </svg>`,
};

async function generateIcon(adventure, title) {
  // default path
  let iconPath = "icons/svg/book.svg";
  let stub = title.trim().split(".")[0].split(" ")[0];
  stub = stub.replace(/(\d+)/, _muncher_adventure_AdventureMunchHelpers_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].unPad */ .Z.unPad);
  if (stub.length <= 4) {
    iconPath = `assets/icons/${stub}.svg`;
    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].info */ .Z.info(stub);
    let content = STUBS[stub.length];
    content = content.replace("REPLACEME", stub);
    const uploadPath = await adventure.importRawFile(iconPath, content, "text/plain", true);
    return uploadPath;
  }
  return iconPath;
}


/***/ }),

/***/ 7669:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const utils = {
  debug: () => {
    return true;
  },

  capitalize: (s) => {
    if (typeof s !== "string") return "";
    return s.charAt(0).toUpperCase() + s.slice(1);
  },

  normalizeString: (str) => {
    return str.toLowerCase().replace(/\W/g, "");
  },

  referenceNameString: (str) => {
    return str.replace(/[^a-zA-Z0-9]/g, "-")
      .replace(/-+/g, "-")
      .trim();
  },

  stripHtml: (html) => {
    let tmp = document.createElement("DIV");
    tmp.innerHTML = html;
    return tmp.textContent || tmp.innerText || "";
  },

  htmlToElement: (html) => {
    const template = document.createElement('template');
    html = html.trim(); // Never return a text node of whitespace as the result
    template.innerHTML = html;
    return template.content.firstChild;
  },

  htmlToDoc: (text) => {
    const parser = new DOMParser();
    return parser.parseFromString(text, "text/html");
  },

  replaceHtmlSpaces: (str) => {
    return str.replace(/&nbsp;/g, ' ').replace(/\xA0/g, ' ').replace(/\s\s+/g, ' ').trim();
  },

  renderLesserString: (str) => {
    return utils.replaceHtmlSpaces(utils.stripHtml(str)).trim().toLowerCase();
  },

  stringKindaEqual(a, b) {
    return utils.renderLesserString(a) === utils.renderLesserString(b);
  },

  findByProperty: (arr, property, searchString) => {
    function levenshtein(a, b) {
      let tmp;
      if (a.length === 0) {
        return b.length;
      }
      if (b.length === 0) {
        return a.length;
      }
      if (a.length > b.length) {
        tmp = a;
        a = b;
        b = tmp;
      }

      let i,
        j,
        res,
        alen = a.length,
        blen = b.length,
        row = Array(alen);
      for (i = 0; i <= alen; i++) {
        row[i] = i;
      }

      for (i = 1; i <= blen; i++) {
        res = i;
        for (j = 1; j <= alen; j++) {
          tmp = row[j - 1];
          row[j - 1] = res;
          res = b[i - 1] === a[j - 1] ? tmp : Math.min(tmp + 1, Math.min(res + 1, row[j] + 1));
        }
      }
      return res;
    }

    const maxDistance = 3;
    let minDistance = 100;
    let nearestHit = undefined;
    let nearestDistance = minDistance;

    if (!Array.isArray(arr)) return undefined;
    arr
      .filter((entry) => Object.prototype.hasOwnProperty.call(entry, property))
      .forEach((entry) => {
        let distance = levenshtein(searchString, entry[property]);
        if (distance < nearestDistance && distance <= maxDistance && distance < minDistance) {
          nearestHit = entry;
          nearestDistance = distance;
        }
      });

    return nearestHit;
  },

  calculateModifier: (val) => {
    return Math.floor((val - 10) / 2);
  },

  diceStringResultBuild: (diceMap, dice, bonus = "", mods = "", diceHint = "", specialFlags = "") => {
    const globalDamageHints = game.settings.get("ddb-importer", "use-damage-hints");
    const resultBonus = bonus === 0 ? "" : `${bonus > 0 ? ' +' : ' '} ${bonus}`;
    const diceHintAdd = globalDamageHints && diceHint && diceMap;
    const hintString = diceHintAdd ? diceHint : "";
    const diceHintString = diceMap.map(({ sign, count, die }, index) =>
      `${index ? `${sign} ` : ''}${count}d${die}${specialFlags}${hintString}`
    ).join(' ');

    const result = {
      dice,
      diceMap,
      diceHintString,
      bonus,
      diceString: [
        diceHintString,
        mods,
        resultBonus
      ].join('').trim(),
    };
    return result;
  },

  parseDiceString: (inStr, mods = "", diceHint = "", specialFlags = "") => {
    // sanitizing possible inputs a bit
    const str = `${inStr}`.toLowerCase().replace(/[â€“-â€“âˆ’]/gu, "-").replace(/\s+/gu, "");

    // all found dice strings, e.g. 1d8, 4d6
    let dice = [];
    // all bonuses, e.g. -1+8
    let bonuses = [];

    const diceRegex = /(?<rawSign>[+-]*)(?<count>\d+)(?:d(?<die>\d+))?/gu;

    for (const { groups } of str.matchAll(diceRegex)) {
      const {
        rawSign = '+',
        count,
        die
      } = groups;

      // sign. We only take the sign standing exactly in front of the dice string
      // so +-1d8 => -1d8. Just as a failsave
      const sign = rawSign === "" ? "+" : rawSign.slice(-1);

      if (die) {
        dice.push({
          sign,
          count: parseInt(sign + count),
          die: parseInt(die)
        });
      } else {
        bonuses.push({
          sign,
          count: parseInt(sign + count)
        });
      }
    }

    // sum up the bonus
    const bonus = bonuses.reduce((prev, cur) => prev + cur.count, 0);

    // group the dice, so that all the same dice are summed up if they have the same sign
    // e.g.
    // +1d8+2d8 => 3d8
    // +1d8-2d8 => +1d8 -2d8 will remain as-is
    const diceMap = [];

    const groupBySign = utils.groupBy(dice, 'sign');
    for (const group of groupBySign.values()) {
      const groupByDie = utils.groupBy(group, 'die');

      for (const dieGroup of groupByDie.values()) {
        diceMap.push(
          dieGroup.reduce((acc, item) => ({
            ...acc,
            count: acc.count + item.count
          }))
        );
      }
    }

    diceMap.sort((a, b) => {
      if (a.die < b.die) return -1;
      if (a.die > b.die) return 1;
      if (a.sign === b.sign) {
        if (a.count < b.count) return -1;
        if (a.count > b.count) return 1;
        return 0;
      } else {
        return a.sign === "+" ? -1 : 1;
      }
    });

    const result = utils.diceStringResultBuild(diceMap, dice, bonus, mods, diceHint, specialFlags);
    return result;
  },

  isObject: (item) => {
    return item && typeof item === "object" && !Array.isArray(item);
  },

  mergeDeep: (target, source) => {
    let output = Object.assign({}, target);
    if (utils.isObject(target) && utils.isObject(source)) {
      Object.keys(source).forEach((key) => {
        if (utils.isObject(source[key])) {
          if (!(key in target)) Object.assign(output, { [key]: source[key] });
          else output[key] = utils.mergeDeep(target[key], source[key]);
        } else {
          Object.assign(output, { [key]: source[key] });
        }
      });
    }
    return output;
  },

  filterDeprecated: (data) => {
    for (let prop in data) {
      if (
        data[prop]
        && Object.prototype.hasOwnProperty.call(data[prop], "_deprecated")
        && data[prop]["_deprecated"] === true
      ) {
        delete data[prop];
      }
      if (prop === "_deprecated" && data[prop] === true) {
        delete data[prop];
      }
    }
    return data;
  },

  getTemplate: (type) => {
    const templates = game.data.template;
    for (let entityType in templates) {
      if (
        templates[entityType].types
        && Array.isArray(templates[entityType].types)
        && templates[entityType].types.includes(type)
      ) {
        let obj = utils.mergeDeep({}, utils.filterDeprecated(templates[entityType][type]));
        if (obj.templates) {
          obj.templates.forEach((tpl) => {
            obj = utils.mergeDeep(obj, utils.filterDeprecated(templates[entityType].templates[tpl]));
          });
          delete obj.templates;
        }
        // store the result as JSON for easy cloning
        return JSON.stringify(obj);
      }
    }
    return undefined;
  },

  getOrCreateFolder: async (root, entityType, folderName, folderColor = "") => {
    let folder = game.folders.contents.find((f) =>
      f.type === entityType && f.name === folderName
      // if a root folder we want to match the root id for the parent folder
      && (root ? root.id : null) === (f.folder?.id ?? null)
    );
    // console.warn(`Looking for ${root} ${entityType} ${folderName}`);
    // console.warn(folder);
    if (folder) return folder;
    folder = await Folder.create(
      {
        name: folderName,
        type: entityType,
        color: folderColor,
        parent: (root) ? root.id : null,
      },
      { displaySheet: false }
    );
    return folder;
  },

  // eslint-disable-next-line no-unused-vars
  getFolder: async (kind, subFolder = "", baseFolderName = "D&D Beyond Import", baseColor = "#6f0006", subColor = "#98020a", typeFolder = true) => {
    let entityTypes = new Map();
    entityTypes.set("spell", "Item");
    entityTypes.set("equipment", "Item");
    entityTypes.set("consumable", "Item");
    entityTypes.set("tool", "Item");
    entityTypes.set("loot", "Item");
    entityTypes.set("class", "Item");
    entityTypes.set("backpack", "Item");
    entityTypes.set("magic-items", "Item");
    entityTypes.set("magic-item-spells", "Item");
    entityTypes.set("npc", "Actor");
    entityTypes.set("character", "Actor");
    entityTypes.set("extras", "Actor");
    entityTypes.set("scene", "Scene");
    entityTypes.set("page", "JournalEntry");
    entityTypes.set("journal", "JournalEntry");
    entityTypes.set("journalEntry", "JournalEntry");
    entityTypes.set("background", "Item");

    const folderName = game.i18n.localize(`ddb-importer.item-type.${kind}`);
    const entityType = entityTypes.get(kind);
    const baseFolder = await utils.getOrCreateFolder(null, entityType, baseFolderName, baseColor);
    const entityFolder = typeFolder ? await utils.getOrCreateFolder(baseFolder, entityType, folderName, subColor) : baseFolder;
    if (subFolder !== "") {
      const subFolderName = subFolder.charAt(0).toUpperCase() + subFolder.slice(1);
      const typeFolder = await utils.getOrCreateFolder(entityFolder, entityType, subFolderName, subColor);
      return typeFolder;
    } else {
      return entityFolder;
    }
  },

  versionCompare: (v1, v2, options) => {
    let lexicographical = options && options.lexicographical,
      zeroExtend = options && options.zeroExtend,
      v1parts = v1.split("."),
      v2parts = v2.split(".");

    function isValidPart(x) {
      return (lexicographical ? /^\d+[A-Za-z]*$/ : /^\d+$/).test(x);
    }

    if (!v1parts.every(isValidPart) || !v2parts.every(isValidPart)) {
      return NaN;
    }

    if (zeroExtend) {
      while (v1parts.length < v2parts.length) v1parts.push("0");
      while (v2parts.length < v1parts.length) v2parts.push("0");
    }

    if (!lexicographical) {
      v1parts = v1parts.map(Number);
      v2parts = v2parts.map(Number);
    }

    for (let i = 0; i < v1parts.length; ++i) {
      if (v2parts.length == i) {
        return 1;
      }

      if (v1parts[i] > v2parts[i]) {
        return 1;
      }
      if (v1parts[i] < v2parts[i]) {
        return -1;
      }
    }

    if (v1parts.length != v2parts.length) {
      return -1;
    }

    return 0;
  },

  groupBy(arr, property) {
    const map = new Map();

    for (const item of arr) {
      const prop = item[property];
      const group = map.get(prop) ?? [];

      group.push(item);
      map.set(prop, group);
    }

    return map;
  },

  async namePrompt(question) {
    const content = `
    <label class="text-label">
      <input type="text" name="name"/>
    </label>
  `;
    const name = await new Promise((resolve) => {
      new Dialog({
        title: question,
        content,
        buttons: {
          ok: {
            label: "Okay",
            callback: async (html) => {
              const value = html.find("input[type='text'][name='name']").val();
              resolve(value);
            },
          },
          cancel: {
            label: "Cancel",
            callback: () => {
              resolve("");
            },
          }
        },
        default: "ok",
        close: () => {
          resolve("");
        },
      }).render(true);
    });
    return name;
  }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (utils);


/***/ }),

/***/ 5259:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const logger = {

  LOG_PREFIX: "DDB Importer",
  LOG_MSG_DEFAULT: "No logging message provided.  Please see the payload for more information.",

  _showMessage: (logLevel, data) => {
    if (!logLevel || !data || typeof (logLevel) !== 'string') {
      return false;
    }

    try {
      const setting = game.settings.get("ddb-importer", "log-level");
      const logLevels = ["DEBUG", "TIME", "TIMEEND", "TIMELOG", "INFO", "WARN", "ERR", "OFF"];
      const logLevelIndex = logLevels.indexOf(logLevel.toUpperCase());
      if (setting == "OFF"
              || logLevelIndex === -1
              || logLevelIndex < logLevels.indexOf(setting)) {
        return false;
      }
      return true;
    } catch (err) {
      return true;
    }

  },
  _addToLogFile: (logLevel, data) => {
    if (getProperty(CONFIG.debug, "ddbimporter.record") === true) {
      CONFIG.debug.ddbimporter.log.push({
        level: logLevel,
        data: data,
      });
    }
  },
  // eslint-disable-next-line complexity
  log: (logLevel, ...data) => {
    logger._addToLogFile(logLevel, data);
    if (!logger._showMessage(logLevel, data)) {
      return;
    }

    const logLevelType = logLevel.startsWith("TIME")
      ? "DEBUG"
      : logLevel.toUpperCase();

    const msgContent = data[0] && typeof (data[0] == 'string')
      ? data[0]
      : logger.LOG_MSG_DEFAULT;
    const payload = data[0] && typeof (data[0] == 'string')
      ? data.length > 1
        ? data.slice(1)
        : null
      : data.slice();
    const msg = `${logger.LOG_PREFIX} | ${logLevelType} > ${msgContent}`;

    switch (logLevel.toUpperCase()) {
      case "DEBUG":
        if (payload) {
          console.debug(msg, ...payload);// eslint-disable-line no-console
        } else {
          console.debug(msg);// eslint-disable-line no-console
        }
        break;
      case "INFO":
        if (payload) {
          console.info(msg, ...payload);// eslint-disable-line no-console
        } else {
          console.info(msg);// eslint-disable-line no-console
        }
        break;
      case "WARN":
        if (payload) {
          console.warn(msg, ...payload);// eslint-disable-line no-console
        } else {
          console.warn(msg);// eslint-disable-line no-console
        }
        break;
      case "ERR":
        if (payload) {
          console.error(msg, ...payload);// eslint-disable-line no-console
        } else {
          console.error(msg);// eslint-disable-line no-console
        }
        break;
      case "TIME":
        if (payload) {
          console.time(msg, ...payload);// eslint-disable-line no-console
        } else {
          console.time(msg);// eslint-disable-line no-console
        }
        break;
      case "TIMEEND":
        if (payload) {
          console.timeEnd(msg, ...payload);// eslint-disable-line no-console
        } else {
          console.timeEnd(msg);// eslint-disable-line no-console
        }
        break;
      case "TIMELOG":
        if (payload) {
          console.timeLog(msg, ...payload);// eslint-disable-line no-console
        } else {
          console.timeLog(msg);// eslint-disable-line no-console
        }
        break;
      default: break;
    }
  },

  debug: (...data) => {
    logger.log("DEBUG", ...data);
  },

  info: (...data) => {
    logger.log("INFO", ...data);
  },

  warn: (...data) => {
    logger.log("WARN", ...data);
  },

  error: (...data) => {
    logger.log("ERR", ...data);
  },

  time: (...data) => {
    logger.log("TIME", ...data);
  },

  timeEnd: (...data) => {
    logger.log("TIMEEND", ...data);
  },

  timeLog: (...data) => {
    logger.log("TIMELOG", ...data);
  },

};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (logger);


/***/ }),

/***/ 6870:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ DDBMonsterFactory)
/* harmony export */ });
/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5259);
/* harmony import */ var _parser_DDBMonster_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(317);
/* harmony import */ var _lib_FileHelper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(2397);
/* harmony import */ var _lib_Secrets_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(2048);
/* harmony import */ var _lib_DDBProxy_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(546);
/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(6451);
/* harmony import */ var _import_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(9193);
/* harmony import */ var _compendiumFolders_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(6269);
/* harmony import */ var _importMonster_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(9633);










// targets for migration


class DDBMonsterFactory {

  static #noteStub(note, nameField = false, monsterNote = false) {
    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].info */ .Z.info(note, { nameField, monsterNote });
  }

  static defaultFetchOptions(ids, searchTerm = null) {
    const searchFilter = $("#monster-munch-filter")[0];
    const finalSearchTerm = searchTerm ?? (searchFilter?.value ?? "");
    const enableSources = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-use-source-filter");
    const sources = enableSources
      ? game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-muncher-sources").flat()
      : [];
    const homebrew = sources.length > 0
      ? false
      : game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-monster-homebrew");
    const homebrewOnly = sources.length > 0
      ? false
      : game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-monster-homebrew-only");
    const exactMatch = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-monster-exact-match");
    const excludeLegacy = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-exclude-legacy");

    const options = {
      ids,
      searchTerm: finalSearchTerm.trim(),
      sources,
      homebrew,
      homebrewOnly,
      exactMatch,
      excludeLegacy,
    };
    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug("Generated monster fetch options", options);
    return options;
  }

  constructor ({ ddbData = null, extra = false, munchNote = null } = {}) {
    this.extra = extra;
    this.npcs = [];
    this.source = ddbData;
    this.munchNote = munchNote ?? DDBMonsterFactory.#noteStub;
  }

  /**
   * Fetch monsters from DDB
   * @param {*} ids limit monsters fetched to specific ids
   * @returns
   */
  async fetchDDBMonsterSourceData({ ids = [], searchTerm = "", sources = [], homebrew = false,
    homebrewOnly = false, exactMatch = false, excludeLegacy = false }
  ) {
    const cobaltCookie = (0,_lib_Secrets_js__WEBPACK_IMPORTED_MODULE_3__/* .getCobalt */ .HF)();
    const betaKey = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "beta-key");
    const parsingApi = _lib_DDBProxy_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].getProxy */ .Z.getProxy();

    const body = {
      cobalt: cobaltCookie,
      betaKey: betaKey,
    };

    if (ids && !Array.isArray(ids)) {
      ids = [ids];
    }

    if (ids && ids.length > 0) {
      body.ids = [...new Set(ids)];
    } else {
      body.sources = sources;
      body.search = searchTerm;
      body.homebrew = homebrew;
      body.homebrewOnly = homebrewOnly;
      body.searchTerm = encodeURIComponent(searchTerm);
      body.exactMatch = exactMatch;
      body.excludeLegacy = excludeLegacy;
    }

    const debugJson = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "debug-json");

    const url = ids && ids.length > 0
      ? `${parsingApi}/proxy/monsters/ids`
      : `${parsingApi}/proxy/monster`;

    return new Promise((resolve, reject) => {
      fetch(url, {
        method: "POST",
        mode: "cors",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(body), // body data type must match "Content-Type" header
      })
        .then((response) => response.json())
        .then((data) => {
          if (!data.success) {
            this.munchNote(`API Failure: ${data.message}`);
            _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].error */ .Z.error(`API Failure:`, data.message);
            reject(data.message);
          }
          if (debugJson) {
            _lib_FileHelper_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].download */ .Z.download(JSON.stringify(data), `monsters-raw.json`, "application/json");
          }
          return data;
        })
        .then((data) => {
          this.munchNote(`Retrieved ${data.data.length} monsters, starting parse...`, true, false);
          _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].info */ .Z.info(`Retrieved ${data.data.length} monsters`);
          this.source = data.data;
          resolve(this.source);
        })
        .catch((error) => reject(error));
    });
  }

  /**
   * Processes the downloaded (or provided) DDB Source data for monsters and generates actors
   * Use this.fetchDDBMonsterSourceData() if you need to get monster data from ddb
   * @returns
   */
  async parse() {
    let foundryActors = [];
    let failedMonsterNames = [];

    const useItemAC = game.settings.get("ddb-importer", "munching-policy-monster-use-item-ac");
    const legacyName = game.settings.get("ddb-importer", "munching-policy-legacy-postfix");
    const addMonsterEffects = game.settings.get("ddb-importer", "munching-policy-add-monster-effects");

    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].time */ .Z.time("Monster Parsing");
    for (const monster of this.source) {
      try {
        _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug(`Attempting to parse ${monster.name}`);
        _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].time */ .Z.time(`Monster Parse ${monster.name}`);
        const ddbMonster = new _parser_DDBMonster_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z(monster, { extra: this.extra, useItemAC, legacyName, addMonsterEffects });
        // eslint-disable-next-line no-await-in-loop
        await ddbMonster.parse();
        foundryActors.push(duplicate(ddbMonster.npc));
        _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].timeEnd */ .Z.timeEnd(`Monster Parse ${monster.name}`);
        // logger.timeLog("Monster Parsing", monster.name);
      } catch (err) {
        _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].error */ .Z.error(`Failed parsing ${monster.name}`);
        _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].error */ .Z.error(err);
        _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].error */ .Z.error(err.stack);
        failedMonsterNames.push(monster.name);
      }
    }

    const result = {
      actors: await Promise.all(foundryActors),
      failedMonsterNames: failedMonsterNames,
    };

    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].timeEnd */ .Z.timeEnd("Monster Parsing");

    this.munchNote(
      `Parsed ${result.actors.length} monsters, failed ${result.failedMonsterNames.length} monsters`,
      false,
      true
    );
    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].info */ .Z.info(`Parsed ${result.actors.length} monsters, failed ${result.failedMonsterNames.length} monsters`);
    if (result.failedMonsterNames && result.failedMonsterNames.length !== 0) {
      _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].error */ .Z.error(`Failed to parse`, result.failedMonsterNames);
    }

    this.npcs = result.actors;
    return result;
  }

  /**
   * Downloads, parces and imports monsters into a compendium
   */
  async processIntoCompendium(ids = null) {
    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].time */ .Z.time("Monster Import Time");
    setProperty(CONFIG.DDBI, "MUNCHER.TEMPORARY", {});
    const updateBool = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-update-existing");
    const updateImages = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-update-images");
    const uploadDirectory = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "other-image-upload-directory").replace(/^\/|\/$/g, "");
    // const bulkImport = game.settings.get(SETTINGS.MODULE_ID, "munching-policy-monster-bulk-import");
    // bulk import is disabled for now de to entry duplication
    const bulkImport = false;

    // to speed up file checking we pregenerate existing files now.
    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].info */ .Z.info("Checking for existing files...");
    this.munchNote(`Checking existing image files...`);
    await _lib_FileHelper_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].generateCurrentFiles */ .Z.generateCurrentFiles(uploadDirectory);
    await _lib_FileHelper_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].generateCurrentFiles */ .Z.generateCurrentFiles("[data] modules/ddb-importer/data");
    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].info */ .Z.info("Check complete getting monster data...");
    this.munchNote(`Getting monster data from DDB...`);
    await this.fetchDDBMonsterSourceData(DDBMonsterFactory.defaultFetchOptions(ids));
    let monsterResults = await this.parse();
    let monsters = monsterResults.actors;

    if (!updateBool || !updateImages) {
      this.munchNote(`Calculating which monsters to update...`, true);
      const existingMonsters = await (0,_import_js__WEBPACK_IMPORTED_MODULE_6__/* .getCompendiumItems */ .pI)(monsters, "npc", { keepDDBId: true });
      const existingMonstersTotal = existingMonsters.length + 1;
      if (!updateBool) {
        _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug("Removing existing monsters from import list");
        _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug(`Matched ${existingMonstersTotal}`);
        this.munchNote(`Removing ${existingMonstersTotal} from update...`);
        monsters = await (0,_import_js__WEBPACK_IMPORTED_MODULE_6__/* .removeItems */ .Er)(monsters, existingMonsters, true);
      }
      if (!updateImages) {
        _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug("Copying monster images across...");
        this.munchNote(`Copying images for ${existingMonstersTotal} monsters...`);
        monsters = (0,_importMonster_js__WEBPACK_IMPORTED_MODULE_8__/* .copyExistingMonsterImages */ .ph)(monsters, existingMonsters);
      }
    }
    this.munchNote("");
    this.munchNote(`Fiddling with the SRD data...`, true);
    const finalMonsters = await (0,_import_js__WEBPACK_IMPORTED_MODULE_6__/* .srdFiddling */ .cC)(monsters, "monsters");

    this.munchNote(`Generating Icon Map..`, true);
    await (0,_importMonster_js__WEBPACK_IMPORTED_MODULE_8__/* .generateIconMap */ .NM)(finalMonsters);

    const addToCompendiumFolder = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-use-compendium-folders");
    const compendiumFoldersInstalled = game.modules.get("compendium-folders")?.active;
    if (addToCompendiumFolder && compendiumFoldersInstalled) {
      this.munchNote(`Checking compendium folders..`, true);
      await (0,_compendiumFolders_js__WEBPACK_IMPORTED_MODULE_7__/* .createCompendiumFolderStructure */ .FT)("monsters");
      this.munchNote("", true);
    }

    let monstersParsed = [];
    let currentMonster = 1;
    const monsterCount = finalMonsters.length;
    this.munchNote(`Preparing dinner for ${monsterCount} monsters!`, true);
    for (const monster of finalMonsters) {
      if (bulkImport) {
        this.munchNote(`[${currentMonster}/${monsterCount}] Checking dietary requirements for ${monster.name}`, false, true);
      } else {
        this.munchNote(`[${currentMonster}/${monsterCount}] Importing ${monster.name} to compendium`, false, true);
      }
      _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug(`Preparing ${monster.name} data for import`);
      // eslint-disable-next-line no-await-in-loop
      const munched = await (0,_importMonster_js__WEBPACK_IMPORTED_MODULE_8__/* .addNPC */ .Fx)(monster, bulkImport, "monster");
      monstersParsed.push(munched);
      currentMonster += 1;
    }
    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug("Monsters Parsed", monstersParsed);
    if (bulkImport) {
      this.munchNote(`Importing ${monstersParsed.length} monsters`, false, true);
      _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug(`Importing ${monstersParsed.length} monsters`);
      await (0,_importMonster_js__WEBPACK_IMPORTED_MODULE_8__/* .addNPCsToCompendium */ .qp)(monstersParsed, "monster");
    }
    this.munchNote("", false, true);
    setProperty(CONFIG.DDBI, "MUNCHER.TEMPORARY", {});

    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].timeEnd */ .Z.timeEnd("Monster Import Time");
    if (ids !== null) {
      return Promise.all(monstersParsed);
    }
    return monsterCount;
  }
}


/***/ }),

/***/ 1475:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "Z": () => (/* binding */ DDBMuncher)
});

// EXTERNAL MODULE: ./src/logger.js
var logger = __webpack_require__(5259);
// EXTERNAL MODULE: ./src/lib/PatreonHelper.js
var PatreonHelper = __webpack_require__(8636);
// EXTERNAL MODULE: ./src/muncher/items.js
var items = __webpack_require__(8638);
// EXTERNAL MODULE: ./src/muncher/spells.js + 1 modules
var spells = __webpack_require__(6502);
// EXTERNAL MODULE: ./src/lib/DDBTemplateStrings.js
var DDBTemplateStrings = __webpack_require__(258);
// EXTERNAL MODULE: ./src/muncher/import.js
var muncher_import = __webpack_require__(9193);
// EXTERNAL MODULE: ./src/parser/race/DDBRace.js
var DDBRace = __webpack_require__(1434);
;// CONCATENATED MODULE: ./src/muncher/races/races.js






const FEATURE_DUP = [
  "Breath Weapon",
  "Natural Armor",
  "Darkvision",
  "Flight",
  "Hunter's Lore",
  "Claws",
  "Beak",
  "Spells of the Mark",
  "Shifting Feature",
  "Creature Type",
  "Aggressive",
  "Amphibious",
  "Ancestral Legacy",
  "Bite",
  "Cantrip",
  "Celestial Resistance",
  "Charge",
  "Child of the Sea",
  "Draconic Resistance",
  "Fey Ancestry",
  "Hold Breath",
  "Hooves",
  "Horns",
  "Magic Resistance",
  "Mental Discipline",
  "Natural Athlete",
  "Powerful Build",
  "Sunlight Sensitivity",
  "Superior Darkvision",
];

function getRacialTrait(trait, fullName, isLegacy) {
  logger/* default.debug */.Z.debug("Race trait build started");

  const traitBase = new DDBRace/* default */.Z(trait, null);
  let result = traitBase.buildBase();

  const duplicateFeature = FEATURE_DUP.includes(result.name.replace("â€™", "'"));
  result.name = (duplicateFeature) ? `${result.name} (${fullName})` : result.name;

  const legacyName = game.settings.get("ddb-importer", "munching-policy-legacy-postfix");
  if (legacyName && isLegacy) {
    // result.name += " (Legacy)";
    logger/* default.debug */.Z.debug(`Trait name ${result.name} is legacy`);
  }


  result.flags.ddbimporter['spellListIds'] = trait.spellListIds;
  result.flags.ddbimporter['definitionKey'] = trait.definitionKey;
  result.flags.ddbimporter['race'] = fullName;
  result.system.requirements = fullName;

  result.system.type = {
    value: "race",
  };

  result.system.description.value = (0,DDBTemplateStrings/* parseTags */.RN)(result.system.description.value);

  return result;
}

const NO_TRAITS = [
  "Speed",
  "Ability Score Increase",
  "Ability Score Increases",
  "Size",
  "Feat",
  "Languages",
  "Extra Language",
  "Age",
  "Alignment",
];

async function getRaces(data) {
  logger/* default.debug */.Z.debug("get races started");
  const updateBool = game.settings.get("ddb-importer", "munching-policy-update-existing");

  let results = [];
  let races = [];
  let racialFeatures = [];

  // const legacyRaces =
  // setProperty(CONFIG, "DDBI.MUNCHER.RACES.LEGACY", duplicateRaces);

  const excludeLegacy = game.settings.get("ddb-importer", "munching-policy-exclude-legacy");
  data
    .filter((race) => !excludeLegacy || (excludeLegacy && !race.isLegacy))
    .forEach((race) => {
      logger/* default.debug */.Z.debug(`${race.fullName} features parsing started...`);
      race.racialTraits.forEach((trait) => {
        logger/* default.debug */.Z.debug(`${trait.definition.name} trait starting...`);
        if (!trait.definition.hideInSheet && !NO_TRAITS.includes(trait.definition.name)) {
          const parsedTrait = getRacialTrait(trait.definition, race.fullName, race.isLegacy);
          racialFeatures.push(parsedTrait);
          results.push({ race: race.fullName, trait: trait.definition.name });
        }
      });
    });

  const fiddledRacialFeatures = await (0,muncher_import/* srdFiddling */.cC)(racialFeatures, "traits");
  DDBMuncher.munchNote(`Importing ${fiddledRacialFeatures.length} traits!`, true);
  logger/* default.debug */.Z.debug("Generated Racial Traits", fiddledRacialFeatures);
  await (0,muncher_import/* updateCompendium */.X)("traits", { traits: fiddledRacialFeatures }, updateBool, ["entityRaceId"]);

  const compendiumRacialTraits = await DDBRace/* default.getRacialTraitsLookup */.Z.getRacialTraitsLookup(fiddledRacialFeatures);

  await Promise.allSettled(data
    .filter((race) => !excludeLegacy || (excludeLegacy && !race.isLegacy))
    .map(async (race) => {
      logger/* default.debug */.Z.debug(`${race.fullName} race parsing started...`);
      const ddbRace = new DDBRace/* default */.Z(race, compendiumRacialTraits);
      const builtRace = await ddbRace.buildRace();
      races.push(builtRace);
    })
  );

  logger/* default.debug */.Z.debug("Pre-fiddled races", duplicate(races));

  const fiddledRaces = await (0,muncher_import/* srdFiddling */.cC)(races, "races");
  DDBMuncher.munchNote(`Importing ${fiddledRaces.length} races!`, true);

  logger/* default.debug */.Z.debug("Fiddled races", fiddledRaces);

  await (0,muncher_import/* updateCompendium */.X)("races", { races: fiddledRaces }, updateBool, ["entityRaceId"]);

  return results;
}

// EXTERNAL MODULE: ./src/lib/Secrets.js
var Secrets = __webpack_require__(2048);
// EXTERNAL MODULE: ./src/lib/Settings.js
var Settings = __webpack_require__(5406);
// EXTERNAL MODULE: ./src/lib/FileHelper.js
var FileHelper = __webpack_require__(2397);
// EXTERNAL MODULE: ./src/settings.js
var settings = __webpack_require__(6451);
// EXTERNAL MODULE: ./src/lib/DDBProxy.js
var DDBProxy = __webpack_require__(546);
;// CONCATENATED MODULE: ./src/muncher/races.js
// Main module class








function getRaceData() {
  const cobaltCookie = (0,Secrets/* getCobalt */.HF)();
  const campaignId = (0,Settings/* getCampaignId */.F9)();
  const parsingApi = DDBProxy/* default.getProxy */.Z.getProxy();
  const betaKey = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "beta-key");
  const body = { cobalt: cobaltCookie, campaignId: campaignId, betaKey: betaKey };
  const debugJson = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "debug-json");

  return new Promise((resolve, reject) => {
    fetch(`${parsingApi}/proxy/races`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(body),
    })
      .then((response) => response.json())
      .then((data) => {
        if (debugJson) {
          FileHelper/* default.download */.Z.download(JSON.stringify(data), `races-raw.json`, "application/json");
        }
        if (!data.success) {
          DDBMuncher.munchNote(`Failure: ${data.message}`);
          reject(data.message);
        }
        return data;
      })
      .then((data) => getRaces(data.data))
      .then((data) => resolve(data))
      .catch((error) => reject(error));
  });
}

async function parseRaces() {
  const results = await getRaceData();

  // FileHelper.download(JSON.stringify(results), `races-icon.json`, "application/json");

  return results;
}



// EXTERNAL MODULE: ./src/muncher/feats/feats.js
var feats = __webpack_require__(267);
;// CONCATENATED MODULE: ./src/muncher/feats.js
// Main module class








function getFeatData() {
  const cobaltCookie = (0,Secrets/* getCobalt */.HF)();
  const campaignId = (0,Settings/* getCampaignId */.F9)();
  const parsingApi = DDBProxy/* default.getProxy */.Z.getProxy();
  const betaKey = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "beta-key");
  const body = { cobalt: cobaltCookie, campaignId: campaignId, betaKey: betaKey };
  const debugJson = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "debug-json");

  return new Promise((resolve, reject) => {
    fetch(`${parsingApi}/proxy/feats`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(body),
    })
      .then((response) => response.json())
      .then((data) => {
        if (debugJson) {
          FileHelper/* default.download */.Z.download(JSON.stringify(data), `feats-raw.json`, "application/json");
        }
        if (!data.success) {
          DDBMuncher.munchNote(`Failure: ${data.message}`);
          reject(data.message);
        }
        return data;
      })
      .then((data) => (0,feats/* getFeats */.S)(data.data))
      .then((data) => resolve(data))
      .catch((error) => reject(error));
  });
}

async function parseFeats() {
  const results = await getFeatData();

  return results;
}



// EXTERNAL MODULE: ./src/lib/CompendiumHelper.js
var CompendiumHelper = __webpack_require__(3893);
// EXTERNAL MODULE: ./src/lib/DDBHelper.js
var DDBHelper = __webpack_require__(1438);
// EXTERNAL MODULE: ./src/dictionary.js
var dictionary = __webpack_require__(37);
// EXTERNAL MODULE: ./src/muncher/table.js + 2 modules
var table = __webpack_require__(7967);
// EXTERNAL MODULE: ./src/lib/utils.js
var utils = __webpack_require__(7669);
;// CONCATENATED MODULE: ./src/muncher/classes/shared.js









const CLASS_TEMPLATE = {
  "name": "",
  "type": "feat",
  "system": {
    "description": {
      "value": "",
      "chat": "",
      "unidentified": ""
    },
    "source": "",
  },
  "sort": 2600000,
  "flags": {
    "ddbimporter": {
      "type": "class",
    },
    "obsidian": {
      "source": {
        "type": "class",
        "text": ""
      }
    },
  },
  "img": null
};

const shared_NO_TRAITS = [
  "Speed",
  "Size",
  "Feat",
  "Languages",
  "Hit Points",
  "Proficiencies",
];

const shared_FEATURE_DUP = [
  "Ability Score Increase",
  "Ability Score Improvement",
  "Expertise",
  "Fighting Style",
  "Land's Stride",
  "Otherworldly Patron",
  "Pact Magic",
  "Potent Spellcasting",
  "Timeless Body",
  "Unarmored Defense",
  "Circle Spells",
  "Divine Strike",
  "Evasion",
  "Channel Divinity",
  "Expanded Spell List",
  "Oath Spells",
  "Psionic Power",
  "Psychic Blades",
  "Spellcasting",
  "Primal Companion",
  "Domain Spells",
  "Bonus Cantrip",
  "Bonus Cantrips",
  "Bonus Proficiencies",
  "Bonus Proficiency",
  "Extra Attack",
  "Tool Proficiency",
];

function buildBase(data) {
  let result = duplicate(CLASS_TEMPLATE);
  const updateExisting = game.settings.get("ddb-importer", "munching-policy-update-existing");

  result.name = data.name;
  const tableDescription = (0,table/* generateTable */.p)(data.name, data.description, updateExisting);
  result.system.description.value += `${tableDescription}\n\n`;

  result.flags.ddbimporter = {
    id: data.id,
    data: data,
    version: CONFIG.DDBI.version,
  };

  if (data.moreDetailsUrl) {
    result.flags.ddbimporter['moreDetailsUrl'] = data.moreDetailsUrl;
  }

  result.system.source = DDBHelper/* default.parseSource */.Z.parseSource(data);

  return result;
}

async function generateFeatureAdvancements(klass, compendiumClassFeatures, ignoreIds = []) {
  logger/* default.debug */.Z.debug(`Parsing ${klass.name} features for advancement`);
  const compendiumLabel = CompendiumHelper/* default.getCompendiumLabel */.Z.getCompendiumLabel("features");

  let advancements = [];
  klass.classFeatures
    .filter((feature) => !ignoreIds.includes(feature.id))
    .forEach((feature) => {
      const featureMatch = compendiumClassFeatures.find((match) => {
        const matchName = hasProperty(match, "flags.ddbimporter.featureName")
          ? getProperty(match, "flags.ddbimporter.featureName").trim().toLowerCase()
          : match.name.trim().toLowerCase();
        return feature.name.trim().toLowerCase() == matchName
          && hasProperty(match, "flags.ddbimporter")
          && (match.flags.ddbimporter.class == klass.name
            || match.flags.ddbimporter.parentClassId == klass.id
            || match.flags.ddbimporter.classId == klass.id);
      });

      if (featureMatch) {
        const levelAdvancement = advancements.findIndex((advancement) => advancement.level === feature.requiredLevel);

        if (levelAdvancement == -1) {
          const advancement = {
            _id: foundry.utils.randomID(),
            type: "ItemGrant",
            configuration: {
              items: [
                `Compendium.${compendiumLabel}.${featureMatch._id}`
              ]
            },
            value: {},
            level: feature.requiredLevel,
            title: "Features",
            icon: "",
            classRestriction: ""
          };
          advancements.push(advancement);
        } else {
          advancements[levelAdvancement].configuration.items.push(`Compendium.${compendiumLabel}.${featureMatch._id}`);
        }
      }
    });

  return advancements;
}

async function buildClassFeatures(klass, compendiumClassFeatures, ignoreIds = []) {
  logger/* default.debug */.Z.debug(`Parsing ${klass.name} features`);
  let description = "<h1>Class Features</h1>\n\n";
  let classFeatures = [];

  const compendiumLabel = CompendiumHelper/* default.getCompendiumLabel */.Z.getCompendiumLabel("features");

  klass.classFeatures.forEach((feature) => {
    const classFeaturesAdded = classFeatures.some((f) => f === feature.name);

    // sort by level?
    if (!classFeaturesAdded && !ignoreIds.includes(feature.id)) {
      const featureMatch = compendiumClassFeatures.find((match) => {
        const matchName = hasProperty(match, "flags.ddbimporter.featureName")
          ? getProperty(match, "flags.ddbimporter.featureName").trim().toLowerCase()
          : match.name.trim().toLowerCase();
        return feature.name.trim().toLowerCase() == matchName
          && hasProperty(match, "flags.ddbimporter")
          && (match.flags.ddbimporter.class == klass.name
            || match.flags.ddbimporter.parentClassId == klass.id
            || match.flags.ddbimporter.classId == klass.id);
      });
      const title = (featureMatch)
        ? `<p><b>@Compendium[${compendiumLabel}.${featureMatch._id}]{${feature.name}}</b></p>`
        : `<p><b>${feature.name}</b></p>`;

      // eslint-disable-next-line require-atomic-updates
      description += `${title}\n${feature.description}\n\n`;
      classFeatures.push(feature.name);
    }
  });

  return description;
}

function getClassFeature(feature, klass, subClassName = "") {
  logger/* default.debug */.Z.debug("Class feature build started");

  let result = buildBase(feature);
  result.flags.obsidian.source.text = klass.name;

  const duplicateFeature = shared_FEATURE_DUP.includes(feature.name);
  result.name = (duplicateFeature) ? `${feature.name} (${klass.name})` : feature.name;

  result.flags.ddbimporter['featureId'] = feature.id;
  result.flags.ddbimporter['featureName'] = feature.name;
  result.flags.ddbimporter['requiredLevel'] = feature.requiredLevel;
  result.flags.ddbimporter['prerequisite'] = feature.prerequisite;
  result.flags.ddbimporter['class'] = klass.name;
  result.flags.ddbimporter['classId'] = klass.id;
  result.flags.ddbimporter['subClass'] = subClassName;
  result.flags.ddbimporter['parentClassId'] = klass.parentClassId;
  const requiredLevel = feature.requiredLevel ? ` ${feature.requiredLevel}` : "";
  result.system.requirements = `${klass.name}${requiredLevel}`;

  result.system.description.value = (0,DDBTemplateStrings/* parseTags */.RN)(result.system.description.value);

  result.system.type = {
    value: "class",
  };

  return result;
}

async function buildBaseClass(klass) {
  let result = buildBase(klass);
  logger/* default.debug */.Z.debug(`Parsing ${klass.name}`);
  result.flags.obsidian.source.text = klass.name;
  result.type = "class";
  result.system.identifier = utils/* default.referenceNameString */.Z.referenceNameString(klass.name).toLowerCase();
  result.system.advancement = [];

  let avatarUrl;
  let largeAvatarUrl;
  let portraitAvatarUrl;

  if (klass.portraitAvatarUrl) {
    const downloadOptions = { type: "class-portrait", name: klass.fullName };
    portraitAvatarUrl = await FileHelper/* default.getImagePath */.Z.getImagePath(klass.portraitAvatarUrl, downloadOptions);
    result.img = portraitAvatarUrl;
    result.flags.ddbimporter['portraitAvatarUrl'] = klass.portraitAvatarUrl;
  }

  if (klass.avatarUrl) {
    const downloadOptions = { type: "class-avatar", name: klass.fullName };
    avatarUrl = await FileHelper/* default.getImagePath */.Z.getImagePath(klass.avatarUrl, downloadOptions);
    result.flags.ddbimporter['avatarUrl'] = klass.avatarUrl;
    if (!result.img) {
      result.img = avatarUrl;
    }
  }

  if (klass.largeAvatarUrl) {
    const downloadOptions = { type: "class-large", name: klass.fullName };
    largeAvatarUrl = await FileHelper/* default.getImagePath */.Z.getImagePath(klass.largeAvatarUrl, downloadOptions);
    // eslint-disable-next-line require-atomic-updates
    result.flags.ddbimporter['largeAvatarUrl'] = klass.largeAvatarUrl;
    if (!result.img) {
      // eslint-disable-next-line require-atomic-updates
      result.img = largeAvatarUrl;
    }
  }

  const image = (avatarUrl)
    ? `<img class="ddb-class-image" src="${avatarUrl}">\n\n`
    : `<img class="ddb-class-image" src="${largeAvatarUrl}">\n\n`;

  // eslint-disable-next-line require-atomic-updates
  result.system.description.value += image;

  // eslint-disable-next-line require-atomic-updates
  result.flags.ddbimporter['parentClassId'] = klass.parentClassId;
  // eslint-disable-next-line require-atomic-updates
  result.flags.ddbimporter['hitDice'] = klass.hitDice;
  // eslint-disable-next-line require-atomic-updates
  result.flags.ddbimporter['spellCastingAbilityId'] = klass.spellCastingAbilityId;
  // eslint-disable-next-line require-atomic-updates
  result.flags.ddbimporter['canCastSpells'] = klass.canCastSpells;

  // setup data
  // eslint-disable-next-line require-atomic-updates
  result.system.levels = 1;
  // eslint-disable-next-line require-atomic-updates
  result.system.hitDice = `d${klass.hitDice}`;

  let spellcasting = {};
  if (klass.canCastSpells) {
    const spellProgression = dictionary/* default.spell.progression.find */.Z.spell.progression.find((cls) => cls.name == klass.name);
    const spellCastingAbility = klass.spellCastingAbilityId
      ? dictionary/* default.character.abilities.find */.Z.character.abilities.find((a) => a.id == klass.spellCastingAbilityId).value
      : null;
    if (spellProgression) {
      spellcasting = {
        progression: spellProgression.value,
        ability: spellCastingAbility,
      };
    }
  }
  // eslint-disable-next-line require-atomic-updates
  result.system.spellcasting = spellcasting;

  // this can be used with the add class response
  // const classSkillSubType = `choose-a-${klass.name.toLowerCase()}-skill`;
  // const skillCount = .filter((mod) => mod.subType === classSkillSubType && mod.type === "proficiency"));

  const proficiencyOption = klass.classFeatures.find((feature) =>
    feature.name === "Proficiencies"
    && feature.requiredLevel === 1
  );

  let dom = new DocumentFragment();
  $.parseHTML(proficiencyOption.description).forEach((element) => {
    dom.appendChild(element);
  });

  // Choose any three
  // Skills: Choose two from Arcana, Animal Handling, Insight, Medicine, Nature, Perception, Religion, and Survival
  const skillText = dom.textContent.toLowerCase().split("skills:").pop().split("\n")[0].split("The")[0].split(".")[0].trim();
  const allSkillRegex = /Skills: Choose any (\w+)(.*)($|\.$|\w+:)/im;
  const allMatch = dom.textContent.match(allSkillRegex);
  const skillRegex = /choose (\w+)(?:\sskills)* from (.*)($|The|\.$|\w+:)/im;
  const skillMatch = skillText.match(skillRegex);

  if (allMatch) {
    const skills = dictionary/* default.character.skills.map */.Z.character.skills.map((skill) => skill.name);
    const numberSkills = dictionary/* default.numbers.find */.Z.numbers.find((num) => allMatch[1].toLowerCase() === num.natural);
    // eslint-disable-next-line require-atomic-updates
    result.system.skills = {
      number: numberSkills ? numberSkills.num : 2,
      choices: skills,
      value: [],
    };
  } else if (skillMatch) {
    const skillNames = skillMatch[2].replace('and', ',').split(',').map((skill) => skill.trim());
    const skills = skillNames.filter((name) => dictionary/* default.character.skills.some */.Z.character.skills.some((skill) => skill.label.toLowerCase() === name.toLowerCase()))
      .map((name) => {
        const dictSkill = dictionary/* default.character.skills.find */.Z.character.skills.find((skill) => skill.label.toLowerCase() === name.toLowerCase());
        return dictSkill.name;
      });
    const numberSkills = dictionary/* default.numbers.find */.Z.numbers.find((num) => skillMatch[1].toLowerCase() === num.natural);
    // eslint-disable-next-line require-atomic-updates
    result.system.skills = {
      number: numberSkills ? numberSkills.num : 2,
      choices: skills,
      value: [],
    };
  }

  // get class saves
  const savingText = dom.textContent.toLowerCase().split("saving throws:").pop().split("\n")[0].split("The")[0].split(".")[0].split("skills:")[0].trim();
  const saveRegex = /(.*)(?:$|The|\.$|\w+:)/im;
  const saveMatch = savingText.match(saveRegex);

  if (saveMatch) {
    const saveNames = saveMatch[1].replace('and', ',').split(',').map((ab) => ab.trim());
    const saves = saveNames
      .filter((name) => dictionary/* default.character.abilities.some */.Z.character.abilities.some((ab) => ab.long.toLowerCase() === name.toLowerCase()))
      .map((name) => {
        const dictAbility = dictionary/* default.character.abilities.find */.Z.character.abilities.find((ab) => ab.long.toLowerCase() === name.toLowerCase());
        return dictAbility.value;
      });
    // eslint-disable-next-line require-atomic-updates
    result.system.saves = saves;
  }

  // "moreDetailsUrl": "/characters/classes/rogue",

  if (klass.equipmentDescription) {
    // eslint-disable-next-line require-atomic-updates
    result.system.description.value += `<p><b>Starting Equipment</b></p>\n${klass.equipmentDescription}\n\n`;
  }

  return result;
}

// EXTERNAL MODULE: ./src/parser/classes/index.js + 1 modules
var classes = __webpack_require__(6103);
;// CONCATENATED MODULE: ./src/muncher/classes/classes.js






// import { buildClassFeatures } from "../../parser/classes/index.js";


async function buildClass(klass, compendiumClassFeatures) {
  let result = await buildBaseClass(klass);
  result.system.description.value += await buildClassFeatures(klass, compendiumClassFeatures);
  result.system.description.value = (0,DDBTemplateStrings/* parseTags */.RN)(result.system.description.value);
  result.system.advancement.push((0,classes/* getHPAdvancement */.$D)(), ...await generateFeatureAdvancements(klass, compendiumClassFeatures));
  result.system.advancement = await (0,classes/* addSRDAdvancements */.WX)(result.system.advancement, result);
  return result;
}

async function getClasses(data) {
  let results = [];
  logger/* default.debug */.Z.debug("get clases started");
  const updateBool = game.settings.get("ddb-importer", "munching-policy-update-existing");

  let klasses = [];
  let classFeatures = [];

  data.forEach((klass) => {
    logger/* default.debug */.Z.debug(`${klass.name} feature parsing started...`);
    klass.classFeatures
      .sort((a, b) => a.requiredLevel - b.requiredLevel)
      .forEach((feature) => {
        const existingFeature = classFeatures.some((f) =>
          f.flags.ddbimporter.featureName === feature.name
          && f.flags.ddbimporter.classId === klass.id
        );
        logger/* default.debug */.Z.debug(`${feature.name} feature starting...`);
        if (!shared_NO_TRAITS.includes(feature.name) && !existingFeature) {
          const parsedFeature = getClassFeature(feature, klass);
          classFeatures.push(parsedFeature);
          results.push({ class: klass.name, subClass: "", feature: feature.name });
        }
      });
  });

  const fiddledClassFeatures = await (0,muncher_import/* srdFiddling */.cC)(classFeatures, "features");
  DDBMuncher.munchNote(`Importing ${fiddledClassFeatures.length} features!`, true);
  logger/* default.debug */.Z.debug(`Importing ${fiddledClassFeatures.length} features!`, classFeatures);
  await (0,muncher_import/* updateCompendium */.X)("features", { features: fiddledClassFeatures }, updateBool);

  const compendium = CompendiumHelper/* default.getCompendiumType */.Z.getCompendiumType("features");
  const index = await compendium.getIndex();
  const firstPassFeatures = await index.filter((i) => fiddledClassFeatures.some((orig) => i.name === orig.name));
  let compendiumClassFeatures = [];

  await Promise.all(firstPassFeatures.map(async (f) => {
    const feature = await compendium.getDocument(f._id);
    compendiumClassFeatures.push(feature.toJSON());
  }));

  await Promise.all(data.map(async (klass) => {
    logger/* default.debug */.Z.debug(`${klass.name} class parsing started...`);
    const builtClass = await buildClass(klass, compendiumClassFeatures);
    klasses.push(builtClass);
  }));

  logger/* default.debug */.Z.debug("Class build finished", klasses);

  const fiddledClasses = await (0,muncher_import/* srdFiddling */.cC)(klasses, "classes");
  DDBMuncher.munchNote(`Importing ${fiddledClasses.length} classes!`, true);

  await (0,muncher_import/* updateCompendium */.X)("classes", { classes: fiddledClasses }, updateBool);

  // return fiddledClasses.concat(fiddledClassFeatures);
  return results;
}

;// CONCATENATED MODULE: ./src/muncher/classes/subclasses.js








// import { buildClassFeatures } from "../../parser/classes/index.js";

async function buildSubClassBase(klass, subClass) {
  delete klass['_id'];

  let avatarUrl;
  let largeAvatarUrl;
  let portraitAvatarUrl;

  if (subClass.portraitAvatarUrl) {
    const downloadOptions = { type: "class-portrait", name: subClass.fullName };
    portraitAvatarUrl = await FileHelper/* default.getImagePath */.Z.getImagePath(subClass.portraitAvatarUrl, downloadOptions);
    // eslint-disable-next-line require-atomic-updates
    klass.img = portraitAvatarUrl;
    // eslint-disable-next-line require-atomic-updates
    klass.flags.ddbimporter['portraitAvatarUrl'] = subClass.portraitAvatarUrl;
  }

  if (subClass.avatarUrl) {
    const downloadOptions = { type: "class-avatar", name: subClass.fullName };
    avatarUrl = await FileHelper/* default.getImagePath */.Z.getImagePath(subClass.avatarUrl, downloadOptions);
    // eslint-disable-next-line require-atomic-updates
    klass.flags.ddbimporter['avatarUrl'] = subClass.avatarUrl;
    if (!klass.img) {
      // eslint-disable-next-line require-atomic-updates
      klass.img = avatarUrl;
    }
  }

  if (subClass.largeAvatarUrl) {
    const downloadOptions = { type: "class-large", name: subClass.fullName };
    largeAvatarUrl = await FileHelper/* default.getImagePath */.Z.getImagePath(subClass.largeAvatarUrl, downloadOptions);
    // eslint-disable-next-line require-atomic-updates
    klass.flags.ddbimporter['largeAvatarUrl'] = subClass.largeAvatarUrl;
    if (!klass.img) {
      // eslint-disable-next-line require-atomic-updates
      klass.img = largeAvatarUrl;
    }
  }

  // eslint-disable-next-line require-atomic-updates
  klass.flags.ddbimporter['parentClassId'] = subClass.parentClassId;
  // eslint-disable-next-line require-atomic-updates
  klass.flags.ddbimporter['spellCastingAbilityId'] = subClass.spellCastingAbilityId;
  // eslint-disable-next-line require-atomic-updates
  klass.flags.ddbimporter['canCastSpells'] = subClass.canCastSpells;
  // eslint-disable-next-line require-atomic-updates
  klass.flags.ddbimporter['moreDetailsUrl'] = subClass.moreDetailsUrl;

  if (avatarUrl || largeAvatarUrl) {
    const imageMatch = /$<img class="ddb-class-image"(.*)$/;
    const image = (avatarUrl)
      ? `<img class="ddb-class-image" src="${avatarUrl}">\n\n`
      : `<img class="ddb-class-image" src="${largeAvatarUrl}">\n\n`;
    klass.system.description.value.replace(imageMatch, image);
  }

  klass.system.classIdentifier = utils/* default.referenceNameString */.Z.referenceNameString(klass.name).toLowerCase();
  klass.system.identifier = utils/* default.referenceNameString */.Z.referenceNameString(subClass.name).toLowerCase();
  klass.type = "subclass";
  klass.name = `${subClass.name} (${klass.name})`;

  // eslint-disable-next-line require-atomic-updates
  klass.system.description.value += `<h3>${subClass.name}</h3>\n${subClass.description}\n\n`;

  // spell caster now?
  // if canCastSpells but now canCastSpells then set to third
  if (klass.system.spellcasting === "" && subClass.canCastSpells) {
    // eslint-disable-next-line require-atomic-updates
    klass.system.spellcasting = "third";
  }

  return klass;

}

async function buildSubClass(klass, subclass, compendiumSubClassFeatures) {
  let baseClass = await buildBaseClass(klass.flags.ddbimporter.data);
  let result = await buildSubClassBase(baseClass, subclass);
  const ignoreIds = klass.flags.ddbimporter.data.classFeatures.map((f) => f.id);
  result.system.description.value += await buildClassFeatures(subclass, compendiumSubClassFeatures, ignoreIds);
  result.system.description.value = (0,DDBTemplateStrings/* parseTags */.RN)(result.system.description.value);
  result.system.advancement.push(...await generateFeatureAdvancements(subclass, compendiumSubClassFeatures, ignoreIds));
  return result;
}

async function getSubClasses(data) {
  logger/* default.debug */.Z.debug("get subclasses started");
  const updateBool = game.settings.get("ddb-importer", "munching-policy-update-existing");

  const classCompendium = CompendiumHelper/* default.getCompendiumType */.Z.getCompendiumType("class");
  const featureCompendium = CompendiumHelper/* default.getCompendiumType */.Z.getCompendiumType("features");
  const content = await classCompendium.getDocuments();
  const fields = ["name", "flags.ddbimporter.classId", "flags.ddbimporter.class", "flags.ddbimporter.featureName", "flags.ddbimporter.subClass", "flags.ddbimporter.parentClassId"];
  const classFeatureIndex = await featureCompendium.getIndex({ fields });

  let subClasses = [];
  let classFeatures = [];
  let results = [];

  data.forEach((subClass) => {
    const classMatch = CONFIG.DDB.classConfigurations.find((k) => k.id === subClass.parentClassId);
    logger/* default.debug */.Z.debug(`${subClass.name} feature parsing started...`);
    subClass.classFeatures
      .filter((feature) =>
        !classFeatureIndex.some((i) => hasProperty(i, "flags.ddbimporter.classId")
        && hasProperty(i, "flags.ddbimporter.featureName")
        && feature.name === i.flags.ddbimporter.featureName
        && subClass.parentClassId === i.flags.ddbimporter.classId)
      )
      .forEach((feature) => {
        const existingFeature = classFeatures.some((f) => f.name === feature.name);
        logger/* default.debug */.Z.debug(`${feature.name} feature starting...`);
        if (!shared_NO_TRAITS.includes(feature.name.trim()) && !existingFeature) {
          const parsedFeature = getClassFeature(feature, subClass, subClass.name);
          classFeatures.push(parsedFeature);
          results.push({ class: classMatch.name, subClass: subClass.name, feature: feature.name });
        }
      });
  });

  const fiddledClassFeatures = await (0,muncher_import/* srdFiddling */.cC)(classFeatures, "features");
  DDBMuncher.munchNote(`Importing ${fiddledClassFeatures.length} features!`, true);
  logger/* default.debug */.Z.debug(`Importing ${fiddledClassFeatures.length} features!`, classFeatures);
  await (0,muncher_import/* updateCompendium */.X)("features", { features: fiddledClassFeatures }, updateBool);

  const importedIndex = await featureCompendium.getIndex({ fields });
  const firstPassFeatures = await importedIndex.filter((i) => fiddledClassFeatures.some((orig) => i.name === orig.name));
  let compendiumClassFeatures = [];

  await Promise.allSettled(firstPassFeatures.map(async (f) => {
    const feature = await featureCompendium.getDocument(f._id);
    compendiumClassFeatures.push(feature.toJSON());
  }));

  logger/* default.debug */.Z.debug("Features fetched", compendiumClassFeatures);

  await Promise.all(data.map(async (subClass) => {
    const classMatch = content.find((i) => i.flags.ddbimporter['id'] == subClass.parentClassId);
    const builtClass = await buildSubClass(classMatch, subClass, compendiumClassFeatures);
    subClasses.push(builtClass);
  }));

  logger/* default.debug */.Z.debug("Subclass build finished", subClasses);

  const fiddledClasses = await (0,muncher_import/* srdFiddling */.cC)(subClasses, "subclasses");
  DDBMuncher.munchNote(`Importing ${fiddledClasses.length} subclasses!`, true);

  await (0,muncher_import/* updateCompendium */.X)("subclasses", { subclasses: fiddledClasses }, updateBool);

  // return fiddledClasses.concat(fiddledClassFeatures);
  return results;
}

;// CONCATENATED MODULE: ./src/muncher/classes/options.js






async function getClassOptions(data, className) {
  logger/* default.debug */.Z.debug("get options started");
  const updateBool = game.settings.get("ddb-importer", "munching-policy-update-existing");
  let results = [];

  let classFeatures = [];
  const classMatch = CONFIG.DDB.classConfigurations.find((k) => k.name === className);

  const klass = {
    name: className,
    id: classMatch.id,
  };

  data.forEach((feature) => {
    const existingFeature = classFeatures.some((f) => f.name === feature.name);
    logger/* default.debug */.Z.debug(`${feature.name} feature starting...`);
    if (!shared_NO_TRAITS.includes(feature.name.trim()) && !existingFeature) {
      const parsedFeature = getClassFeature(feature, klass);
      classFeatures.push(parsedFeature);
      results.push({ class: className, subClass: "", feature: feature.name });
    }
  });

  const fiddledClassFeatures = await (0,muncher_import/* srdFiddling */.cC)(classFeatures, "features");
  DDBMuncher.munchNote(`Importing ${fiddledClassFeatures.length} options!`, true);
  await (0,muncher_import/* updateCompendium */.X)("features", { features: fiddledClassFeatures }, updateBool);

  // return fiddledClassFeatures;
  return results;
}

;// CONCATENATED MODULE: ./src/muncher/classes.js
// Main module class










function getSubClassesData(className) {
  const cobaltCookie = (0,Secrets/* getCobalt */.HF)();
  const campaignId = (0,Settings/* getCampaignId */.F9)();
  const parsingApi = DDBProxy/* default.getProxy */.Z.getProxy();
  const betaKey = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "beta-key");
  const body = { cobalt: cobaltCookie, campaignId: campaignId, betaKey: betaKey, className: className };
  const debugJson = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "debug-json");

  return new Promise((resolve, reject) => {
    fetch(`${parsingApi}/proxy/subclass`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(body),
    })
      .then((response) => response.json())
      .then((data) => {
        if (debugJson) {
          FileHelper/* default.download */.Z.download(JSON.stringify(data), `subclass-${className}-raw.json`, "application/json");
        }
        if (!data.success) {
          DDBMuncher.munchNote(`Failure: ${data.message}`);
          reject(data.message);
        }
        return data;
      })
      .then((data) => getSubClasses(data.data))
      .then((data) => resolve(data))
      .catch((error) => reject(error));
  });
}

function getClassOptionsData(className) {
  const cobaltCookie = (0,Secrets/* getCobalt */.HF)();
  const campaignId = (0,Settings/* getCampaignId */.F9)();
  const parsingApi = DDBProxy/* default.getProxy */.Z.getProxy();
  const betaKey = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "beta-key");
  const body = { cobalt: cobaltCookie, campaignId: campaignId, betaKey: betaKey, className: className };
  const debugJson = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "debug-json");

  return new Promise((resolve, reject) => {
    fetch(`${parsingApi}/proxy/v5/classes/options`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(body),
    })
      .then((response) => response.json())
      .then((data) => {
        if (debugJson) {
          FileHelper/* default.download */.Z.download(JSON.stringify(data), `subclass-${className}-raw.json`, "application/json");
        }
        if (!data.success) {
          DDBMuncher.munchNote(`Failure: ${data.message}`);
          reject(data.message);
        }
        return data;
      })
      .then((data) => getClassOptions(data.data, className))
      .then((data) => resolve(data))
      .catch((error) => reject(error));
  });
}

function getClassesData() {
  const cobaltCookie = (0,Secrets/* getCobalt */.HF)();
  const campaignId = (0,Settings/* getCampaignId */.F9)();
  const parsingApi = DDBProxy/* default.getProxy */.Z.getProxy();
  const betaKey = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "beta-key");
  const body = { cobalt: cobaltCookie, campaignId: campaignId, betaKey: betaKey };
  const debugJson = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "debug-json");

  return new Promise((resolve, reject) => {
    fetch(`${parsingApi}/proxy/classes`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(body),
    })
      .then((response) => response.json())
      .then((data) => {
        if (debugJson) {
          FileHelper/* default.download */.Z.download(JSON.stringify(data), `classes-raw.json`, "application/json");
        }
        if (!data.success) {
          DDBMuncher.munchNote(`Failure: ${data.message}`);
          reject(data.message);
        }
        return data;
      })
      .then((data) => getClasses(data.data))
      .then((data) => resolve(data))
      .catch((error) => reject(error));
  });
}

async function parseClasses() {
  const classesResults = await getClassesData();

  const subClassResults = await Promise.all([
    getSubClassesData("Cleric"),
    getSubClassesData("Druid"),
    getSubClassesData("Sorcerer"),
    getSubClassesData("Warlock"),
    getSubClassesData("Wizard"),
    getSubClassesData("Paladin"),
    getSubClassesData("Ranger"),
    getSubClassesData("Bard"),
    getSubClassesData("Barbarian"),
    getSubClassesData("Fighter"),
    getSubClassesData("Artificer"),
    getSubClassesData("Rogue"),
    getSubClassesData("Monk"),
    getSubClassesData("Blood Hunter"),
  ]);

  const classOptionsResults = await Promise.all([
    getClassOptionsData("Cleric"),
    getClassOptionsData("Druid"),
    getClassOptionsData("Sorcerer"),
    getClassOptionsData("Warlock"),
    getClassOptionsData("Wizard"),
    getClassOptionsData("Paladin"),
    getClassOptionsData("Ranger"),
    getClassOptionsData("Bard"),
    getClassOptionsData("Barbarian"),
    getClassOptionsData("Fighter"),
    getClassOptionsData("Rogue"),
    getClassOptionsData("Monk"),
    getClassOptionsData("Blood Hunter"),
    getClassOptionsData("Artificer"),
  ]);

  const results = classesResults.concat(subClassResults.flat(), classOptionsResults.flat());

  // FileHelper.download(JSON.stringify(results), `classes-icon.json`, "application/json");
  return results;
}



;// CONCATENATED MODULE: ./src/muncher/frames.js
// Main module class







async function getFrameData() {
  const cobaltCookie = (0,Secrets/* getCobalt */.HF)();
  const betaKey = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "beta-key");
  const parsingApi = DDBProxy/* default.getProxy */.Z.getProxy();
  const debugJson = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "debug-json");

  const body = {
    cobalt: cobaltCookie,
    betaKey: betaKey,
  };

  return new Promise((resolve, reject) => {
    fetch(`${parsingApi}/proxy/frames`, {
      method: "POST",
      mode: "cors",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(body), // body data type must match "Content-Type" header
    })
      .then((response) => response.json())
      .then((data) => {
        if (!data.success) {
          DDBMuncher.munchNote(`API Failure: ${data.message}`);
          reject(data.message);
        }
        if (debugJson) {
          FileHelper/* default.download */.Z.download(JSON.stringify(data), `frames-raw.json`, "application/json");
        }
        return data;
      })
      .then((data) => {
        DDBMuncher.munchNote(`Retrieved ${data.data.length} frames, starting parse...`, true, false);
        logger/* default.info */.Z.info(`Retrieved ${data.data.length} frames`);
        resolve(data.data);
      })
      .catch((error) => reject(error));
  });
}

async function parseFrames() {
  const frames = await getFrameData();
  logger/* default.debug */.Z.debug("Importing frames", frames);

  DDBMuncher.munchNote(`Fetching DDB Frames`);
  frames.forEach(async (frame) => {
    const options = { type: "frame", name: `DDB ${frame.name}`, download: true };
    await FileHelper/* default.getImagePath */.Z.getImagePath(frame.frameAvatarUrl, options);
  });

  DDBMuncher.munchNote("");

  return frames.length;
}

// EXTERNAL MODULE: ./src/lib/base64Check.js
var base64Check = __webpack_require__(9460);
// EXTERNAL MODULE: ./src/muncher/adventure.js
var adventure = __webpack_require__(9441);
// EXTERNAL MODULE: ./src/muncher/adventure/AdventureMunch.js
var AdventureMunch = __webpack_require__(1423);
// EXTERNAL MODULE: ./src/muncher/adventure/AdventureMunchHelpers.js
var AdventureMunchHelpers = __webpack_require__(7801);
// EXTERNAL MODULE: ./src/lib/icons.js
var icons = __webpack_require__(3716);
;// CONCATENATED MODULE: ./src/muncher/adventure/PageFinder.js

class PageFinder {

  generateContentLinks() {
    for (const page of this.journal.pages.filter((p) => p.type === "text")) {
      const dom = new DocumentFragment();
      $.parseHTML(page.text.content).forEach((element) => {
        dom.appendChild(element);
      });
      const chunkElements = dom.querySelectorAll("[data-content-chunk-id]");
      const chunkIds = new Set();
      chunkElements.forEach((chunk) => {
        chunkIds.add(chunk.dataset["contentChunkId"]);
      });
      this.contentChunkIds[page._id] = chunkIds;

      const idElements = dom.querySelectorAll("[id]");
      const elementIds = new Set();
      idElements.forEach((chunk) => {
        elementIds.add(chunk.id);
      });
      this.elementIds[page._id] = elementIds;
    }
  }

  constructor(journal) {
    this.journal = journal;
    this.contentChunkIds = {};
    this.elementIds = {};
    this.generateContentLinks();
  }


  // returns page Id if content chunk id known in contents
  getPageIdForContentChunkId(chunkId) {
    for (const [key, value] of Object.entries(this.contentChunkIds)) {
      if (value.has(chunkId)) return key;
    }
    return undefined;
  }

  // returns page Id if element id known in contents
  getPageIdForElementId(elementId) {
    for (const [key, value] of Object.entries(this.elementIds)) {
      if (value.has(elementId)) return key;
      // if (value.has(elementId.replace(/^0+/, ""))) return key;
    }
    return undefined;
  }

}

;// CONCATENATED MODULE: ./src/muncher/adventure/ThirdPartyMunch.js








const MR_PRIMATES_THIRD_PARTY_REPO = "MrPrimate/ddb-third-party-scenes";
const RAW_BASE_URL = `https://raw.githubusercontent.com/${MR_PRIMATES_THIRD_PARTY_REPO}`;
const RAW_MODULES_URL = `${RAW_BASE_URL}/main/modules.json`;

class ThirdPartyMunch extends FormApplication {
  /** @override */
  constructor(object = {}, options = {}) {
    super(object, options);
    this._itemsToRevisit = [];
    this._adventure = {};
    this._scenePackage = {};
    this._packageName = "";
    this._description = "";
    this._pageFinders = {};
    this.adventureMunch = new AdventureMunch/* default */.Z();
  }

  /** @override */
  static get defaultOptions() {
    this.pattern = /(@[a-z]*)(\[)([a-z0-9]*|[a-z0-9.]*)(\])(\{)(.*?)(\})/gmi;
    this.altpattern = /((data-entity)=\\?["']?([a-zA-Z]*)\\?["']?|(data-pack)=\\?["']?([[\S.]*)\\?["']?) data-id=\\?["']?([a-zA-Z0-9]*)\\?["']?.*?>(.*?)<\/a>/gmi;

    return mergeObject(super.defaultOptions, {
      id: "ddb-adventure-import",
      classes: ["ddb-adventure-import"],
      title: "Third Party Munch",
      template: "modules/ddb-importer/handlebars/adventure/import-third.hbs",
      width: 400,
      height: "auto",
    });
  }

  /** @override */
  // eslint-disable-next-line class-methods-use-this
  async getData() {
    let data;
    let packages = [];

    try {
      data = await $.getJSON(RAW_MODULES_URL);
      this._defaultRepoData = data;
      for (const [key, value] of Object.entries(data.packages)) {
        logger/* default.debug */.Z.debug(`${key}: ${value}`);
        packages.push(value);
      }
      const partialScenes = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "third-party-scenes-partial");
      packages = packages
        .filter((p) => p.released || partialScenes)
        .sort((a, b) => a.name.localeCompare(b.last_nom));
      logger/* default.debug */.Z.debug("_defaultRepoData", this._defaultRepoData);
    } catch (err) {
      logger/* default.error */.Z.error(err);
      logger/* default.warn */.Z.warn(`Unable to generate package list.`);
    }

    return {
      data,
      packages,
      cssClass: "ddb-importer-third-party-window"
    };

  }

  /** @override */
  activateListeners(html) {
    super.activateListeners(html);

    html.find(".dialog-button").on("click", this._dialogButton.bind(this));
    html.find("#select-package").on("change", this._selectPackage.bind(this, null, html));
  }

  async _selectPackage(event, html) {
    const packageSelectionElement = html.find("#select-package");

    // get selected campaign from html selection
    const packageSelection = packageSelectionElement[0].selectedOptions[0]
      ? packageSelectionElement[0].selectedOptions[0].value
      : undefined;

    const moduleMessage = html.find("#ddb-message");

    if (packageSelection) {
      const missingModules = [this._defaultRepoData.packages[packageSelection].module].filter((module) => {
        return !game.modules.get(module)?.active;
      });

      this._packageName = packageSelectionElement[0].selectedOptions[0].text;
      this._description = this._defaultRepoData.packages[packageSelection].description;


      let message = "";
      if (missingModules.length > 0) {
        const missingModulesString = missingModules.join(", ");
        message += `<p>You need to install the modules: ${missingModulesString}</p>`;
      }

      const missingBooks = this._defaultRepoData.packages[packageSelection].books.filter((book) => {
        const matchingJournals = game.journal.some((j) => j.flags.ddb?.bookCode === book);
        if (matchingJournals) {
          logger/* default.info */.Z.info(`Found journals for ${book}`);
          return false;
        } else {
          logger/* default.warn */.Z.warn(`Missing journals for ${book}`);
          return true;
        }
      });

      if (missingBooks.length > 0) {
        const bookString = missingBooks.map((bookCode) => ThirdPartyMunch._getDDBBookName(bookCode)).join(", ");
        message += `<p>You need to use Adventure Muncher to load the following books first: ${bookString}</p>`;
      }

      if (this._description && this.description !== "") {
        message += `<p><b>Details</b>: ${this._description}</p>`;
      }

      if (message !== "") {
        moduleMessage[0].innerHTML = message;
        $(".ddb-message").removeClass("import-hidden");
      }

      if (missingBooks.length === 0 && missingModules.length === 0) {
        $(".dialog-button").prop('disabled', false);
      }

    } else {
      moduleMessage[0].innerHTML = "";
      $(".ddb-message").addClass("import-hidden");
    }
    $('#ddb-adventure-import').css("height", "auto");
  }

  async _createFolders(adventure, folders) {
    if (folders) {
      CONFIG.DDBI.ADVENTURE.TEMPORARY.folders["null"] = null;
      CONFIG.DDBI.ADVENTURE.TEMPORARY.lookups = null;

      // the folder list could be out of order, we need to create all folders with parent null first
      const firstLevelFolders = folders.filter((folder) => folder.parent === null);
      await this.adventureMunch.importFolder(firstLevelFolders, adventure, folders);
    }
  }

  async _checkForMissingData(adventure, folders) {
    await this._createFolders(adventure, folders);

    if (adventure.required?.spells && adventure.required.spells.length > 0) {
      logger/* default.debug */.Z.debug(`${adventure.name} - spells required`, adventure.required.spells);
      ThirdPartyMunch._progressNote(`Checking for missing spells from DDB`);
      await AdventureMunchHelpers/* default.checkForMissingDocuments */.Z.checkForMissingDocuments("spell", adventure.required.spells);
    }
    if (adventure.required?.items && adventure.required.items.length > 0) {
      logger/* default.debug */.Z.debug(`${adventure.name} - items required`, adventure.required.items);
      ThirdPartyMunch._progressNote(`Checking for missing items from DDB`);
      await AdventureMunchHelpers/* default.checkForMissingDocuments */.Z.checkForMissingDocuments("item", adventure.required.items);
    }
    if (adventure.required?.monsters && adventure.required.monsters.length > 0) {
      logger/* default.debug */.Z.debug(`${adventure.name} - monsters required`, adventure.required.monsters);
      ThirdPartyMunch._progressNote(`Checking for missing monsters from DDB`);
      await AdventureMunchHelpers/* default.checkForMissingDocuments */.Z.checkForMissingDocuments("monster", adventure.required.monsters);
    }
  }

  static _renderCompleteDialog(title, adventure) {
    new Dialog(
      {
        title: title,
        content: { adventure },
        buttons: { two: { label: "OK" } },
      },
      {
        classes: ["dialog", "adventure-import-export"],
        template: "modules/ddb-importer/handlebars/adventure/import-complete.hbs",
      }
    ).render(true);
  }

  static async _fixupScenes(scenes) {
    try {
      if (scenes.length > 0) {
        let totalCount = scenes.length;
        let currentCount = 0;

        await AdventureMunchHelpers/* default.asyncForEach */.Z.asyncForEach(scenes, async (obj) => {
          try {
            let updatedData = {};
            switch (obj.documentName) {
              case "Scene": {
                // In 0.8.x the thumbs don't seem to be auto generated anymore
                // This code would embed the thumbnail.
                // Remove once/if resolved
                if (!obj.thumb) {
                  const thumbData = await obj.createThumbnail();
                  updatedData["thumb"] = thumbData.thumb;
                }
                await obj.update(updatedData);
                break;
              }
              // no default
            }
          } catch (err) {
            logger/* default.warn */.Z.warn(`Error updating references for scene ${obj}`, err);
          }
          currentCount += 1;
          ThirdPartyMunch._updateProgress(totalCount, currentCount, "References");
        });
      }
    } catch (err) {
      // eslint-disable-next-line no-undef
      logger/* default.warn */.Z.warn(`Error during reference update for object ${item}`, err);
    }
  }

  static async _createFolder(label, type) {
    const folderData = {
      "name": label,
      "type": type,
      "parent": null,
      "sorting": "m",
    };
    const newFolder = await Folder.create(folderData);
    logger/* default.debug */.Z.debug(`Created new folder ${newFolder._id} with data:`, folderData, newFolder);
    return newFolder;
  }

  static async _findFolder(label, type) {
    const folder = game.folders.find((f) =>
      f.type === type
      && f.parentFolder === undefined
      && f.name === label
    );

    return folder ? folder : ThirdPartyMunch._createFolder(label, type);
  }

  static _getDDBBookName(bookCode) {
    const selection = CONFIG.DDB.sources.find((source) => bookCode.toLowerCase() === source.name.toLowerCase());
    return selection.description;
  }

  static _generateMockAdventure(scene) {
    const monsters = scene.flags?.ddbimporter?.export?.actors && scene.flags?.ddb?.tokens
      ? scene.flags.ddb.tokens
        .filter((token) => token.flags?.ddbActorFlags?.id)
        .map((token) => token.flags.ddbActorFlags.id)
      : [];
    return {
      id: randomID(),
      name: ThirdPartyMunch._getDDBBookName(scene.flags.ddb.bookCode),
      description: "",
      system: "dnd5e",
      modules: [],
      version: "2.5",
      options: {
        folders: true
      },
      folderColour: "FF0000",
      required: {
        monsters,
      }
    };
  }

  static _generateActorId(token) {
    if (!hasProperty(token, "flags.ddbActorFlags.id")) logger/* default.warn */.Z.warn("Token does not link to DDB Actor", token);
    const ddbId = token.flags.ddbActorFlags?.id;
    const folderId = token.flags.actorFolderId;
    const key = `${ddbId}-${folderId}`;
    if (CONFIG.DDBI.ADVENTURE.TEMPORARY.mockActors[key]) {
      return CONFIG.DDBI.ADVENTURE.TEMPORARY.mockActors[key];
    } else {
      const existingActor = game.actors.find((actor) => actor.folder?.id == folderId && actor.flags.ddbimporter.id == ddbId);
      const actorId = existingActor ? existingActor.id : randomID();
      CONFIG.DDBI.ADVENTURE.TEMPORARY.mockActors[key] = actorId;
      return actorId;
    }
  }

  static async _linkSceneTokens(scene) {
    logger/* default.info */.Z.info(`Updating ${scene.name}, ${scene.tokens.length} tokens`);
    const tokens = await Promise.all(scene.tokens.map(async (token) => {
      if (token.actorId) {
        const worldActor = game.actors.get(token.actorId);
        if (worldActor) {
          // we merge the override data provided by the token to the actor to get
          // world specific things like img paths and scales etc
          const sceneToken = scene.flags.ddb.tokens.find((t) => t._id === token._id);
          delete sceneToken.scale;
          const tokenData = await worldActor.getTokenDocument();
          delete tokenData.y;
          delete tokenData.x;
          const jsonTokenData = duplicate(tokenData);
          const newToken = mergeObject(jsonTokenData, sceneToken);
          logger/* default.debug */.Z.debug(`${token.name} token data for id ${token.actorId}`, newToken);
          return newToken;
        }
      }
      return token;
    }));
    return tokens;
  }

  async _linkSceneNotes(scene, adventure) {
    const journalNotes = game.journal.filter((journal) => journal?.flags?.ddb?.bookCode === scene.flags.ddb.bookCode);
    this.adventureMunch.adventure = deepClone(adventure);

    const noJournalPinNotes = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "third-party-scenes-notes-merged");

    const notes = await Promise.all([scene]
      .filter((scene) => scene.flags?.ddb?.notes)
      .map((scene) => scene.flags.ddb.notes)
      .flat()
      .map(async (note) => {
        const noteJournal = noJournalPinNotes
          ? journalNotes.find((journal) => journal.flags.ddb.cobaltId == note.flags.ddb.parentId)
          : journalNotes.find((journal) => {
            const contentChunkIdMatch = note.flags.ddb.contentChunkId
              ? journal.flags.ddb && note.flags.ddb
                && journal.flags.ddb.contentChunkId == note.flags.ddb.contentChunkId
              : false;

            const noContentChunk = !note.flags.ddb.contentChunkId
              && note.flags.ddb.originalLink && note.flags.ddb.ddbId && note.flags.ddb.parentId
              && note.flags.ddb.slug && note.flags.ddb.linkName;
            const originMatch = noContentChunk
              ? journal.flags.ddb.slug == note.flags.ddb.slug
                && journal.flags.ddb.ddbId == note.flags.ddbId
                && journal.flags.ddb.parentId == note.flags.ddb.parentId
                && journal.flags.ddb.cobaltId == note.flags.ddb.cobaltId
                && journal.flags.ddb.originalLink == note.flags.ddb.originalLink
                && journal.flags.ddb.linkName == note.flags.ddb.linkName
              : false;
            const journalNameMatch = !contentChunkIdMatch && !originMatch
              ? journal.name.trim() == note.label.trim() // ||
              //  journal.pages.some((page) => page.name.trim() === note.label.trim())
              : false;
            return contentChunkIdMatch || originMatch || journalNameMatch;

          });

        if (noteJournal) {
          logger/* default.info */.Z.info(`Found note "${note.label}" matched to Journal with ID "${noteJournal.id}" (${noteJournal.name})`);
          note.flags.ddb.journalId = noteJournal.id;
          // eslint-disable-next-line require-atomic-updates
          note.icon = await (0,icons/* generateIcon */.r)(this.adventureMunch, note.label);
          if (noJournalPinNotes) {
            note.flags.ddb.labelName = `${note.label}`;
            note.flags.ddb.slugLink = note.label.replace(/[^\w\d]+/g, "").replace(/^([a-zA-Z]?)0+/, "$1");
            note.flags.anchor = {
              slug: note.flags.ddb.slugLink
            };
            note.text = note.label;

            if (!this._pageFinders[noteJournal._id]) {
              this._pageFinders[noteJournal._id] = new PageFinder(noteJournal);
            }
            const contentChunkIdPageId = hasProperty(note, "flags.ddb.contentChunkId")
              ? this._pageFinders[noteJournal._id].getPageIdForContentChunkId(note.flags.ddb.contentChunkId)
              : undefined;
            const slugLinkPageId = hasProperty(note, "flags.ddb.slugLink")
              ? this._pageFinders[noteJournal._id].getPageIdForElementId(note.flags.ddb.slugLink)
              : undefined;

            // console.warn("MATCHES", { slugLinkPageId, contentChunkIdPageId, noteFlags: note.flags.ddb });
            // console.warn("PageIds", noteJournal.pages.map((p) => {return {id: p._id, flags: p.flags.ddb}}));
            const journalPage = noteJournal.pages.find((page) =>
              page.flags.ddb.parentId == note.flags.ddb.parentId
              && (page.flags.ddb.slug == note.flags.ddb.slug
              || page.flags.ddb.slug.replace(/^([a-zA-Z]?)0+/, "$1") == note.flags.ddb.slug
              || page.flags.ddb.slug.startsWith(note.flags.ddb.slug)
              || note.flags.ddb.slug.startsWith(page.flags.ddb.slug))
              && (page._id === contentChunkIdPageId || page._id === slugLinkPageId)
            );

            if (journalPage) {
              note.pageId = journalPage._id;
            }
          }
        }
        return note;
      }));

    const positionedNotes = [];
    notes.forEach((note) => {
      if (note.flags?.ddb?.journalId) {
        note.positions.forEach((position) => {
          logger/* default.info */.Z.info(`Matching ${note.label} to position ${position.x}/${position.y}`);
          const noteId = randomID();
          const n = {
            "_id": noteId,
            "flags": {
              "ddb": note.flags.ddb,
              "importid": noteId,
              "anchor": note.flags.anchor ?? {},
            },
            "entryId": note.flags.ddb.journalId,
            "x": position.x,
            "y": position.y,
            "icon": note.icon, // "assets/icons/1.svg",
            "iconSize": note.iconSize ? note.iconSize : 40,
            "iconTint": "",
            "text": note.text ? note.text : "",
            "fontFamily": note.fontFamily ? note.fontFamily : "Signika",
            "fontSize": note.fontSize ? note.fontSize : 48,
            "textAnchor": 1,
            "textColor": note.textColor ? note.textColor : "",
            "pageId": note.pageId ? note.pageId : undefined,
          };
          positionedNotes.push(n);
        });
      }
    });

    return positionedNotes;
  }

  async _getAdjustedScenes() {
    const adjustedScenes = this._scenePackage.scenes
      .filter((scene) => scene.flags?.ddbimporter?.export?.actors && scene.flags?.ddb?.tokens);

    await AdventureMunchHelpers/* default.asyncForEach */.Z.asyncForEach(adjustedScenes, async(scene) => {
      logger/* default.debug */.Z.debug(`Adjusting scene ${scene.name}`);
      const mockAdventure = ThirdPartyMunch._generateMockAdventure(scene);
      if (scene.flags?.ddbimporter?.export?.actors && scene.flags?.ddb?.tokens) {
        await this._checkForMissingData(mockAdventure, []);
        const bookName = ThirdPartyMunch._getDDBBookName(scene.flags.ddb.bookCode);
        const actorFolder = await ThirdPartyMunch._findFolder(bookName, "Actor");
        scene.tokens = scene.flags.ddb.tokens.map((token) => {
          token.flags.actorFolderId = actorFolder.id;
          token.actorId = ThirdPartyMunch._generateActorId(token);
          return token;
        });

      }
      // eslint-disable-next-line require-atomic-updates
      scene.notes = await this._linkSceneNotes(scene, mockAdventure);
      logger/* default.debug */.Z.debug(`Finished scene adjustment for ${scene.name}`);
    });

    return adjustedScenes;
  }

  async _updateScenes(scenes) {
    logger/* default.debug */.Z.debug("Processing scenes!", scenes);
    const filteredScenes = scenes
      .filter((scene) => scene.flags?.ddbimporter?.export?.compendium)
      // does the scene match a compendium scene
      .filter(async (scene) => {
        const compendium = game.packs.get(scene.flags.ddbimporter.export.compendium);
        const compendiumScene = compendium.index.find((s) => s.name === scene.name);
        if (compendiumScene) return true;
        else return false;
      });

    const processedScenes = [];

    await AdventureMunchHelpers/* default.asyncForEach */.Z.asyncForEach(filteredScenes, async(scene) => {
      logger/* default.debug */.Z.debug(`Processing scene ${scene.name} with DDB Updates`);
      const compendiumId = scene.flags.ddbimporter.export.compendium;
      const compendium = game.packs.get(compendiumId);
      const folderName = this._scenePackage.folder ? this._scenePackage.folder : compendium.metadata.label;
      const folder = await ThirdPartyMunch._findFolder(folderName, "Scene");
      const compendiumScene = compendium.index.find((s) => s.name === scene.name);

      const existingScene = game.scenes.find((s) =>
        s.name === scene.name
        && (s.folder?.id === folder.id || s.folder?.ancestors?.some((f) => f.id === folder.id))
      );

      logger/* default.debug */.Z.debug("Third Party Scene Processing", {
        existingScene,
        scene,
        folder,
        folderName,
        compendiumScene
      });

      // if scene already exists, update
      if (existingScene) {
        logger/* default.info */.Z.info(`Updating ${scene.name}`);
        logger/* default.debug */.Z.debug(`${scene.name}update data`, { scene, existingScene });
        await existingScene.update(scene);
        processedScenes.push(existingScene);
      } else {
        scene.folder = folder.id;
        const worldScene = await game.scenes.importFromCompendium(compendium, compendiumScene._id, scene, { keepId: true });
        logger/* default.info */.Z.info(`Scene: ${scene.name} folder:`, folder);
        logger/* default.debug */.Z.debug("worldScene:", worldScene);
        processedScenes.push(worldScene);
      }
      logger/* default.debug */.Z.debug(`Finished scene DDB update ${scene.name}`);
    });
    return processedScenes;
  }

  async _dialogButton(event) {
    event.preventDefault();
    event.stopPropagation();
    const a = event.currentTarget;
    const action = a.dataset.button;
    const packageName = this._packageName;

    if (action === "import") {
      $(".import-progress").toggleClass("import-hidden");
      $(".ddb-overlay").toggleClass("import-invalid");
      const selectedPackage = $("#select-package").val();
      const packageURL = `${RAW_BASE_URL}/main/${selectedPackage}/module.json`;

      this._scenePackage = await fetch(packageURL)
        .then((response) => {
          if (response.status === 200 || response.status === 0) {
            return Promise.resolve(response.json());
          } else {
            return Promise.reject(new Error(response.statusText));
          }
        });

      // check for valid json object?

      logger/* default.debug */.Z.debug("_scenePackage", this._scenePackage);

      CONFIG.DDBI.ADVENTURE.TEMPORARY = {
        folders: {},
        import: {},
        actors: {},
        sceneTokens: {},
        mockActors: {},
      };

      this.folderNames = this._scenePackage.folder
        ? [this._scenePackage.folder]
        : [...new Set(this._scenePackage.scenes
          .filter((scene) => scene.flags?.ddbimporter?.export?.compendium)
          .map((scene) => {
            const compendiumId = scene.flags.ddbimporter.export.compendium;
            const compendium = game.packs.get(compendiumId);
            return compendium.metadata.label;
          }))];

      // We need to check for potential Scene Folders and Create if missing
      const compendiumLabels = this.folderNames
        .map((label) => {
          return ThirdPartyMunch._findFolder(label, "Scene");
        });

      await Promise.all(compendiumLabels);

      const adventureLabels = [...new Set(this._scenePackage.scenes
        .filter((scene) => scene.flags?.ddb?.bookCode)
        .map((scene) => {
          return ThirdPartyMunch._getDDBBookName(scene.flags.ddb.bookCode);
        }))]
        .map((label) => {
          return ThirdPartyMunch._findFolder(label, "Actor");
        });
      await Promise.all(adventureLabels);

      logger/* default.debug */.Z.debug("Competed folder creation");

      // import any missing monsters into the compendium
      // add tokens to scene
      // add notes to scene
      const adjustedScenes = await this._getAdjustedScenes(this._scenePackage.scenes);

      logger/* default.debug */.Z.debug("adjustedScenes", duplicate(adjustedScenes));

      logger/* default.debug */.Z.debug("About to generate Token Actors");
      // load token actors into world
      await AdventureMunchHelpers/* default.asyncForEach */.Z.asyncForEach(adjustedScenes, async(scene) => {
        logger/* default.debug */.Z.debug(`Generating scene actors for ${scene.name}`);
        await this.adventureMunch.generateTokenActors(scene);
        logger/* default.debug */.Z.debug(`Finished scene actors for ${scene.name}`);
      });

      // link tokens on scene to imported actors
      const tokenAdjustedScenes = await Promise.all(adjustedScenes
        .map(async (scene) => {
          logger/* default.debug */.Z.debug(`Updating scene tokens for ${scene.name}`);
          const newScene = duplicate(scene);
          newScene.tokens = await ThirdPartyMunch._linkSceneTokens(scene);
          return newScene;
        })
      );

      logger/* default.debug */.Z.debug("tokenAdjustedScenes", tokenAdjustedScenes);

      CONFIG.DDBI.ADVENTURE.TEMPORARY.lookups = await (0,adventure/* generateAdventureConfig */.k)(true);
      logger/* default.debug */.Z.debug("Lookups loaded", CONFIG.DDBI.ADVENTURE.TEMPORARY.lookups.lookups);

      const scenes = await this._updateScenes(tokenAdjustedScenes);
      // logger.debug("finalScenes", scenes);

      const toTimer = setTimeout(() => {
        logger/* default.warn */.Z.warn(`Reference update timed out.`);
        ThirdPartyMunch._renderCompleteDialog(`Un-Successful Import of ${packageName}`, { name: packageName });
        this.close();
      }, 120000);

      // clearup remaining scene things
      await ThirdPartyMunch._fixupScenes(scenes);
      clearTimeout(toTimer);

      $(".ddb-overlay").toggleClass("import-invalid");

      ThirdPartyMunch._renderCompleteDialog(`Successful Import of ${packageName}`, { name: packageName });

      // eslint-disable-next-line require-atomic-updates
      CONFIG.DDBI.ADVENTURE.TEMPORARY = {};
      this.close();
    }
  }

  static _updateProgress(total, count, type) {
    const localizedType = `ddb-importer.label.${type}`;
    $(".import-progress-bar")
      .width(`${Math.trunc((count / total) * 100)}%`)
      .html(`<span>${game.i18n.localize("ddb-importer.label.Working")} (${game.i18n.localize(localizedType)})...</span>`);
  }

  static _progressNote(note) {
    $(".import-progress-bar")
      .html(`<span>${game.i18n.localize("ddb-importer.label.Working")} (${note})...</span>`);
  }
}

// EXTERNAL MODULE: ./src/muncher/MuncherSettings.js
var MuncherSettings = __webpack_require__(7004);
// EXTERNAL MODULE: ./src/muncher/compendiumFolders.js
var compendiumFolders = __webpack_require__(6269);
// EXTERNAL MODULE: ./src/effects/macros.js
var macros = __webpack_require__(3752);
// EXTERNAL MODULE: ./src/muncher/tools.js
var tools = __webpack_require__(8089);
// EXTERNAL MODULE: ./src/parser/character/bio.js
var bio = __webpack_require__(2331);
;// CONCATENATED MODULE: ./src/muncher/backgrounds/backgrounds.js








const BACKGROUND_TEMPLATE = {
  "name": "",
  "type": "background",
  "system": {
    "description": {
      "value": "",
      "chat": "",
      "unidentified": ""
    },
    "type": {
      "value": "background",
    },
    "source": "",
  },
  "sort": 2600000,
  "flags": {
    "ddbimporter": {},
    "obsidian": {
      "source": {
        "type": "background"
      }
    },
  },
  "img": "icons/skills/trades/academics-book-study-purple.webp",
};

function backgrounds_buildBase(data) {
  let result = duplicate(BACKGROUND_TEMPLATE);
  const bgData = (0,bio/* generateBackground */.E)(data);
  result.name = data.name;
  result.system.description.value += `${bgData.description}\n\n`;

  result.flags.ddbimporter = {
    featId: data.id,
    version: CONFIG.DDBI.version,
  };

  result.system.source = DDBHelper/* default.parseSource */.Z.parseSource(data);
  result.system.description.value = (0,DDBTemplateStrings/* parseTags */.RN)(result.system.description.value);
  result.system.description.value = (0,table/* generateTable */.p)(result.name, result.system.description.value, true, "background");

  return result;
}


function buildBackground(background) {
  let result = backgrounds_buildBase(background);

  return result;
}


async function getBackgrounds(data) {
  logger/* default.debug */.Z.debug("get backgrounds started");
  const updateBool = game.settings.get("ddb-importer", "munching-policy-update-existing");

  let backgrounds = [];

  // console.warn(data);

  data.forEach((background) => {
    logger/* default.debug */.Z.debug(`${background.name} background parsing started...`);
    const parsedBackground = buildBackground(background);
    backgrounds.push(parsedBackground);
  });

  // console.warn("backgrounds", backgrounds);

  const fiddledBackgrounds = await (0,muncher_import/* srdFiddling */.cC)(backgrounds, "backgrounds");
  const finalBackgrounds = await (0,muncher_import/* daeFiddling */.xh)(fiddledBackgrounds);

  DDBMuncher.munchNote(`Importing ${finalBackgrounds.length} backgrounds!`, true);
  await (0,muncher_import/* updateCompendium */.X)("backgrounds", { backgrounds: finalBackgrounds }, updateBool);

  return finalBackgrounds;
}

;// CONCATENATED MODULE: ./src/muncher/backgrounds.js
// Main module class








function getBackgroundData() {
  const cobaltCookie = (0,Secrets/* getCobalt */.HF)();
  const campaignId = (0,Settings/* getCampaignId */.F9)();
  const parsingApi = DDBProxy/* default.getProxy */.Z.getProxy();
  const betaKey = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "beta-key");
  const body = { cobalt: cobaltCookie, campaignId: campaignId, betaKey: betaKey };
  const debugJson = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "debug-json");

  return new Promise((resolve, reject) => {
    fetch(`${parsingApi}/proxy/backgrounds`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(body),
    })
      .then((response) => response.json())
      .then((data) => {
        if (debugJson) {
          FileHelper/* default.download */.Z.download(JSON.stringify(data), `backgrounds-raw.json`, "application/json");
        }
        if (!data.success) {
          DDBMuncher.munchNote(`Failure: ${data.message}`);
          reject(data.message);
        }
        return data;
      })
      .then((data) => getBackgrounds(data.data))
      .then((data) => resolve(data))
      .catch((error) => reject(error));
  });
}

async function parseBackgrounds() {
  const results = await getBackgroundData();

  return results;
}

// EXTERNAL MODULE: ./src/muncher/vehicles.js + 10 modules
var vehicles = __webpack_require__(1187);
// EXTERNAL MODULE: ./src/lib/DDBSources.js
var DDBSources = __webpack_require__(5817);
// EXTERNAL MODULE: ./src/muncher/DDBMonsterFactory.js
var DDBMonsterFactory = __webpack_require__(6870);
;// CONCATENATED MODULE: ./src/muncher/DDBMuncher.js
// Main module class
























class DDBMuncher extends Application {
  static get defaultOptions() {
    const options = super.defaultOptions;
    options.id = "ddb-importer-monsters";
    options.template = "modules/ddb-importer/handlebars/munch.hbs";
    options.resizable = false;
    options.height = "auto";
    options.width = 800;
    options.title = "MrPrimate's Muncher";
    options.classes = ["ddb-muncher", "sheet"];
    options.tabs = [{ navSelector: ".tabs", contentSelector: "div", initial: "settings" }];
    return options;
  }

  /**
   * Display information when Munching
   * @param {*} note
   * @param {*} nameField
   * @param {*} monsterNote
   */
  static munchNote(note, nameField = false, monsterNote = false) {
    if (nameField) {
      $("#munching-task-name").text(note);
      $("#ddb-importer-monsters").css("height", "auto");
    } else if (monsterNote) {
      $("#munching-task-monster").text(note);
      $("#ddb-importer-monsters").css("height", "auto");
    } else {
      $("#munching-task-notes").text(note);
      $("#ddb-importer-monsters").css("height", "auto");
    }
  }

  static munchMonsters() {
    DDBMuncher.munchNote(`Downloading monsters...`, true);
    $('button[id^="munch-"]').prop('disabled', true);
    $('button[id^="adventure-config-start"]').prop('disabled', true);
    DDBMuncher.parseCritters();
  }

  static munchVehicles() {
    DDBMuncher.munchNote(`Downloading vehicles...`, true);
    $('button[id^="munch-"]').prop('disabled', true);
    $('button[id^="adventure-config-start"]').prop('disabled', true);
    DDBMuncher.parseTransports();
  }

  activateListeners(html) {
    super.activateListeners(html);
    html.find("#munch-monsters-start").click(async () => {
      DDBMuncher.munchMonsters();
    });
    html.find("#munch-vehicles-start").click(async () => {
      DDBMuncher.munchVehicles();
    });
    html.find("#munch-source-select").click(async () => {
      new DDBSources/* default */.Z().render(true);
    });

    html.find("#munch-spells-start").click(async () => {
      DDBMuncher.munchNote(`Downloading spells...`, true);
      $('button[id^="munch-"]').prop('disabled', true);
      DDBMuncher.parseSpells();
    });
    html.find("#munch-items-start").click(async () => {
      DDBMuncher.munchNote(`Downloading items...`, true);
      $('button[id^="munch-"]').prop('disabled', true);
      DDBMuncher.parseItems();
    });
    html.find("#munch-races-start").click(async () => {
      DDBMuncher.munchNote(`Downloading races...`, true);
      $('button[id^="munch-"]').prop('disabled', true);
      DDBMuncher.parseRaces();
    });
    html.find("#munch-feats-start").click(async () => {
      DDBMuncher.munchNote(`Downloading feats...`, true);
      $('button[id^="munch-"]').prop('disabled', true);
      DDBMuncher.parseFeats();
    });
    html.find("#munch-backgrounds-start").click(async () => {
      DDBMuncher.munchNote(`Downloading backgrounds...`, true);
      $('button[id^="munch-"]').prop('disabled', true);
      DDBMuncher.parseBackgrounds();
    });
    html.find("#munch-classes-start").click(async () => {
      DDBMuncher.munchNote(`Downloading classes...`, true);
      $('button[id^="munch-"]').prop('disabled', true);
      DDBMuncher.parseClasses();
    });
    html.find("#munch-frames-start").click(async () => {
      DDBMuncher.munchNote(`Downloading frames...`, true);
      $('button[id^="munch-"]').prop('disabled', true);
      DDBMuncher.parseFrames();
    });
    html.find("#munch-adventure-config-start").click(async () => {
      DDBMuncher.munchNote(`Generating config file...`, true);
      $('button[id^="munch-"]').prop('disabled', true);
      DDBMuncher.generateAdventureConfig();
    });
    html.find("#munch-adventure-import-start").click(async () => {
      new AdventureMunch/* default */.Z().render(true);
    });
    html.find("#munch-adventure-third-party-start").click(async () => {
      new ThirdPartyMunch().render(true);
    });
    html.find("#munch-migrate-compendium-monster").click(async () => {
      DDBMuncher.munchNote(`Migrating monster compendium...`, true);
      $('button[id^="munch-"]').prop('disabled', true);
      DDBMuncher.migrateCompendiumFolders("monsters");
    });
    html.find("#munch-migrate-compendium-spell").click(async () => {
      DDBMuncher.munchNote(`Migrating spell compendium...`, true);
      $('button[id^="munch-"]').prop('disabled', true);
      DDBMuncher.migrateCompendiumFolders("spells");
    });
    html.find("#munch-migrate-compendium-item").click(async () => {
      DDBMuncher.munchNote(`Migrating item compendium...`, true);
      $('button[id^="munch-"]').prop('disabled', true);
      DDBMuncher.migrateCompendiumFolders("items");
    });
    html.find("#munch-fix-base64").click(async () => {
      DDBMuncher.munchNote(`Checking Scenes for base64 data...`, true);
      $('button[id^="munch-"]').prop('disabled', true);
      DDBMuncher.base64Check();
    });
    html.find("#munch-world-monster-update").click(async () => {
      DDBMuncher.munchNote(`Updating world actors...`, true);
      $('button[id^="munch-"]').prop('disabled', true);
      DDBMuncher.updateWorldMonsters();
    });
    html.find("#munch-reset-images").click(async () => {
      DDBMuncher.munchNote(`Resetting images...`, true);
      $('button[id^="munch-"]').prop('disabled', true);
      DDBMuncher.resetCompendiumActorImages();
    });

    // watch the change of the import-policy-selector checkboxes
    $(html)
      .find(
        [
          '.munching-generic-config input[type="checkbox"]',
          '.munching-spell-config input[type="checkbox"]',
          '.munching-item-config input[type="checkbox"]',
          '.munching-monster-config input[type="checkbox"]',
          '.munching-monster-world-update-config input[type="checkbox"]',
        ].join(",")
      )
      .on("change", (event) => {
        MuncherSettings/* default.updateMuncherSettings */.Z.updateMuncherSettings(html, event, this);
      });


    html.find("#monster-munch-filter").on("keyup", (event) => {
      event.preventDefault();
      if (event.key !== "Enter") return; // Use `.key` instead.
      DDBMuncher.munchMonsters();
    });

    // compendium style migrations
    html.find("#compendium-folder-style-monster").on("change", async () => {
      const style = html.find("#compendium-folder-style-monster");
      const importStyle = style[0].selectedOptions[0] ? style[0].selectedOptions[0].value : "TYPE";
      game.settings.set("ddb-importer", "munching-selection-compendium-folders-monster", importStyle);
    });
    html.find("#compendium-folder-style-spell").on("change", async () => {
      const style = html.find("#compendium-folder-style-spell");
      const importStyle = style[0].selectedOptions[0] ? style[0].selectedOptions[0].value : "SCHOOL";
      game.settings.set("ddb-importer", "munching-selection-compendium-folders-spell", importStyle);
    });
    html.find("#compendium-folder-style-item").on("change", async () => {
      const style = html.find("#compendium-folder-style-item");
      const importStyle = style[0].selectedOptions[0] ? style[0].selectedOptions[0].value : "TYPE";
      game.settings.set("ddb-importer", "munching-selection-compendium-folders-item", importStyle);
    });

    this.close();
  }

  static enableButtons() {
    const cobalt = (0,Secrets/* getCobalt */.HF)() != "";
    const tier = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "patreon-tier");
    const tiers = PatreonHelper/* default.getPatreonTiers */.Z.getPatreonTiers(tier);

    if (cobalt) {
      $('button[id^="munch-spells-start"]').prop('disabled', false);
      $('button[id^="munch-items-start"]').prop('disabled', false);
      $('button[id^="munch-adventure-config-start"]').prop('disabled', false);
      $('button[id^="munch-adventure-import-start"]').prop('disabled', false);
      $('button[id^="munch-adventure-third-party-start"]').prop('disabled', false);
      $('button[id^="munch-migrate-compendium-monster"]').prop('disabled', false);
      $('button[id^="munch-migrate-compendium-spell"]').prop('disabled', false);
      $('button[id^="munch-migrate-compendium-item"]').prop('disabled', false);
      $('button[id^="munch-fix-base64"]').prop('disabled', false);
      $('button[id^="munch-reset-images"]').prop('disabled', false);

      if (tiers.all) {
        $('button[id^="munch-monsters-start"]').prop('disabled', false);
        $('button[id^="munch-source-select"]').prop('disabled', false);
      }
      if (tiers.supporter) {
        $('button[id^="munch-races-start"]').prop('disabled', false);
        $('button[id^="munch-feats-start"]').prop('disabled', false);
        $('button[id^="munch-frames-start"]').prop('disabled', false);
        $('button[id^="munch-classes-start"]').prop('disabled', false);
        $('button[id^="munch-backgrounds-start"]').prop('disabled', false);
      }
      if (tiers.experimentalMid) {
        $('button[id^="munch-vehicles-start"]').prop('disabled', false);
      }
    }
  }

  static async parseCritters() {
    try {
      logger/* default.info */.Z.info("Munching monsters!");
      const monsterFactory = new DDBMonsterFactory/* default */.Z({ munchNote: DDBMuncher.munchNote });
      const result = await monsterFactory.processIntoCompendium();
      DDBMuncher.munchNote(`Finished importing ${result} monsters!`, true);
      DDBMuncher.munchNote("");
      DDBMuncher.enableButtons();
    } catch (error) {
      logger/* default.error */.Z.error(error);
      logger/* default.error */.Z.error(error.stack);
    }
  }

  static async parseTransports() {
    try {
      logger/* default.info */.Z.info("Munching vehicles!");
      const result = await (0,vehicles/* parseTransports */.b)();
      DDBMuncher.munchNote(`Finished importing ${result} vehicles!`, true);
      DDBMuncher.munchNote("");
      DDBMuncher.enableButtons();
    } catch (error) {
      logger/* default.error */.Z.error(error);
      logger/* default.error */.Z.error(error.stack);
    }
  }

  static async parseSpells() {
    try {
      logger/* default.info */.Z.info("Munching spells!");
      if (game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "munching-policy-add-spell-effects")) await (0,macros/* createGMMacros */.Kk)("spells");
      await (0,spells/* parseSpells */.Z)();
      DDBMuncher.munchNote(`Finished importing spells!`, true);
      DDBMuncher.munchNote("");
      DDBMuncher.enableButtons();
    } catch (error) {
      logger/* default.error */.Z.error(error);
      logger/* default.error */.Z.error(error.stack);
    }
  }

  static async parseItems() {
    try {
      logger/* default.info */.Z.info("Munching items!");
      await (0,items/* parseItems */.S)();
      DDBMuncher.munchNote(`Finished importing items!`, true);
      DDBMuncher.munchNote("");
      DDBMuncher.enableButtons();
    } catch (error) {
      logger/* default.error */.Z.error(error);
      logger/* default.error */.Z.error(error.stack);
    }
  }

  static async parseRaces() {
    try {
      logger/* default.info */.Z.info("Munching races!");
      const result = await parseRaces();
      DDBMuncher.munchNote(`Finished importing ${result.length} races and features!`, true);
      DDBMuncher.munchNote("");
      DDBMuncher.enableButtons();
    } catch (error) {
      logger/* default.error */.Z.error(error);
      logger/* default.error */.Z.error(error.stack);
    }
  }

  static async parseFeats() {
    try {
      logger/* default.info */.Z.info("Munching feats!");
      const result = await parseFeats();
      DDBMuncher.munchNote(`Finished importing ${result.length} feats!`, true);
      DDBMuncher.munchNote("");
      DDBMuncher.enableButtons();
    } catch (error) {
      logger/* default.error */.Z.error(error);
      logger/* default.error */.Z.error(error.stack);
    }
  }

  static async parseBackgrounds() {
    try {
      logger/* default.info */.Z.info("Munching backgrounds!");
      const result = await parseBackgrounds();
      DDBMuncher.munchNote(`Finished importing ${result.length} backgrounds!`, true);
      DDBMuncher.munchNote("");
      DDBMuncher.enableButtons();
    } catch (error) {
      logger/* default.error */.Z.error(error);
      logger/* default.error */.Z.error(error.stack);
    }
  }

  static async parseClasses() {
    try {
      logger/* default.info */.Z.info("Munching classes!");
      const result = await parseClasses();
      DDBMuncher.munchNote(`Finished importing ${result.length} classes and features!`, true);
      DDBMuncher.munchNote("");
      DDBMuncher.enableButtons();
    } catch (error) {
      logger/* default.error */.Z.error(error);
      logger/* default.error */.Z.error(error.stack);
    }
  }

  static async parseFrames() {
    try {
      logger/* default.info */.Z.info("Munching frames!");
      const result = await parseFrames();
      DDBMuncher.munchNote(`Finished importing ${result.length} frames!`, true);
      DDBMuncher.munchNote("");
      DDBMuncher.enableButtons();
    } catch (error) {
      logger/* default.error */.Z.error(error);
      logger/* default.error */.Z.error(error.stack);
    }
  }

  static async generateAdventureConfig() {
    try {
      logger/* default.info */.Z.info("Generating adventure config!");
      await (0,adventure/* downloadAdventureConfig */.T)();
      DDBMuncher.munchNote(`Downloading config file`, true);
      DDBMuncher.munchNote("");
      DDBMuncher.enableButtons();
    } catch (error) {
      logger/* default.error */.Z.error(error);
      logger/* default.error */.Z.error(error.stack);
    }
  }

  static async updateWorldMonsters() {
    try {
      logger/* default.info */.Z.info("Updating world monsters!");
      await (0,tools/* updateWorldMonsters */.BU)();
      DDBMuncher.enableButtons();
    } catch (error) {
      logger/* default.error */.Z.error(error);
      logger/* default.error */.Z.error(error.stack);
    }
  }

  static async migrateCompendiumFolders(type) {
    logger/* default.info */.Z.info(`Migrating ${type} compendium`);
    await (0,compendiumFolders/* migrateExistingCompendium */.W3)(type);
    DDBMuncher.munchNote(`Migrating complete.`, true);
    DDBMuncher.enableButtons();
  }

  static async base64Check() {
    logger/* default.info */.Z.info("Checking base64 in scenes");
    const results = (0,base64Check/* base64Check */.g)();
    let notifyString = `Check complete.`;
    if (results.fixedScenes.length === 0 && results.badScenes.length === 0) {
      notifyString += " No problems found.";
    } else {
      if (results.fixedScenes.length > 0) notifyString += ` Fixing ${results.fixedScenes.length} scenes (wait untill uploads complete).`;
      if (results.badScenes.length > 0) notifyString += ` Found ${results.badScenes.length} scenes that I couldn't fix.`;
    }
    DDBMuncher.munchNote(notifyString, true);
    DDBMuncher.enableButtons();
  }

  static async resetCompendiumActorImages() {
    logger/* default.info */.Z.info("Resetting compendium actor images");
    const results = await (0,tools/* resetCompendiumActorImages */.mk)();
    const notifyString = `Reset ${results.length} compendium actors.`;
    DDBMuncher.munchNote(notifyString, true);
    DDBMuncher.enableButtons();
  }

  async getData() { // eslint-disable-line class-methods-use-this
    const resultData = MuncherSettings/* default.getMuncherSettings */.Z.getMuncherSettings();
    await (0,DDBTemplateStrings/* importCacheLoad */.uB)();
    return resultData;
  }
}


/***/ }),

/***/ 7004:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5259);
/* harmony import */ var _lib_FileHelper_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2397);
/* harmony import */ var _lib_PatreonHelper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(8636);
/* harmony import */ var _lib_Secrets_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(2048);
/* harmony import */ var _lib_DDBSources_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(5817);
/* harmony import */ var _effects_specialSpells_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(7980);
/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(6451);
// import logger from "../logger.js";








const MuncherSettings = {

  setRecommendedCharacterActiveEffectSettings: (html) => {
    $(html).find("#character-import-policy-dae-effect-copy").prop("checked", !(0,_effects_specialSpells_js__WEBPACK_IMPORTED_MODULE_5__/* .spellEffectModules */ .fM)().hasCore);
    game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-dae-effect-copy", !(0,_effects_specialSpells_js__WEBPACK_IMPORTED_MODULE_5__/* .spellEffectModules */ .fM)().hasCore);
    $(html).find("#character-import-policy-add-spell-effects").prop("checked", (0,_effects_specialSpells_js__WEBPACK_IMPORTED_MODULE_5__/* .spellEffectModules */ .fM)().hasCore);
    game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-add-spell-effects", (0,_effects_specialSpells_js__WEBPACK_IMPORTED_MODULE_5__/* .spellEffectModules */ .fM)().hasCore);
    $(html).find("#character-import-policy-dae-effect-copy").prop("checked", false);
    game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-dae-effect-copy", false);
    $(html).find("#character-import-policy-add-item-effects").prop("checked", true);
    game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-add-item-effects", true);
    $(html).find("#character-import-policy-add-character-effects").prop("checked", true);
    game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-add-character-effects", true);
    $(html).find("#character-import-policy-generate-ac-feature-effects").prop("checked", true);
    game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-generate-ac-feature-effects", true);
    $(html).find("#character-import-policy-active-effect-copy").prop("checked", false);
    game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-active-effect-copy", false);

    ["class", "race", "background", "feat"].forEach((type) => {
      $(html).find(`#character-import-policy-effect-${type}-spell-bonus`).prop("checked", true);
      game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, `character-update-policy-effect-${type}-spell-bonus`, true);
      $(html).find(`#character-import-policy-effect-${type}-speed`).prop("checked", false);
      game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, `character-update-policy-effect-${type}-speed`, false);
      $(html).find(`#character-import-policy-effect-${type}-senses`).prop("checked", false);
      game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, `character-update-policy-effect-${type}-senses`, false);
      $(html).find(`#character-import-policy-effect-${type}-hp`).prop("checked", false);
      game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, `character-update-policy-effect-${type}-hp`, false);
      $(html).find(`#character-import-policy-effect-${type}-damages`).prop("checked", false);
      game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, `character-update-policy-effect-${type}-damages`, false);
    });
  },

  getInstalledIcon: (name) => {
    return (0,_effects_specialSpells_js__WEBPACK_IMPORTED_MODULE_5__/* .spellEffectModules */ .fM)()[name] ? "<i class='fas fa-check-circle' style='color: green'></i>" : "<i class='fas fa-times-circle' style='color: red'></i> ";
  },

  getCharacterImportSettings: () => {
    const importPolicies1 = [
      {
        name: "name",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-name"),
        description: "Name",
      },
      {
        name: "hp",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-hp"),
        description: "HP",
      },
      {
        name: "hit-die",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-hit-die"),
        description: "Hit Die",
      },
      {
        name: "image",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-image"),
        description: "Image",
      },
      {
        name: "bio",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-bio"),
        description: "Bio",
      },
      {
        name: "languages",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-languages"),
        description: "Languages",
      },
      {
        name: "spell-use",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-spell-use"),
        description: "Spell Slots",
      }
    ];
    const importPolicies2 = [
      {
        name: "class",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-class"),
        description: "Classes",
      },
      {
        name: "feat",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-feat"),
        description: "Features",
      },
      {
        name: "weapon",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-weapon"),
        description: "Weapons",
      },
      {
        name: "equipment",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-equipment"),
        description: "Other Equipment",
      },
      {
        name: "currency",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-currency"),
        description: "Currency",
      },
      {
        name: "spell",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-spell"),
        description: "Spells",
      },
    ];

    const spellEffectModulesAvailable = (0,_effects_specialSpells_js__WEBPACK_IMPORTED_MODULE_5__/* .spellEffectModules */ .fM)();
    const generateSpellEffects = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-add-spell-effects");
    if (generateSpellEffects && !spellEffectModulesAvailable.hasCore) {
      game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-add-spell-effects", false);
    }
    const daeInstalled = spellEffectModulesAvailable.daeInstalled;
    // disable srd/midi srd copy as v10 does not work
    // const daeSRDInstalled = game.modules.get("Dynamic-Effects-SRD")?.active;
    // const midiSRDInstalled = game.modules.get("midi-srd")?.active;
    // const daeSRDContentAvailable = (daeSRDInstalled || midiSRDInstalled);
    const featureEffectText = `Generate effects for a character. Some effects are always generated, some are optional (see below). These require DAE${MuncherSettings.getInstalledIcon("daeInstalled")}. For best results Midi-QOL${MuncherSettings.getInstalledIcon("midiQolInstalled")}, Advanced Macros${MuncherSettings.getInstalledIcon("advancedMacrosInstalled")}, Item Macro${MuncherSettings.getInstalledIcon("itemMacroInstalled")}, Times Up${MuncherSettings.getInstalledIcon("timesUp")}, and Convenient Effects${MuncherSettings.getInstalledIcon("convenientEffectsInstalled")} are strongly recommended.`;
    const spellEffectText = `Generate effects for spells. These require DAE${MuncherSettings.getInstalledIcon("daeInstalled")}, Midi-QOL${MuncherSettings.getInstalledIcon("midiQolInstalled")}, Advanced Macros${MuncherSettings.getInstalledIcon("advancedMacrosInstalled")}, Item Macro${MuncherSettings.getInstalledIcon("itemMacroInstalled")}, Times Up${MuncherSettings.getInstalledIcon("timesUp")}, and Convenient Effects${MuncherSettings.getInstalledIcon("convenientEffectsInstalled")} as a minimum. Also recommened is Active Auras${MuncherSettings.getInstalledIcon("activeAurasInstalled")}, Active Token Effects${MuncherSettings.getInstalledIcon("atlInstalled")}, Token Magic FX${MuncherSettings.getInstalledIcon("tokenMagicInstalled")}, and Automated Animations${MuncherSettings.getInstalledIcon("autoAnimationsInstalled")}`;

    // const importExtras = game.settings.get(SETTINGS.MODULE_ID, "character-update-policy-import-extras");

    const importConfig = [
      {
        name: "use-inbuilt-icons",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-use-inbuilt-icons"),
        description: "Use icons from the inbuilt dictionary. (High coverage of items, feats, and spells).",
        enabled: true,
      },
      {
        name: "use-srd-icons",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-use-srd-icons"),
        description: "Use icons from the SRD compendium. (This can take a while).",
        enabled: true,
      },
      {
        name: "use-ddb-spell-icons",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-use-ddb-spell-icons"),
        description: "Use spell school icons from D&DBeyond.",
        enabled: true,
      },
      {
        name: "use-ddb-item-icons",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-use-ddb-item-icons"),
        description: "Use equipment icons from D&DBeyond (where they exist).",
        enabled: true,
      },
      {
        name: "use-ddb-generic-item-icons",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-use-ddb-generic-item-icons"),
        description: "Use D&D Beyond generic item type images, if available (final fallback)",
        enabled: true,
      },
      {
        name: "use-full-description",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-use-full-description"),
        description: "For actions use full description and snippets, else use snippets only.",
        enabled: true,
      },
      {
        name: "use-actions-as-features",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-use-actions-as-features"),
        description:
          "Import D&D Beyond Actions as Features, not weapons.",
        enabled: true,
      },
      {
        name: "use-action-and-feature",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-use-action-and-feature"),
        description:
          "[CAUTION] If a feature is marked as an action, import both the action and the feature. This might lead to some weird behaviour.",
        enabled: true,
      },
      {
        name: "ignore-non-ddb-items",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-ignore-non-ddb-items"),
        description:
          "Ignore items on character sheet that have not been imported from D&D Beyond. This will remove items that have been removed from the DDB character since the last import, but will keep items added to the character within Foundry.",
        enabled: true,
      },
      {
        name: "use-item-containers",
        isChecked: game.modules.get("itemcollection")?.active && game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-use-item-containers"),
        description: "If Item Collection/Containers module is installed, put items in containers to match DDB layout",
        enabled: game.modules.get("itemcollection")?.active,
      },
      {
        name: "create-companions",
        isChecked: game.modules.get("arbron-summoner")?.active && game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-create-companions"),
        description: "[Experimental] Generate summon monster actors? (Requires item create permissions and Arbron Summoner module)",
        enabled: game.modules.get("arbron-summoner")?.active,
      },
    ];

    const advancedImportConfig = [
      {
        name: "use-scalevalue",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-use-scalevalue"),
        title: "Generate Scale Value links in damage fields",
        description:
          "If not enabled will use fixed value for the current level.",
        enabled: true,
      },
      {
        name: "use-scalevalue-description",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-use-scalevalue-description"),
        title: "Generate Scale Value links in descriptions",
        description:
          "If not enabled will use fixed value for the current level.",
        enabled: true,
      },
      {
        name: "use-override",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-use-override"),
        title: "Replace Items using those in your Override compendium",
        description:
          "Use existing items from <i>ddb-import Override compendium</i>, rather than parsing from DDB. This is useful if you want to place customised items into the compendium for use by characters.",
        enabled: true,
      },
      {
        name: "use-existing",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-use-existing"),
        title: "[Caution] Replace Items using ddb-importer compendiums",
        description:
          "Use existing items from <i>ddb-import compendiums</i>, rather than parsing from DDB. This is useful if you have customised the items in the compendium, although you will lose any custom effects applied by this module e.g. Improved Divine Smite. Please consider marking the item you wish to keep as ignored by import instead.",
        enabled: true,
      },
      {
        name: "use-srd",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-use-srd"),
        title: "[Caution] Replace Items using SRD compendiums",
        description:
          "Use the <i>SRD compendiums</i>, rather than DDB. Importing using SRD will not include features like fighting style and divine smite in damage calculations. Please consider marking the item you wish to keep as ignored by import instead.",
        enabled: true,
      },
    ];

    const effectImportConfig = [
      {
        name: "add-item-effects",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-add-item-effects") && daeInstalled,
        title: "Generate Effects for Equipment",
        description: "Generate effects for a characters equipment, doesn't include AC effects on armor, but will for things like the Ring of Protection.",
        enabled: daeInstalled,
      },
      {
        name: "add-spell-effects",
        isChecked: generateSpellEffects && spellEffectModulesAvailable.hasCore,
        title: "Generate Active Effects for Spells",
        description: spellEffectText,
        enabled: spellEffectModulesAvailable.hasCore,
      },
      {
        name: "add-character-effects",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-add-character-effects") && daeInstalled,
        title: "Generate Effects for Character Features/Racial Traits/Feats/Backgrounds",
        description: featureEffectText,
        enabled: daeInstalled,
      },
      {
        name: "generate-ac-feature-effects",
        isChecked:
          game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-generate-ac-feature-effects") && daeInstalled,
        title: "Generate Effects ACs for Character Features & Racial Traits",
        description: "Add AC values as effects to features, this might not work as expected for some AC calculations. If unticked some ac bonuses will still be generated.",
        enabled: daeInstalled,
      },
      // {
      //   name: "dae-effect-copy",
      //   isChecked: game.settings.get(SETTINGS.MODULE_ID, "character-update-policy-dae-effect-copy") && daeSRDContentAvailable,
      //   title: "Copy Active Effect from DAE Compendiums",
      //   description:
      //     "<i>Transfer</i> the <i>Dynamic Active Effects Compendiums</i> effect for matching items/features/spells (requires DAE SRD and/or Midi SRD module). This may result in odd character AC's, HP etc. especially if the generate item and character effect options above are unticked. Please try importing the character with this option disabled before logging a bug. This will overwrite effects generated with the above options.",
      //   enabled: daeInstalled && daeSRDContentAvailable,
      // },
      {
        name: "active-effect-copy",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-active-effect-copy"),
        title: "Retain Active Effects",
        description:
          "Retain existing Effects, this will try and transfer any existing effects on the actor such as custom effects, effects from conditions or existing spells. Untick this option if you experience <i>odd</i> behaviour.",
        enabled: true,
      },
    ];

    const effectSelectionConfig = {
      class: [
        {
          name: "effect-class-spell-bonus",
          title: "Spell Bonuses",
          isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-effect-class-spell-bonus"),
          enabled: true,
        },
        {
          name: "effect-class-speed",
          title: "Movement",
          isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-effect-class-speed"),
          enabled: true,
        },
        {
          name: "effect-class-senses",
          title: "Senses",
          isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-effect-class-senses"),
          enabled: true,
        },
        {
          name: "effect-class-hp",
          title: "HP",
          isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-effect-class-hp"),
          enabled: true,
        },
        {
          name: "effect-class-damages",
          title: "Imm/Res/Vuln",
          isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-effect-class-damages"),
          enabled: true,
        },
      ],
      race: [
        {
          name: "effect-race-spell-bonus",
          title: "Spell Bonuses",
          isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-effect-race-spell-bonus"),
          enabled: true,
        },
        {
          name: "effect-race-speed",
          title: "Movement",
          isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-effect-race-speed"),
          enabled: true,
        },
        {
          name: "effect-race-senses",
          title: "Senses",
          isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-effect-race-senses"),
          enabled: true,
        },
        {
          name: "effect-race-hp",
          title: "HP",
          isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-effect-race-hp"),
          enabled: true,
        },
        {
          name: "effect-race-damages",
          title: "Imm/Res/Vuln",
          isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-effect-race-damages"),
          enabled: true,
        },
      ],
      background: [
        {
          name: "effect-background-spell-bonus",
          title: "Spell Bonuses",
          isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-effect-background-spell-bonus"),
          enabled: true,
        },
        {
          name: "effect-background-speed",
          title: "Movement",
          isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-effect-background-speed"),
          enabled: true,
        },
        {
          name: "effect-background-senses",
          title: "Senses",
          isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-effect-background-senses"),
          enabled: true,
        },
        {
          name: "effect-background-hp",
          title: "HP",
          isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-effect-background-hp"),
          enabled: true,
        },
        {
          name: "effect-background-damages",
          title: "Imm/Res/Vuln",
          isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-effect-background-damages"),
          enabled: true,
        },
      ],
      feat: [
        {
          name: "effect-feat-spell-bonus",
          title: "Spell Bonuses",
          isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-effect-feat-spell-bonus"),
          enabled: true,
        },
        {
          name: "effect-feat-speed",
          title: "Movement",
          isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-effect-feat-speed"),
          enabled: true,
        },
        {
          name: "effect-feat-senses",
          title: "Senses",
          isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-effect-feat-senses"),
          enabled: true,
        },
        {
          name: "effect-feat-hp",
          title: "HP",
          isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-effect-feat-hp"),
          enabled: true,
        },
        {
          name: "effect-feat-damages",
          title: "Imm/Res/Vuln",
          isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-effect-feat-damages"),
          enabled: true,
        },
      ],
    };

    const syncConfig = [
      {
        name: "action-use",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "sync-policy-action-use"),
        description: "Action Uses",
        enabled: true,
      },
      {
        name: "currency",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "sync-policy-currency"),
        description: "Currency",
        enabled: true,
      },
      {
        name: "deathsaves",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "sync-policy-deathsaves"),
        description: "Death Saves",
        enabled: true,
      },
      {
        name: "equipment",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "sync-policy-equipment"),
        description: "Equipment",
        enabled: true,
      },
      {
        name: "condition",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "sync-policy-condition"),
        description: "Exhaustion",
        enabled: true,
      },
      {
        name: "hitdice",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "sync-policy-hitdice"),
        description: "Hit Dice/Short Rest",
        enabled: true,
      },
      {
        name: "hitpoints",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "sync-policy-hitpoints"),
        description: "Hit Points",
        enabled: true,
      },
      {
        name: "inspiration",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "sync-policy-inspiration"),
        description: "Inspiration",
        enabled: true,
      },
      {
        name: "spells-prepared",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "sync-policy-spells-prepared"),
        description: "Spells Prepared",
        enabled: true,
      },
      {
        name: "spells-slots",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "sync-policy-spells-slots"),
        description: "Spell Slots",
        enabled: true,
      },
      {
        name: "spells-sync",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "sync-policy-spells-sync"),
        description: "Spells Known",
        enabled: false,
      },
      {
        name: "xp",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "sync-policy-xp"),
        description: "XP",
        enabled: true,
      },
    ];

    const extrasConfig = [
      // {
      //   name: "update-existing",
      //   isChecked: game.settings.get(SETTINGS.MODULE_ID, "munching-policy-update-existing"),
      //   description: "Update existing things.",
      //   enabled: true,
      // },
      // {
      //   name: "use-srd",
      //   isChecked: game.settings.get(SETTINGS.MODULE_ID, "munching-policy-use-srd"),
      //   description: "Use SRD compendium things instead of importing.",
      //   enabled: true,
      // },
      // {
      //   name: "use-inbuilt-icons",
      //   isChecked: game.settings.get(SETTINGS.MODULE_ID, "munching-policy-use-inbuilt-icons"),
      //   description: "Use icons from the inbuilt dictionary. (High coverage of items, feats, and spells).",
      //   enabled: true,
      // },
      // {
      //   name: "use-srd-icons",
      //   isChecked: game.settings.get(SETTINGS.MODULE_ID, "munching-policy-use-srd-icons"),
      //   description: "Use icons from the SRD compendiums.",
      //   enabled: true,
      // },
      // {
      //   name: "download-images",
      //   isChecked: game.settings.get(SETTINGS.MODULE_ID, "munching-policy-download-images"),
      //   description: "Download D&D Beyond images (takes longer and needs space).",
      //   enabled: true,
      // },
      // {
      //   name: "remote-images",
      //   isChecked: game.settings.get(SETTINGS.MODULE_ID, "munching-policy-remote-images"),
      //   description: "Use D&D Beyond remote images (a lot quicker)",
      //   enabled: true,
      // },
      // {
      //   name: "use-dae-effects",
      //   isChecked: game.settings.get(SETTINGS.MODULE_ID, "munching-policy-use-dae-effects"),
      //   description: "Copy effects from DAE (items and spells only). (Requires DAE and SRD module)",
      //   enabled: daeInstalled,
      // },
      // {
      //   name: "hide-description",
      //   isChecked: game.settings.get(SETTINGS.MODULE_ID, "munching-policy-hide-description"),
      //   description: "Hide description from players?",
      //   enabled: true,
      // },
      // {
      //   name: "monster-items",
      //   isChecked: game.settings.get(SETTINGS.MODULE_ID, "munching-policy-monster-items"),
      //   description: "[Experimental] Load items from DDB compendium instead of parsing action/attack?",
      //   enabled: true,
      // },
      // {
      //   name: "update-images",
      //   isChecked: game.settings.get(SETTINGS.MODULE_ID, "munching-policy-update-images"),
      //   description: "Update images on existing items?",
      //   enabled: true,
      // },
      // {
      //   name: "dae-copy",
      //   isChecked: game.settings.get(SETTINGS.MODULE_ID, "munching-policy-dae-copy"),
      //   description: "Use Dynamic Active Effects Compendiums for matching items/features (requires DAE and SRD module).",
      //   enabled: daeInstalled,
      // },
    ];

    const uploadDir = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "image-upload-directory");
    const dataDirSet = !_lib_FileHelper_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].BAD_DIRS.includes */ .Z.BAD_DIRS.includes(uploadDir);
    const tier = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "patreon-tier");
    const tiers = _lib_PatreonHelper_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].getPatreonTiers */ .Z.getPatreonTiers(tier);

    const result = {
      importPolicies1,
      importPolicies2,
      importConfig,
      extrasConfig,
      advancedImportConfig,
      effectImportConfig,
      effectSelectionConfig,
      dataDirSet,
      syncConfig,
      tiers,
    };

    return result;
  },

  updateActorSettings: (html, event) => {
    const selection = event.currentTarget.dataset.section;
    const checked = event.currentTarget.checked;

    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug(`Updating munching-policy-${selection} to ${checked}`);
    game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-" + selection, checked);

    if (selection === "dae-copy" && checked) {
      $(html).find("#character-import-policy-dae-effect-copy").prop("checked", false);
      game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-dae-effect-copy", false);
    } else if (selection === "dae-effect-copy" && checked) {
      $(html).find("#character-import-policy-add-item-effects").prop("checked", true);
      game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-add-item-effects", true);
      $(html).find("#character-import-policy-add-character-effects").prop("checked", true);
      game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-add-character-effects", true);
    }
  },

  getCompendiumFolderLookups: (type) => {
    const compendiumFolderSetting = game.settings.settings.get(`ddb-importer.munching-selection-compendium-folders-${type}`);
    const settingValue = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, `munching-selection-compendium-folders-${type}`);

    let selections = [];
    for (const [key, value] of Object.entries(compendiumFolderSetting.choices)) {
      selections.push({
        key: key,
        label: value,
        selected: key === settingValue,
      });
    }

    return selections;
  },

  getMuncherSettings: (includeHomebrew = true) => {
    const cobalt = (0,_lib_Secrets_js__WEBPACK_IMPORTED_MODULE_3__/* .getCobalt */ .HF)() != "";
    const betaKey = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "beta-key") != "";
    const tier = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "patreon-tier");
    const tiers = _lib_PatreonHelper_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].getPatreonTiers */ .Z.getPatreonTiers(tier);
    const spellEffectModulesAvailable = (0,_effects_specialSpells_js__WEBPACK_IMPORTED_MODULE_5__/* .spellEffectModules */ .fM)();
    const daeInstalled = spellEffectModulesAvailable.daeInstalled;
    // disable srd/midi srd copy as v10 does not work
    // const daeSRDInstalled = game.modules.get("Dynamic-Effects-SRD")?.active;
    // const midiSRDInstalled = game.modules.get("midi-srd")?.active;
    // const daeSRDContentAvailable = (daeSRDInstalled || midiSRDInstalled);
    const compendiumFolderAdd = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-use-compendium-folders");
    const compendiumFoldersInstalled = game.modules.get("compendium-folders")?.active;
    const compendiumFolderMonsterStyles = MuncherSettings.getCompendiumFolderLookups("monster");
    const compendiumFolderSpellStyles = MuncherSettings.getCompendiumFolderLookups("spell");
    const compendiumFolderItemStyles = MuncherSettings.getCompendiumFolderLookups("item");
    const spellEffectText = `Create active effects. These require DAE${MuncherSettings.getInstalledIcon("daeInstalled")}, Midi-QOL${MuncherSettings.getInstalledIcon("midiQolInstalled")}, Advanced Macros${MuncherSettings.getInstalledIcon("advancedMacrosInstalled")}, Item Macro${MuncherSettings.getInstalledIcon("itemMacroInstalled")}, Times Up${MuncherSettings.getInstalledIcon("timesUp")}, and Convenient Effects${MuncherSettings.getInstalledIcon("convenientEffectsInstalled")} as a minimum. Also recommened is Active Auras${MuncherSettings.getInstalledIcon("activeAurasInstalled")}, Active Token Effects${MuncherSettings.getInstalledIcon("atlInstalled")}, Token Magic FX${MuncherSettings.getInstalledIcon("tokenMagicInstalled")}, and Automated Animations${MuncherSettings.getInstalledIcon("autoAnimationsInstalled")}. Copying from MidiSRD will override these spells.`;

    const generateSpellEffects = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-add-spell-effects");
    if (generateSpellEffects && !spellEffectModulesAvailable.hasCore) {
      game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-add-spell-effects", false);
    }

    const enableSources = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-use-source-filter");
    const sourceArray = enableSources
      ? game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-muncher-sources").flat()
      : [];
    const sourcesSelected = enableSources && sourceArray.length > 0;
    const sourceNames = _lib_DDBSources_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].getSourcesLookups */ .Z.getSourcesLookups(sourceArray).filter((source) => source.selected).map((source) => source.label);
    const homebrewDescription = sourcesSelected
      ? "Include homebrew? SOURCES SELECTED! You can't import homebrew with a source filter selected"
      : "Include homebrew?";
    const sourceDescription = `Importing from the following sources only: ${sourceNames.join(", ")}`;

    const itemConfig = [
      {
        name: "use-ddb-item-icons",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-use-ddb-item-icons"),
        description: "Use D&D Beyond item images, if available",
        enabled: true,
      },
      {
        name: "use-ddb-generic-item-icons",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-use-ddb-generic-item-icons"),
        description: "Use D&D Beyond generic item type images, if available (final fallback)",
        enabled: true,
      },
      {
        name: "add-effects",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-add-effects"),
        description: "Dynamically generate effects (equipment only). (Requires DAE)",
        enabled: daeInstalled,
      },
      // {
      //   name: "add-ac-armor-effects",
      //   isChecked: game.settings.get(SETTINGS.MODULE_ID, "munching-policy-add-ac-armor-effects"),
      //   description: "[Caution] Dynamically generate DAE AC effects on armor equipment. (Requires DAE). Probably not required.",
      //   enabled: daeInstalled,
      // },
      {
        name: "item-homebrew",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-item-homebrew"),
        description: homebrewDescription,
        enabled: !sourcesSelected,
      },
      {
        name: "item-homebrew-only",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-item-homebrew-only"),
        description: "Only homebrew items?",
        enabled: !sourcesSelected,
      },
    ];

    const spellConfig = [
      {
        name: "use-ddb-spell-icons",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-use-ddb-spell-icons"),
        description: "If no other icon, use the D&DBeyond spell school icon.",
        enabled: true,
      },
      {
        name: "add-spell-effects",
        isChecked: generateSpellEffects && spellEffectModulesAvailable.hasCore,
        description: spellEffectText,
        enabled: spellEffectModulesAvailable.hasCore,
      },
      {
        name: "spell-homebrew",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-spell-homebrew"),
        description: homebrewDescription,
        enabled: !sourcesSelected,
      },
      {
        name: "spell-homebrew-only",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-spell-homebrew-only"),
        description: "Only homebrew spells?",
        enabled: !sourcesSelected,
      },
    ];

    const tokenizerReady = game.modules.get("vtta-tokenizer")?.active;

    const basicMonsterConfig = [
      {
        name: "hide-description",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-hide-description"),
        description: "Hide monster action description from players?",
        enabled: true,
      },
      {
        name: "monster-items",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-monster-items"),
        description: "[Experimental] Load attack/weapon items from DDB compendium instead of parsing action/attack? (Poor success rate)",
        enabled: true,
      },
      {
        name: "monster-use-item-ac",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-monster-use-item-ac"),
        description: "Use AC items instead of setting a flat AC? (Recommended if using spell effects like shield on NPC's).",
        enabled: true,
      },
      {
        name: "use-full-token-image",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-use-full-token-image"),
        description: "Use avatar image for token rather than token image (full art)",
        enabled: true,
      },
      {
        name: "use-token-avatar-image",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-use-token-avatar-image"),
        description: "Use token image for avatar rather than avatar image (close up)",
        enabled: true,
      },
      {
        name: "update-images",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-update-images"),
        description: "[CAUTION] Update Monster images on existing npcs? (This will dramatically slow down re-munching).",
        enabled: true,
      },
      {
        name: "monster-tokenize",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-monster-tokenize"),
        description: "Auto-Tokenize monsters token image? (Adds Tokenizer default token ring)",
        enabled: tokenizerReady,
      },
      {
        name: "monster-retain-biography",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-monster-retain-biography"),
        description: "Should monsters retain existing biography?",
        enabled: true,
      },
      {
        name: "monster-strip-name",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-monster-strip-name"),
        description: "Strip uses and recharge information from action names?",
        enabled: true,
      },
      {
        name: "munching-policy-monster-set-legendary-resource-bar",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-monster-set-legendary-resource-bar"),
        description: "Monsters display legendary resources on bar2? (Like the SRD Monsters)",
        enabled: true,
      },
      {
        name: "add-monster-effects",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-add-monster-effects"),
        description: "[Experimental] Attempt to generate Midi-QOL effects on monster attacks/features?",
        enabled: spellEffectModulesAvailable.hasCore,
      },
      // {
      //   name: "dae-copy",
      //   isChecked: game.settings.get(SETTINGS.MODULE_ID, "munching-policy-dae-copy"),
      //   description: "Use Dynamic Active Effects Compendiums for matching items/features (requires DAE SRD/Midi SRD module).",
      //   enabled: daeInstalled && daeSRDContentAvailable,
      // },
      // {
      //   name: "monster-bulk-import",
      //   isChecked: game.settings.get(SETTINGS.MODULE_ID, "munching-policy-monster-bulk-import"),
      //   description: "Use bulk import mode? Experimental, potentially faster. Does not preserve excluded items.",
      //   enabled: true,
      // },
    ];

    const homebrewMonsterConfig = includeHomebrew
      ? [
        {
          name: "monster-homebrew",
          isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-monster-homebrew") && !sourcesSelected,
          description: homebrewDescription,
          enabled: tiers.homebrew && !sourcesSelected,
        },
        {
          name: "monster-homebrew-only",
          isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-monster-homebrew-only") && !sourcesSelected,
          description: "Homebrew monsters only? (Otherwise both)",
          enabled: tiers.homebrew && !sourcesSelected,
        },
        {
          name: "monster-exact-match",
          isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-monster-exact-match"),
          description: "Exact name match?",
          enabled: tiers.homebrew,
        }
      ]
      : [];

    const monsterConfig = basicMonsterConfig.concat(homebrewMonsterConfig);

    const genericConfig = [
      {
        name: "update-existing",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-update-existing"),
        description: "Update existing things.",
        enabled: true,
      },
      {
        name: "use-inbuilt-icons",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-use-inbuilt-icons"),
        description: "Use icons from the inbuilt dictionary. (High coverage, recommended, fast).",
        enabled: true,
      },
      {
        name: "use-srd-icons",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-use-srd-icons"),
        description: "Use icons from the SRD compendiums.",
        enabled: true,
      },
      {
        name: "download-images",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-download-images"),
        description: "Download D&D Beyond images (takes longer and needs space).",
        enabled: true,
      },
      {
        name: "remote-images",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-remote-images"),
        description: "Use D&D Beyond remote images (a lot quicker)",
        enabled: true,
      },
      // {
      //   name: "use-dae-effects",
      //   isChecked: game.settings.get(SETTINGS.MODULE_ID, "munching-policy-use-dae-effects"),
      //   description: "Copy effects from DAE (items and spells only). (Requires DAE and SRD or Midi content module). Will replace dynamically generated effects.",
      //   enabled: daeInstalled && daeSRDContentAvailable,
      // },
      {
        name: "use-compendium-folders",
        isChecked: compendiumFoldersInstalled ? compendiumFolderAdd : false,
        description: "Generate compendium folders. You can migrate an existing import in the Tools tab.",
        enabled: compendiumFoldersInstalled,
      },
      {
        name: "use-srd",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-use-srd"),
        description:
          "[CAUTION] Use SRD compendium things instead of importing. This is not recommended, and may break adventure munching functionality.",
        enabled: true,
      },
      {
        name: "exclude-legacy",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-exclude-legacy"),
        description: "Exclude legacy monsters/races from import? These are replaced by newer versions e.g. in Monsters of the Multiverse.",
        enabled: true,
      },
      {
        name: "legacy-postfix",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-legacy-postfix"),
        description: "Append (Legacy) to Legacy monster/race names? These are replaced by newer versions e.g. in Monsters of the Multiverse.",
        enabled: true,
      },
      {
        name: "use-source-filter",
        isChecked: enableSources,
        description: "Restrict import to specific source book(s)? (DDB sets this as the <i>first</i> book a monster appears in).",
        enabled: true,
      }
    ];

    const worldUpdateConfig = [
      {
        name: "update-world-monster-update-images",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-update-world-monster-update-images"),
        description: "Update Monster images?",
        enabled: true,
      },
      {
        name: "update-world-monster-retain-biography",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-update-world-monster-retain-biography"),
        description: "Retain existing biography?",
        enabled: true,
      },
    ];

    const resultData = {
      cobalt,
      genericConfig,
      monsterConfig,
      spellConfig,
      itemConfig,
      worldUpdateConfig,
      beta: betaKey && cobalt,
      tiers,
      compendiumFoldersInstalled,
      compendiumFolderMonsterStyles,
      compendiumFolderItemStyles,
      compendiumFolderSpellStyles,
      sourcesSelected,
      sourceDescription,
      enableSources,
      version: CONFIG.DDBI.version,
    };

    // console.warn(resultData);

    return resultData;
  },

  // eslint-disable-next-line complexity
  updateMuncherSettings: (html, event, dialog) => {
    const selection = event.currentTarget.dataset.section;
    const checked = event.currentTarget.checked;

    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug(`Updating munching-policy-${selection} to ${checked}`);

    game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-" + selection, checked);

    switch (selection) {
      case "use-full-token-image": {
        if (checked) {
          game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-use-token-avatar-image", false);
          $("#munching-policy-use-token-avatar-image").prop("checked", false);
        }
        break;
      }
      case "use-token-avatar-image": {
        if (checked) {
          game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-use-full-token-image", false);
          $("#munching-policy-use-full-token-image").prop("checked", false);
        }
        break;
      }
      case "monster-homebrew": {
        if (!checked) {
          game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-monster-homebrew-only", false);
          $("#munching-policy-monster-homebrew-only").prop("checked", false);
        }
        break;
      }
      case "monster-homebrew-only": {
        if (checked) {
          game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-monster-homebrew", true);
          $("#munching-policy-monster-homebrew").prop("checked", true);
        }
        break;
      }
      case "spell-homebrew": {
        if (!checked) {
          game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-spell-homebrew-only", false);
          $("#munching-policy-spell-homebrew-only").prop("checked", false);
        }
        break;
      }
      case "spell-homebrew-only": {
        if (checked) {
          game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-spell-homebrew", true);
          $("#munching-policy-spell-homebrew").prop("checked", true);
        }
        break;
      }
      case "item-homebrew": {
        if (!checked) {
          game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-item-homebrew-only", false);
          $("#munching-policy-item-homebrew-only").prop("checked", false);
        }
        break;
      }
      case "item-homebrew-only": {
        if (checked) {
          game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-item-homebrew", true);
          $("#munching-policy-item-homebrew").prop("checked", true);
        }
        break;
      }
      case "remote-images": {
        if (checked) {
          game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-download-images", false);
          $("#munching-generic-policy-download-images").prop("checked", false);
        }
        break;
      }
      case "download-images": {
        if (checked) {
          game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-remote-images", false);
          $("#munching-generic-policy-remote-images").prop("checked", false);
        }
        break;
      }
      case "use-source-filter": {
        $("#munch-source-select").prop("disabled", !checked);
        $("#munch-source-div").toggleClass("ddbimporter-hidden");
        dialog.render(true);
        break;
      }
      // no default
    }
  },
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MuncherSettings);


/***/ }),

/***/ 9441:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "T": () => (/* binding */ downloadAdventureConfig),
/* harmony export */   "k": () => (/* binding */ generateAdventureConfig)
/* harmony export */ });
/* harmony import */ var _lib_Settings_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5406);
/* harmony import */ var _lib_Secrets_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2048);
/* harmony import */ var _vehicles_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1187);
/* harmony import */ var _lib_FileHelper_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(2397);
/* harmony import */ var _lib_CompendiumHelper_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(3893);
/* harmony import */ var _lib_DDBProxy_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(546);







async function getMonsterMap () {
  // ddb://monsters
  const monsterCompendiumLabel = _lib_CompendiumHelper_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].getCompendiumLabel */ .Z.getCompendiumLabel("monster");
  const monsterCompendium = _lib_CompendiumHelper_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].getCompendium */ .Z.getCompendium(monsterCompendiumLabel);
  const monsterIndices = ["name", "flags.ddbimporter.id"];
  const monsterIndex = await monsterCompendium.getIndex({ fields: monsterIndices });

  const results = monsterIndex
    .filter((monster) => monster.flags?.ddbimporter?.id)
    .map((monster) => {
      return {
        id: monster.flags.ddbimporter.id,
        _id: monster._id,
        compendium: monsterCompendiumLabel,
        name: monster.name,
        documentName: monster.name,
      };
    });

  return Promise.all(results);
}

async function getSpellMap() {
  // ddb://spells
  // mm 2176
  const spellCompendiumLabel = await game.settings.get("ddb-importer", "entity-spell-compendium");
  const spellCompendium = await game.packs.find((pack) => pack.collection === spellCompendiumLabel);
  const spellIndices = ["name", "flags.ddbimporter.definitionId"];
  const spellIndex = await spellCompendium.getIndex({ fields: spellIndices });

  const results = spellIndex
    .filter((spell) => spell.flags?.ddbimporter?.definitionId)
    .map((spell) => {
      return {
        id: spell.flags.ddbimporter.definitionId,
        _id: spell._id,
        compendium: spellCompendiumLabel,
        name: spell.name,
        documentName: spell.name,
      };
    });

  return Promise.all(results);
}

async function getItemMap() {
  // ddb://magicitems
  const itemCompendiumLabel = await game.settings.get("ddb-importer", "entity-item-compendium");
  const itemCompendium = await game.packs.find((pack) => pack.collection === itemCompendiumLabel);
  const itemIndices = ["name", "flags.ddbimporter.definitionId"];
  const itemIndex = await itemCompendium.getIndex({ fields: itemIndices });

  const results = itemIndex
    .filter((item) => item.flags?.ddbimporter?.definitionId)
    .map((item) => {
      return {
        id: item.flags.ddbimporter.definitionId,
        _id: item._id,
        compendium: itemCompendiumLabel,
        name: item.name,
        documentName: item.name,
      };
    });

  return Promise.all(results);
}

const ATTACK_ACTION_MAP = {
  "Opportunity Attack": {
    hint: "Opportunity Attacks",
    page: "Making an Attack"
  },
  Grapple: {
    hint: "Grappling",
    page: "Making an Attack"
  },
  Shove: {
    hint: "Shoving a Creature",
    page: "Making an Attack"
  },
  "Two-Weapon Fighting": {
    hint: "Two-Weapon Fighting",
    page: "Making an Attack"
  },
  "Interact with an Object": {
    hint: "Use an Object",
    page: "Actions in Combat",
  },
};

async function generateAdventureConfig(full = false, cobalt = true, fullPageMap = false) {
  const result = {
    generateTokens: true,
    schemaVersion: CONFIG.DDBI.schemaVersion,
    createPinJournals: false,
    createPlayerHandouts: false,
    createHandouts: false,
    debug: false,
    observeAll: false,
    version: game.modules.get("ddb-importer").version,
    lookups: {
      monsters: [],
      items: [],
      spells: [],
      skills: [],
      senses: [],
      conditions: [],
      actions: [],
      weaponproperties: [],
      vehicles: [],
      rule: [],
    },
    fullPageMap: [],
  };

  if (cobalt) {
    result.cobalt = (0,_lib_Secrets_js__WEBPACK_IMPORTED_MODULE_1__/* .getCobalt */ .HF)();
    result.campaignId = (0,_lib_Settings_js__WEBPACK_IMPORTED_MODULE_0__/* .getCampaignId */ .F9)();
  }

  // @Compendium[${compendiumLabel}.${featureMatch._id}]{${feature.name}}

  if (full) {
    result.lookups.monsters = await getMonsterMap();
    result.lookups.spells = await getSpellMap();
    result.lookups.items = await getItemMap();
  }

  // vehicles
  if (!_lib_DDBProxy_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].isCustom */ .Z.isCustom() && cobalt) {
    const vehicleData = await (0,_vehicles_js__WEBPACK_IMPORTED_MODULE_2__/* .getVehicleData */ .f)();

    result.lookups.vehicles = vehicleData.map((v) => {
      return {
        id: v.id,
        url: v.url,
        name: v.name,
      };
    });
  }

  const rulesCompendium = "dnd5e.rules";
  const srdCompendium = _lib_CompendiumHelper_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].getCompendium */ .Z.getCompendium(rulesCompendium);
  if (!srdCompendium) return result;

  const srdIndex = await srdCompendium.getIndex();
  const srdDocuments = await srdCompendium.getDocuments();
  result.index = srdIndex;

  const skillEntryDocument = srdDocuments.find((d) => d.name === "Chapter 7: Using Ability Scores");
  if (skillEntryDocument) {
    result.lookups.skills = CONFIG.DDB.abilitySkills.map((skill) => {
      const skillEntryPage = skillEntryDocument.pages.find((p) => p.name === "Using Each Ability");
      const stat = CONFIG.DDB.stats.find((s) => s.id === skill.stat);
      const headerLink = `${stat.name} Checks`;
      return {
        id: skill.id,
        _id: skillEntryDocument._id,
        name: skill.name,
        compendium: rulesCompendium,
        documentName: skillEntryDocument.name,
        pageId: skillEntryPage._id,
        headerLink,
      };
    });
  }

  const senseEntryDocument = srdDocuments.find((d) => d.name === "Appendix D: Senses and Speeds");
  if (senseEntryDocument) {
    result.lookups.senses = CONFIG.DDB.senses
      .filter((sense) => senseEntryDocument.pages.some((p) => p.name === sense.name))
      .map((sense) => {
        const senseEntryPage = senseEntryDocument.pages.find((p) => p.name === sense.name);
        return {
          id: sense.id,
          _id: senseEntryDocument._id,
          name: sense.name,
          compendium: rulesCompendium,
          documentName: senseEntryDocument.name,
          pageId: senseEntryPage._id,
          headerLink: null,
        };
      });
  }

  const conditionEntryDocument = srdDocuments.find((d) => d.name === "Appendix A: Conditions");
  if (conditionEntryDocument) {
    result.lookups.conditions = CONFIG.DDB.conditions
      .filter((condition) => conditionEntryDocument.pages.some((p) => p.name.trim() === condition.definition.name.trim()))
      .map((condition) => {
        const conditionEntryPage = conditionEntryDocument.pages.find((p) => p.name.trim() === condition.definition.name.trim());
        return {
          id: condition.definition.id,
          _id: conditionEntryDocument.id,
          name: condition.definition.name,
          compendium: rulesCompendium,
          slug: condition.definition.slug,
          documentName: conditionEntryDocument.name,
          pageId: conditionEntryPage._id,
          headerLink: null,
        };
      });
  }

  const actionEntryDocument = srdDocuments.find((d) => d.name === "Chapter 9: Combat");
  if (actionEntryDocument) {
    const actionEntryPage = actionEntryDocument.pages.find((p) => p.name === "Actions in Combat");
    CONFIG.DDB.basicActions.forEach((action) => {
      if (ATTACK_ACTION_MAP[action.name]) {
        const attackEntryPage = actionEntryDocument.pages.find((p) => p.name === ATTACK_ACTION_MAP[action.name].page);
        result.lookups.actions.push({
          id: action.id,
          _id: actionEntryDocument._id,
          name: action.name,
          compendium: rulesCompendium,
          documentName: actionEntryDocument.name,
          pageId: attackEntryPage._id,
          headerLink: ATTACK_ACTION_MAP[action.name].hint,
        });
      } else if (action.id < 100) {
        result.lookups.actions.push({
          id: action.id,
          _id: actionEntryDocument.id,
          name: action.name,
          compendium: rulesCompendium,
          documentName: actionEntryDocument.name,
          pageId: actionEntryPage._id,
          headerLink: action.name,
        });
      }
    });
  }

  const equipmentDocument = srdDocuments.find((d) => d.name === "Chapter 5: Equipment");
  if (equipmentDocument) {
    const weaponPropertiesPage = equipmentDocument.pages.find((p) => p.name === "Weapons");
    result.lookups.weaponproperties = CONFIG.DDB.weaponProperties.map((prop) => {
      return {
        id: prop.id,
        _id: equipmentDocument._id,
        name: prop.name,
        compendium: rulesCompendium,
        documentName: equipmentDocument.name,
        pageId: weaponPropertiesPage._id,
        headerLink: "Weapon Properties",
      };
    });
  }

  if (fullPageMap) {
    srdDocuments.forEach((document) => {
      document.pages.forEach((page) => {
        result.fullPageMap.push({
          id: null,
          _id: document.id,
          name: page.name,
          compendium: rulesCompendium,
          documentName: document.name,
          pageId: page._id,
          headerLink: null,
        });
      });
    });
  }

  return result;

}

async function downloadAdventureConfig() {
  const fullConfig = game.settings.get("ddb-importer", "adventure-muncher-full-config");
  const result = await generateAdventureConfig(fullConfig);
  _lib_FileHelper_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].download */ .Z.download(JSON.stringify(result, null, 4), `adventure-config.json`, "application/json");
  return result;
}


/***/ }),

/***/ 1423:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ AdventureMunch)
/* harmony export */ });
/* harmony import */ var _AdventureMunchHelpers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7801);
/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5259);
/* harmony import */ var _lib_FileHelper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(2397);
/* harmony import */ var _adventure_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(9441);
/* harmony import */ var _lib_DirectoryPicker_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(4222);
/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(6451);
/* harmony import */ var _lib_CompendiumHelper_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(3893);
/* harmony import */ var _lib_utils_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(7669);









class AdventureMunch extends FormApplication {

  static COMPENDIUM_MAP = {
    "spells": "spells",
    "magicitems": "items",
    "weapons": "items",
    "armor": "items",
    "adventuring-gear": "items",
    "monsters": "monsters",
    "vehicles": "vehicles",
  };

  static DDB_MAP = {
    "spells": "spells",
    "magicitems": "magic-items",
    "weapons": "equipment",
    "armor": "equipment",
    "adventuring-gear": "equipment",
    "monsters": "monsters",
    "vehicles": "vehicles",
  };


  /** @override */
  constructor(object = {}, options = {}) {
    super(object, options);
    this._itemsToRevisit = [];
    const importPathData = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "adventure-import-path");
    this._importPathData = _lib_DirectoryPicker_js__WEBPACK_IMPORTED_MODULE_4__/* .DirectoryPicker.parse */ .B.parse(importPathData);
    this.adventure = null;
    this.folders = null;
    this.raw = {
      scene: [],
      journal: [],
      actor: [],
      item: [],
      table: [],
      playlist: [],
      macro: [],
      folder: [],
    };
    this.temporary = {
      scenes: [],
      journals: [],
      actors: [],
      items: [],
      tables: [],
      playlists: [],
      macros: [],
      folders: [],
    };
    this.remove = {
      folderIds: new Set(),
    };
    this.zip = null;
    this.allMonsters = false;
    this.journalWorldActors = false;
    this.importFilename = null;
    this.importToAdventureCompendium = false;
    this.lookups = {
      folders: {},
      import: {},
      actors: {},
      sceneTokens: {},
      adventureConfig: {},
    };
  }

  /** @override */
  static get defaultOptions() {
    this.pattern = /(@[a-z]*)(\[)([a-z0-9]*|[a-z0-9.]*)(\])(\{)(.*?)(\})/gim;
    this.altpattern
      = /((data-entity)=\\?["']?([a-zA-Z]*)\\?["']?|(data-pack)=\\?["']?([[\S.]*)\\?["']?) data-id=\\?["']?([a-zA-Z0-9]*)\\?["']?.*?>(.*?)<\/a>/gim;

    return mergeObject(super.defaultOptions, {
      id: "ddb-adventure-import",
      classes: ["ddb-adventure-import"],
      title: "Adventure Munch",
      template: "modules/ddb-importer/handlebars/adventure/import.hbs",
      width: 350,
    });
  }

  /**
   * @param  {String} path
   * @param  {Boolean} misc Miscellaneous import type/location?
   * @returns {Object} An object detailing various file path
   */
  getImportFilePaths(path, misc) {
    const useWebP = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "use-webp") && !path.endsWith("svg") && !path.endsWith("pdf");
    const adventurePath = this.adventure.name.replace(/[^a-z0-9]/gi, "_");
    const targetPath = path.replace(/[\\/][^\\/]+$/, "");
    const baseFilename = path.replace(/^.*[\\/]/, "").replace(/\?(.*)/, "");
    const filename
      = useWebP && !baseFilename.endsWith(".webp")
        ? `${_lib_FileHelper_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].removeFileExtension */ .Z.removeFileExtension(baseFilename)}.webp`
        : baseFilename;
    const baseUploadPath = misc
      ? game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "adventure-misc-path")
      : game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "adventure-upload-path");
    const parsedBaseUploadPath = _lib_DirectoryPicker_js__WEBPACK_IMPORTED_MODULE_4__/* .DirectoryPicker.parse */ .B.parse(baseUploadPath);
    const uploadPath = misc
      ? `${parsedBaseUploadPath.current}/${targetPath}`
      : `${parsedBaseUploadPath.current}/${adventurePath}/${targetPath}`;
    const fullUploadPath = misc
      ? `${baseUploadPath}/${targetPath}`
      : `${baseUploadPath}/${adventurePath}/${targetPath}`;
    const returnFilePath = misc ? `${targetPath}/${filename}` : `${adventurePath}/${targetPath}/${filename}`;
    return {
      adventurePath,
      targetPath,
      filename,
      baseUploadPath,
      parsedBaseUploadPath,
      uploadPath,
      returnFilePath,
      baseFilename,
      fullUploadPath,
      forcingWebp: useWebP && baseFilename !== filename,
    };
  }

  /**
   * Import a non-image file
   * @param {String} path
   * @param {Blob} content
   * @param {String} mimeType
   * @param {Boolean} misc Miscellaneous import type/location?
   * @returns {Promise<String>} file path
   */
  async importRawFile(path, content, mimeType, misc) {
    try {
      if (path[0] === "*") {
        // this file was flagged as core data, just replace name.
        return path.replace(/\*/g, "");
      } else if (path.startsWith("icons/") || path.startsWith("systems/dnd5e/icons/") || path.startsWith("ddb://")) {
        // these are core icons, ignore
        // or are ddb:// paths that will be replaced by muncher
        return path;
      } else {
        const paths = this.getImportFilePaths(path, misc);
        const returnPath = await _lib_FileHelper_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].getFileUrl */ .Z.getFileUrl(paths.baseUploadPath, paths.returnFilePath);

        if (paths.uploadPath && !CONFIG.DDBI.KNOWN.CHECKED_DIRS.has(paths.uploadPath)) {
          _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Checking dir path ${paths.uploadPath}`, paths);
          await _lib_DirectoryPicker_js__WEBPACK_IMPORTED_MODULE_4__/* .DirectoryPicker.verifyPath */ .B.verifyPath(paths.parsedBaseUploadPath, `${paths.uploadPath}`);
          _lib_FileHelper_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].generateCurrentFiles */ .Z.generateCurrentFiles(paths.uploadPath);
          CONFIG.DDBI.KNOWN.CHECKED_DIRS.add(paths.uploadPath);
        }

        if (!CONFIG.DDBI.KNOWN.FILES.has(returnPath)) {
          _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Importing raw file from ${path}`, paths);
          const fileData = new File([content], paths.filename, { type: mimeType });
          await _AdventureMunchHelpers_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].UploadFile */ .Z.UploadFile(paths.parsedBaseUploadPath.activeSource, `${paths.uploadPath}`, fileData, {
            bucket: paths.parsedBaseUploadPath.bucket,
          });
          CONFIG.DDBI.KNOWN.FILES.add(returnPath);
        } else {
          _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`File already imported ${path}`);
        }

        return `${returnPath}`;
      }
    } catch (err) {
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].error */ .Z.error(`Error importing image file ${path} : ${err.message}`);
    }

    return path;
  }

  /**
   * Imports binary file, by extracting from zip file and uploading to path.
   *
   * @param  {String} path - Path to image within zip file
   * @returns {Promise<String>} - Path to file within VTT
   */
  async importImage(path, misc = false) {
    try {
      if (path[0] === "*") {
        // this file was flagged as core data, just replace name.
        return path.replace(/\*/g, "");
      } else if (path.startsWith("icons/") || path.startsWith("systems/dnd5e/icons/") || path.startsWith("ddb://")) {
        // these are core icons, ignore
        // or are ddb:// paths that will be replaced by muncher
        return path;
      } else {
        const paths = this.getImportFilePaths(path, misc);
        const returnPath = await _lib_FileHelper_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].getFileUrl */ .Z.getFileUrl(paths.baseUploadPath, paths.returnFilePath);

        if (paths.uploadPath && !CONFIG.DDBI.KNOWN.CHECKED_DIRS.has(paths.uploadPath)) {
          _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Checking dir path ${paths.uploadPath}`, paths);
          await _lib_DirectoryPicker_js__WEBPACK_IMPORTED_MODULE_4__/* .DirectoryPicker.verifyPath */ .B.verifyPath(paths.parsedBaseUploadPath, `${paths.uploadPath}`);
          _lib_FileHelper_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].generateCurrentFiles */ .Z.generateCurrentFiles(paths.uploadPath);
          CONFIG.DDBI.KNOWN.CHECKED_DIRS.add(paths.uploadPath);
        }

        if (!CONFIG.DDBI.KNOWN.FILES.has(returnPath)) {
          _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Importing image from ${path}`, paths);
          const img = await this.zip.file(path).async("blob");
          await _lib_FileHelper_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].uploadImage */ .Z.uploadImage(img, paths.fullUploadPath, paths.filename, paths.forcingWebp);
          CONFIG.DDBI.KNOWN.FILES.add(returnPath);
        } else {
          _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`File already imported ${path}`);
        }

        return `${returnPath}`;
      }
    } catch (err) {
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].error */ .Z.error(`Error importing image file ${path} : ${err.message}`);
    }

    return path;
  }

  /** @override */
  // eslint-disable-next-line class-methods-use-this
  async getData() {
    let data;
    let files = [];

    try {
      const verifiedDirectory = await _lib_DirectoryPicker_js__WEBPACK_IMPORTED_MODULE_4__/* .DirectoryPicker.verifyPath */ .B.verifyPath(this._importPathData);
      if (verifiedDirectory) {
        const options = {
          bucket: this._importPathData.bucket,
          extensions: [".fvttadv", ".FVTTADV", ".zip"],
          wildcard: false,
        };
        data = await _AdventureMunchHelpers_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].BrowseFiles */ .Z.BrowseFiles(this._importPathData.activeSource, this._importPathData.current, options);
        files = data.files.map((file) => {
          const filename = decodeURIComponent(file).replace(/^.*[\\/]/, "");

          return { path: decodeURIComponent(file), name: filename };
        });
      }
    } catch (err) {
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].error */ .Z.error(err);
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].warn */ .Z.warn(
        `Unable to verify import path, this may be due to permissions on the server. You may be able to ignore this message.`
      );
    }

    return {
      data,
      allScenes: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "adventure-policy-all-scenes"),
      allMonsters: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "adventure-policy-all-actors-into-world"),
      journalWorldActors: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "adventure-policy-journal-world-actors"),
      files,
      cssClass: "ddb-importer-window",
    };
  }

  async importFolder(folders, folderList) {
    await _AdventureMunchHelpers_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].asyncForEach */ .Z.asyncForEach(folders, async (f) => {
      let folderData = f;

      let newFolder = game.folders.find((folder) =>
        (folder._id === folderData._id || folder.flags.importid === folderData._id)
        && folder.type === folderData.type
      );

      if (newFolder) {
        if (!this.temporary.folders.some((f) => f._id === newFolder._id)) {
          this.temporary.folders.push(newFolder);
        }
        _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Found existing folder ${newFolder._id} with data:`, folderData, newFolder);
      } else {
        if (folderData.parent === null) {
          folderData.parent = this.lookups.folders[folderData.type];
        } else {
          folderData.parent = this.lookups.folders[folderData.parent];
        }

        // eslint-disable-next-line require-atomic-updates
        newFolder = await Folder.create(folderData, { keepId: true });
        this.temporary.folders.push(newFolder);
        if (this.importToAdventureCompendium) this.remove.folderIds.add(newFolder._id);
        _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Created new folder ${newFolder._id} with data:`, folderData, newFolder);
      }

      // eslint-disable-next-line require-atomic-updates
      this.lookups.folders[folderData.flags.importid] = newFolder._id;

      let childFolders = folderList.filter((folder) => {
        return folder.parent === folderData._id;
      });

      if (childFolders.length > 0) {
        await this.importFolder(childFolders, folderList);
      }
    });
  }

  /**
   * Create missing folder structures in the world
   */
  async _createFolders() {
    this.lookups.folders["null"] = null;

    // the folder list could be out of order, we need to create all folders with parent null first
    const firstLevelFolders = this.folders.filter((folder) => folder.parent === null);
    await this.importFolder(firstLevelFolders, this.folders);
  }

  /** @override */
  activateListeners(html) {
    super.activateListeners(html);

    html.find(".world-button").on("click", this._importAdventure.bind(this));
    html.find(".compendium-button").on("click", this._importAdventure.bind(this));
  }

  /**
   * Checks for any missing data from DDB in the compendiums, spells, items, monsters that have been referenced by the
   * adventure and imports them using DDB Importer.
   */
  async _checkForMissingData() {
    if (this.adventure.required?.spells && this.adventure.required.spells.length > 0) {
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`${this.adventure.name} - spells required`, this.adventure.required.spells);
      AdventureMunch._progressNote(`Checking for missing spells from DDB`);
      await _AdventureMunchHelpers_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].checkForMissingDocuments */ .Z.checkForMissingDocuments("spell", this.adventure.required.spells);
    }
    if (this.adventure.required?.items && this.adventure.required.items.length > 0) {
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`${this.adventure.name} - items required`, this.adventure.required.items);
      AdventureMunch._progressNote(`Checking for missing items from DDB`);
      await _AdventureMunchHelpers_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].checkForMissingDocuments */ .Z.checkForMissingDocuments("item", this.adventure.required.items);
    }
    if (this.adventure.required?.monsters && this.adventure.required.monsters.length > 0) {
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`${this.adventure.name} - monsters required`, this.adventure.required.monsters);
      AdventureMunch._progressNote(`Checking for missing monsters from DDB`);
      await _AdventureMunchHelpers_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].checkForMissingDocuments */ .Z.checkForMissingDocuments("monster", this.adventure.required.monsters);
    }
    if (parseFloat(this.adventure.version) < 4.1 && this.allMonsters) {
      ui.notifications.warn(`Unable to add all monsters from this adventure, please re-munch adventure with Adventure Muncher v1.0.9 or higher`);
    } else if (parseFloat(this.adventure.version) >= 4.1 && this.allMonsters && this.adventure.required?.monsterData
      && this.adventure.required?.monsterData?.length > 0
    ) {
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`${this.adventure.name} - Importing Remaining Actors`);
      AdventureMunch._progressNote(`Checking for missing world actors (${this.adventure.required.monsterData}) from compendium...`);
      await this.importRemainingActors(this.adventure.required.monsterData);
    }
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug("Missing data check complete");
  }

  /**
   * Work through the different types in the adventure and import them
   * @returns {Promise<>}
   */
  async _importFiles() {
    if (_AdventureMunchHelpers_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].folderExists */ .Z.folderExists("scene", this.zip)) {
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`${this.adventure.name} - Loading scenes`);
      await this._checkForDataUpdates("scene");
    }
    if (_AdventureMunchHelpers_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].folderExists */ .Z.folderExists("actor", this.zip)) {
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`${this.adventure.name} - Loading actors`);
      await this._importFile("actor");
    }
    if (_AdventureMunchHelpers_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].folderExists */ .Z.folderExists("item", this.zip)) {
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`${this.adventure.name} - Loading item`);
      await this._importFile("item");
    }
    if (_AdventureMunchHelpers_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].folderExists */ .Z.folderExists("journal", this.zip)) {
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`${this.adventure.name} - Loading journal`);
      await this._importFile("journal");
    }
    if (_AdventureMunchHelpers_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].folderExists */ .Z.folderExists("table", this.zip)) {
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`${this.adventure.name} - Loading table`);
      await this._importFile("table");
    }
    if (_AdventureMunchHelpers_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].folderExists */ .Z.folderExists("playlist", this.zip)) {
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`${this.adventure.name} - Loading playlist`);
      await this._importFile("playlist");
    }
    if (_AdventureMunchHelpers_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].folderExists */ .Z.folderExists("macro", this.zip)) {
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`${this.adventure.name} - Loading macro`);
      await this._importFile("macro");
    }
    if (_AdventureMunchHelpers_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].folderExists */ .Z.folderExists("compendium", this.zip)) {
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`${this.adventure.name} - Loading compendium`);
      await this._importCompendium();
    }
  }

  _renderCompleteDialog() {
    new Dialog(
      {
        title: `Successful Import of ${this.adventure.name}`,
        content: { adventure: this.adventure },
        buttons: { two: { label: "OK" } },
      },
      {
        classes: ["dialog", "adventure-import-export"],
        template: "modules/ddb-importer/handlebars/adventure/import-complete.hbs",
      }
    ).render(true);
  }

  /**
   * Search temporary items and return a match
   *
   * @param  {String} uuid - Item id or uuid
   * @returns {Object} - Document
   */
  fetchTemporaryItem(uuid) {
    const id = uuid.split(".").pop();
    for (const [key, itemArray] of Object.entries(this.temporary)) {
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Checking temporary ${key} for ${uuid}`, itemArray);
      const match = itemArray.find((i) => i._id === id);
      if (match) {
        _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Found ${key} match for ${uuid}`, match);
        return match;
      }
    }
    return undefined;
  }

  /**
   * Get the world actor, or actor that represents the world actor for adventure compendium build
   *
   * @param  {String} actorId - Actor Id
   * @returns {Object} - Actor
   */
  _getWorldActor(actorId) {
    return this.importToAdventureCompendium
      ? this.temporary.actors.find((a) => a._id === actorId)
      : game.actors.get(actorId);
  }

  static async _getTokenUpdateData(worldActor, sceneToken, token) {
    const tokenData = await worldActor.getTokenDocument();
    delete tokenData.y;
    delete tokenData.x;
    const jsonTokenData = duplicate(tokenData);
    const items = [];
    const ddbItems = sceneToken.flags.ddbItems ?? [];
    for (const item of ddbItems) {
      if (item.customItem) {
        items.push(item.data);
      } else {
        const ddbId = getProperty(item, "ddbId");
        if (Number.isInteger(ddbId)) {
          // fetch ddbItem
          const compendium = _lib_CompendiumHelper_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].getCompendiumType */ .Z.getCompendiumType(item.type);
          const itemRef = compendium.index.find((i) => i.name === item.name && i.type === item.type);
          if (itemRef) {
            // eslint-disable-next-line no-await-in-loop
            const compendiumItem = await compendium.getDocument(itemRef._id);
            const jsonItem = compendiumItem.toObject();
            delete jsonItem._id;
            items.push(jsonItem);
          } else {
            _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].error */ .Z.error(`Unable to find compendium item ${item.name}`, { item, sceneToken });
          }
        } else {
          // fetch actor item here
          const actorItem = worldActor.items.find((i) => i.name === item.name && i.type === item.type);
          if (actorItem) {
            const jsonItem = actorItem.toObject();
            delete jsonItem._id;
            items.push(jsonItem);
          } else {
            _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].error */ .Z.error(`Unable to find monster feature/item ${item.name}`, { item, sceneToken, worldActor });
          }
        }
      }
    }

    if (items.length > 0) {
      jsonTokenData.actorData = {
        items,
      };
    }

    if (sceneToken.flags.ddbImages?.keepToken)
      setProperty(jsonTokenData, "texture.src", sceneToken.flags.ddbImages.tokenImage);
    if (sceneToken.flags.ddbImages?.keepAvatar)
      setProperty(jsonTokenData, "actorData.img", sceneToken.flags.ddbImages.avatarImage);

    const updateData = mergeObject(jsonTokenData, sceneToken);
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`${token.name} token data for id ${token.actorId}`, updateData);
    return updateData;
  }

  async _revisitScene(document) {
    let updatedData = {};
    let tokenUpdates = [];
    const scene = duplicate(document);
    // this is a scene we need to update links to all items
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].info */ .Z.info(`Updating ${scene.name}, ${scene.tokens.length} tokens`);
    let deadTokenIds = [];
    await _AdventureMunchHelpers_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].asyncForEach */ .Z.asyncForEach(scene.tokens, async (token) => {
      if (token.actorId) {
        const sceneToken = scene.flags.ddb.tokens.find((t) => t._id === token._id);
        delete sceneToken.scale;
        const worldActor = this._getWorldActor(token.actorId);
        if (worldActor) {
          const updateData = await AdventureMunch._getTokenUpdateData(worldActor, sceneToken, token);
          if (this.importToAdventureCompendium) {
            await document.updateSource({ tokens: updateData });
            tokenUpdates.push(updateData);
          } else {
            await document.updateEmbeddedDocuments("Token", [updateData], { keepId: true, keepEmbeddedIds: true });
          }
        } else {
          deadTokenIds.push(token._id);
        }
      } else {
        deadTokenIds.push(token._id);
      }
    });

    if (this.importToAdventureCompendium) {
      await document.updateSource({ tokens: tokenUpdates }, { recursive: false });
    }

    // remove a token from the scene if we have not been able to link it
    if (!this.importToAdventureCompendium && deadTokenIds.length > 0) {
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].warn */ .Z.warn(`Removing ${scene.name} tokens with no world actors`, deadTokenIds);
      await document.deleteEmbeddedDocuments("Token", deadTokenIds);
    }

    if (!this.importToAdventureCompendium) {
      // In 0.8.x the thumbs don't seem to be generated.
      // This code would embed the thumbnail.
      // Consider writing this out.
      if (!document.thumb) {
        const thumbData = await document.createThumbnail();
        updatedData["thumb"] = thumbData.thumb;
      }
      await document.update(updatedData);
    }
  }

  /**
   * Some items need linking up or tweaking post import.
   * @returns {Promise<>}
   */
  async _revisitItems() {
    try {
      if (this._itemsToRevisit.length > 0) {
        let totalCount = this._itemsToRevisit.length;
        let currentCount = 0;

        await _AdventureMunchHelpers_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].asyncForEach */ .Z.asyncForEach(this._itemsToRevisit, async (itemUuid) => {
          const toTimer = setTimeout(() => {
            _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].warn */ .Z.warn(`Reference update timed out.`);
            this._renderCompleteDialog();
            this.close();
          }, 180000);
          try {
            const document = this.importToAdventureCompendium
              ? this.fetchTemporaryItem(itemUuid)
              : await fromUuid(itemUuid);
            // let rawData;
            switch (document.documentName) {
              case "Scene": {
                await this._revisitScene(document);
                break;
              }
              // no default
            }
          } catch (err) {
            _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].warn */ .Z.warn(`Error updating references for object ${itemUuid}`, err);
          }
          currentCount += 1;
          AdventureMunch._updateProgress(totalCount, currentCount, "References");
          clearTimeout(toTimer);
        });
      }
    } catch (err) {
      // eslint-disable-next-line no-undef
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].warn */ .Z.warn(`Error during reference update for object ${item}`, err);
    }
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].info */ .Z.info("Revisit data complete");
  }

  async _loadZip() {
    const form = document.querySelector(`form[class="ddb-importer-window"]`);
    if (form.data.files.length) {
      this.importFilename = form.data.files[0].name;
      this.zip = await _lib_FileHelper_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].readBlobFromFile */ .Z.readBlobFromFile(form.data.files[0]).then(JSZip.loadAsync);
    } else {
      const selectedFile = document.querySelector(`[name="import-file"]`).value;
      this.importFilename = selectedFile;
      this.zip = await fetch(`/${selectedFile}`)
        .then((response) => {
          if (response.status === 200 || response.status === 0) {
            return Promise.resolve(response.blob());
          } else {
            return Promise.reject(new Error(response.statusText));
          }
        })
        .then(JSZip.loadAsync);
    }
  }

  async _importAdventureToWorld() {
    await this._importFiles();
    await this._revisitItems();
  }

  async _importAdventureToCompendium() {
    try {
      const adventureData = await this._createAdventure();
      await this._importAdventureCompendium(adventureData);
    } finally {
      const folderIds = [...this.remove.folderIds];
      if (folderIds.length > 0) {
        _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug("Removing folders", folderIds);
        const results = await Folder.deleteDocuments(folderIds);
        _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug("Delete results", results);
      }
    }

  }

  _unpackZip() {
    for (const key of Object.keys(this.raw)) {
      this.raw[key] = _AdventureMunchHelpers_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].getFiles */ .Z.getFiles(key, this.zip);
    }
  }

  async _chooseScenes() {
    const dataFiles = this.raw["scene"];

    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].info */ .Z.info(`Selecting Scenes for ${this.adventure.name} - (${dataFiles.length} possible scenes for import)`);

    let fileData = [];

    await _AdventureMunchHelpers_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].asyncForEach */ .Z.asyncForEach(dataFiles, async (file) => {
      const raw = await this.zip.file(file.name).async("text");
      const json = JSON.parse(raw);
      const existingScene = await game.scenes.find((item) => item.id === json._id);
      const scene = _AdventureMunchHelpers_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].extractDocumentVersionData */ .Z.extractDocumentVersionData(json, existingScene);
      fileData.push(scene);
    });

    return new Promise((resolve) => {
      new Dialog(
        {
          title: "Choose Scenes to Import",
          content: {
            fileData: fileData,
            cssClass: "import-data-selection",
          },
          buttons: {
            selection: {
              label: "Selected",
              callback: async () => {
                const formData = $(".import-data-selection").serializeArray();
                const scenes = [];
                for (let i = 0; i < formData.length; i++) {
                  const key = formData[i].name;
                  scenes.push(this.raw.scene.find((s) => s.name.includes(key)));
                }
                _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug("scenes to import", scenes);
                this.raw.scene = scenes;
                resolve(this);
              },
            },
            all: {
              label: "All",
              callback: async () => {
                resolve(this);
              },
            },
          },
          default: "all",
          close: async () => {
            resolve(this);
          },
        },
        {
          width: 700,
          classes: ["dialog", "adventure-import-selection"],
          template: "modules/ddb-importer/handlebars/adventure/choose-scenes.hbs",
        }
      ).render(true);
    });

  }

  async _importAdventure(event) {
    event.preventDefault();
    event.stopPropagation();
    event.stopImmediatePropagation();
    const a = event.currentTarget;
    const action = a.dataset.button;

    if (action === "world" || action === "compendium") {
      try {
        $(".import-progress").toggleClass("import-hidden");
        $(".ddb-overlay").toggleClass("import-invalid");

        this.allScenes = document.querySelector(`[name="all-scenes"]`).checked;
        game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "adventure-policy-all-scenes", this.allScenes);
        this.allMonsters = document.querySelector(`[name="all-monsters"]`).checked;
        game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "adventure-policy-all-actors-into-world", this.allMonsters);
        this.journalWorldActors = document.querySelector(`[name="journal-world-actors"]`).checked;
        game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "adventure-policy-journal-world-actors", this.journalWorldActors);

        await this._loadZip();
        this._unpackZip();

        this.adventure = JSON.parse(await this.zip.file("adventure.json").async("text"));
        _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug("Loaded adventure data", { adventure: this.adventure });
        try {
          this.folders = JSON.parse(await this.zip.file("folders.json").async("text"));
          _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug("Adventure folders", { folders: this.folders });
        } catch (err) {
          _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].warn */ .Z.warn(`Folder structure file not found.`);
        }

        if (this.adventure.system !== game.data.system.id) {
          ui.notifications.error(
            `Invalid system for Adventure ${this.adventure.name}.  Expects ${this.adventure.system}`,
            { permanent: true }
          );
          throw new Error(`Invalid system for Adventure ${this.adventure.name}.  Expects ${this.adventure.system}`);
        }

        if (parseFloat(this.adventure.version) < 4.0) {
          ui.notifications.error(
            `This Adventure (${this.adventure.name}) was generated for v9.  Please regenerate your config file for Adventure Muncher.`,
            { permanent: true }
          );
          throw new Error(
            `This Adventure (${this.adventure.name}) was generated for v9.  Please regenerate your config file for Adventure Muncher.`
          );
        }

        if (action === "compendium") this.importToAdventureCompendium = true;

        await this._createFolders();
        if (!this.allScenes) await this._chooseScenes();
        await this._checkForMissingData();
        this.lookups.adventureConfig = await (0,_adventure_js__WEBPACK_IMPORTED_MODULE_3__/* .generateAdventureConfig */ .k)(true);

        if (action === "world") await this._importAdventureToWorld();
        else if (action === "compendium") await this._importAdventureToCompendium();

        $(".ddb-overlay").toggleClass("import-invalid");

        this._renderCompleteDialog();

        this.close();
      } catch (err) {
        $(".ddb-overlay").toggleClass("import-invalid");
        ui.notifications.error(`There was an error importing ${this.importFilename}`);
        _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].error */ .Z.error(`Error importing file ${this.importFilename}`, err);
        this.close();
      } finally {
        // eslint-disable-next-line require-atomic-updates
        this.lookups = {};
      }
    }
  }

  /**
   * Import actors from compendium into world
   * @param {Array<Objects>} neededActors array of needed actors
   * @returns {Promise<Array>} array of world actors
   */
  async ensureWorldActors(neededActors) {
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug("Trying to import actors from compendium", neededActors);
    const monsterCompendium = _lib_CompendiumHelper_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].getCompendiumType */ .Z.getCompendiumType("monster", false);
    const results = [];
    await _AdventureMunchHelpers_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].asyncForEach */ .Z.asyncForEach(neededActors, async (actor) => {
      let worldActor = this._getWorldActor(actor.actorId);
      if (!worldActor) {
        _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].info */ .Z.info(`Importing actor ${actor.name} with DDB ID ${actor.ddbId} from ${monsterCompendium.metadata.name} with compendium id ${actor.compendiumId}`);
        try {
          const options = { keepId: true, keepEmbeddedIds: true, temporary: this.importToAdventureCompendium };
          worldActor = await game.actors.importFromCompendium(monsterCompendium, actor.compendiumId, { _id: actor.actorId, folder: actor.folderId }, options);
        } catch (err) {
          _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].error */ .Z.error(err);
          _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].warn */ .Z.warn(`Unable to import actor ${actor.name} with id ${actor.compendiumId} from DDB Compendium`);
          _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Failed on: game.actors.importFromCompendium(monsterCompendium, "${actor.compendiumId}", { _id: "${actor.actorId}", folder: "${actor.folderId}" }, { keepId: true });`);
        }
      }
      if (worldActor) results.push(worldActor);
      if (this.importToAdventureCompendium && !this.temporary.actors.some((a) => a._id === actor.actorId)) {
        this.temporary.actors.push(worldActor);
      }
    });
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug("Actors transferred from compendium to world.", results);
    return results;
  }

  static async linkDDBActors(tokens) {
    const linkedExistingTokens = await _AdventureMunchHelpers_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].linkExistingActorTokens */ .Z.linkExistingActorTokens(tokens);
    const newTokens = linkedExistingTokens
      .filter((token) => token.flags.ddbActorFlags?.id && token.flags.compendiumActorId);

    return Promise.all(newTokens);
  }

  /**
   * Import actors, matching up import ids and actor ids for scene token linking
   * @param {object} data array of actor data objects
   * @param {boolean} temporary create the items in the world?
   * @returns {Promise<Array>} array of world actors
   */
  async importRemainingActors(data) {
    const results = [];
    const monsterCompendium = _lib_CompendiumHelper_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].getCompendiumType */ .Z.getCompendiumType("monster", false);
    const monsterIndex = await _AdventureMunchHelpers_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].getCompendiumIndex */ .Z.getCompendiumIndex("monster");

    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug("Checking for the following actors in world", data);
    await _AdventureMunchHelpers_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].asyncForEach */ .Z.asyncForEach(data, async (actorData) => {
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Checking for ${actorData.ddbId}`, actorData);
      let worldActor = this._getWorldActor(actorData.actorId);

      if (worldActor) {
        _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Actor found for ${actorData.actorId}, with name ${worldActor.name}`);
      } else {
        const monsterHit = monsterIndex.find((monster) =>
          monster.flags?.ddbimporter?.id && monster.flags.ddbimporter.id == actorData.ddbId
        );
        if (monsterHit) {
          _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].info */ .Z.info(`Importing actor ${monsterHit.name} with DDB ID ${actorData.ddbId} from ${monsterCompendium.metadata.name} with compendium id ${monsterHit._id} (temporary? ${this.importToAdventureCompendium})`);
          try {
            const actorOverride = { _id: actorData.actorId, folder: actorData.folderId };
            const options = { keepId: true, keepEmbeddedIds: true, temporary: this.importToAdventureCompendium };
            // eslint-disable-next-line require-atomic-updates
            worldActor = await game.actors.importFromCompendium(monsterCompendium, monsterHit._id, actorOverride, options);
          } catch (err) {
            _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].error */ .Z.error(err);
            _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].warn */ .Z.warn(`Unable to import actor ${monsterHit.name} with id ${monsterHit._id} from DDB Compendium`);
            _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Failed on: game.actors.importFromCompendium(monsterCompendium, "${monsterHit._id}", { _id: "${actorData.actorId}", folder: "${actorData.folderId}" }, { keepId: true });`);
          }
        } else {
          _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].error */ .Z.error("Actor not found in compendium", actorData);
        }
      }
      if (worldActor) results.push(worldActor);
      if (worldActor && this.importToAdventureCompendium && !this.temporary.actors.some((a) => worldActor.flags.ddbimporter.id == a.flags.ddbimporter.id)) {
        this.temporary.actors.push(worldActor);
      }
    });
    return results;
  }

  /**
   * Generates actors for tokens on a scene
   * @param {object} scene the scene to generate actors for
   * @returns {Promise<Array>} array of world actors
   */
  async generateTokenActors(scene) {
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Token Actor generation for ${scene.name} starting`);
    const tokens = await AdventureMunch.linkDDBActors(scene.tokens);
    const neededActors = tokens
      .map((token) => {
        return {
          name: token.name,
          ddbId: token.flags.ddbActorFlags.id,
          actorId: token.actorId,
          compendiumId: token.flags.compendiumActorId,
          folderId: token.flags.actorFolderId
        };
      })
      .filter((obj, pos, arr) => {
        // we only need to create 1 actor per actorId
        return arr.map((mapObj) => mapObj["actorId"]).indexOf(obj["actorId"]) === pos;
      });

    const results = await this.ensureWorldActors(neededActors);
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Token Actor generation for ${scene.name} complete`, results);
    return results;
  }

  async _loadDocumentAssets(data, importType) {

    data.flags.importid = data._id;

    if (data.img) {
      // eslint-disable-next-line require-atomic-updates
      data.img = await this.importImage(data.img);
    }
    if (data.thumb) {
      // eslint-disable-next-line require-atomic-updates
      data.thumb = await this.importImage(data.thumb);
    }
    if (data?.token?.img) {
      // eslint-disable-next-line require-atomic-updates
      data = await this._importTokenImage("token", data, { img: true, texture: false });
    }
    if (data.toke?.texture?.src) {
      // eslint-disable-next-line require-atomic-updates
      data = await this._importTokenImage("token", data);
    }
    if (data?.prototypeToken?.img) {
      // eslint-disable-next-line require-atomic-updates
      data = await this._importTokenImage("prototypeToken", data, { img: true, texture: false });
    }
    if (data.prototypeToken?.texture?.src) {
      // eslint-disable-next-line require-atomic-updates
      data = await this._importTokenImage("prototypeToken", data);
    }

    if (data?.items?.length) {
      await _AdventureMunchHelpers_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].asyncForEach */ .Z.asyncForEach(data.items, async (item) => {
        if (item.img) {
          // eslint-disable-next-line require-atomic-updates
          item.img = await this.importImage(item.img);
        }
      });
    }

    if (data?.pages?.length) {
      await _AdventureMunchHelpers_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].asyncForEach */ .Z.asyncForEach(data.pages, async (page) => {
        if (page.src) {
          // eslint-disable-next-line require-atomic-updates
          page.src = await this.importImage(page.src);
        }
      });
    }

    if (importType === "Scene") {
      if (data.tokens) {
        await this.generateTokenActors(data);
      }
      if (data.flags["perfect-vision"] && Array.isArray(data.flags["perfect-vision"])) {
        data.flags["perfect-vision"] = {};
      }
    } else if (importType === "Playlist") {
      await _AdventureMunchHelpers_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].asyncForEach */ .Z.asyncForEach(data.sounds, async (sound) => {
        if (sound.path) {
          // eslint-disable-next-line require-atomic-updates
          sound.path = await this.importImage(sound.path);
        }
      });
    } else if (importType === "RollTable") {
      await _AdventureMunchHelpers_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].asyncForEach */ .Z.asyncForEach(data.results, async (result) => {
        if (result.img) {
          // eslint-disable-next-line require-atomic-updates
          result.img = await this.importImage(result.img);
        }
        if (result.resultId) {
          data.flags.ddb.needRevisit = true;
        }
        _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Updating DDB links for ${data.name}`);
        // eslint-disable-next-line require-atomic-updates
        data.text = this.foundryCompendiumReplace(data.text);
      });
    } else if (importType === "JournalEntry" && data.pages) {
      await _AdventureMunchHelpers_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].asyncForEach */ .Z.asyncForEach(data.pages, async (page) => {
        if (page.text.content) {
          const journalImages = _AdventureMunchHelpers_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].reMatchAll */ .Z.reMatchAll(
            /(src|href)="(?!http(?:s*):\/\/)([\w0-9\-._~%!$&'()*+,;=:@/]*)"/,
            page.text.content
          );
          if (journalImages) {
            _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Updating Image links for ${page.name}`);
            await _AdventureMunchHelpers_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].asyncForEach */ .Z.asyncForEach(journalImages, async (result) => {
              const path = await this.importImage(result[2]);
              page.text.content = page.text.content.replace(result[0], `${result[1]}="${path}"`);
            });
          }
          _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Updating DDB links for ${page.name}`);
          page.text.content = this.foundryCompendiumReplace(page.text.content);
        }
      });
    }

    return data;

  }


  async _createAdventure() {
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug("Packing up adventure");
    if (this.allMonsters) await this.importRemainingActors(this.adventure.required.monsterData, true);
    const itemData = await _AdventureMunchHelpers_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].getDocuments */ .Z.getDocuments("items", this.adventure.required.items ?? [], {}, true);
    const spellData = await _AdventureMunchHelpers_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].getDocuments */ .Z.getDocuments("spells", this.adventure.required.spells ?? [], {}, true);

    await this._importFile("journal", [], true);
    await this._importFile("scene", [], true);
    await this._importFile("table", [], true);
    // await this._importFile("Macro", [], true);
    // await this._importFile("Card", [], true);
    // await this._importFile("Playlist", [], true);
    // await this._importFile("Combat", [], true);
    // await this._importFile("Actor", [], true);
    // await this._importFile("Item", [], true);

    const ddbSource = CONFIG.DDB.sources.find((source) => source.description === this.adventure.name);
    const image = ddbSource?.avatarURL
      ? ddbSource.avatarURL
      : await this.importImage("assets/images/cover.jpg");

    await this._revisitItems();

    const data = {
      img: image,
      name: this.adventure.name,
      description: this.adventure.description,
      folders: this.temporary.folders.map((doc) => doc.toObject()),
      combats: [],
      items: itemData.concat(spellData).map((doc) => doc.toObject()),
      // actors: actorData.map((doc) => doc.toObject()),
      actors: this.temporary.actors.map((doc) => doc.toObject()),
      journal: this.temporary.journals.map((doc) => doc.toObject()),
      scenes: this.temporary.scenes.map((doc) => doc.toObject()),
      tables: this.temporary.tables.map((doc) => doc.toObject()),
      macros: [],
      cards: [],
      playlists: [],

      flags: {
        ddbimporter: {
          isDDBAdventure: true,
          adventure: {
            required: this.adventure.required,
            revisitUuids: this._itemsToRevisit,
          },
        },
        core: { sheetClass: "ddb-importer.DDBAdventureImporter" },
      },
    };

    return data;
  }


  async _importAdventureCompendium(adventureData) {
    try {
      const pack = _lib_CompendiumHelper_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].getCompendiumType */ .Z.getCompendiumType("adventure");
      const existingAdventure = pack.index.find((i) => i.name === adventureData.name);

      let adventure;
      if (existingAdventure) {
        _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug("Deleting existing adventure", existingAdventure._id);
        adventureData._id = existingAdventure._id;
        const loadedAdventure = await pack.getDocument(existingAdventure._id);
        adventure = await loadedAdventure.update(adventureData, { diff: false, recursive: false });
        ui.notifications.info(game.i18n.format("ADVENTURE.UpdateSuccess", { name: adventureData.name }));
      } else {
        adventure = await Adventure.createDocuments([adventureData], {
          pack: pack.metadata.id,
          keepId: true,
          keepEmbeddedIds: true
        });
        ui.notifications.info(game.i18n.format("ADVENTURE.CreateSuccess", { name: adventureData.name }));

      }

      // console.warn("Adventure!", {
      //   pack,
      //   item: adventureData,
      //   adventure,
      //   temp: this.temporary,
      //   thisAdventure: this.adventure,
      // });
      return adventure;
    } catch (err) {
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].error */ .Z.error("error building adventure", { err, this: this });
      throw err;
    }
  }

  async _importCompendium(folderName) {
    let totalCount = 0;
    let currentCount = 0;
    const dataFiles = _AdventureMunchHelpers_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].getFiles */ .Z.getFiles(folderName, this.zip);
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].info */ .Z.info(`Importing ${this.adventure.name} - Compendium (${dataFiles.length} items)`);
    totalCount = dataFiles.length;

    await _AdventureMunchHelpers_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].asyncForEach */ .Z.asyncForEach(dataFiles, async (file) => {
      const rawData = await this.zip.file(file.name).async("text");
      const data = JSON.parse(rawData);

      const pack = _lib_CompendiumHelper_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].createIfNotExists */ .Z.createIfNotExists({ type: data.info.entity, label: data.info.label }).compendium;
      await pack.getIndex();

      totalCount += data.items.length;
      await _AdventureMunchHelpers_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].asyncForEach */ .Z.asyncForEach(data.items, async (item) => {
        let obj;
        let entry = pack.index.find((e) => e.name === item.name);

        // eslint-disable-next-line require-atomic-updates
        item = await this._loadDocumentAssets(item, data.info.entity, true);

        switch (data.info.entity) {
          case "Adventure":
            obj = this._importAdventureCompendium(item);
            break;
          case "Item":
            obj = new Item(item, { temporary: true, keepId: true, keepEmbeddedIds: true });
            break;
          case "Actor":
            obj = new Actor(item, { temporary: true, keepId: true, keepEmbeddedIds: true });
            break;
          case "Scene":
            obj = new Scene(item, { temporary: true, keepId: true, keepEmbeddedIds: true });
            break;
          case "JournalEntry":
            obj = new JournalEntry(item, { temporary: true, keepId: true, keepEmbeddedIds: true });
            break;
          case "Macro":
            obj = new Macro(item, { temporary: true, keepId: true, keepEmbeddedIds: true });
            break;
          case "RollTable":
            obj = new RollTable(item, { temporary: true, keepId: true, keepEmbeddedIds: true });
            break;
          case "Playlist":
            obj = new Playlist(item, { temporary: true, keepId: true, keepEmbeddedIds: true });
            break;
          // no default
        }

        if (!entry && obj && data.info.entity !== "Adventure") {
          const compendiumItem = await pack.importDocument(obj, { keepId: true, keepEmbeddedIds: true });

          if (JSON.stringify(item).match(this.pattern) || JSON.stringify(item).match(this.altpattern)) {
            this._itemsToRevisit.push(`Compendium.${pack.metadata.package}.${pack.metadata.name}.${compendiumItem.id}`);
          }
        }
        currentCount += 1;
        AdventureMunch._updateProgress(totalCount, currentCount, "Compendium");
      });
      currentCount += 1;
      AdventureMunch._updateProgress(totalCount, currentCount, "Compendium");
    });
  }

  // import a scene file
  async _importRenderedSceneFile(data, overwriteEntity) {
    if (!_AdventureMunchHelpers_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].findEntityByImportId */ .Z.findEntityByImportId("scenes", data._id) || overwriteEntity || this.importToAdventureCompendium) {
      await _AdventureMunchHelpers_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].asyncForEach */ .Z.asyncForEach(data.tokens, async (token) => {
        // eslint-disable-next-line require-atomic-updates
        if (token.img) token.img = await this.importImage(token.img);
        if (token.prototypeToken?.texture?.src) {
          // eslint-disable-next-line require-atomic-updates
          token.prototypeToken.texture.src = await this.importImage(token.prototypeToken.texture.src);
        }
      });

      await _AdventureMunchHelpers_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].asyncForEach */ .Z.asyncForEach(data.sounds, async (sound) => {
        // eslint-disable-next-line require-atomic-updates
        sound.path = await this.importImage(sound.path);
      });

      await _AdventureMunchHelpers_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].asyncForEach */ .Z.asyncForEach(data.notes, async (note) => {
        // eslint-disable-next-line require-atomic-updates
        if (note.icon) note.icon = await this.importImage(note.icon, true);
        // eslint-disable-next-line require-atomic-updates
        if (note.texture?.src) note.texture.src = await this.importImage(note.texture.src, true);
      });

      await _AdventureMunchHelpers_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].asyncForEach */ .Z.asyncForEach(data.tiles, async (tile) => {
        // eslint-disable-next-line require-atomic-updates
        tile.img = await this.importImage(tile.img);
      });

      if (overwriteEntity) await Scene.deleteDocuments([data._id]);
      const options = { keepId: true, keepEmbeddedIds: true, temporary: this.importToAdventureCompendium };
      const scene = await Scene.create(data, options);
      this._itemsToRevisit.push(`Scene.${scene.id}`);
      if (this.importToAdventureCompendium) this.temporary.scenes.push(scene);
    }
  }

  // eslint-disable-next-line complexity
  async _importRenderedFile(typeName, data, needRevisit, overwriteIds) {
    const overwriteEntity = overwriteIds.includes(data._id);
    const options = { keepId: true, keepEmbeddedIds: true, temporary: this.importToAdventureCompendium };
    switch (typeName) {
      case "Scene": {
        await this._importRenderedSceneFile(data, overwriteEntity);
        break;
      }
      case "Actor":
        if (!_AdventureMunchHelpers_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].findEntityByImportId */ .Z.findEntityByImportId("actors", data._id)) {
          let actor = await Actor.create(data, options);
          await actor.update({ [`prototypeToken.actorId`]: actor.id });
          if (needRevisit) this._itemsToRevisit.push(`Actor.${actor.id}`);
          if (this.importToAdventureCompendium) this.temporary.actors.push(actor);
        }
        break;
      case "Item":
        if (!_AdventureMunchHelpers_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].findEntityByImportId */ .Z.findEntityByImportId("items", data._id)) {
          let item = await Item.create(data, options);
          if (needRevisit) this._itemsToRevisit.push(`Item.${item.id}`);
          if (this.importToAdventureCompendium) this.temporary.items.push(item);
        }
        break;
      case "JournalEntry":
        if (!_AdventureMunchHelpers_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].findEntityByImportId */ .Z.findEntityByImportId("journal", data._id)) {
          let journal = await JournalEntry.create(data, options);
          if (needRevisit) this._itemsToRevisit.push(`JournalEntry.${journal.id}`);
          if (this.importToAdventureCompendium) this.temporary.journals.push(journal);
        }
        break;
      case "RollTable":
        if (!_AdventureMunchHelpers_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].findEntityByImportId */ .Z.findEntityByImportId("tables", data._id)) {
          let rolltable = await RollTable.create(data, options);
          if (needRevisit) this._itemsToRevisit.push(`RollTable.${rolltable.id}`);
          if (this.importToAdventureCompendium) this.temporary.tables.push(rolltable);
        }
        break;
      case "Playlist":
        if (!_AdventureMunchHelpers_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].findEntityByImportId */ .Z.findEntityByImportId("playlists", data._id)) {
          data.name = `${this.adventure.name}.${data.name}`;
          let playlist = await Playlist.create(data, options);
          if (this.importToAdventureCompendium) this.temporary.playlists.push(playlist);
        }
        break;
      case "Macro":
        if (!_AdventureMunchHelpers_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].findEntityByImportId */ .Z.findEntityByImportId("macros", data._id)) {
          let macro = await Macro.create(data, options);
          if (needRevisit) this._itemsToRevisit.push(`Macro.${macro.id}`);
          if (this.importToAdventureCompendium) this.temporary.macros.push(macro);
        }
        break;
      // no default
    }
  }

  async _checkForDataUpdates(type) {
    const importType = _AdventureMunchHelpers_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].getImportType */ .Z.getImportType(type);
    const dataFiles = this.raw[type];

    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].info */ .Z.info(`Checking ${this.adventure.name} - ${importType} (${dataFiles.length} for updates)`);

    let fileData = [];
    let hasVersions = false;

    await _AdventureMunchHelpers_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].asyncForEach */ .Z.asyncForEach(dataFiles, async (file) => {
      const raw = await this.zip.file(file.name).async("text");
      const json = JSON.parse(raw);
      if (!hasVersions && json?.flags?.ddb?.versions) {
        hasVersions = true;
      }
      switch (importType) {
        case "Scene": {
          const existingScene = await game.scenes.find((item) => item.id === json._id);
          const scene = _AdventureMunchHelpers_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].extractDocumentVersionData */ .Z.extractDocumentVersionData(json, existingScene);
          const sceneVersions = scene.flags?.ddb?.versions?.importer;
          if (existingScene) {
            if (
              sceneVersions
              && (sceneVersions.metaVersionChanged
                || sceneVersions.muncherVersionChanged
                || sceneVersions.foundryVersionNewer)
            ) {
              fileData.push(scene);
            }
          } else if (sceneVersions && sceneVersions.foundryVersionNewer) {
            fileData.push(scene);
          }
          break;
        }
        // no default
      }
    });

    return new Promise((resolve) => {
      if (hasVersions && fileData.length > 0) {
        new Dialog(
          {
            title: `${importType} updates`,
            content: {
              dataType: type,
              dataTypeDisplay: importType,
              fileData: fileData,
              cssClass: "import-data-updates",
            },
            buttons: {
              confirm: {
                label: "Confirm",
                callback: async () => {
                  const formData = $(".import-data-updates").serializeArray();
                  let ids = [];
                  let dataType = "";
                  for (let i = 0; i < formData.length; i++) {
                    const key = formData[i].name;
                    if (key.startsWith("new_")) {
                      ids.push(key.substr(4));
                    } else if (key === "type") {
                      dataType = formData[i].value;
                    }
                  }
                  resolve(this._importFile(dataType, ids));
                },
              },
            },
            default: "confirm",
            close: async () => {
              resolve(this._importFile(type));
            },
          },
          {
            width: 700,
            classes: ["dialog", "adventure-import-updates"],
            template: "modules/ddb-importer/handlebars/adventure/import-updates.hbs",
          }
        ).render(true);
      } else {
        resolve(this._importFile(type));
      }
    });
  }

  async _importTokenImage(tokenType, data, { img = false, texture = true } = {}) {
    if (data[tokenType]?.randomImg) {
      const imgFilepaths = data[tokenType].img.split("/");
      const imgFilename = imgFilepaths.reverse()[0];
      const imgFilepath = data[tokenType].img.replace(imgFilename, "");

      const filesToUpload = Object.values(this.zip.files).filter((file) => {
        return !file.dir && file.name.includes(imgFilepath);
      });

      let adventurePath = this.adventure.name.replace(/[^a-z0-9]/gi, "_");

      if (img) {
        const imgPath = `${this._importPathData.current}/${adventurePath}/${data[tokenType].img}`;
        data[tokenType].img = imgPath;
      }
      if (texture) {
        const imgPath = `${this._importPathData.current}/${adventurePath}/${data[tokenType].texture.src}`;
        data[tokenType].texture.src = imgPath;
      }

      if (filesToUpload.length > 0) {
        let currentCount = 1;

        await _AdventureMunchHelpers_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].asyncForEach */ .Z.asyncForEach(filesToUpload, async (file) => {
          await this.importImage(file.name);
          currentCount += 1;
          AdventureMunch._updateProgress(filesToUpload.length, currentCount, "Token Image");
        });
      }
    } else {

      if (img) {
        // eslint-disable-next-line require-atomic-updates
        data[tokenType].img = await this.importImage(data[tokenType].img);
      }
      if (texture) {
        // eslint-disable-next-line require-atomic-updates
        data[tokenType].texture.src = await this.importImage(data[tokenType].texture.src);
      }
    }

    return data;
  }

  async _importFile(type, overwriteIds = []) {
    let totalCount = 0;
    let currentCount = 0;

    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].info */ .Z.info(`IDs to overwrite of type ${type}: ${JSON.stringify(overwriteIds)}`);

    const importType = _AdventureMunchHelpers_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].getImportType */ .Z.getImportType(type);
    const dataFiles = this.raw[type];

    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].info */ .Z.info(`Importing ${this.adventure.name} - ${importType} (${dataFiles.length} items)`);

    totalCount = dataFiles.length;

    // eslint-disable-next-line complexity
    await _AdventureMunchHelpers_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].asyncForEach */ .Z.asyncForEach(dataFiles, async (file) => {
      const rawData = await this.zip.file(file.name).async("text");
      let data = JSON.parse(rawData);
      let needRevisit = false;

      // let pattern = /(\@[a-z]*)(\[)([a-z0-9]*|[a-z0-9\.]*)(\])/gmi
      if (rawData.match(this.pattern) || rawData.match(this.altpattern)) needRevisit = true;

      // eslint-disable-next-line require-atomic-updates
      data = await this._loadDocumentAssets(data, importType);

      if (data.flags.ddb.needRevisit) needRevisit = true;

      setProperty(data.flags, "ddbimporter.version", CONFIG.DDBI.version);

      if (importType !== "Playlist" && importType !== "Compendium") {
        if (this.lookups.folders[data.folder]) {
          _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(
            `Adding data to subfolder importkey = ${data.folder}, folder = ${
              this.lookups.folders[data.folder]
            }`
          );
          data.folder = this.lookups.folders[data.folder];
        } else {
          _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(
            `Adding data to subfolder importkey = ${data.folder}, folder = ${this.lookups.folders["null"]}`
          );
          if (this.adventure?.options?.folders) {
            data.folder = this.lookups.folders["null"];
          } else {
            data.folder = this.lookups.folders[importType];
          }
        }
      }

      await this._importRenderedFile(importType, data, needRevisit, overwriteIds);

      currentCount += 1;
      AdventureMunch._updateProgress(totalCount, currentCount, importType);
    });
  }

  /**
   * Replaced ddb links with compendium or world links
   * @param {Document} doc HTML document to act on
   * @param {Object} options provide journalWorldActors and actorData if linking to world actors
   * @returns {Document} HTML document with modified links
   */
  replaceLookupLinks(doc) {
    const lookups = this.lookups.adventureConfig.lookups;
    const actorData = this.adventure.required?.monsterData ?? [];

    for (const lookupKey in AdventureMunch.COMPENDIUM_MAP) {
      const compendiumLinks = doc.querySelectorAll(`a[href*="ddb://${lookupKey}/"]`);
      const lookupRegExp = new RegExp(`ddb://${lookupKey}/([0-9]*)`);
      compendiumLinks.forEach((node) => {
        const lookupMatch = node.outerHTML.match(lookupRegExp);
        const lookupValue = lookups[AdventureMunch.COMPENDIUM_MAP[lookupKey]];
        if (lookupValue) {
          const worldActorLink = this.journalWorldActors && ["monsters"].includes(lookupKey);
          const lookupEntry = worldActorLink
            ? actorData.find((a) => a.ddbId === parseInt(lookupMatch[1]))
            : lookupValue.find((e) => e.id == lookupMatch[1]);

          if (lookupEntry) {
            const pageLink = lookupEntry.pageId ? `.JournalEntryPage.${lookupEntry.pageId}` : "";
            const linkStub = lookupEntry.headerLink ? `#${lookupEntry.headerLink}` : "";
            const linkType = worldActorLink ? "UUID" : "Compendium";
            const linkBody = worldActorLink
              ? `Actor.${lookupEntry.actorId}`
              : `${lookupEntry.compendium}.${lookupEntry._id}${pageLink}${linkStub}`;
            doc.body.innerHTML = doc.body.innerHTML.replace(node.outerHTML, `@${linkType}[${linkBody}]{${node.textContent}}`);
          } else {
            _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].warn */ .Z.warn(`NO Lookup Compendium Entry for ${node.outerHTML}`);
          }
        }
      });
    }

    return doc;
  }

  /**
   * Replaced ddb links with compendium or world links, or links back to DDB
   * @param {Document} doc HTML document to act on
   * @param {Object} options provide journalWorldActors and actorData if linking to world actors
   * @returns {Document} HTML document with modified links
   */
  foundryCompendiumReplace(text) {
    // replace the ddb:// entries with known compendium look ups if we have them
    // ddb://spells
    // ddb://magicitems || weapons || adventuring-gear || armor
    // ddb://monsters

    let doc = this.replaceLookupLinks(_lib_utils_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"].htmlToDoc */ .Z.htmlToDoc(text));

    // vehicles - if not imported, link to DDB
    const compendiumLinks = doc.querySelectorAll("a[href*=\"ddb://vehicles/\"]");
    const lookupRegExp = /ddb:\/\/vehicles\/([0-9]*)/g;
    compendiumLinks.forEach((node) => {
      const target = node.outerHTML;
      const lookupMatch = node.outerHTML.match(lookupRegExp);
      const lookupValue = this.lookups.adventureConfig.lookups["vehicles"];
      if (lookupMatch) {
        const lookupEntry = lookupValue.find((e) => e.id == lookupMatch[1]);
        if (lookupEntry) {
          node.setAttribute("href", `https://www.dndbeyond.com${lookupEntry.url}`);
          doc.body.innerHTML = doc.body.innerHTML.replace(target, node.outerHTML);
        } else {
          _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].warn */ .Z.warn(`NO Vehicle Lookup Entry for ${node.outerHTML}`);
        }
      } else {
        _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].warn */ .Z.warn(`NO Vehicle Lookup Match for ${node.outerHTML}`);
      }
    });

    // final replace in case of failure
    // there is a chance that the adventure references items or monsters we don't have access to
    // in this case attempt to link to DDB instead of compendium doc
    for (const lookupKey in AdventureMunch.COMPENDIUM_MAP) {
      const compendiumLinks = doc.querySelectorAll(`a[href*="ddb://${lookupKey}/"]`);
      // logger.debug(`final replace for missing ${lookupKey} references`, compendiumLinks);

      compendiumLinks.forEach((node) => {
        const target = node.outerHTML;
        const ddbStub = AdventureMunch.DDB_MAP[lookupKey];
        const ddbNameGuess = node.textContent.toLowerCase().replace(" ", "-").replace(/[^0-9a-z-]/gi, '');
        _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].warn */ .Z.warn(`No Compendium Entry for ${node.outerHTML} attempting to guess a link to DDB`);

        node.setAttribute("href", `https://www.dndbeyond.com/${ddbStub}/${ddbNameGuess}`);
        doc.body.innerHTML = doc.body.innerHTML.replace(target, node.outerHTML);
      });
    }

    return doc.body.innerHTML;
  }

  static _updateProgress(total, count, type) {
    const localizedType = `ddb-importer.label.${type}`;
    $(".import-progress-bar")
      .width(`${Math.trunc((count / total) * 100)}%`)
      .html(
        `<span>${game.i18n.localize("ddb-importer.label.Working")} (${game.i18n.localize(localizedType)})...</span>`
      );
  }

  static _progressNote(note) {
    $(".import-progress-bar").html(`<span>${game.i18n.localize("ddb-importer.label.Working")} (${note})...</span>`);
  }
}


/***/ }),

/***/ 7801:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ AdventureMunchHelpers)
/* harmony export */ });
/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5259);
/* harmony import */ var _lib_CompendiumHelper_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3893);
/* harmony import */ var _lib_PatreonHelper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(8636);
/* harmony import */ var _spells_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(6502);
/* harmony import */ var _items_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(8638);
/* harmony import */ var _AdventureMunch_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(1423);
/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(6451);
/* harmony import */ var _DDBMonsterFactory_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(6870);
/* harmony import */ var _DDBMuncher_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(1475);










class AdventureMunchHelpers {

  static unPad(match, p1) {
    if (isNaN(parseInt(p1))) {
      return p1;
    } else {
      return parseInt(p1);
    }
  }

  /**
   * Async for each loop
   *
   * @param  {array} array - Array to loop through
   * @param  {function} callback - Function to apply to each array item loop
   */
  static async asyncForEach(array, callback) {
    for (let index = 0; index < array.length; index += 1) {
      // eslint-disable-next-line callback-return, no-await-in-loop
      await callback(array[index], index, array);
    }
  }

  /**
   * Find an entity by the import key.
   * @param  {string} type - Entity type to search for
   * @param  {string} id - Entity Id
   * @returns {object} - Entity Object Data
   */
  static findEntityByImportId(type, id) {
    return game.data[type].find((item) => item._id === id);
    // item.flags.importid === id
  }


  /**
   * Async replace for all matching patterns
   *
   * @param  {string} str - Original string to replace values in
   * @param  {string} regex - regex for matching
   * @param  {function} asyncFn - async function to run on each match
   * @returns {string}
   */
  static async replaceAsync(str, regex, asyncFn) {
    const promises = [];
    str.replace(regex, (match, ...args) => {
      const promise = asyncFn(match, ...args);
      promises.push(promise);
    });
    const data = await Promise.all(promises);
    return str.replace(regex, () => data.shift());
  }

  /**
   * Returns the difference between object 1 and 2
   * @param  {object} obj1
   * @param  {object} obj2
   * @returns {object}
   */
  static diff(obj1, obj2) {
    let result = {};
    for (const key in obj1) {
      if (obj2[key] != obj1[key]) result[key] = obj2[key];
      // eslint-disable-next-line valid-typeof
      if (typeof obj2[key] == 'array' && typeof obj1[key] == 'array')
        result[key] = this.diff(obj1[key], obj2[key]);
      if (typeof obj2[key] == 'object' && typeof obj1[key] == 'object')
        result[key] = this.diff(obj1[key], obj2[key]);
    }
    return result;
  }

  /**
   * Replaces matchAll as it's not yet available in Electron App
   * @param   {string} regex  RegEx to use
   * @param   {string} string String to match on
   * @returns {Array}
   */
  static reMatchAll(regexp, string) {
    const matches = string.match(new RegExp(regexp, "gm"));
    if (matches) {
      let start = 0;
      return matches.map((group0) => {
        const match = group0.match(regexp);
        match.index = string.indexOf(group0, start);
        start = match.index;
        return match;
      });
    }
    return matches;
  }

  /**
   * Uploads a file to Foundry without the UI Notification
   * @param  {string} source
   * @param  {string} path
   * @param  {blog} file
   * @param  {object} options
   */
  static async UploadFile(source, path, file, options) {
    if (typeof ForgeVTT !== "undefined" && ForgeVTT?.usingTheForge) {
      return AdventureMunchHelpers.ForgeUploadFile(path, file);
    }

    const fd = new FormData();
    fd.set("source", source);
    fd.set("target", path);
    fd.set("upload", file);
    Object.entries(options).forEach((o) => fd.set(...o));

    const request = await fetch(FilePicker.uploadURL, { method: "POST", body: fd });
    if (request.status === 413) {
      return ui.notifications.error(game.i18n.localize("FILES.ErrorTooLarge"));
    } else if (request.status !== 200) {
      return ui.notifications.error(game.i18n.localize("FILES.ErrorSomethingWrong"));
    }
    return undefined;
  }

  /**
   * Uploads a file to Forge Asset Library without the UI Notification
   * @param  {string} source
   * @param  {string} path
   * @param  {blog} file
   * @param  {object} options
   */
  static async ForgeUploadFile(path, file) {
    const fd = new FormData();
    fd.append("file", file);
    fd.append("path", `${path}/${file.name}`);

    const response = await ForgeAPI.call("assets/upload", fd);
    if (!response || response.error) {
      ui.notifications.error(response ? response.error : "An unknown error occured accessing The Forge API");
      return false;
    } else {
      return { path: response.url };
    }
  }

  /**
   * Browse files using FilePicker
   * @param  {string} source
   * @param  {string} target
   * @param  {object} options={}
   */
  static async BrowseFiles(source, target, options = {}) {
    if (typeof ForgeVTT !== "undefined" && ForgeVTT?.usingTheForge) {
      if (target.startsWith(ForgeVTT.ASSETS_LIBRARY_URL_PREFIX)) source = "forgevtt";

      if (source === "forgevtt") {
        return AdventureMunchHelpers.BrowseForgeFiles(source, target, options);
      }
    }

    return FilePicker.browse(source, target, options);
  }

  /**
   * Browse files using Forge API
   * @param  {string} source
   * @param  {string} target
   * @param  {object} options={}
   */
  static async BrowseForgeFiles(source, target, options = {}) {
    if (target.startsWith(ForgeVTT.ASSETS_LIBRARY_URL_PREFIX)) {
      if (options.wildcard)
        options.wildcard = target;
      target = target.slice(ForgeVTT.ASSETS_LIBRARY_URL_PREFIX.length);
      target = target.split("/").slice(1, -1).join("/"); // Remove userid from url to get target path
    }

    const response = await ForgeAPI.call('assets/browse', { path: decodeURIComponent(target), options });
    if (!response || response.error) {
      ui.notifications.error(response ? response.error : "An unknown error occured accessing The Forge API");
      return { target, dirs: [], files: [], gridSize: null, private: false, privateDirs: [], extensions: options.extensions };
    }
    // Should be decodeURIComponent but FilePicker's _onPick needs to do encodeURIComponent too, but on each separate path.
    response.target = decodeURI(response.folder);
    delete response.folder;
    response.dirs = response.dirs.map((d) => d.path.slice(0, -1));
    response.files = response.files.map((f) => f.url);
    // 0.5.6 specific
    response.private = true;
    response.privateDirs = [];
    response.gridSize = null;
    response.extensions = options.extensions;
    return response;
  }

  static async loadMissingDocuments(type, docIds) {
    return new Promise((resolve) => {
      if (docIds && docIds.length > 0) {
        switch (type) {
          case "item":
            _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug(`Importing missing ${type}s from DDB`, docIds);
            _AdventureMunch_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"]._progressNote */ .Z._progressNote(`Importing ${docIds.length} missing ${type}s from DDB`);
            resolve((0,_items_js__WEBPACK_IMPORTED_MODULE_4__/* .parseItems */ .S)(docIds));
            break;
          case "monster": {
            try {
              const tier = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "patreon-tier");
              const tiers = _lib_PatreonHelper_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].getPatreonTiers */ .Z.getPatreonTiers(tier);
              if (tiers.all) {
                _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug(`Importing missing ${type}s from DDB`, docIds);
                _AdventureMunch_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"]._progressNote */ .Z._progressNote(`Importing ${docIds.length} missing ${type}s from DDB`);
                const monsterFactory = new _DDBMonsterFactory_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z({ munchNote: _DDBMuncher_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].munchNote */ .Z.munchNote });
                resolve(monsterFactory.processIntoCompendium(docIds));
              } else {
                _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].warn */ .Z.warn(`Unable to import missing ${type}s from DDB - link to patreon or use your own proxy`, docIds);
                ui.notifications.warn(`Unable to import missing ${type}s from DDB - link to patreon or use your own proxy`, { permanent: true });
                resolve([]);
              }
            } catch (err) {
              if (err instanceof SyntaxError) {
                ui.notifications.error("Error fetching monsters, likely cause outdated ddb-proxy", { permanent: true });
              } else {
                throw err;
              }
            }
            break;
          }
          case "spell":
            _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug(`Importing missing ${type}s from DDB`);
            _AdventureMunch_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"]._progressNote */ .Z._progressNote(`Missing spells detected, importing from DDB`);
            // we actually want all spells, because monsters don't just use spells from a single source
            resolve((0,_spells_js__WEBPACK_IMPORTED_MODULE_3__/* .parseSpells */ .Z)());
            break;
          // no default
        }
      } else {
        resolve([]);
      }
    });
  }

  static async getCompendiumIndex(type) {
    return new Promise((resolve) => {
      const compendium = _lib_CompendiumHelper_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].getCompendiumType */ .Z.getCompendiumType(type);
      const fields = (type === "monster")
        ? ["flags.ddbimporter.id"]
        : ["flags.ddbimporter.definitionId"];

      const compendiumIndex = compendium.getIndex({ fields: fields });
      resolve(compendiumIndex);
    });
  }

  static async checkForMissingDocuments(type, ids) {
    const index = await AdventureMunchHelpers.getCompendiumIndex(type);
    // console.warn(`${type} index`, index);

    return new Promise((resolve) => {
      const missingIds = ids.filter((id) => {
        switch (type) {
          case "monster":
            return !index.some((i) => i.flags?.ddbimporter?.id && String(i.flags.ddbimporter.id) == String(id));
          case "spell":
          case "item":
            return !index.some((i) => i.flags?.ddbimporter?.definitionId && String(i.flags.ddbimporter.definitionId) == String(id));
          default:
            return false;
        }
      });
      _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug(`${type} missing ids`, missingIds);
      const missingDocuments = AdventureMunchHelpers.loadMissingDocuments(type, missingIds);
      _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug(`${type} missing`, missingDocuments);
      resolve(missingDocuments);
    });
  }

  /**
   * Get documents for ids from compendium
   * @param {string} type compendium type
   * @param {Array} ids array of ddb ids
   * @param {boolean} temporary create the items in the world?
   * @returns {Promise<Array>} array of world actors
   */
  static async getDocuments(type, ids, overrides = {}, temporary = false) {
    const compendium = _lib_CompendiumHelper_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].getCompendiumType */ .Z.getCompendiumType(type);
    const index = await AdventureMunchHelpers.getCompendiumIndex(type);
    const ddbIds = ids.map((num) => {
      return String(num);
    });

    return new Promise((resolve) => {
      const documents = index
        .filter((idx) => {
          switch (type) {
            case "monster":
              return ddbIds.includes(String(getProperty(idx, "flags.ddbimporter.id")));
            case "spell":
            case "item":
              return ddbIds.includes(String(getProperty(idx, "flags.ddbimporter.definitionId")));
            default:
              return false;
          }
        })
        .map((i) => {
          switch (type) {
            case "monster":
              return game.actors.importFromCompendium(compendium, i._id, overrides, { temporary, keepId: true, keepEmbeddedIds: true });
            case "spell":
            case "item":
              return game.items.importFromCompendium(compendium, i._id, overrides, { temporary, keepId: true, keepEmbeddedIds: true });
            default:
              // this should never happen
              return undefined;
          }

        });
      _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug(`${type} documents loaded`, documents);
      resolve(documents);
    });
  }


  static async linkExistingActorTokens(tokens) {
    const monsterIndex = await AdventureMunchHelpers.getCompendiumIndex("monster");

    const newTokens = tokens.map((token) => {
      const monsterHit = monsterIndex.find((monster) =>
        monster.flags?.ddbimporter?.id && token.flags.ddbActorFlags?.id
        && monster.flags.ddbimporter.id === token.flags.ddbActorFlags.id);
      if (monsterHit) {
        token.flags.compendiumActorId = monsterHit._id;
      }
      return token;
    });

    return newTokens;
  }

  // check the document for version data and for update info to see if we can replace it
  static extractDocumentVersionData(newDoc, existingDoc) {
    const ddbIVersion = game.modules.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID).version;
    if (!existingDoc) existingDoc = {};
    // do we have versioned metadata?
    setProperty(newDoc, "flags.ddb.versions.importer", {});
    if (newDoc?.flags?.ddb?.versions?.ddbMetaData?.lastUpdate) {
      // check old data, it might not exist
      const oldDDBMetaDataVersions = existingDoc.flags?.ddb?.versions?.ddbMetaData?.lastUpdate
        ? existingDoc.flags.ddb.versions.ddbMetaData
        : {
          lastUpdate: "0.0.1",
          drawings: "0.0.1",
          notes: "0.0.1",
          tokens: "0.0.1",
          walls: "0.0.1",
          lights: "0.0.1",
          foundry: "0.8.9",
        };
      const oldDDBImporterVersion = existingDoc?.flags?.ddb?.versions?.ddbImporter
        ? existingDoc.flags.ddb.versions.ddbImporter
        : "2.0.1";
      const oldAdventureMuncherVersion = existingDoc?.flags?.ddb?.versions?.adventureMuncher
        ? existingDoc.flags.ddb.versions.adventureMuncher
        : "0.3.0";
      const oldVersions = { ddbImporter: oldDDBImporterVersion, ddbMetaData: oldDDBMetaDataVersions, adventureMuncher: oldAdventureMuncherVersion };

      const documentVersions = newDoc.flags.ddb.versions;
      const documentFoundryVersion = documentVersions["ddbMetaData"]["foundry"] !== undefined ? documentVersions["ddbMetaData"]["foundry"] : "0.8.9";
      const importerVersionChanged = isNewerVersion(ddbIVersion, oldVersions["ddbImporter"]);
      const metaVersionChanged = isNewerVersion(documentVersions["ddbMetaData"]["lastUpdate"], oldVersions["ddbMetaData"]["lastUpdate"]);
      const muncherVersionChanged = isNewerVersion(documentVersions["adventureMuncher"], oldVersions["adventureMuncher"]);
      const foundryVersionNewer = isNewerVersion(documentFoundryVersion, game.version);

      let versionUpdates = {};

      if (metaVersionChanged || muncherVersionChanged || foundryVersionNewer) {
        versionUpdates.oldVersions = oldVersions;
        versionUpdates.importerVersionChanged = importerVersionChanged;
        versionUpdates.metaVersionChanged = metaVersionChanged;
        versionUpdates.muncherVersionChanged = muncherVersionChanged;
        versionUpdates.foundryVersionNewer = foundryVersionNewer;
        versionUpdates.drawingVersionChanged = isNewerVersion(documentVersions["ddbMetaData"]["drawings"], oldVersions["ddbMetaData"]["drawings"]);
        versionUpdates.noteVersionChanged = isNewerVersion(documentVersions["ddbMetaData"]["notes"], oldVersions["ddbMetaData"]["notes"]);
        versionUpdates.tokenVersionChanged = isNewerVersion(documentVersions["ddbMetaData"]["tokens"], oldVersions["ddbMetaData"]["tokens"]);
        versionUpdates.wallVersionChanged = isNewerVersion(documentVersions["ddbMetaData"]["walls"], oldVersions["ddbMetaData"]["walls"]);
        versionUpdates.lightVersionChanged = isNewerVersion(documentVersions["ddbMetaData"]["lights"], oldVersions["ddbMetaData"]["lights"]);
      }
      setProperty(newDoc, "flags.ddb.versions.importer", versionUpdates);
    }
    return newDoc;
  }

  static getImportType(type) {
    const typeName = type[0].toUpperCase() + type.slice(1);
    let importType = typeName;

    switch (type) {
      case "journal":
        importType = "JournalEntry";
        break;
      case "table":
        importType = "RollTable";
        break;
      default:
        importType = typeName;
        break;
    }

    return importType;
  }

  /**
   * Does the folder exist in the zip archive?
   * @param {String} folder folder name
   * @param {Zip} zip
   * @returns {Boolean}
   */
  static folderExists(folder, zip) {
    const files = Object.values(zip.files).filter((file) => {
      return file.dir && file.name.toLowerCase().includes(folder);
    });

    return files.length > 0;
  }

  /**
   * Get the files in the zip archive at the specified path
   * @param {String} folder a folder path to start from
   * @param {Zip} zip
   * @returns {Array} list of files in zip
   */
  static getFiles(folder, zip) {
    const files = Object.values(zip.files).filter((file) => {
      return !file.dir && file.name.split('.').pop() === 'json' && file.name.includes(`${folder}/`);
    });

    return files;
  }


}


/***/ }),

/***/ 6269:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FT": () => (/* binding */ createCompendiumFolderStructure),
/* harmony export */   "W3": () => (/* binding */ migrateExistingCompendium),
/* harmony export */   "l0": () => (/* binding */ addToCompendiumFolder)
/* harmony export */ });
/* harmony import */ var _lib_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7669);
/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5259);
/* harmony import */ var _dictionary_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(37);
/* harmony import */ var _lib_CompendiumHelper_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(3893);





let compendiumFolderTypeMonster;
let compendiumFolderTypeSpell;
let compendiumFolderTypeItem;

let rootItemFolders = {};
let equipmentFolders = {};
let weaponFolders = {};
let trinketFolders = {};
let consumableFolders = {};
let lootFolders = {};
let toolFolders = {};
let backpackFolders = {};

const spellLevelFolderNames = [
  "0th Level (Cantrip)",
  "1st Level",
  "2nd Level",
  "3rd Level",
  "4th Level",
  "5th Level",
  "6th Level",
  "7th Level",
  "8th Level",
  "9th Level",
];

const itemRarityNames = [
  "Common",
  "Uncommon",
  "Rare",
  "Very Rare",
  "Legendary",
  "Artifact",
  "Varies",
  "Unknown",
];

const rootItemFolderNames = {
  equipment: "Equipment",
  tool: "Tools",
  loot: "Loot",
  weapon: "Weapon",
  backpack: "Backpack",
  consumable: "Consumable",
};

const equipmentFolderNames = {
  heavy: "Heavy Armor",
  medium: "Medium Armor",
  light: "Light Armor",
  trinket: "Trinket",
  shield: "Shield",
};
const weaponFolderNames = {
  simpleM: "Simple Melee",
  simpleR: "Simple Ranged",
  martialM: "Martial Melee",
  martialR: "Martial Ranged",
};
const trinketFolderNames = ["Wand", "Wondrous item", "Ring", "Rod"];
const consumableFolderNames = ["Ammunition", "Potion", "Scroll", "Poison", "Adventuring Gear"];
const lootFolderNames = [
  "Adventuring Gear",
  "Vehicle",
  "Gemstone",
  "Mount",
  "Arcane Focus",
  "Holy Symbol",
  "Druidic Focus",
];
const toolFolderNames = {
  art: "Artisan's Tools",
  music: "Musical Instrument",
  game: "Gaming Set",
};
const backpackFolderNames = ["Equipment Pack", "Adventuring Gear", "Vehicle", "Mount"];

async function createCompendiumFolder(packName, folderName, color = "#6f0006") {
  const existingFolder = game.customFolders.fic.folders.find((f) => f.packCode === packName && f.name == folderName);
  return new Promise((resolve) => {
    if (!existingFolder) {
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].info */ .Z.info(`Creating compendium folder ${folderName}`);
      // createFolderAtRoot(packCode,name,color,fontColor)
      resolve(game.CF.FICFolderAPI.createFolderAtRoot(packName, folderName, color));
    } else {
      resolve(existingFolder);
    }
  });
}

async function createCompendiumFolderWithParent(packName, folderName, parentFolder, color = "#6f0006") {
  const existingFolder = game.customFolders.fic.folders.find(
    (f) => f.packCode === packName && f.name == folderName && f.parentId == parentFolder.id
  );
  return new Promise((resolve) => {
    if (!existingFolder) {
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].info */ .Z.info(`Creating compendium folder ${folderName} in ${parentFolder.name}`);
      resolve(game.CF.FICFolderAPI.createFolderWithParent(parentFolder, folderName, color));
    } else {
      resolve(existingFolder);
    }
  });
}

// assume type is monster compendium
async function createCreatureTypeCompendiumFolders(packName) {
  return new Promise((resolve) => {
    let promises = [];
    CONFIG.DDB.monsterTypes.forEach(async (monsterType) => {
      promises.push(createCompendiumFolder(packName, monsterType.name, "#6f0006"));
    });
    resolve(Promise.all(promises));
  });
}

// challenge rating
async function createChallengeRatingCompendiumFolders(packName) {
  return new Promise((resolve) => {
    let promises = [];
    CONFIG.DDB.challengeRatings.forEach((cr) => {
      const paddedCR = String(cr.value).padStart(2, "0");
      promises.push(createCompendiumFolder(packName, `CR ${paddedCR}`, "#6f0006"));
    });
    resolve(Promise.all(promises));
  });
}

// alphabetical
async function createAlphabeticalCompendiumFolders(packName) {
  return new Promise((resolve) => {
    let promises = [];
    for (let i = 9; ++i < 36;) {
      const folderName = i.toString(36).toUpperCase();
      createCompendiumFolder(packName, folderName, "#6f0006").then((folder) => {
        promises.push(folder);
      });
    }
    resolve(promises);
  });
}

// spell level
async function createSpellLevelCompendiumFolders(packName) {
  return new Promise((resolve) => {
    let promises = [];
    spellLevelFolderNames.forEach((levelName) => {
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].info */ .Z.info(`Creating folder '${levelName}'`);
      promises.push(createCompendiumFolder(packName, levelName));
    });
    resolve(Promise.all(promises));
  });
}

// spell school
async function createSpellSchoolCompendiumFolders(packName) {
  return new Promise((resolve) => {
    let promises = [];
    _dictionary_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].spell.schools.forEach */ .Z.spell.schools.forEach((school) => {
      const schoolName = _lib_utils_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].capitalize */ .Z.capitalize(school.name);
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].info */ .Z.info(`Creating folder '${schoolName}'`);
      promises.push(createCompendiumFolder(packName, schoolName));
    });
    resolve(Promise.all(promises));
  });
}

// item rarity folder
async function createItemRarityCompendiumFolders(packName) {
  return new Promise((resolve) => {
    let promises = [];
    itemRarityNames.forEach((rarityName) => {
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].info */ .Z.info(`Creating folder '${rarityName}'`);
      promises.push(createCompendiumFolder(packName, rarityName));
    });
    resolve(promises);
  });
}

// item type folder
async function createItemTypeCompendiumFolders(packName) {
  let promises = [];

  for (const [key, value] of Object.entries(rootItemFolderNames)) {
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].info */ .Z.info(`Creating root folder '${value}' with key '${key}'`);
    // eslint-disable-next-line no-await-in-loop
    const folder = await createCompendiumFolder(packName, value);
    rootItemFolders[key] = folder;
    promises.push(folder);
  }

  for (const [key, value] of Object.entries(equipmentFolderNames)) {
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].info */ .Z.info(`Creating Equipment folder '${value}' with key '${key}'`);
    // eslint-disable-next-line no-await-in-loop
    const folder = await createCompendiumFolderWithParent(packName, value, rootItemFolders["equipment"], "#222222");
    equipmentFolders[key] = folder;
    promises.push(folder);
  }

  for (const [key, value] of Object.entries(weaponFolderNames)) {
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].info */ .Z.info(`Creating Weapon folder '${value}' with key '${key}'`);
    // eslint-disable-next-line no-await-in-loop
    const folder = await createCompendiumFolderWithParent(packName, value, rootItemFolders["weapon"], "#222222");
    weaponFolders[key] = folder;
    promises.push(folder);
  }

  for (const [key, value] of Object.entries(toolFolderNames)) {
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].info */ .Z.info(`Creating Tool folder '${value}' with key '${key}'`);
    // eslint-disable-next-line no-await-in-loop
    const folder = await createCompendiumFolderWithParent(packName, value, rootItemFolders["tool"], "#222222");
    toolFolders[key] = folder;
    promises.push(folder);
  }

  for (const folderName of trinketFolderNames) {
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].info */ .Z.info(`Creating Equipment\\Trinket folder '${folderName}'`);
    // eslint-disable-next-line no-await-in-loop
    const folder = await createCompendiumFolderWithParent(packName, folderName, equipmentFolders["trinket"], "#444444");
    trinketFolders[folderName] = folder;
    promises.push(folder);
  }

  for (const folderName of consumableFolderNames) {
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].info */ .Z.info(`Creating Consumable folder '${folderName}'`);
    // eslint-disable-next-line no-await-in-loop
    const folder = await createCompendiumFolderWithParent(packName, folderName, rootItemFolders["consumable"], "#222222");
    consumableFolders[folderName] = folder;
    promises.push(folder);
  }

  for (const folderName of lootFolderNames) {
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].info */ .Z.info(`Creating Loot folder '${folderName}'`);
    // eslint-disable-next-line no-await-in-loop
    const folder = await createCompendiumFolderWithParent(packName, folderName, rootItemFolders["loot"], "#222222");
    lootFolders[folderName] = folder;
    promises.push(folder);
  }

  for (const folderName of backpackFolderNames) {
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].info */ .Z.info(`Creating Backpack folder '${folderName}'`);
    // eslint-disable-next-line no-await-in-loop
    const folder = await createCompendiumFolderWithParent(packName, folderName, rootItemFolders["backpack"], "#222222");
    backpackFolders[folderName] = folder;
    promises.push(folder);
  }

  return new Promise((resolve) => {
    resolve(promises);
  });
}

// create compendium folder structure
async function createCompendiumFolderStructure(type) {
  const compendiumFoldersInstalled = game.modules.get("compendium-folders")?.active;

  if (compendiumFoldersInstalled) {
    compendiumFolderTypeMonster = game.settings.get("ddb-importer", "munching-selection-compendium-folders-monster");
    compendiumFolderTypeSpell = game.settings.get("ddb-importer", "munching-selection-compendium-folders-spell");
    compendiumFolderTypeItem = game.settings.get("ddb-importer", "munching-selection-compendium-folders-item");
    // generate compendium folders for type
    const packName = await _lib_CompendiumHelper_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].getCompendiumLabel */ .Z.getCompendiumLabel(type);
    await game.CF.FICFolderAPI.loadFolders(packName);
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Creating Compendium folder structure for ${type}`);

    switch (type) {
      case "monsters":
      case "npc":
      case "monster": {
        switch (compendiumFolderTypeMonster) {
          case "TYPE": {
            await createCreatureTypeCompendiumFolders(packName);
            break;
          }
          case "ALPHA": {
            await createAlphabeticalCompendiumFolders(packName);
            break;
          }
          case "CR": {
            await createChallengeRatingCompendiumFolders(packName);
            break;
          }
          // no default
        }
        break;
      }
      case "spell":
      case "spells": {
        switch (compendiumFolderTypeSpell) {
          case "SCHOOL":
            await createSpellSchoolCompendiumFolders(packName);
            break;
          case "LEVEL":
            await createSpellLevelCompendiumFolders(packName);
            break;
          // no default
        }
        break;
      }
      case "inventory":
      case "item":
      case "items": {
        rootItemFolders = {};
        equipmentFolders = {};
        weaponFolders = {};
        trinketFolders = {};
        consumableFolders = {};
        lootFolders = {};
        toolFolders = {};
        backpackFolders = {};
        switch (compendiumFolderTypeItem) {
          case "TYPE":
            await createItemTypeCompendiumFolders(packName);
            break;
          case "RARITY":
            await createItemRarityCompendiumFolders(packName);
            break;
          // no default
        }
        break;
      }
      // no default
    }
    // reload folders
    return game.CF.FICFolderAPI.loadFolders(packName);
  }

  return undefined;
}

function getItemCompendiumFolderNameForRarity(document) {
  let name;
  const rarity = document.system.rarity;

  if (rarity && rarity != "") {
    switch (rarity.toLowerCase().trim()) {
      case "common":
        name = "Common";
        break;
      case "uncommon":
        name = "Uncommon";
        break;
      case "rare":
        name = "Rare";
        break;
      case "very rare":
      case "veryrare":
        name = "Very Rare";
        break;
      case "legendary":
        name = "Legendary";
        break;
      case "artifact":
        name = "Artifact";
        break;
      case "varies":
        name = "Varies";
        break;
      case "unknown":
      default:
        name = "Unknown";
        break;
    }
  } else {
    name = "Unknown";
  }
  return name;
}

function getItemCompendiumFolderNameForType(document) {
  let name;

  switch (document.type) {
    case "equipment": {
      switch (document.system?.armor?.type) {
        case "trinket": {
          const ddbType = document.flags?.ddbimporter?.dndbeyond?.type;
          if (ddbType) {
            name = trinketFolders[ddbType].name;
          }
          break;
        }
        default: {
          name = equipmentFolders[document.system.armor.type].name;
          break;
        }
      }
      break;
    }
    case "weapon": {
      name = weaponFolders[document.system.weaponType].name;
      break;
    }
    case "consumable": {
      const ddbType = document.flags?.ddbimporter?.dndbeyond?.type;
      if (ddbType) {
        name = consumableFolders[ddbType].name;
      }
      break;
    }
    case "loot": {
      const ddbType = document.flags?.ddbimporter?.dndbeyond?.type;
      if (ddbType) {
        name = lootFolders[ddbType].name;
      }
      break;
    }
    case "backpack": {
      const ddbType = document.flags?.ddbimporter?.dndbeyond?.type;
      if (ddbType) {
        name = backpackFolders[ddbType].name;
      }
      break;
    }
    case "tool": {
      const toolType = document.system.toolType;
      const instrument = document.flags?.ddbimporter?.dndbeyond?.tags.includes("Instrument");
      const ddbType = ["art", "music", "game"].includes(toolType);
      if (instrument) {
        name = toolFolders["music"].name;
      } else if (ddbType) {
        name = toolFolders[toolType].name;
      } else {
        name = rootItemFolders[document.type].name;
      }
      break;
    }
    default: {
      name = rootItemFolders[document.type].name;
      break;
    }
  }

  return name;
}

function getItemCompendiumFolderName(document) {
  let name;
  switch (compendiumFolderTypeItem) {
    case "RARITY": {
      name = getItemCompendiumFolderNameForRarity(document);
      break;
    }
    case "TYPE": {
      name = getItemCompendiumFolderNameForType(document);
      break;
    }
    // no default
  }
  return name;
}

function getCompendiumFolderName(type, document) {
  let name;
  switch (type) {
    case "monsters":
    case "npc":
    case "monster": {
      switch (compendiumFolderTypeMonster) {
        case "TYPE": {
          const creatureType = document.system?.details?.type?.value
            ? document.system?.details?.type?.value
            : "Unknown";
          const ddbType = CONFIG.DDB.monsterTypes.find((c) => creatureType.toLowerCase() == c.name.toLowerCase());
          if (ddbType) name = ddbType.name;
          break;
        }
        case "ALPHA": {
          name = document.name
            .replace(/[^a-z]/gi, "")
            .charAt(0)
            .toUpperCase();
          break;
        }
        case "CR": {
          if (document.system.details.cr !== undefined || document.system.details.cr !== "") {
            const paddedCR = String(document.system.details.cr).padStart(2, "0");
            name = `CR ${paddedCR}`;
          }
        }
        // no default
      }
      break;
    }
    case "spell":
    case "spells": {
      switch (compendiumFolderTypeSpell) {
        case "SCHOOL": {
          const school = document.system?.school;
          if (school) {
            name = _lib_utils_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].capitalize */ .Z.capitalize(_dictionary_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].spell.schools.find */ .Z.spell.schools.find((sch) => school == sch.id).name);
          }
          break;
        }
        case "LEVEL": {
          const levelFolder = spellLevelFolderNames[document.system?.level];
          if (levelFolder) {
            name = levelFolder;
          }
          break;
        }
        // no default
      }
      break;
    }
    case "inventory":
    case "item":
    case "items": {
      name = getItemCompendiumFolderName(document);
    }
    // no default
  }
  return name;
}

async function addToCompendiumFolder(type, document, folders) {
  const compendiumFoldersInstalled = game.modules.get("compendium-folders")?.active;

  if (compendiumFoldersInstalled && (folders || game.customFolders?.fic?.folders)) {
    if (!folders) folders = game.customFolders.fic.folders;
    const packName = await _lib_CompendiumHelper_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].getCompendiumLabel */ .Z.getCompendiumLabel(type);
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Checking ${document.name} in ${packName}`);

    switch (type) {
      case "inventory":
      case "items":
      case "item":
      case "spells":
      case "spell":
      case "monsters":
      case "npc":
      case "monster": {
        const folderName = getCompendiumFolderName(type, document);
        if (folderName) {
          const folder = folders.find((f) => f.packCode === packName && f.name == folderName);
          if (document?.flags?.cf?.id) setProperty(document, "flags.cf.id", undefined);
          if (folder) {
            _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].info */ .Z.info(`Moving ${type} ${document.name} to folder ${folder.name}`);
            await game.CF.FICFolderAPI.moveDocumentToFolder(packName, document, folder);
          } else {
            _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].error */ .Z.error(`Unable to find folder "${folderName}" in "${packName}" for ${type}`);
          }
        }
      }
      // no default
    }
  }
}

// create compendium folders for existing things
async function migrateExistingCompendium(type) {
  const compendiumFoldersInstalled = game.modules.get("compendium-folders")?.active;

  if (!compendiumFoldersInstalled) {
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].warn */ .Z.warn("Compendium Folders module is not installed");
    return new Promise((resolve) => {
      resolve(false);
    });
  }
  // loop through all existing monts/etc and generate a folder and move documents to it
  const packName = await _lib_CompendiumHelper_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].getCompendiumLabel */ .Z.getCompendiumLabel(type);

  if (game.CF.cleanupCompendium) {
    await game.CF.cleanupCompendium(packName);
  }

  const folders = await createCompendiumFolderStructure(type);

  _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug("Compendium Folders", folders);

  const compendium = _lib_CompendiumHelper_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].getCompendium */ .Z.getCompendium(packName);
  if (!compendium) return undefined;
  let indexFields = ["name"];
  switch (type) {
    case "spells":
    case "spell": {
      indexFields = ["name", "flags.cf", "data.level"];
      break;
    }
    case "inventory":
    case "items":
    case "item": {
      indexFields = [
        "name",
        "type",
        "flags.cf",
        "flags.ddbimporter.dndbeyond.type",
        "data.armor.type",
        "data.weaponType",
        "data.rarity"
      ];
      break;
    }
    // no default
  }

  const index = await compendium.getIndex({ fields: indexFields });

  switch (type) {
    case "inventory":
    case "items":
    case "item":
    case "spells":
    case "spell":
    case "monsters":
    case "npc":
    case "monster": {
      // loop through all existing monsters and move them to their type
      await index
        .filter((i) => i.name !== game.CF.TEMP_ENTITY_NAME)
        .forEach(async (i) => {
          const existing = await compendium.getDocument(i._id);
          await addToCompendiumFolder(type, existing, folders);
        });
      break;
    }
    // no default
  }

  const newFolders = await game.CF.FICFolderAPI.loadFolders(packName);

  return new Promise((resolve) => {
    resolve(newFolders);
  });
}


/***/ }),

/***/ 7728:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "$n": () => (/* binding */ addItemsDAESRD),
/* harmony export */   "TH": () => (/* binding */ migrateItemsDAESRD)
/* harmony export */ });
/* unused harmony exports loadPacks, migrateActorDAESRD */
/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5259);
/* harmony import */ var _import_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9193);
// Modified from https://gitlab.com/tposney/dae/-/blob/master/src/module/migration.ts

// MIT License

// Copyright (c) 2020 Tim Posney

// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.




var packsLoaded = false;
var itemPack;
var spellPack;
var featsPack;
var midiPack;
var magicItemsPack;
var midiItemsPack;
var midiSpellsPack;
var midiFeatsPack;


async function loadPacks() {
  if (packsLoaded) return;
  const items = game.packs.get("Dynamic-Effects-SRD.DAE SRD Items");
  itemPack = items ? await items.getDocuments() : [];

  const spells = game.packs.get("Dynamic-Effects-SRD.DAE SRD Spells");
  spellPack = spells ? await spells.getDocuments() : [];

  const magicItems = game.packs.get("Dynamic-Effects-SRD.DAE SRD Magic Items");
  magicItemsPack = magicItems ? await magicItems.getDocuments() : [];

  const feats = game.packs.get("Dynamic-Effects-SRD.DAE SRD Feats");
  featsPack = feats ? await feats.getDocuments() : [];

  const srdMidi = game.packs.get("Dynamic-Effects-SRD.DAE SRD Midi-collection");
  midiPack = srdMidi ? await srdMidi.getDocuments() : [];

  const midiItems = game.packs.get("midi-srd.Midi SRD Items");
  midiItemsPack = midiItems ? await midiItems.getDocuments() : [];
  const midiSpells = game.packs.get("midi-srd.Midi SRD Spells");
  midiSpellsPack = midiSpells ? await midiSpells.getDocuments() : [];
  const midiFeats = game.packs.get("midi-srd.Midi SRD Feats");
  midiFeatsPack = midiFeats ? await midiFeats.getDocuments() : [];

  // eslint-disable-next-line require-atomic-updates
  packsLoaded = true;
}

function findDAEItem(itemData, packs) {
  for (let pack of packs) {
    let matchItem = pack.find((pd) =>
      pd.name === itemData.name
      && pd.type === itemData.type
    );
    // console.warn(itemData.name);
    // console.warn(matchItem);
    if (matchItem) {
      matchItem = duplicate(matchItem);
      delete matchItem._id;
      return matchItem;
    }

  }
  return undefined;
}

function dataSwap(itemData, replaceData) {
  (0,_import_js__WEBPACK_IMPORTED_MODULE_1__/* .updateCharacterItemFlags */ .Oi)(itemData, replaceData);
  if (itemData._id) {
    replaceData._id = itemData._id;
  } else {
    delete replaceData._id;
  }
  if (itemData.flags) replaceData.flags = { ...itemData.flags, ...replaceData.flags };
  if (replaceData.effects.length > 0) {
    replaceData.effects = replaceData.effects.map((effect) => {
      delete effect._id;
      return effect;
    });
  }
  return replaceData;
}

function matchItem(itemData) {
  // we only add the midi packs if midi is actually installed
  let returnItem = null;
  switch (itemData.type) {
    case "feat": {
      const featPacks = [midiFeatsPack, midiPack, featsPack];
      returnItem = findDAEItem(itemData, featPacks);
      break;
    }
    case "spell": {
      const spellPacks = [midiSpellsPack, midiPack, spellPack];
      returnItem = findDAEItem(itemData, spellPacks);
      break;
    }
    case "equipment":
    case "weapon":
    case "loot":
    case "consumable":
    case "tool":
    case "backpack": {
      const equipmentPacks = [midiItemsPack, midiPack, itemPack, magicItemsPack];
      returnItem = findDAEItem(itemData, equipmentPacks);
      break;
    }
    default:
      break;
  }
  return returnItem;
}


/**
 * Migrates items wholesale
 * @param {*} items
 */
async function migrateItemsDAESRD(items) {
  if (!packsLoaded) await loadPacks();

  return new Promise((resolve) => {
    resolve(
      items.map((itemData) => {
        let replaceData = matchItem(itemData);
        if (replaceData) {
          _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug(`migrating ${replaceData.name}`);
          setProperty(replaceData, "flags.dae.migrated", true);
          return dataSwap(itemData, replaceData);
        }
        return itemData;
      })
    );
  });
}

/**
 * Adds dae effects to existing items
 * @param {*} items
 */
async function addItemsDAESRD(items) {
  // eslint-disable-next-line require-atomic-updates
  if (!packsLoaded) await loadPacks();

  return new Promise((resolve) => {
    resolve(
      items.map((itemData) => {
        let replaceData = matchItem(itemData);
        if (replaceData && !replaceData.name.startsWith("Unarmored Defense")) {
          _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug(`Adding effects for ${replaceData.name}`);
          itemData.effects = replaceData.effects;
          if (replaceData.flags.dae) itemData.flags.dae = replaceData.flags.dae;
          if (replaceData.flags['midi-qol']) itemData.flags['midi-qol'] = replaceData.flags['midi-qol'];
          if (replaceData.flags.itemacro) itemData.flags.itemacro = replaceData.flags.itemacro;
          if (replaceData.flags.itemmacro) itemData.flags.itemmacro = replaceData.flags.itemmacro;
        }
        return itemData;
      })
    );
  });
}

/**
 * Replaces matching items in an actor
 * @param {*} actor
 */
async function migrateActorDAESRD(actor, includeSRD = false) {
  await DAE.migrateActorDAESRD(actor, includeSRD);
}


/***/ }),

/***/ 267:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "S": () => (/* binding */ getFeats)
/* harmony export */ });
/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5259);
/* harmony import */ var _lib_DDBTemplateStrings_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(258);
/* harmony import */ var _lib_DDBHelper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1438);
/* harmony import */ var _import_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(9193);
/* harmony import */ var _DDBMuncher_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(1475);






const FEAT_TEMPLATE = {
  "name": "",
  "type": "feat",
  "system": {
    "description": {
      "value": "",
      "chat": "",
      "unidentified": ""
    },
    "type": {
      "value": "feat",
    },
    "source": "",
  },
  "sort": 2600000,
  "flags": {
    "ddbimporter": {
      "type": "feat",
    },
    "obsidian": {
      "source": {
        "type": "feat"
      }
    },
  },
  "img": null
};

function buildBase(data) {
  let result = duplicate(FEAT_TEMPLATE);

  result.name = data.name;
  result.system.description.value += `${data.description}\n\n`;
  result.system.description.chat += `${data.snippet}\n\n`;

  result.flags.ddbimporter = {
    featId: data.id,
    version: CONFIG.DDBI.version,
  };

  result.flags.ddbimporter['prerequisites'] = data.prerequisites;
  if (data.prerequisites.length > 0) {
    const requirements = data.prerequisites.map((requirement) => requirement.description);
    result.system.requirements = requirements.join(", ");
    result.system.description.value += `<h3>Requirements</h3>\n\n${requirements.join("\n\n")}\n\n`;
  }

  result.system.source = _lib_DDBHelper_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].parseSource */ .Z.parseSource(data);

  result.system.description.value = (0,_lib_DDBTemplateStrings_js__WEBPACK_IMPORTED_MODULE_1__/* .parseTags */ .RN)(result.system.description.value);

  return result;
}


async function buildFeat(feat,) {
  let result = buildBase(feat);

  return result;
}


async function getFeats(data) {
  _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug("get feats started");
  const updateBool = game.settings.get("ddb-importer", "munching-policy-update-existing");

  let feats = [];

  data.forEach((feat) => {
    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug(`${feat.name} feat parsing started...`);
    const parsedFeat = buildFeat(feat);
    feats.push(parsedFeat);
  });

  const fiddledFeats = await (0,_import_js__WEBPACK_IMPORTED_MODULE_3__/* .srdFiddling */ .cC)(feats, "feats");
  const finalFeats = await (0,_import_js__WEBPACK_IMPORTED_MODULE_3__/* .daeFiddling */ .xh)(fiddledFeats);

  _DDBMuncher_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].munchNote */ .Z.munchNote(`Importing ${finalFeats.length} feats!`, true);
  await (0,_import_js__WEBPACK_IMPORTED_MODULE_3__/* .updateCompendium */ .X)("feats", { feats: finalFeats }, updateBool);

  return finalFeats;
}


/***/ }),

/***/ 9193:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BO": () => (/* binding */ getDDBEquipmentIcons),
/* harmony export */   "CW": () => (/* binding */ getSRDIconLibrary),
/* harmony export */   "EX": () => (/* binding */ compendiumFolders),
/* harmony export */   "Er": () => (/* binding */ removeItems),
/* harmony export */   "Oi": () => (/* binding */ updateCharacterItemFlags),
/* harmony export */   "X": () => (/* binding */ updateCompendium),
/* harmony export */   "X9": () => (/* binding */ retainExistingIcons),
/* harmony export */   "ah": () => (/* binding */ addMagicItemSpells),
/* harmony export */   "ao": () => (/* binding */ loadPassedItemsFromCompendium),
/* harmony export */   "cC": () => (/* binding */ srdFiddling),
/* harmony export */   "m$": () => (/* binding */ getDDBGenericItemIcons),
/* harmony export */   "oU": () => (/* binding */ addItemEffectIcons),
/* harmony export */   "pI": () => (/* binding */ getCompendiumItems),
/* harmony export */   "pV": () => (/* binding */ getDDBSpellSchoolIcons),
/* harmony export */   "pt": () => (/* binding */ getIndividualOverrideItems),
/* harmony export */   "u4": () => (/* binding */ copySRDIcons),
/* harmony export */   "uc": () => (/* binding */ looseItemNameMatch),
/* harmony export */   "uf": () => (/* binding */ copySupportedItemFlags),
/* harmony export */   "wW": () => (/* binding */ getSRDCompendiumItems),
/* harmony export */   "wo": () => (/* binding */ updateIcons),
/* harmony export */   "xh": () => (/* binding */ daeFiddling)
/* harmony export */ });
/* unused harmony exports filterItemsByUserSelection, updateMidiFlags, updateMagicItemImages, updateMatchingItems, addACEffectIcons */
/* harmony import */ var _lib_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7669);
/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5259);
/* harmony import */ var _dictionary_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(37);
/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(6451);
/* harmony import */ var _lib_FileHelper_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(2397);
/* harmony import */ var _lib_CompendiumHelper_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(3893);
/* harmony import */ var _DDBMuncher_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(1475);
/* harmony import */ var _dae_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(7728);
/* harmony import */ var _icons_index_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(6547);
/* harmony import */ var _compendiumFolders_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(6269);











async function loadpacks(compendiumName) {
  if (CONFIG.DDBI.SRD_LOAD.packsLoaded[compendiumName]) return;
  const srdPack = _lib_CompendiumHelper_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].getCompendium */ .Z.getCompendium(compendiumName);
  if (!srdPack) {
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].error */ .Z.error(`Failed to load SRDPack ${compendiumName}`);
  } else {
    // eslint-disable-next-line require-atomic-updates
    CONFIG.DDBI.SRD_LOAD.packs[compendiumName] = await srdPack.getDocuments();
    // eslint-disable-next-line require-atomic-updates
    CONFIG.DDBI.SRD_LOAD.packsLoaded[compendiumName] = true;
  }
}

/**
 * Removes items
 * @param {*} items
 * @param {*} itemsToRemove
 */
async function removeItems(items, itemsToRemove, matchDDBId = false) {
  return new Promise((resolve) => {
    resolve(
      items.filter(
        (item) =>
          !itemsToRemove.some((originalItem) =>
            (item.name === originalItem.name || item.flags?.ddbimporter?.originalName === originalItem.name)
            && item.type === originalItem.type
            && (!matchDDBId || (matchDDBId && item.flags?.ddbimporter?.id === originalItem.flags?.ddbimporter?.id))
          )
      )
    );
  });
}

function getCharacterUpdatePolicyTypes() {
  let itemTypes = [];
  itemTypes.push("class");
  if (game.settings.get("ddb-importer", "character-update-policy-feat")) itemTypes.push("feat");
  if (game.settings.get("ddb-importer", "character-update-policy-weapon")) itemTypes.push("weapon");
  if (game.settings.get("ddb-importer", "character-update-policy-equipment"))
    itemTypes = itemTypes.concat(DICTIONARY.types.equipment);
  if (game.settings.get("ddb-importer", "character-update-policy-spell")) itemTypes.push("spell");
  return itemTypes;
}

/**
 * Returns a combined array of all items to process, filtered by the user's selection on what to skip and what to include
 * @param {object} result object containing all character items sectioned as individual properties
 * @param {array[string]} sections an array of object properties which should be filtered
 */
function filterItemsByUserSelection(result, sections) {
  let items = [];
  const validItemTypes = getCharacterUpdatePolicyTypes();

  for (const section of sections) {
    items = items.concat(result[section]).filter((item) => validItemTypes.includes(item.type));
  }
  return items;
};

async function copyFlagGroup(flagGroup, originalItem, targetItem) {
  if (targetItem.flags === undefined) targetItem.flags = {};
  // if we have generated effects we dont want to copy some flag groups. mostly for AE on spells
  const effectsProperty = getProperty(targetItem, "flags.ddbimporter.effectsApplied")
    && _settings_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].EFFECTS_IGNORE_FLAG_GROUPS.includes */ .Z.EFFECTS_IGNORE_FLAG_GROUPS.includes(flagGroup);
  if (originalItem.flags && !!originalItem.flags[flagGroup] && !effectsProperty) {
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Copying ${flagGroup} for ${originalItem.name}`);
    targetItem.flags[flagGroup] = originalItem.flags[flagGroup];
  }
}

/**
 * Copies across some flags for existing item
 * @param {*} items
 */
async function copySupportedItemFlags(originalItem, targetItem) {
  _settings_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].SUPPORTED_FLAG_GROUPS.forEach */ .Z.SUPPORTED_FLAG_GROUPS.forEach((flagGroup) => {
    copyFlagGroup(flagGroup, originalItem, targetItem);
  });
}

function getMonsterNames(name) {
  let magicNames = [name, name.toLowerCase()];

  // +2 sword
  let frontPlus = name.match(/^(\+\d*)\s*(.*)/);
  if (frontPlus) {
    magicNames.push(`${frontPlus[2].trim()}, ${frontPlus[1]}`.toLowerCase().trim());
  }

  // sword +2
  let backPlus = name.match(/(.*)\s*(\+\d*)$/);
  if (backPlus) {
    magicNames.push(`${backPlus[1].trim()}, ${backPlus[2]}`.toLowerCase().trim());
  }

  return magicNames;
}

function getLooseNames(name, extraNames = []) {
  let looseNames = extraNames;
  looseNames.push(name.toLowerCase());
  let refactNameArray = name.split("(")[0].trim().split(", ");
  refactNameArray.unshift(refactNameArray.pop());
  const refactName = refactNameArray.join(" ").trim();
  looseNames.push(refactName, refactName.toLowerCase());
  looseNames.push(refactName.replace(/\+\d*\s*/, "").trim().toLowerCase());
  looseNames.push(refactName.replace(/\+\d*\s*/, "").trim().toLowerCase().replace(/s$/, ""));

  let refactNamePlusArray = name.replace(/\+\d*\s*/, "").trim().split("(")[0].trim().split(", ");
  refactNamePlusArray.unshift(refactNamePlusArray.pop());
  const refactNamePlus = refactNamePlusArray.join(" ").trim();
  looseNames.push(refactNamePlus.toLowerCase());

  let deconNameArray = name.replace("(", "").replace(")", "").trim().split(",");
  deconNameArray.unshift(deconNameArray.pop());
  const deconName = deconNameArray.join(" ").trim();
  looseNames.push(deconName, deconName.toLowerCase());

  // word smart quotes are the worst
  looseNames.push(name.replace("'", "â€™").toLowerCase());
  looseNames.push(name.replace("â€™", "'").toLowerCase());
  looseNames.push(name.replace(/s$/, "").toLowerCase()); // trim s, e.g. crossbow bolt(s)
  looseNames.push(name.replace(",", "").toLowerCase()); // +1 weapons etc
  looseNames.push(`${name} attack`.toLowerCase()); // Claw Attack
  looseNames.push(name.split(",")[0].toLowerCase());

  return looseNames;
}

// The monster setting is less vigorous!
async function looseItemNameMatch(item, items, loose = false, monster = false, magicMatch = false) {
  // first pass is a strict match
  let matchingItem = items.find((matchItem) => {
    let activationMatch = false;
    const alternativeNames = matchItem.flags?.ddbimporter?.dndbeyond?.alternativeNames;
    const extraNames = (alternativeNames) ? matchItem.flags.ddbimporter.dndbeyond.alternativeNames : [];

    const itemActivationProperty = Object.prototype.hasOwnProperty.call(item.system, 'activation');
    const matchItemActivationProperty = Object.prototype.hasOwnProperty.call(item.system, 'activation');

    if (itemActivationProperty && item.system?.activation?.type == "") {
      activationMatch = true;
    } else if (matchItemActivationProperty && itemActivationProperty) {
      // I can't remember why I added this. Maybe I was concerned about identical named items with
      // different activation times?
      // maybe I just want to check it exists?
      // causing issues so changed.
      // activationMatch = matchItem.system.activation.type === item.system.activation.type;
      activationMatch = matchItemActivationProperty && itemActivationProperty;
    } else if (!itemActivationProperty) {
      activationMatch = true;
    }

    const nameMatch = item.name === matchItem.name || extraNames.includes(item.name);
    const isMatch = nameMatch && item.type === matchItem.type && activationMatch;
    return isMatch;
  });

  if (!matchingItem && monster) {
    matchingItem = items.find(
      (matchItem) => {
        const monsterNames = getMonsterNames(matchItem.name);
        const monsterMatch = (monsterNames.includes(item.name.toLowerCase()))
          && _dictionary_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].types.monster.includes */ .Z.types.monster.includes(matchItem.type)
          && _dictionary_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].types.inventory.includes */ .Z.types.inventory.includes(item.type);
        return monsterMatch;
      });
  }

  if (!matchingItem && magicMatch) {
    // is this an inverse match for updates?
    // if so strip out the non-magic names, we want to match on the magic names
    const magicName = item.name.replace(/(.*)\s+(\+\d*)\s*/, "$1, $2").trim().toLowerCase();
    matchingItem = items.find(
      (matchItem) => matchItem.name.trim().toLowerCase() == magicName
    );
  }

  if (!matchingItem && loose) {
    const looseNames = getLooseNames(item.name)
      .filter((name) => {
        if (!magicMatch) return true;
        const removeMagicName = name.replace(/\+\d*\s*/, "").trim();
        if (name === removeMagicName) return false;
        return true;
      });
    // lets go loosey goosey on matching equipment, we often get types wrong
    matchingItem = items.find(
      (matchItem) =>
        (looseNames.includes(matchItem.name.toLowerCase()) || looseNames.includes(matchItem.name.toLowerCase().replace(" armor", "")))
        && _dictionary_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].types.inventory.includes */ .Z.types.inventory.includes(item.type)
        && _dictionary_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].types.inventory.includes */ .Z.types.inventory.includes(matchItem.type)
    );

    // super loose name match!
    if (!matchingItem) {
      // still no matching item, lets do a final pass
      matchingItem = items.find(
        (matchItem) => looseNames.includes(matchItem.name.split("(")[0].trim().toLowerCase())
      );
    }
  }
  return matchingItem;
}

function flagMatch(item1, item2, matchFlags) {
  // console.warn("flagMatch", {item1, item2, matchFlags});
  if (matchFlags.length === 0) return true;
  const matched = matchFlags.some((flag) =>
    item1.flags.ddbimporter[flag] && item2.flags.ddbimporter[flag]
    && item1.flags.ddbimporter[flag] === item2.flags.ddbimporter[flag]
  );
  return matched;
}

async function getFilteredItems(compendium, item, index, matchFlags) {
  const indexEntries = index.filter((idx) => idx.name === item.name);

  const mapped = await Promise.all(indexEntries.map((idx) => {
    const entry = compendium.getDocument(idx._id).then((doc) => doc);
    return entry;
  }));

  const flagFiltered = mapped.filter((idx) => {
    const nameMatch = idx.name === item.name;
    const flagMatched = flagMatch(idx, item, matchFlags);
    return nameMatch && flagMatched;
  });

  return flagFiltered;
}

// async function getFlaggedItems(compendium, items, index, matchFlags) {
//   let results = [];
//   items.forEach((item) => {
//     const flagged = getFilteredItems(compendium, item, index, matchFlags);
//     results.push(flagged);
//   });
//   return Promise.all(results);
// }

async function updateCompendiumItems(compendium, inputItems, index, matchFlags) {
  let updates = [];
  inputItems.forEach(async (item) => {
    const existingItems = await getFilteredItems(compendium, item, index, matchFlags);
    // we have a match, update first match
    if (existingItems.length >= 1) {
      const existing = existingItems[0];
      // eslint-disable-next-line require-atomic-updates
      item._id = existing._id;
      _DDBMuncher_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].munchNote */ .Z.munchNote(`Updating ${item.name} compendium entry`);
      // purge existing active effects on this item
      if (existing.results) await existing.deleteEmbeddedDocuments("TableResult", [], { deleteAll: true });
      if (existing.effects) await existing.deleteEmbeddedDocuments("ActiveEffect", [], { deleteAll: true });
      if (existing.flags) await copySupportedItemFlags(existing, item);

      const tableUpdate = await existing.update(item, { pack: compendium.metadata.id });
      // v10 bug - left in until fixed - tables don't update correctly
      // if (tableUpdate === undefined) console.warn("Undefined table update");
      updates.push(tableUpdate);
    }
  });

  // in v10 the table.update may not be returning all the updated items correctly

  return updates;
  // const results = await RollTable.updateDocuments(updates, { pack: compendium.metadata.id });
  // console.warn(results);
  // return results;
}

async function updateMidiFlags() {
  const compendium = game.packs.get("midi-srd.Midi SRD Spells");
  const index = await compendium.getIndex();
  const docs = await compendium.getDocuments();
  const spells = docs.map((s) => s.toObject()).filter((s) => s.type === "spell");
  const filteredSpells = spells.map((s) => {
    delete s.flags.dynamiceffects;
    delete s.flags.core;
    if (s.flags.itemacro && s.flags.itemacro.macro.data.command == "") delete s.flags.itemacro;
    if (s.flags.itemacro) {
      delete s.flags.itemacro.macro._data;
      delete s.flags.itemacro.macro.data.author;
    }
    const effects = s.effects.map((e) => {
      if (e.flags) {
        let flags = { };
        if (e.flags.dae && e.flags.dae.macroRepeat !== "none") setProperty(flags, "dae.macroRepeat", e.flags.dae.macroRepeat);
        if (e.flags["midi-qol"]) flags["midi-qol"] = e.flags["midi-qol"];
        e.flags = flags;
      }
      return e;
    });
    s.effects = effects;

    return s;
  });

  updateCompendiumItems(compendium, filteredSpells, index, []);

}

// window.updateMidiFlags = updateMidiFlags;

async function createCompendiumItems(type, compendium, inputItems, index, matchFlags) {
  let promises = [];
  // compendiumItems.forEach(async (item) => {
  for (const item of inputItems) {
    // eslint-disable-next-line no-await-in-loop
    const existingItems = await getFilteredItems(compendium, item, index, matchFlags);
    // we have a single match
    if (existingItems.length === 0) {
      let newItem;
      switch (type) {
        case "table":
        case "tables": {
          newItem = new RollTable(item);
          break;
        }
        default: {
          try {
            // eslint-disable-next-line no-await-in-loop
            newItem = await Item.create(item, {
              temporary: true,
              displaySheet: false,
            });
          } catch (err) {
            _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].error */ .Z.error(`Error creating ${item.name}`, { item, err });
            throw err;
          }

        }
      }
      if (!newItem) {
        _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].error */ .Z.error(`Item ${item.name} failed creation`, { item, newItem });
      }
      _DDBMuncher_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].munchNote */ .Z.munchNote(`Creating ${item.name}`);
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Pushing ${item.name} to compendium`);
      promises.push(compendium.importDocument(newItem));
    }
  };
  return Promise.all(promises);
}

async function compendiumFolders(document, type) {
  // using compendium folders?
  const compendiumFolderAdd = game.settings.get("ddb-importer", "munching-policy-use-compendium-folders");
  const compendiumFoldersInstalled = game.modules.get("compendium-folders")?.active;
  if (compendiumFolderAdd && compendiumFoldersInstalled) {
    // we create the compendium folder before import
    _DDBMuncher_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].munchNote */ .Z.munchNote(`Adding ${document.name} to compendium folder`);
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Adding ${document.name} to compendium folder`);
    await (0,_compendiumFolders_js__WEBPACK_IMPORTED_MODULE_9__/* .addToCompendiumFolder */ .l0)(type, document);
  }
}

async function updateCompendium(type, input, updateExisting = false, matchFlags = []) {
  _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Getting compendium for update of ${type} documents (checking ${input[type].length} docs)`);
  const compendium = await _lib_CompendiumHelper_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].getCompendiumType */ .Z.getCompendiumType(type);
  compendium.configure({ locked: false });

  if (game.user.isGM) {
    const initialIndex = await compendium.getIndex();
    // remove duplicate items based on name and type
    const inputItems = [...new Map(input[type].map((item) => {
      let filterItem = item["name"] + item["type"];
      matchFlags.forEach((flag) => {
        filterItem += item.flags.ddbimporter[flag];
      });
      return [filterItem, item];
    })).values()];

    let updateResults = [];
    // update existing items
    _DDBMuncher_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].munchNote */ .Z.munchNote(`Creating and updating ${inputItems.length} new ${type} items in compendium...`, true);

    if (updateExisting) {
      updateResults = await updateCompendiumItems(compendium, inputItems, initialIndex, matchFlags);
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Updated ${updateResults.length} existing ${type} items in compendium`);
    }

    // create new items
    const createResults = await createCompendiumItems(type, compendium, inputItems, initialIndex, matchFlags);
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Created ${createResults.length} new ${type} items in compendium`);
    _DDBMuncher_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].munchNote */ .Z.munchNote("", true);

    // compendium folders
    createResults.forEach(async (document) => {
      await compendiumFolders(document, type);
    });

    const results = createResults.concat(updateResults);
    return new Promise((resolve) => resolve(results));
  }
  return [];
}

async function getSRDIconMatch(type) {
  const compendiumName = _settings_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].SRD_COMPENDIUMS.find */ .Z.SRD_COMPENDIUMS.find((c) => c.type == type).name;
  if (!CONFIG.DDBI.SRD_LOAD.packsLoaded[compendiumName]) await loadpacks(compendiumName);

  const items = CONFIG.DDBI.SRD_LOAD.packs[compendiumName].map((item) => {
    let smallItem = {
      name: item.name,
      img: item.img,
      type: item.type,
      system: {},
    };
    if (item.system.activation) smallItem.system.activation = item.system.activation;
    return smallItem;
  });

  return items;
}

async function getSRDIconLibrary() {
  if (CONFIG.DDBI.SRD_LOAD.mapLoaded) return CONFIG.DDBI.SRD_LOAD.iconMap;
  const compendiumFeatureItems = await getSRDIconMatch("features");
  const compendiumInventoryItems = await getSRDIconMatch("inventory");
  const compendiumSpellItems = await getSRDIconMatch("spells");
  const compendiumMonsterFeatures = await getSRDIconMatch("monsterfeatures");

  // eslint-disable-next-line require-atomic-updates
  CONFIG.DDBI.SRD_LOAD.iconMap = compendiumInventoryItems.concat(
    compendiumSpellItems,
    compendiumFeatureItems,
    compendiumMonsterFeatures,
  );
  return CONFIG.DDBI.SRD_LOAD.iconMap;
}

async function copySRDIcons(items, srdIconLibrary = null, nameMatchList = []) {
  // eslint-disable-next-line require-atomic-updates
  if (!srdIconLibrary) srdIconLibrary = await getSRDIconLibrary();

  return new Promise((resolve) => {
    const srdItems = items.map((item) => {
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Matching ${item.name}`);
      const nameMatch = nameMatchList.find((m) => m.name === item.name);
      if (nameMatch) {
        item.img = nameMatch.img;
      } else {
        looseItemNameMatch(item, srdIconLibrary, true).then((match) => {
          if (match) {
            srdIconLibrary.push({ name: item.name, img: match.img });
            item.img = match.img;
          }
        });
      }
      return item;

    });
    resolve(srdItems);
  });
}

async function retainExistingIcons(items) {
  return new Promise((resolve) => {
    const newItems = items.map((item) => {
      if (item.flags.ddbimporter?.ignoreIcon) {
        _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Retaining icon for ${item.name} to ${item.flags.ddbimporter.matchedImg}`);
        item.img = item.flags.ddbimporter.matchedImg;
      }
      return item;
    });
    resolve(newItems);
  });
}

async function getDDBItemImages(items, download) {
  _DDBMuncher_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].munchNote */ .Z.munchNote(`Fetching DDB Item Images`);
  const downloadImages = (download) ? true : game.settings.get("ddb-importer", "munching-policy-download-images");
  const remoteImages = game.settings.get("ddb-importer", "munching-policy-remote-images");

  const itemMap = items.map(async (item) => {
    let itemImage = {
      name: item.name,
      type: item.type,
      img: null,
      large: null,
    };

    if (item.flags && item.flags.ddbimporter && item.flags.ddbimporter && item.flags.ddbimporter.dndbeyond) {
      if (item.flags.ddbimporter.dndbeyond.avatarUrl) {
        const avatarUrl = item.flags.ddbimporter.dndbeyond['avatarUrl'];
        if (avatarUrl && avatarUrl != "") {
          _DDBMuncher_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].munchNote */ .Z.munchNote(`Downloading ${item.name} image`);
          const downloadOptions = { type: "item", name: item.name, download: downloadImages, remoteImages };
          const smallImage = await _lib_FileHelper_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].getImagePath */ .Z.getImagePath(avatarUrl, downloadOptions);
          _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Final image ${smallImage}`);
          itemImage.img = smallImage;
        }
      }
      if (item.flags.ddbimporter.dndbeyond.largeAvatarUrl) {
        const largeAvatarUrl = item.flags.ddbimporter.dndbeyond['largeAvatarUrl'];
        if (largeAvatarUrl && largeAvatarUrl != "") {
          const downloadOptions = { type: "item-large", name: item.name, download: downloadImages, remoteImages };
          const largeImage = await _lib_FileHelper_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].getImagePath */ .Z.getImagePath(largeAvatarUrl, downloadOptions);
          itemImage.large = largeImage;
          if (!itemImage.img) itemImage.img = largeImage;
        }
      }
    }

    _DDBMuncher_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].munchNote */ .Z.munchNote("");
    return itemImage;
  });

  return Promise.all(itemMap);
}

async function getDDBGenericItemImages(download) {
  _DDBMuncher_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].munchNote */ .Z.munchNote(`Fetching DDB Generic Item icons`);
  const itemMap = _dictionary_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].items.map */ .Z.items.map(async (item) => {
    const downloadOptions = { type: "item", name: item.filterType, download };
    const img = await _lib_FileHelper_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].getImagePath */ .Z.getImagePath(item.img, downloadOptions);
    let itemIcons = {
      filterType: item.filterType,
      img: img,
    };
    return itemIcons;
  });

  _DDBMuncher_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].munchNote */ .Z.munchNote("");
  return Promise.all(itemMap);
}

async function getDDBGenericLootImages(download) {
  _DDBMuncher_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].munchNote */ .Z.munchNote(`Fetching DDB Generic Loot icons`);
  const itemMap = _dictionary_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].genericItemIcons.map */ .Z.genericItemIcons.map(async (item) => {
    const downloadOptions = { type: "equipment", name: item.name, download };
    const img = await _lib_FileHelper_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].getImagePath */ .Z.getImagePath(item.img, downloadOptions);
    let itemIcons = {
      name: item.name,
      img: img,
    };
    return itemIcons;
  });

  _DDBMuncher_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].munchNote */ .Z.munchNote("");
  return Promise.all(itemMap);
}

async function getDDBGenericItemIcons(items, download) {
  const genericItems = await getDDBGenericItemImages(download);
  const genericLoots = await getDDBGenericLootImages(download);

  let updatedItems = items.map((item) => {
    // logger.debug(item.name);
    // logger.debug(item.flags.ddbimporter.dndbeyond.filterType);
    const excludedItems = ["spell", "feat", "class"];
    if (!excludedItems.includes(item.type)
        && item.flags
        && item.flags.ddbimporter
        && item.flags.ddbimporter.dndbeyond) {
      let generic = null;
      if (item.flags.ddbimporter.dndbeyond.filterType) {
        generic = genericItems.find((i) => i.filterType === item.flags.ddbimporter.dndbeyond.filterType);
      } else if (item.flags.ddbimporter.dndbeyond.type) {
        generic = genericLoots.find((i) => i.name === item.flags.ddbimporter.dndbeyond.type);
      }
      if (generic && (!item.img || item.img == "" || item.img == CONST.DEFAULT_TOKEN)) {
        item.img = generic.img;
      }
    }
    return item;
  });
  return Promise.all(updatedItems);
}

async function getDDBSchoolSpellImages(download) {
  _DDBMuncher_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].munchNote */ .Z.munchNote(`Fetching spell school icons`);
  const schoolMap = _dictionary_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].spell.schools.map */ .Z.spell.schools.map(async (school) => {
    const downloadOptions = { type: "spell", name: school.name, download };
    const img = await _lib_FileHelper_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].getImagePath */ .Z.getImagePath(school.img, downloadOptions);
    let schoolIcons = {
      name: school.name,
      img: img,
      id: school.id,
    };
    return schoolIcons;
  });

  _DDBMuncher_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].munchNote */ .Z.munchNote("");
  return Promise.all(schoolMap);
}

async function getDDBSpellSchoolIcons(items, download) {
  const schools = await getDDBSchoolSpellImages(download);

  let updatedItems = items.map((item) => {
    // logger.debug(item.name);
    // logger.debug(item.flags.ddbimporter.dndbeyond);
    if (item.type == "spell") {
      const school = schools.find((school) => school.id === item.system.school);
      if (school && (!item.img || item.img == "" || item.img == CONST.DEFAULT_TOKEN)) {
        item.img = school.img;
      }
    }
    return item;
  });
  return Promise.all(updatedItems);
}

async function getDDBEquipmentIcons(items, download) {
  const itemImages = await getDDBItemImages(items.filter((item) => _dictionary_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].types.inventory.includes */ .Z.types.inventory.includes(item.type)), download);

  let updatedItems = items.map((item) => {
    // logger.debug(item.name);
    // logger.debug(item.flags.ddbimporter.dndbeyond);
    if (_dictionary_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].types.inventory.includes */ .Z.types.inventory.includes(item.type)) {
      if (!item.img || item.img == "" || item.img == CONST.DEFAULT_TOKEN) {
        const imageMatch = itemImages.find((m) => m.name == item.name && m.type == item.type);
        if (imageMatch && imageMatch.img) {
          item.img = imageMatch.img;
        }
        if (imageMatch && imageMatch.large) {
          item.flags.ddbimporter.dndbeyond['pictureUrl'] = imageMatch.large;
        }
      }
    }
    return item;
  });
  return Promise.all(updatedItems);
}


async function updateMagicItemImages(items) {
  const useSRDCompendiumIcons = game.settings.get("ddb-importer", "character-update-policy-use-srd-icons");
  const ddbSpellIcons = game.settings.get("ddb-importer", "character-update-policy-use-ddb-spell-icons");
  const inbuiltIcons = game.settings.get("ddb-importer", "character-update-policy-use-inbuilt-icons");
  const ddbItemIcons = game.settings.get("ddb-importer", "character-update-policy-use-ddb-item-icons");

  // if we still have items to add, add them
  if (items.length > 0) {
    if (ddbItemIcons) {
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug("Magic items: adding equipment icons");
      items = await getDDBEquipmentIcons(items, true);
    }

    if (inbuiltIcons) {
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug("Magic items: adding inbuilt icons");
      items = await (0,_icons_index_js__WEBPACK_IMPORTED_MODULE_8__/* .copyInbuiltIcons */ .b)(items);
    }

    if (useSRDCompendiumIcons) {
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug("Magic items: adding srd compendium icons");
      items = await copySRDIcons(items);
    }

    if (ddbSpellIcons) {
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug("Magic items: adding ddb spell school icons");
      items = await getDDBSpellSchoolIcons(items, true);
    }
  }
  return items;
}

/**
 * Updates game folder items
 * @param {*} type
 */
async function updateFolderItems(type, input, update = true) {
  if (type === "itemSpells") {
    // eslint-disable-next-line require-atomic-updates
    input[type] = await updateMagicItemImages(input[type]);
  }

  const folderLookup = _settings_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].GAME_FOLDER_LOOKUPS.find */ .Z.GAME_FOLDER_LOOKUPS.find((c) => c.type == type);
  const itemFolderNames = [...new Set(input[type]
    .filter((item) => item.flags?.ddbimporter?.dndbeyond?.lookupName)
    .map((item) => item.flags.ddbimporter.dndbeyond.lookupName))];

  const getSubFolders = async () => {
    return Promise.all(
      itemFolderNames.map((name) => {
        return _lib_utils_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].getFolder */ .Z.getFolder(folderLookup.folder, name);
      })
    );
  };

  const subFolders = await getSubFolders();

  const defaultItemsFolder = await _lib_utils_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].getFolder */ .Z.getFolder(folderLookup.folder);
  const existingItems = await game.items.entities.filter((item) => {
    const itemFolder = subFolders.find((folder) =>
      item.flags?.ddbimporter?.dndbeyond?.lookupName
      && folder.name === item.flags.ddbimporter.dndbeyond.lookupName
    );
    return itemFolder && item.type === folderLookup.itemType && item.folder === itemFolder._id;
  });

  // update or create folder items
  const updateItems = async () => {
    return Promise.all(
      input[type]
        .filter((item) => existingItems.some((idx) => idx.name === item.name))
        .map(async (item) => {
          const existingItem = await existingItems.find((existing) => item.name === existing.name);
          item._id = existingItem._id;
          _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].info */ .Z.info(`Updating ${type} ${item.name}`);
          await copySupportedItemFlags(existingItem, item);
          await Item.update(item);
          return item;
        })
    );
  };

  const createItems = async () => {
    return Promise.all(
      input[type]
        .filter((item) => !existingItems.some((idx) => idx.name === item.name))
        .map(async (item) => {
          if (!game.user.can("ITEM_CREATE")) {
            ui.notifications.warn(`Cannot create ${folderLookup.type} ${item.name} for ${type}`);
          } else {
            _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].info */ .Z.info(`Creating ${type} ${item.name}`);
            const itemsFolder = subFolders.find((folder) =>
              item.flags?.ddbimporter?.dndbeyond?.lookupName
              && folder.name === item.flags.ddbimporter.dndbeyond.lookupName
            );
            item.folder = (itemsFolder) ? itemsFolder._id : defaultItemsFolder._id;
            await Item.create(item);
          }
          return item;
        })
    );
  };

  if (update) await updateItems();
  await createItems();

  // lets generate our compendium info like id, pack and img for use
  // by things like magicitems
  const folderIds = [defaultItemsFolder._id, ...subFolders.map((f) => f._id)];
  const items = Promise.all(
    game.items.entities
      .filter((item) => item.type === folderLookup.itemType && folderIds.includes(item.folder))
      .map((result) => {
        const subFolder = (result.flags.ddbimporter?.dndbeyond?.lookupName)
          ? result.flags.ddbimporter.dndbeyond.lookupName
          : null;
        return {
          magicItem: {
            _id: result._id,
            id: result._id,
            pack: "world",
            img: result.img,
            name: result.name,
            subFolder: subFolder,
            flatDc: result.flags?.ddbimporter?.dndbeyond?.overrideDC,
            dc: result.flags?.ddbimporter?.dndbeyond?.dc,
          },
          _id: result._id,
          name: result.name,
          compendium: false,
        };
      })
  );
  return items;
}

function updateCharacterItemFlags(itemData, replaceData) {
  if (itemData.flags?.ddbimporter?.importId) setProperty(replaceData, "flags.ddbimporter.importId", itemData.flags.ddbimporter.importId);
  if (itemData.system.quantity) replaceData.system.quantity = itemData.system.quantity;
  if (itemData.system.attuned) replaceData.system.attuned = itemData.system.attuned;
  if (itemData.system.attunement) replaceData.system.attunement = itemData.system.attunement;
  if (itemData.system.equipped) replaceData.system.equipped = itemData.system.equipped;
  if (itemData.system.uses) replaceData.system.uses = itemData.system.uses;
  if (itemData.system.resources) replaceData.system.resources = itemData.system.resources;
  if (itemData.system.consume) replaceData.system.consume = itemData.system.consume;
  if (itemData.system.preparation) replaceData.system.preparation = itemData.system.preparation;
  if (itemData.system.proficient) replaceData.system.proficient = itemData.system.proficient;
  if (itemData.system.ability) replaceData.system.ability = itemData.system.ability;
  return replaceData;
}

async function updateMatchingItems(oldItems, newItems, inOptions) {
  let results = [];

  const defaultOptions = {
    looseMatch: false,
    monster: false,
    keepId: false,
    keepDDBId: false,
    overrideId: false,
  };
  const options = mergeObject(defaultOptions, inOptions);

  for (let newItem of newItems) {
    let item = duplicate(newItem);

    const matched = options.overrideId
      ? oldItems.find((oldItem) => getProperty(oldItem, "flags.ddbimporter.overrideId") == item._id)
      : await looseItemNameMatch(item, oldItems, options.looseMatch, options.monster); // eslint-disable-line no-await-in-loop

    if (matched) {
      const match = duplicate(matched);
      // in some instances we want to keep the ddb id
      if (options.keepDDBId && hasProperty(item, "flags.ddbimporter.id")) {
        setProperty(match, "flags.ddbimporter.id", duplicate(item.flags.ddbimporter.id));
      }
      if (!item.flags.ddbimporter) {
        setProperty(item, "flags.ddbimporter", match.flags.ddbimporter);
      } else if (match.flags.ddbimporter && item.flags.ddbimporter) {
        const mergedFlags = mergeObject(item.flags.ddbimporter, match.flags.ddbimporter);
        setProperty(item, "flags.ddbimporter", mergedFlags);
      }
      if (!item.flags.monsterMunch && match.flags.monsterMunch) {
        setProperty(item, "flags.monsterMunch", match.flags.monsterMunch);
      }
      setProperty(item, "flags.ddbimporter.originalItemName", match.name);
      setProperty(item, "flags.ddbimporter.replaced", true);
      item = updateCharacterItemFlags(match, item);

      if (!options.keepId) delete item["_id"];
      results.push(item);
    }
  }

  return results;
}

async function getIndividualOverrideItems(overrideItems) {
  const label = _lib_CompendiumHelper_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].getCompendiumLabel */ .Z.getCompendiumLabel("custom");
  const compendium = _lib_CompendiumHelper_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].getCompendium */ .Z.getCompendium(label);

  const compendiumItems = await Promise.all(overrideItems.map(async (item) => {
    const compendiumItem = duplicate(await compendium.getDocument(item.flags.ddbimporter.overrideId));
    setProperty(compendiumItem, "flags.ddbimporter.pack", `${compendium.metadata.id}`);
    if (hasProperty(item, "flags.ddbimporter.overrideItem")) {
      setProperty(compendiumItem, "flags.ddbimporter.overrideItem", item.flags.ddbimporter.overrideItem);
    } else {
      setProperty(compendiumItem, "flags.ddbimporter.overrideItem", {
        name: item.name,
        type: item.type,
        ddbId: item.flags.ddbimporter?.id
      });
    }

    return compendiumItem;
  }));

  const matchingOptions = {
    looseMatch: false,
    monster: false,
    keepId: true,
    keepDDBId: true,
    overrideId: true,
  };

  const remappedItems = await updateMatchingItems(overrideItems, compendiumItems, matchingOptions);

  return remappedItems;
}

/**
 *
 */
async function loadPassedItemsFromCompendium(compendium, items, type, inOptions) {
  if (!compendium) return [];
  const defaultOptions = {
    looseMatch: false,
    monsterMatch: false,
    keepId: false,
    deleteCompendiumId: true,
    indexFilter: {}, // { fields: ["name", "flags.ddbimporter.id"] }
    keepDDBId: false,
  };
  const options = mergeObject(defaultOptions, inOptions);

  if (!compendium.indexed) await compendium.getIndex(options.indexFilter);
  const index = compendium.index;
  const firstPassItems = await index.filter((i) =>
    items.some((orig) => {
      const extraNames = (orig.flags?.ddbimporter?.dndbeyond?.alternativeNames)
        ? orig.flags.ddbimporter.dndbeyond.alternativeNames
        : [];
      if (options.looseMatch) {
        const looseNames = getLooseNames(orig.name, extraNames);
        return looseNames.includes(i.name.split("(")[0].trim().toLowerCase());
      } else if (options.monsterMatch) {
        const monsterNames = getMonsterNames(orig.name);
        // console.log(magicNames)
        if (i.name === orig.name) {
          return true;
        } else if (monsterNames.includes(i.name.toLowerCase())) {
          return true;
        } else {
          return false;
        }
      } else {
        return i.name === orig.name || extraNames.includes(i.name);
      }
    })
  );

  let loadedItems = [];
  for (const i of firstPassItems) {
    // eslint-disable-next-line no-await-in-loop
    let item = await compendium.getDocument(i._id).then((doc) => {
      const docData = doc.toObject();
      if (options.deleteCompendiumId) delete docData._id;
      _settings_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].COMPENDIUM_REMOVE_FLAGS.forEach */ .Z.COMPENDIUM_REMOVE_FLAGS.forEach((flag) => {
        if (hasProperty(docData, flag)) setProperty(docData, flag, undefined);
      });

      return docData;
    });
    setProperty(item, "flags.ddbimporter.pack", `${compendium.metadata.id}`);
    loadedItems.push(item);
  }
  _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`compendium ${type} loaded items:`, loadedItems);

  const matchingOptions = {
    looseMatch: options.looseMatch,
    monster: options.monsterMatch,
    keepId: options.keepId,
    keepDDBId: options.keepDDBId,
  };

  const results = await updateMatchingItems(items, loadedItems, matchingOptions);
  _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`compendium ${type} result items:`, results);
  return results;
}

/**
 * gets items from compendium
 * @param {*} items
 * @param {*} type
 * @param {*} options
 */
async function getCompendiumItems(items, type, inOptions) {
  const defaultOptions = {
    compendiumLabel: null,
    looseMatch: false,
    monsterMatch: false,
    keepId: false,
    deleteCompendiumId: true,
    keepDDBId: false,
  };
  const options = mergeObject(defaultOptions, inOptions);

  if (!options.compendiumLabel) {
    options.compendiumLabel = _lib_CompendiumHelper_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].getCompendiumLabel */ .Z.getCompendiumLabel(type);
  }
  const compendium = _lib_CompendiumHelper_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].getCompendium */ .Z.getCompendium(options.compendiumLabel, false);
  if (!compendium) return [];

  const loadOptions = {
    looseMatch: options.looseMatch,
    monsterMatch: options.monsterMatch,
    keepId: options.keepId,
    keepDDBId: options.keepDDBId,
    deleteCompendiumId: options.deleteCompendiumId,
  };
  const results = await loadPassedItemsFromCompendium(compendium, items, type, loadOptions);

  return results;
}

async function getSRDCompendiumItems(items, type, looseMatch = false, keepId = false, monster = false) {
  const compendiumName = _settings_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].SRD_COMPENDIUMS.find */ .Z.SRD_COMPENDIUMS.find((c) => c.type == type).name;
  if (!CONFIG.DDBI.SRD_LOAD.packsLoaded[compendiumName]) await loadpacks(compendiumName);
  const compendiumItems = CONFIG.DDBI.SRD_LOAD.packs[compendiumName];

  const loadedItems = await compendiumItems.filter((i) =>
    compendiumItems.some((orig) => {
      const extraNames = (orig.flags?.ddbimporter?.dndbeyond?.alternativeNames)
        ? orig.flags.ddbimporter.dndbeyond.alternativeNames
        : [];
      if (looseMatch) {
        const looseNames = getLooseNames(orig.name, extraNames);
        return looseNames.includes(i.name.split("(")[0].trim().toLowerCase());
      } else {
        return i.name === orig.name || extraNames.includes(i.name);
      }
    })
  ).map((i) => {
    const item = i.toObject();
    if (item.flags.ddbimporter) {
      item.flags.ddbimporter["pack"] = compendiumName;
    } else {
      item.flags.ddbimporter = { pack: compendiumName };
    }
    return item;
  });
  // logger.debug(`SRD ${type} loaded items:`, loadedItems);

  const matchingOptions = {
    looseMatch,
    monster,
    keepId,
  };

  const results = await updateMatchingItems(items, loadedItems, matchingOptions);
  _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`SRD ${type} result items:`, results);

  return results;
}

/**
 * Add an item to effects, if available
 * @param {*} items
 */
function addItemEffectIcons(items) {
  _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug("Adding Icons to effects");

  items.forEach((item) => {
    if (item.effects && (item.img || item.img !== "" || item.img !== CONST.DEFAULT_TOKEN)) {
      item.effects.forEach((effect) => {

        if (!effect.icon || effect.icon === "" || effect.icon === CONST.DEFAULT_TOKEN) {
          effect.icon = item.img;
        }
      });
    }

  });
  return items;
}

/**
 * TO DO : This function should do something.
 * @param {*} effects
 */
function addACEffectIcons(effects) {
  logger.debug("Adding Icons to AC effects");

  // effects.forEach((item) => {
  //   if (!effect.icon || effect.icon === "" || effect.icon === CONST.DEFAULT_TOKEN) {
  //     effect.icon = item.img;
  //   }
  // });
  return effects;
}

async function updateIcons(items, srdIconUpdate = true, monster = false, monsterName = "") {
  // this will use ddb item icons as a fall back
  const ddbItemIcons = game.settings.get("ddb-importer", "munching-policy-use-ddb-item-icons");
  if (ddbItemIcons) {
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug("DDB Equipment Icon Match");
    items = await getDDBEquipmentIcons(items);
  }

  const inBuiltIcons = game.settings.get("ddb-importer", "munching-policy-use-inbuilt-icons");
  if (inBuiltIcons) {
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Inbuilt icon matching (Monster? ${monster ? monsterName : monster})`);
    items = await (0,_icons_index_js__WEBPACK_IMPORTED_MODULE_8__/* .copyInbuiltIcons */ .b)(items, monster, monsterName);
  }

  // check for SRD icons
  const srdIcons = game.settings.get("ddb-importer", "munching-policy-use-srd-icons");
  // eslint-disable-next-line require-atomic-updates
  if (srdIcons && srdIconUpdate) {
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug("SRD Icon Matching");
    items = await copySRDIcons(items);
  }

  // this will use ddb spell school icons as a fall back
  const ddbSpellIcons = game.settings.get("ddb-importer", "munching-policy-use-ddb-spell-icons");
  if (ddbSpellIcons) {
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug("DDB Spell School Icon Match");
    items = await getDDBSpellSchoolIcons(items, true);
  }

  // this will use ddb generic icons as a fall back
  const ddbGenericItemIcons = game.settings.get("ddb-importer", "munching-policy-use-ddb-generic-item-icons");
  if (ddbGenericItemIcons) {
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug("DDB Generic Item Icon Match");
    items = await getDDBGenericItemIcons(items, true);
  }

  // update any generated effects
  const addEffects = game.settings.get("ddb-importer", "munching-policy-add-effects");
  if (addEffects) {
    items = addItemEffectIcons(items);
  }

  return items;
}

async function srdFiddling(items, type) {
  const updateBool = game.settings.get("ddb-importer", "munching-policy-update-existing");
  const useSrd = game.settings.get("ddb-importer", "munching-policy-use-srd");

  if (useSrd && type == "monsters") {
    const srdItems = await getSRDCompendiumItems(items, type);
    // removed existing items from those to be imported
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug("Removing compendium items");
    const lessSrdItems = await removeItems(items, srdItems);
    const newIcons = lessSrdItems.concat(srdItems);
    const iconedItems = await updateIcons(newIcons);
    // console.warn("Final Monsters", srdItems);
    return iconedItems;
  } else if (useSrd) {
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug("Removing compendium items");
    let itemMap = {};
    const srdItems = await getSRDCompendiumItems(items, type);
    itemMap[type] = srdItems;
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug("Adding SRD compendium items");
    updateCompendium(type, itemMap, updateBool);
    // removed existing items from those to be imported
    return new Promise((resolve) => {
      removeItems(items, srdItems)
        .then((cleanedItems) => updateIcons(cleanedItems))
        .then((iconItems) => resolve(iconItems));
    });
  } else {
    const iconItems = await updateIcons(items);
    return iconItems;
  }
}


async function daeFiddling(items) {
  const fiddle = game.settings.get("ddb-importer", "munching-policy-use-dae-effects");
  const installed = game.modules.get("dae")?.active
    && (game.modules.get("Dynamic-Effects-SRD")?.active || game.modules.get("midi-srd")?.active);

  if (fiddle && installed) {
    return (0,_dae_js__WEBPACK_IMPORTED_MODULE_7__/* .addItemsDAESRD */ .$n)(items);
  } else return items;
}

async function getCompendiumItemSpells(spells) {
  const getItemsOptions = {
    looseMatch: true,
    keepId: true,
    deleteCompendiumId: false,
  };
  const compendiumSpells = await getCompendiumItems(spells, "spell", getItemsOptions);
  const lessCompendiumSpells = await removeItems(spells, compendiumSpells);
  const srdSpells = await getSRDCompendiumItems(lessCompendiumSpells, "spell", true, true);
  const foundSpells = compendiumSpells.concat(srdSpells);

  const itemSpells = foundSpells.map((result) => {
    return {
      magicItem: {
        _id: result._id,
        id: result._id,
        pack: result.flags.ddbimporter.pack,
        img: result.img,
        name: result.name,
        flatDc: result.flags.ddbimporter.dndbeyond?.overrideDC,
        dc: result.flags.ddbimporter.dndbeyond?.dc,
      },
      _id: result._id,
      name: result.name,
      compendium: true,
    };
  });

  return [foundSpells, itemSpells];
}

/**
 * This adds magic item spells to an item, by looking in compendium or from a world.
 */
async function addMagicItemSpells(input) {
  // check for existing spells in spell compendium & srdCompendium
  const [compendiumSpells, compendiumItemSpells] = await getCompendiumItemSpells(input.itemSpells);
  // if spells not found create world version
  const remainingSpells = {
    itemSpells: await removeItems(input.itemSpells, compendiumSpells),
  };
  const worldSpells = remainingSpells.length > 0
    ? await updateFolderItems("itemSpells", remainingSpells)
    : [];
  const itemSpells = worldSpells.concat(compendiumItemSpells);

  _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug("itemSpells fetched", itemSpells);

  // scan the inventory for each item with spells and copy the imported data over
  input.inventory.forEach((item) => {
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug("replacing spells for item", item);
    const magicItemsSpells = getProperty(item, "flags.magicitems.spells");
    if (magicItemsSpells) {
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug("item.flags.magicitems.spells", magicItemsSpells);
      for (let [i, spell] of Object.entries(magicItemsSpells)) {
        const itemSpell = itemSpells.find((iSpell) => iSpell.name === spell.name
          && (iSpell.compendium || iSpell.magicItem.subFolder === item.name)
        );
        if (itemSpell) {
          for (const [key, value] of Object.entries(itemSpell.magicItem)) {
            item.flags.magicitems.spells[i][key] = value;
          }
        } else if (!game.user.can("ITEM_CREATE")) {
          ui.notifications.warn(`Magic Item ${item.name} cannot be enriched because of lacking player permissions`);
        } else {
          ui.notifications.warn(`Magic Item ${item.name}: cannot add spell ${spell.name}`);
        }
      }
    }
    // {
    //   magicItem: {
    //     _id: result._id,
    //     id: result._id,
    //     pack: result.flags.ddbimporter.pack,
    //     img: result.img,
    //     name: result.name,
    //     flatDc: result.flags.ddbimporter.dndbeyond?.overrideDC,
    //     dc: result.flags.ddbimporter.dndbeyond?.dc,
    //   },
    //   _id: result._id,
    //   name: result.name,
    //   compendium: true,
    // };
    const itemsWithSpells = getProperty(item, "flags.items-with-spells-5e.item-spells");
    if (itemsWithSpells) {
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug("item.flags.items-with-spells-5e.item-spells", item.flags["items-with-spells-5e"]["item-spells"]);
      itemsWithSpells.forEach((spellData, i) => {
        const itemSpell = itemSpells.find((iSpell) => iSpell.name === spellData.flags.ddbimporter.spellName
          && (iSpell.compendium || iSpell.magicItem.subFolder === item.name)
        );
        if (itemSpell) {
          item.flags["items-with-spells-5e"]["item-spells"][i].uuid = `Compendium.${itemSpell.magicItem.pack}.${itemSpell._id}`;
          if (item._id) {
            setProperty(item.flags["items-with-spells-5e"]["item-spells"][i], "flags.items-with-spells-5e.item-spells.parent-item", item._id);
          }
        } else if (!game.user.can("ITEM_CREATE")) {
          ui.notifications.warn(`Magic Item ${item.name} cannot be enriched because of lacking player permissions`);
        } else {
          ui.notifications.warn(`Magic Item ${item.name}: cannot add spell ${spellData.name}`);
        }


      });
    }
  });
}


/***/ }),

/***/ 9633:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Fx": () => (/* binding */ addNPC),
/* harmony export */   "NM": () => (/* binding */ generateIconMap),
/* harmony export */   "ln": () => (/* binding */ buildNPC),
/* harmony export */   "ph": () => (/* binding */ copyExistingMonsterImages),
/* harmony export */   "qp": () => (/* binding */ addNPCsToCompendium),
/* harmony export */   "xD": () => (/* binding */ getNPCImage)
/* harmony export */ });
/* unused harmony export addNPCDDBId */
/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5259);
/* harmony import */ var _lib_CompendiumHelper_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3893);
/* harmony import */ var _lib_FileHelper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(2397);
/* harmony import */ var _import_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(9193);
/* harmony import */ var _DDBMuncher_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(1475);
/* harmony import */ var _dae_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(7728);
/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(6451);
/* harmony import */ var _lib_utils_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(7669);









// check items to see if retaining item, img or resources
async function existingItemRetentionCheck(currentItems, newItems, checkId = true) {
  const returnItems = [];

  await newItems.forEach((item) => {
    const existingItem = currentItems.find((owned) => {
      const simpleMatch
        = item.name === owned.name
        && item.type === owned.type
        && item.system.activation?.type === owned.system.activation?.type
        && ((checkId && item.flags?.ddbimporter?.id === owned.flags?.ddbimporter?.id) || !checkId);

      return simpleMatch;
    });

    if (existingItem) {
      if (existingItem.flags.ddbimporter?.ignoreItemImport) {
        returnItems.push(duplicate(existingItem));
      } else {
        item["_id"] = existingItem.id;
        if (getProperty(existingItem, "flags.ddbimporter.ignoreIcon") === true) {
          item.img = existingItem.img;
          setProperty(item, "flags.ddbimporter.ignoreIcon", true);
        }
        if (getProperty(existingItem, "flags.ddbimporter.retainResourceConsumption")) {
          item.system.consume = existingItem.system.consume;
          setProperty(item, "flags.ddbimporter.retainResourceConsumption", true);
          if (hasProperty(existingItem, "flags.link-item-resource-5e")) {
            setProperty(item, "flags.link-item-resource-5e", existingItem.flags["link-item-resource-5e"]);
          }
        }

        if (!item.effects
          || (item.effects && item.effects.length == 0 && existingItem.effects && existingItem.effects.length > 0)
        ) {
          item.effects = duplicate(existingItem.getEmbeddedCollection("ActiveEffect"));
        }

        returnItems.push(item);
      }
    } else {
      returnItems.push(item);
    }
  });

  _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug("Finished retaining items");
  return returnItems;
}


async function addNPCToCompendium(npc, type = "monster") {
  const compendium = _lib_CompendiumHelper_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].getCompendiumType */ .Z.getCompendiumType(type, false);
  if (compendium) {
    const npcBasic = duplicate(npc);

    // unlock the compendium for update/create
    compendium.configure({ locked: false });

    let compendiumNPC;
    if (hasProperty(npc, "_id") && compendium.index.has(npc._id)) {
      if (game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-update-existing")) {
        const existingNPC = await compendium.getDocument(npc._id);

        const monsterTaggedItems = npcBasic.items.map((item) => {
          setProperty(item, "flags.ddbimporter.parentId", npc._id);
          return item;
        });
        const existingItems = existingNPC.getEmbeddedCollection("Item");
        npcBasic.items = await existingItemRetentionCheck(existingItems, monsterTaggedItems, false);

        _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug("NPC Update Data", duplicate(npcBasic));
        await existingNPC.deleteEmbeddedDocuments("Item", [], { deleteAll: true });
        await existingNPC.deleteEmbeddedDocuments("ActiveEffect", [], { deleteAll: true });
        compendiumNPC = await existingNPC.update(npcBasic, { pack: compendium.collection, recursive: true, keepId: true });
        if (!compendiumNPC) {
          _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug("No changes made to base character", npcBasic);
          compendiumNPC = existingNPC;
        }
      }
    } else {
      // create the new npc
      _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug(`Creating NPC actor ${npcBasic.name}`);
      const options = {
        displaySheet: false,
        pack: compendium.collection,
        keepId: true,
      };
      _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug("NPC New Data", duplicate(npcBasic));
      compendiumNPC = await Actor.create(npcBasic, options);
    }

    // using compendium folders?
    if (compendiumNPC) {
      await (0,_import_js__WEBPACK_IMPORTED_MODULE_3__/* .compendiumFolders */ .EX)(compendiumNPC, "npc");
      return compendiumNPC;
    }
  } else {
    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].error */ .Z.error("Error opening compendium, check your settings");
  }
  return npc;
}

async function addNPCsToCompendium(npcs, type = "monster") {
  const compendium = _lib_CompendiumHelper_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].getCompendiumType */ .Z.getCompendiumType(type, false);
  let results = [];
  if (compendium) {
    // unlock the compendium for update/create
    compendium.configure({ locked: false });

    const options = {
      pack: compendium.collection,
      displaySheet: false,
      recursive: false,
      keepId: true,
    };

    if (game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-update-existing")) {
      const updateNPCs = npcs.filter((npc) => hasProperty(npc, "_id") && compendium.index.has(npc._id));
      _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug("NPCs Update Data", duplicate(updateNPCs));
      const updateResults = await Actor.updateDocuments(updateNPCs, options);
      results = results.concat(updateResults);
    }

    const newNPCs = npcs.filter((npc) => !hasProperty(npc, "_id") || !compendium.index.has(npc._id));
    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug("NPC New Data", duplicate(newNPCs));
    const createResults = await Actor.createDocuments(newNPCs, options);
    results = results.concat(createResults);

    // // using compendium folders?
    // if (compendiumNPC) {
    //   await compendiumFolders(compendiumNPC, "npc");
    //   return compendiumNPC;
    // }
  } else {
    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].error */ .Z.error("Error opening compendium, check your settings");
  }
  return results;
}

async function addNPCDDBId(npc, type = "monster") {
  let npcBasic = duplicate(npc);
  const compendium = CompendiumHelper.getCompendiumType(type, false);
  if (compendium) {
    // unlock the compendium for update/create
    compendium.configure({ locked: false });
    const monsterIndexFields = ["name", "flags.ddbimporter.id"];

    const index = await compendium.getIndex({ fields: monsterIndexFields });
    const npcMatch = index.contents.find((entity) =>
      !hasProperty(entity, "flags.ddbimporter.id")
      && entity.name.toLowerCase() === npcBasic.name.toLowerCase()
    );

    if (npcMatch) {
      if (game.settings.get(SETTINGS.MODULE_ID, "munching-policy-update-existing")) {
        const existingNPC = await compendium.getDocument(npcMatch._id);
        const updateDDBData = {
          _id: npcMatch._id,
          "flags.ddbimporter.id": npcBasic.flags.ddbimporter.id,
        };
        logger.debug("NPCId Update Data", duplicate(updateDDBData));
        await existingNPC.update(updateDDBData);
      }
    }
  } else {
    logger.error("Error opening compendium, check your settings");
  }
}


// eslint-disable-next-line complexity
async function getNPCImage(npcData, options) {
  const defaultOptions = {
    forceUpdate: false,
    forceUseFullToken: false,
    forceUseTokenAvatar: false,
    disableAutoTokenizeOverride: false,
    type: "monster"
  };
  const mergedOptions = mergeObject(defaultOptions, options);
  // check to see if we have munched flags to work on
  if (!hasProperty(npcData, "flags.monsterMunch.img")) {
    return npcData;
  }

  const updateImages = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-update-images");
  if (!mergedOptions.forceUpdate && !updateImages && npcData.img !== CONST.DEFAULT_TOKEN) {
    return npcData;
  }

  let ddbAvatarUrl = npcData.flags.monsterMunch.img;
  let ddbTokenUrl = npcData.flags.monsterMunch.tokenImg;
  const useAvatarAsToken = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-use-full-token-image") || mergedOptions.forceUseFullToken;
  const useTokenAsAvatar = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-use-token-avatar-image") || mergedOptions.forceUseTokenAvatar;
  if (useAvatarAsToken) {
    ddbTokenUrl = ddbAvatarUrl;
  } else if (useTokenAsAvatar) {
    ddbAvatarUrl = ddbTokenUrl;
  }

  const npcType = options.type.startsWith("vehicle") ? "vehicle" : npcData.system.details.type.value;
  const genericNPCName = _lib_utils_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"].referenceNameString */ .Z.referenceNameString(npcType);
  const npcName = _lib_utils_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"].referenceNameString */ .Z.referenceNameString(npcData.name);

  if (!ddbAvatarUrl && ddbTokenUrl) ddbAvatarUrl = ddbTokenUrl;
  if (!ddbTokenUrl && ddbAvatarUrl) ddbTokenUrl = ddbAvatarUrl;

  if (ddbAvatarUrl) {
    const ext = ddbAvatarUrl.split(".").pop().split(/#|\?|&/)[0];
    const genericNpc = ddbAvatarUrl.endsWith(npcType + "." + ext);
    const name = genericNpc ? genericNPCName : npcName;
    const nameType = genericNpc ? "npc-generic" : "npc";
    const downloadOptions = { type: nameType, name };
    // eslint-disable-next-line require-atomic-updates
    npcData.img = await _lib_FileHelper_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].getImagePath */ .Z.getImagePath(ddbAvatarUrl, downloadOptions);
  }

  // Token images always have to be downloaded.
  if (ddbTokenUrl) {
    const tokenExt = ddbTokenUrl.split(".").pop().split(/#|\?|&/)[0];
    const genericNpc = ddbTokenUrl.endsWith(npcType + "." + tokenExt);
    const name = genericNpc ? genericNPCName : npcName;
    const nameType = genericNpc ? "npc-generic-token" : "npc-token";
    const downloadOptions = { type: nameType, name, download: true, remoteImages: false, force: true };
    // eslint-disable-next-line require-atomic-updates
    npcData.prototypeToken.texture.src = await _lib_FileHelper_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].getImagePath */ .Z.getImagePath(ddbTokenUrl, downloadOptions);
  }

  // check avatar, if not use token image
  // eslint-disable-next-line require-atomic-updates
  if (!npcData.img && npcData.prototypeToken.texture.src) npcData.img = npcData.prototypeToken.texture.src;

  // final check if image comes back as null
  // eslint-disable-next-line require-atomic-updates
  if (npcData.img === null) npcData.img = CONST.DEFAULT_TOKEN;
  // eslint-disable-next-line require-atomic-updates
  if (npcData.prototypeToken.texture.src === null) npcData.prototypeToken.texture.src = CONST.DEFAULT_TOKEN;

  // okays, but do we now want to tokenize that?
  const tokenizerReady = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-monster-tokenize")
    && !mergedOptions.disableAutoTokenizeOverride
    && game.modules.get("vtta-tokenizer")?.active;
  if (tokenizerReady) {
    const compendiumLabel = _lib_CompendiumHelper_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].getCompendiumLabel */ .Z.getCompendiumLabel(options.type);
    // eslint-disable-next-line require-atomic-updates
    npcData.prototypeToken.texture.src = await window.Tokenizer.autoToken(npcData, { nameSuffix: `-${compendiumLabel}`, updateActor: false });
    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug(`Generated tokenizer image at ${npcData.prototypeToken.texture.src}`);
  }

  return npcData;
}

async function swapItems(data) {
  const swap = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-monster-items");

  if (swap) {
    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug("Replacing items...");
    // console.info(data.items);
    const getItemOptions = {
      monsterMatch: true,
    };
    const updatedItems = await (0,_import_js__WEBPACK_IMPORTED_MODULE_3__/* .getCompendiumItems */ .pI)(data.items, "inventory", getItemOptions);
    const itemsToRemove = updatedItems.map((item) => {
      _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug(`${item.name} to ${item.flags.ddbimporter.originalItemName}`);
      return { name: item.flags.ddbimporter.originalItemName, type: item.type };
    });
    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug("Swapping items", itemsToRemove);
    // console.warn(itemsToRemove);
    const lessUpdatedItems = data.items.filter((item) =>
      !itemsToRemove.some((target) => item.name === target.name && item.type === target.type)
    );
    // console.log(lessUpdatedItems);
    const newItems = lessUpdatedItems.concat(updatedItems);
    // console.error(newItems);
    // eslint-disable-next-line require-atomic-updates
    data.items = newItems;

  }
}

async function linkResourcesConsumption(actor) {
  if (actor.items.some((item) => item.system.recharge?.value)) {
    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug(`Resource linking for ${actor.name}`);
    actor.items.forEach((item) => {
      if (item.system?.recharge?.value) {
        const itemID = randomID(16);
        item._id = itemID;
        if (item.type === "weapon") {
          item.type = "feat";
          delete item.system.weaponType;
          item.system.type = {
            value: "monster",
            subtype: "",
          };
        }
        item.system.consume = {
          type: "charges",
          target: itemID,
          amount: null,
        };
      }
    });
  }
  return actor;
}

// async function buildNPC(data, srdIconLibrary, iconMap) {
async function buildNPC(data, type = "monster", temporary = true, update = false, handleBuild = false) {
  _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug("Importing Images");
  await getNPCImage(data, { type });
  _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug("Checking Items");
  await swapItems(data);

  // DAE
  const daeInstalled = game.modules.get("dae")?.active
    && (game.modules.get("Dynamic-Effects-SRD")?.active || game.modules.get("midi-srd")?.active);
  const daeCopy = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-dae-copy");
  if (daeInstalled && daeCopy) {
    _DDBMuncher_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].munchNote */ .Z.munchNote(`Importing DAE Item for ${data.name}`);
    // eslint-disable-next-line require-atomic-updates
    data.items = await (0,_dae_js__WEBPACK_IMPORTED_MODULE_5__/* .migrateItemsDAESRD */ .TH)(data.items);
  }

  _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug("Importing Icons");
  // eslint-disable-next-line require-atomic-updates
  data.items = await (0,_import_js__WEBPACK_IMPORTED_MODULE_3__/* .updateIcons */ .wo)(data.items, false, true, data.name);
  data = await linkResourcesConsumption(data);

  if (handleBuild) {
    // create the new npc
    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug("Creating NPC actor");
    const options = {
      temporary: temporary,
      displaySheet: false,
    };
    if (update) {
      const npc = game.actors.get(data._id);
      await npc.deleteEmbeddedDocuments("Item", [], { deleteAll: true });
      await Actor.updateDocuments([data]);
      return npc;
    } else {
      const npc = await Actor.create(data, options);
      return npc;
    }

  } else {
    return data;
  }

}

async function parseNPC (data, bulkImport, type) {
  const buildNpc = await buildNPC(data, type);
  _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].info */ .Z.info(`Processing ${type} ${buildNpc.name} for the compendium`);
  if (bulkImport) {
    return buildNpc;
  } else {
    const compendiumNPC = await addNPCToCompendium(buildNpc, type);
    return compendiumNPC;
  }
}

function addNPC(data, bulkImport, type) {
  return new Promise((resolve, reject) => {
    parseNPC(data, bulkImport, type)
      .then((npc) => {
        resolve(npc);
      })
      .catch((error) => {
        _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].error */ .Z.error(`error parsing NPC type ${type}: ${error} ${data.name}`);
        _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].error */ .Z.error(error.stack);
        reject(error);
      });
  });
}

async function generateIconMap(monsters) {
  let promises = [];

  const srdIcons = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-use-srd-icons");
  // eslint-disable-next-line require-atomic-updates
  if (srdIcons) {
    const srdIconLibrary = await (0,_import_js__WEBPACK_IMPORTED_MODULE_3__/* .getSRDIconLibrary */ .CW)();
    _DDBMuncher_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].munchNote */ .Z.munchNote(`Updating SRD Icons`, true);
    let itemMap = [];

    monsters.forEach((monster) => {
      _DDBMuncher_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].munchNote */ .Z.munchNote(`Processing ${monster.name}`);
      promises.push(
        (0,_import_js__WEBPACK_IMPORTED_MODULE_3__/* .copySRDIcons */ .u4)(monster.items, srdIconLibrary, itemMap).then((items) => {
          monster.items = items;
        })
      );
    });
  }

  return Promise.all(promises);
}

function copyExistingMonsterImages(monsters, existingMonsters) {
  const updated = monsters.map((monster) => {
    const existing = existingMonsters.find((m) => monster.name === m.name);
    if (existing) {
      monster.img = existing.img;
      monster.prototypeToken.texture.src = existing.prototypeToken.texture.src;
      return monster;
    } else {
      return monster;
    }
  });
  return updated;
}


/***/ }),

/***/ 8638:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "S": () => (/* binding */ parseItems)
/* harmony export */ });
/* unused harmony export addMagicItemSpells */
/* harmony import */ var _import_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9193);
/* harmony import */ var _DDBMuncher_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1475);
/* harmony import */ var _lib_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7669);
/* harmony import */ var _lib_FileHelper_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(2397);
/* harmony import */ var _lib_Secrets_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(2048);
/* harmony import */ var _lib_Settings_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(5406);
/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(5259);
/* harmony import */ var _compendiumFolders_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(6269);
/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(6451);
/* harmony import */ var _lib_DDBProxy_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(546);
/* harmony import */ var _parser_DDBCharacter_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(1269);
// Main module class












async function getCharacterInventory(items) {
  return items.map((item) => {
    return {
      chargesUsed: 0,
      definitionId: 0,
      definitionTypeId: 0,
      displayAsAttack: null,
      entityTypeId: 0,
      equipped: false,
      id: 0,
      isAttuned: false,
      quantity: item.bundleSize ? item.bundleSize : 1,
      definition: item,
    };
  });
}

async function generateImportItems(items) {
  const mockCharacter = {
    system: JSON.parse(_lib_utils_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].getTemplate */ .Z.getTemplate("character")),
    type: "character",
    name: "",
    flags: {
      ddbimporter: {
        compendium: true,
        dndbeyond: {
          effectAbilities: [],
          totalLevels: 0,
          proficiencies: [],
          proficienciesIncludingEffects: [],
          characterValues: [],
        },
      },
    },
  };
  const mockDDB = {
    character: {
      classes: [],
      race: {
        racialTraits: [],
      },
      characterValues: [],
      inventory: items,
      customItems: null,
      options: {
        class: [],
        race: [],
        feat: [],
      },
      modifiers: {
        race: [],
        class: [],
        background: [],
        feat: [],
        item: [],
        condition: [],
      },
      feats: [],
    }
  };
  let itemSpells = []; // here we need to parse each available spell and build a mock spell parser
  const ddbCharacter = new _parser_DDBCharacter_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .Z(mockDDB);
  ddbCharacter.raw.character = mockCharacter;
  ddbCharacter.source = {
    ddb: mockDDB
  };
  ddbCharacter.raw.itemSpells = [];
  const inventory = await ddbCharacter.getInventory();
  const results = {
    items: inventory,
    itemSpellNames: itemSpells, // this needs to be a list of spells to find
  };
  return results;
}

function getItemData(sourceFilter) {
  const cobaltCookie = (0,_lib_Secrets_js__WEBPACK_IMPORTED_MODULE_4__/* .getCobalt */ .HF)();
  const campaignId = (0,_lib_Settings_js__WEBPACK_IMPORTED_MODULE_5__/* .getCampaignId */ .F9)();
  const parsingApi = _lib_DDBProxy_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"].getProxy */ .Z.getProxy();
  const betaKey = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "beta-key");
  const body = { cobalt: cobaltCookie, campaignId: campaignId, betaKey: betaKey };
  const debugJson = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "debug-json");
  const enableSources = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-use-source-filter");
  const sources = enableSources
    ? game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-muncher-sources").flat()
    : [];

  return new Promise((resolve, reject) => {
    fetch(`${parsingApi}/proxy/items`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(body), // body data type must match "Content-Type" header
    })
      .then((response) => response.json())
      .then((data) => {
        if (debugJson) {
          _lib_FileHelper_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].download */ .Z.download(JSON.stringify(data), `items-raw.json`, "application/json");
        }
        if (!data.success) {
          _DDBMuncher_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].munchNote */ .Z.munchNote(`Failure: ${data.message}`);
          reject(data.message);
        }
        return data;
      })
      .then((data) => {
        if (sources.length == 0 || !sourceFilter) return data.data;
        return data.data.filter((item) =>
          item.sources.some((source) => sources.includes(source.sourceId))
        );
      })
      .then((data) => {
        if (sources.length > 0) return data;
        if (game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-item-homebrew-only")) {
          return data.filter((item) => item.isHomebrew);
        } else if (!game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-item-homebrew")) {
          return data.filter((item) => !item.isHomebrew);
        } else {
          return data;
        }
      })
      .then((data) => getCharacterInventory(data))
      .then((items) => generateImportItems(items))
      .then((data) => resolve(data))
      .catch((error) => reject(error));
  });
}

async function addMagicItemSpells(items, spells, updateBool) {
  if (spells.length === 0) return;
  const itemSpells = await (0,_import_js__WEBPACK_IMPORTED_MODULE_0__/* .updateCompendium */ .X)("itemspells", { itemspells: spells }, updateBool);
  // scan the inventory for each item with spells and copy the imported data over
  items.forEach((item) => {
    if (item.flags.magicitems.spells) {
      for (let [i, spell] of Object.entries(item.flags.magicitems.spells)) {
        const itemSpell = itemSpells.find((item) => item.name === spell.name);
        if (itemSpell) {
          for (const [key, value] of Object.entries(itemSpell)) {
            item.flags.magicitems.spells[i][key] = value;
          }
        }
      }
    }
  });
}

async function parseItems(ids = null) {
  const updateBool = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-update-existing");
  const magicItemsInstalled = !!game.modules.get("magicitems");
  const uploadDirectory = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "other-image-upload-directory").replace(/^\/|\/$/g, "");

  // to speed up file checking we pregenerate existing files now.
  _logger_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].info */ .Z.info("Checking for existing files...");
  await _lib_FileHelper_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].generateCurrentFiles */ .Z.generateCurrentFiles(uploadDirectory);
  _logger_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].info */ .Z.info("Check complete, getting ItemData.");

  const addToCompendiumFolder = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-use-compendium-folders");
  const compendiumFoldersInstalled = game.modules.get("compendium-folders")?.active;
  if (addToCompendiumFolder && compendiumFoldersInstalled) {
    _DDBMuncher_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].munchNote */ .Z.munchNote(`Checking compendium folders..`, true);
    await (0,_compendiumFolders_js__WEBPACK_IMPORTED_MODULE_7__/* .createCompendiumFolderStructure */ .FT)("items");
  }

  _DDBMuncher_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].munchNote */ .Z.munchNote("Downloading item data..");

  // disable source filter if ids provided
  const sourceFilter = !(ids !== null && ids.length > 0);
  const results = await getItemData(sourceFilter);
  let items = results.items;

  _DDBMuncher_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].munchNote */ .Z.munchNote("Parsing item data..");

  // Items Spell addition is currently not done, parsing out spells needs to be addded
  // let itemSpells = results.value.itemSpells;
  let itemSpells = null;

  // store all spells in the folder specific for Dynamic Items
  if (magicItemsInstalled && itemSpells && Array.isArray(itemSpells)) {
    await addMagicItemSpells(items, itemSpells, updateBool);
  }

  const srdItems = await (0,_import_js__WEBPACK_IMPORTED_MODULE_0__/* .srdFiddling */ .cC)(items, "inventory");
  const filteredItems = (ids !== null && ids.length > 0)
    ? srdItems.filter((s) => s.flags?.ddbimporter?.definitionId && ids.includes(String(s.flags.ddbimporter.definitionId)))
    : srdItems;
  const finalItems = await (0,_import_js__WEBPACK_IMPORTED_MODULE_0__/* .daeFiddling */ .xh)(filteredItems);

  const finalCount = finalItems.length;
  _DDBMuncher_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].munchNote */ .Z.munchNote(`Importing ${finalCount} items!`, true);

  return new Promise((resolve) => {
    resolve((0,_import_js__WEBPACK_IMPORTED_MODULE_0__/* .updateCompendium */ .X)("inventory", { inventory: finalItems }, updateBool));
  });
}




/***/ }),

/***/ 6502:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "Z": () => (/* binding */ parseSpells)
});

// EXTERNAL MODULE: ./src/muncher/import.js
var muncher_import = __webpack_require__(9193);
// EXTERNAL MODULE: ./src/muncher/DDBMuncher.js + 13 modules
var DDBMuncher = __webpack_require__(1475);
// EXTERNAL MODULE: ./src/parser/spells/special.js
var special = __webpack_require__(1838);
// EXTERNAL MODULE: ./src/parser/spells/parseSpell.js + 12 modules
var parseSpell = __webpack_require__(1702);
;// CONCATENATED MODULE: ./src/parser/spells/getGenericSpells.js
// Import parsing functions



async function getSpells(spells) {
  let items = await Promise.all(spells
    .filter((spell) => spell.definition)
    .filter((spell) => {
      // remove archived material
      if (spell.definition.sources && spell.definition.sources.some((source) => source.sourceId === 39)) {
        return false;
      } else {
        return true;
      }
    })
    .map(async (spell) => {
      spell.flags = {
        ddbimporter: {
          generic: true,
          dndbeyond: {
            lookup: "generic",
            lookupName: "generic",
            level: spell.castAtLevel,
            castAtLevel: spell.castAtLevel,
          },
        },
      };

      return (0,parseSpell/* parseSpell */.T)(spell, null);
    }));

  if (items) (0,special/* fixSpells */.F)(null, items);

  return items;
}

// EXTERNAL MODULE: ./src/lib/FileHelper.js
var FileHelper = __webpack_require__(2397);
// EXTERNAL MODULE: ./src/logger.js
var logger = __webpack_require__(5259);
// EXTERNAL MODULE: ./src/lib/Secrets.js
var Secrets = __webpack_require__(2048);
// EXTERNAL MODULE: ./src/lib/Settings.js
var Settings = __webpack_require__(5406);
// EXTERNAL MODULE: ./src/muncher/compendiumFolders.js
var compendiumFolders = __webpack_require__(6269);
// EXTERNAL MODULE: ./src/settings.js
var settings = __webpack_require__(6451);
// EXTERNAL MODULE: ./src/lib/DDBProxy.js
var DDBProxy = __webpack_require__(546);
;// CONCATENATED MODULE: ./src/muncher/spells.js
// Main module class











function getSpellData(className, sourceFilter) {
  const cobaltCookie = (0,Secrets/* getCobalt */.HF)();
  const campaignId = (0,Settings/* getCampaignId */.F9)();
  const parsingApi = DDBProxy/* default.getProxy */.Z.getProxy();
  const betaKey = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "beta-key");
  const body = { cobalt: cobaltCookie, campaignId: campaignId, betaKey: betaKey, className: className };
  const debugJson = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "debug-json");
  const enableSources = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "munching-policy-use-source-filter");
  const sources = enableSources
    ? game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "munching-policy-muncher-sources").flat()
    : [];

  return new Promise((resolve, reject) => {
    fetch(`${parsingApi}/proxy/class/spells`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(body), // body data type must match "Content-Type" header
    })
      .then((response) => response.json())
      .then((data) => {
        if (debugJson) {
          FileHelper/* default.download */.Z.download(JSON.stringify(data), `spells-raw.json`, "application/json");
        }
        if (!data.success) {
          DDBMuncher/* default.munchNote */.Z.munchNote(`Failure: ${data.message}`);
          reject(data.message);
        }
        return data;
      })
      .then((data) => {
        if (sources.length == 0 || !sourceFilter) return data.data;
        return data.data.filter((spell) =>
          spell.definition.sources.some((source) => sources.includes(source.sourceId))
        );
      })
      .then((data) => {
        if (sources.length > 0) return data;
        if (game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "munching-policy-spell-homebrew-only")) {
          return data.filter((spell) => spell.definition.isHomebrew);
        } else if (!game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "munching-policy-spell-homebrew")) {
          return data.filter((spell) => !spell.definition.isHomebrew);
        } else {
          return data;
        }
      })
      .then((data) => resolve(data))
      .catch((error) => {
        logger/* default.warn */.Z.warn(error);
        reject(error);
      });
  });
}

async function parseSpells(ids = null) {
  const updateBool = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "munching-policy-update-existing");
  const uploadDirectory = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "other-image-upload-directory").replace(/^\/|\/$/g, "");

  // to speed up file checking we pregenerate existing files now.
  await FileHelper/* default.generateCurrentFiles */.Z.generateCurrentFiles(uploadDirectory);

  const addToCompendiumFolder = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "munching-policy-use-compendium-folders");
  const compendiumFoldersInstalled = game.modules.get("compendium-folders")?.active;
  if (addToCompendiumFolder && compendiumFoldersInstalled) {
    DDBMuncher/* default.munchNote */.Z.munchNote(`Checking compendium folders..`, true);
    await (0,compendiumFolders/* createCompendiumFolderStructure */.FT)("spells");
    DDBMuncher/* default.munchNote */.Z.munchNote("", true);
  }

  DDBMuncher/* default.munchNote */.Z.munchNote("Downloading spell data..");

  // disable source filter if ids provided
  const sourceFilter = !(ids !== null && ids.length > 0);
  const results = await Promise.allSettled([
    getSpellData("Cleric", sourceFilter),
    getSpellData("Druid", sourceFilter),
    getSpellData("Sorcerer", sourceFilter),
    getSpellData("Warlock", sourceFilter),
    getSpellData("Wizard", sourceFilter),
    getSpellData("Paladin", sourceFilter),
    getSpellData("Ranger", sourceFilter),
    getSpellData("Bard", sourceFilter),
    getSpellData("Graviturgy", sourceFilter),
    getSpellData("Chronurgy", sourceFilter),
    getSpellData("Artificer", sourceFilter),
  ]);

  DDBMuncher/* default.munchNote */.Z.munchNote("Parsing spell data..");

  const filteredResults = results
    .filter((r) => r.status === "fulfilled")
    .map((r) => r.value).flat().flat();

  const rawSpells = await getSpells(filteredResults);

  const spells = rawSpells
    .filter((spell) => spell?.name)
    .map((spell) => {
      spell.name = spell.name.replace(/â€™/g, "'");
      return spell;
    });

  if (results.some((r) => r.status === "rejected")) {
    DDBMuncher/* default.munchNote */.Z.munchNote("Failed to parse some spells, see the developer console (F12) for details.");
    logger/* default.error */.Z.error("Failed spell parsing", results);
  }

  let uniqueSpells = spells.filter((v, i, a) => a.findIndex((t) => t.name === v.name) === i);
  const srdSpells = await (0,muncher_import/* srdFiddling */.cC)(uniqueSpells, "spells");
  const filteredSpells = (ids !== null && ids.length > 0)
    ? srdSpells.filter((s) => s.flags?.ddbimporter?.definitionId && ids.includes(String(s.flags.ddbimporter.definitionId)))
    : srdSpells;
  const finalSpells = await (0,muncher_import/* daeFiddling */.xh)(filteredSpells);

  const finalCount = finalSpells.length;
  DDBMuncher/* default.munchNote */.Z.munchNote(`Importing ${finalCount} spells...`, true);

  return new Promise((resolve) => {
    resolve((0,muncher_import/* updateCompendium */.X)("spells", { spells: finalSpells }, updateBool));
  });
}




/***/ }),

/***/ 7967:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "p": () => (/* binding */ generateTable)
});

;// CONCATENATED MODULE: ./vendor/lowdash/uniq.js
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** `Object#toString` result references. */
var funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]';

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/**
 * A specialized version of `_.includes` for arrays without support for
 * specifying an index to search from.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludes(array, value) {
  var length = array ? array.length : 0;
  return !!length && baseIndexOf(array, value, 0) > -1;
}

/**
 * This function is like `arrayIncludes` except that it accepts a comparator.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludesWith(array, value, comparator) {
  var index = -1,
      length = array ? array.length : 0;

  while (++index < length) {
    if (comparator(value, array[index])) {
      return true;
    }
  }
  return false;
}

/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while ((fromRight ? index-- : ++index < length)) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseIndexOf(array, value, fromIndex) {
  if (value !== value) {
    return baseFindIndex(array, baseIsNaN, fromIndex);
  }
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */
function baseIsNaN(value) {
  return value !== value;
}

/**
 * Checks if a cache value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function isHostObject(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;
  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }
  return result;
}

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

/** Used for built-in method references. */
var arrayProto = Array.prototype,
    funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var uniq_hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(uniq_hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/** Built-in value references. */
var splice = arrayProto.splice;

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map'),
    Set = getNative(root, 'Set'),
    nativeCreate = getNative(Object, 'create');

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  return this.has(key) && delete this.__data__[key];
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return uniq_hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : uniq_hasOwnProperty.call(data, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
}

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  return getMapData(this, key)['delete'](key);
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  getMapData(this, key).set(key, value);
  return this;
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values ? values.length : 0;

  this.__data__ = new MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * The base implementation of `_.uniqBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 */
function baseUniq(array, iteratee, comparator) {
  var index = -1,
      includes = arrayIncludes,
      length = array.length,
      isCommon = true,
      result = [],
      seen = result;

  if (comparator) {
    isCommon = false;
    includes = arrayIncludesWith;
  }
  else if (length >= LARGE_ARRAY_SIZE) {
    var set = iteratee ? null : createSet(array);
    if (set) {
      return setToArray(set);
    }
    isCommon = false;
    includes = cacheHas;
    seen = new SetCache;
  }
  else {
    seen = iteratee ? [] : result;
  }
  outer:
  while (++index < length) {
    var value = array[index],
        computed = iteratee ? iteratee(value) : value;

    value = (comparator || value !== 0) ? value : 0;
    if (isCommon && computed === computed) {
      var seenIndex = seen.length;
      while (seenIndex--) {
        if (seen[seenIndex] === computed) {
          continue outer;
        }
      }
      if (iteratee) {
        seen.push(computed);
      }
      result.push(value);
    }
    else if (!includes(seen, computed, comparator)) {
      if (seen !== result) {
        seen.push(computed);
      }
      result.push(value);
    }
  }
  return result;
}

/**
 * Creates a set object of `values`.
 *
 * @private
 * @param {Array} values The values to add to the set.
 * @returns {Object} Returns the new set.
 */
var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {
  return new Set(values);
};

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * Creates a duplicate-free version of an array, using
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons, in which only the first occurrence of each
 * element is kept.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @returns {Array} Returns the new duplicate free array.
 * @example
 *
 * _.uniq([2, 1, 2]);
 * // => [2, 1]
 */
function uniq(array) {
  return (array && array.length)
    ? baseUniq(array)
    : [];
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * This method returns `undefined`.
 *
 * @static
 * @memberOf _
 * @since 2.3.0
 * @category Util
 * @example
 *
 * _.times(2, _.noop);
 * // => [undefined, undefined]
 */
function noop() {
  // No operation performed.
}

;// CONCATENATED MODULE: ./vendor/parseTable.js
/**
 * @license
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2014 Nick Williams
 * Copyright (c) 2021 Jack Holloway
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */



/**
 * generates factory functions to convert table rows to objects,
 * based on the titles in the table's <thead>
 * @param  {Array<String>} headings the values of the table's <thead>
 * @return {(row: HTMLTableRowElement) => Object} a function that takes a table row and spits out an object
 */
function mapRow(headings, highSplit = false) {
  return function mapRowToObject({ cells }) {
    const lowCells = [...cells];
    const highCells = lowCells.length > headings.length ? lowCells.splice(lowCells.length / 2) : [];
    const range = highSplit ? highCells : lowCells;

    return range.reduce((result, cell, i) => {
      const input = cell.querySelector("input,select");
      var value;

      if (input) {
        value = input.type === "checkbox" ? input.checked : input.value;
      } else {
        value = cell.innerHTML;
      }

      return Object.assign(result, { [headings[i]]: value });
    }, {});
  };
}

/**
 * given a table, generate an array of keys/column names
 *
 * @param  {HTMLTableElement} table the table to convert
 * @return {Array<String>}       array of strings representing each header in the table
 */
function getHeadings(table, unique = true) {
  if (!table.tHead || table.tHead.rows.length === 0) return [];
  const headings = [...table.tHead.rows[0].cells].map((heading) => {
    return heading.textContent;
  });

  if (unique) return uniq(headings);
  return headings;
}


function getRowsFromHeader(table) {
  let rows = [...table.tHead.rows];
  rows.splice(0, 1);
  return rows;
}

/**
 * given a table, generate an array of objects.
 * each object corresponds to a row in the table.
 * each object's key/value pairs correspond to a column's heading and the row's value for that column
 *
 * @param  {HTMLTableElement} table the table to convert
 * @return {Array<Object>}       array of objects representing each row in the table
 */
function parseTable(table) {
  const headings = getHeadings(table);
  const allHeadings = getHeadings(table, false);

  if (headings.length === 0) return [];
  // some tables are misformated and only have a thead and no tbody
  const rows = table.tBodies[0]
    ? [...table.tBodies[0].rows]
    : table.tHead.rows.length > 1
      ? getRowsFromHeader(table)
      : [];
  // DDB often puts d rolls alongside each other. we attempt to detect these
  const lowResults = rows.map(mapRow(headings));
  const highResults =
    allHeadings.length !== headings.length ? rows.map(mapRow(headings, true)) : [];

  return lowResults.concat(highResults);
}


// EXTERNAL MODULE: ./src/lib/utils.js
var utils = __webpack_require__(7669);
// EXTERNAL MODULE: ./src/logger.js
var logger = __webpack_require__(5259);
// EXTERNAL MODULE: ./src/muncher/import.js
var muncher_import = __webpack_require__(9193);
;// CONCATENATED MODULE: ./src/muncher/table.js





function diceRollMatcher(match, p1, p2, p3, p4, p5) {
  if (p5 && p5.toLowerCase() === "damage") {
    let dmgString = `${p4} damage`;
    dmgString = dmgString[0].toUpperCase() + dmgString.substring(1);
    const diceString = utils/* default.parseDiceString */.Z.parseDiceString(p2, null, `[${p4.toLowerCase()}]`).diceString;
    return `${p1 ? p1 : ""}[[/r ${diceString} # ${dmgString}]]${p3} damage`;
  } else if (p5 && p1 && p5.toLowerCase() === "points" && p1.toLowerCase() === "regains") {
    const diceString = utils/* default.parseDiceString */.Z.parseDiceString(p2, null, "[healing]").diceString;
    return `${p1 ? p1 : ""}[[/r ${diceString} # Healing]]${p3} hit points`;
  } else {
    const diceString = utils/* default.parseDiceString */.Z.parseDiceString(p2).diceString;
    const result = `${p1 ? p1 : ""}[[/r ${diceString}]]${p3 ? p3 : ""} ${p4 ? p4 : ""} ${p5 ? p5 : ""}`.trim();
    return result;
  }
}

function replaceRollLinks(text) {
  text = text.replace(/[Â­â€“â€“âˆ’-]/gu, "-").replace(/-+/g, "-");
  const damageRegex = new RegExp(/([.>( ^]|^|regains +)?(\d*d\d+(?:\s*[+-]\s*\d*d*\d*)*)([.,<)]|$| +) *([a-z,A-Z]*) *(damage|points)?/, "g");
  text = text.replace(damageRegex, diceRollMatcher);

  // const Regex
  // to hit rolls
  const toHitRegex = new RegExp(/ ([+-]) *(\d+) to hit/, "g");
  text = text.replace(toHitRegex, " [[/r 1d20 $1 $2]] to hit");
  return text;
}

function findDiceColumns(table) {
  let result = [];
  if (table.tHead) {
    const headings = getHeadings(table);
    headings.forEach((h) => {
      const diceRegex = new RegExp(/(\d*[d|D]\d+(\s*[+-]?\s*\d*)?)/, "g");
      const match = h.replace(/[Â­â€“â€“âˆ’-]/gu, "-").replace(/-+/g, "-").match(diceRegex);
      if (match) {
        result.push(h);
      }
    });
  }
  return result;
}

function guessTableName(parentName, htmlDocument, tableNum) {
  const element = htmlDocument.querySelectorAll('table');
  let track = element[tableNum];
  let sibling = track.previousElementSibling;

  while (!sibling && track.parentElement?.nodeName === "DIV") {
    if (!track.parentElement.previousElementSibling) {
      track = track.parentElement;
    } else {
      sibling = track.parentElement.previousElementSibling;
    }
  }

  if (sibling) {
    return sibling.textContent;
  } else {
    logger/* default.warn */.Z.warn(`No table name identified for ${parentName}`);
    return "";
  }
}


function tableReplacer(htmlDocument, tableNum, compendiumTables) {
  // future enhancement - replace liks to DDB spells, monsters, items etc to munched compendium
  const element = htmlDocument.querySelectorAll('table');
  const tablePoint = element[tableNum];

  if (tablePoint) {
    const rollCompendiumLabel = game.settings.get("ddb-importer", "entity-table-compendium");
    compendiumTables.slice().reverse().forEach((table) => {
      logger/* default.debug */.Z.debug(`Updating table reference for: ${table.name}`);
      tablePoint.insertAdjacentHTML("afterend", `<div id="table-link">@Compendium[${rollCompendiumLabel}.${table.name}]{Open RollTable ${table.name}}</div>`);
    });
  }

  return htmlDocument;
}


function diceInt(text) {
  if (text === "0") return 10;
  if (text === "00") return 100;
  return parseInt(text);
}

/**
 * This could be:
 * a single value e.g. 19
 * a range of values 19-20
 * remaining values 19+
 * @param {*} value
 * @returns array of range
 */
function getDiceTableRange(value) {
  const document = utils/* default.htmlToDoc */.Z.htmlToDoc(value);
  const text = document.body.textContent.replace(/[Â­â€“â€“âˆ’-]/gu, "-").replace(/-+/g, "-").replace(/\s/g, "").trim();
  // eslint-disable-next-line no-useless-escape
  const valueRegex = new RegExp(/^(\d+)\-(\d+)|^(\d+)(\+?)$/);
  const valueMatch = text.match(valueRegex);

  if (valueMatch) {
    if (valueMatch[1] !== undefined && valueMatch[2] !== undefined) {
      const low = diceInt(valueMatch[1]);
      const high = diceInt(valueMatch[2]);
      return [low, high];
    }

    if (valueMatch[3]) {
      if (valueMatch[4] !== undefined && valueMatch[4] === "+") {
        const low = diceInt(valueMatch[3]);
        return [low, 0];
      }
      if (valueMatch[4] !== undefined && valueMatch[4] === "") {
        const low = diceInt(valueMatch[3]);
        return [low, low];
      }
    }
  }

  // logger.debug(`Dice range: Unable to table range match '${value}' text was '${text}'`);
  return [];
}


function buildTable(parsedTable, keys, diceKeys, tableName, parentName) {
  let generatedTables = [];

  diceKeys.forEach((diceKey) => {
    const nameExtension = diceKeys > 1 ? ` [${diceKeys}]` : "";
    const realName = ((tableName && tableName !== "") ? tableName : "Unnamed Table") + nameExtension;
    logger/* default.debug */.Z.debug(`Generating table ${realName}`);

    const diceRegex = new RegExp(/(\d*d\d+(\s*[+-]?\s*\d*d*\d*)?)/, "g");
    const formulaMatch = diceKey.match(diceRegex);

    let table = {
      "name": realName,
      "sort": 100000,
      "flags": {
        "ddbimporter": {
          "parentName": parentName,
          "keys": keys,
          "diceKeys": diceKeys
        }
      },
      "img": "icons/svg/d20-grey.svg",
      "description": "",
      "results": [],
      "formula": formulaMatch ? formulaMatch[0].trim() : "",
      "replacement": true,
      "displayRoll": true,
    };

    const concatKeys = (keys.length - diceKeys.length) > 1;
    // loop through rows and build result entry.
    // if more than one result key then we will concat the results.
    parsedTable.forEach((entry) => {
      const result = {
        flags: {},
        type: 0,
        text: "",
        img: "icons/svg/d20-black.svg",
        resultId: null,
        weight: 1,
        range: [],
        drawn: false,
        resultCollection: "",
      };
      Object.entries(entry).forEach(([key, value]) => {
        if (key === diceKey) {
          result.range = getDiceTableRange(value);
        } else if (diceKeys.includes(key)) return;
        if (concatKeys) {
          if (result.text != "") result.text += "\n\n";
          result.text += `<b>${key}</b>${value}`;
        } else {
          result.text = value;
        }
      });
      result.text = replaceRollLinks(result.text);
      const diceRollerRegexp = new RegExp(/\[\[\/r\s*([0-9d+-\s]*)(:?#.*)?\]\]/);
      result.text = result.text.replace(diceRollerRegexp, "[[$1]] ($&)");
      table.results.push(result);
    });

    generatedTables.push(table);

  });

  return generatedTables;
}

function generateTable(parentName, html, updateExisting, type = "") {
  const document = utils/* default.htmlToDoc */.Z.htmlToDoc(html);
  const tableNodes = document.querySelectorAll("table");
  let tablesMatched = [];
  let updatedDocument = utils/* default.htmlToDoc */.Z.htmlToDoc(html);
  if (type === "background" && !parentName.startsWith("Background:")) {
    parentName = `Background: ${parentName}`;
  }
  if (parentName.startsWith("Background:")) {
    const parentNamesArray = parentName.split(":");
    // if (parentNamesArray.length > 2) parentNamesArray.pop();
    parentName = parentNamesArray.join(":");
  }

  let tableNum = 0;
  tableNodes.forEach((node) => {
  // for (let i = 0; i < tableNodes.length; i++) {
    // const node = tableNodes[i];
    const parsedTable = parseTable(node);
    const keys = getHeadings(node);
    const diceKeys = findDiceColumns(node);
    let nameGuess = guessTableName(parentName, document, tableNum);
    if (nameGuess.split(" ").length > 5 && diceKeys.length === 1 && keys.length === 2) {
      nameGuess = keys[1];
    }
    const finalName = `${parentName}: ${nameGuess}`;
    const tableGenerated = (finalName in CONFIG.DDBI.TABLES);

    logger/* default.debug */.Z.debug(`Table detection triggered for ${parentName}!`);
    logger/* default.debug */.Z.debug(`Table: "${finalName}"`);
    logger/* default.debug */.Z.debug(`Dice Keys: ${diceKeys.join(", ")}`);
    logger/* default.debug */.Z.debug(`Keys: ${keys.join(", ")}`);

    const builtTables = tableGenerated
      ? CONFIG.DDBI.TABLES[finalName]
      : buildTable(parsedTable, keys, diceKeys, finalName, parentName);

    if (builtTables.length > 0) {
      // these updates are done async, and we continue. this is fine as we actually use the table name for linking
      if (!tableGenerated) {
        CONFIG.DDBI.TABLES[finalName] = builtTables;
        logger/* default.debug */.Z.debug(`Generated table`, builtTables);
        (0,muncher_import/* updateCompendium */.X)("tables", { tables: builtTables }, updateExisting);
      }

      let tableData = {
        nameGuess,
        finalName,
        parentName,
        tableNum,
        length: parsedTable.length,
        keys: keys,
        diceKeys: diceKeys,
        diceTable: diceKeys.length > 0,
        multiDiceKeys: diceKeys.length > 1,
        diceKeysNumber: diceKeys.length,
        totalKeys: keys.length,
        builtTables: CONFIG.DDBI.TABLES[finalName],
      };
      tablesMatched.push(tableData);
      updatedDocument = tableReplacer(updatedDocument, tableNum, tableData.builtTables);

    }
    tableNum++;
  // }
  });

  return updatedDocument.body.innerHTML;

}


/***/ }),

/***/ 8089:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BU": () => (/* binding */ updateWorldMonsters),
/* harmony export */   "CY": () => (/* binding */ parseCritters),
/* harmony export */   "mk": () => (/* binding */ resetCompendiumActorImages)
/* harmony export */ });
/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5259);
/* harmony import */ var _lib_FileHelper_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2397);
/* harmony import */ var _lib_CompendiumHelper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3893);
/* harmony import */ var _DDBMuncher_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(1475);
/* harmony import */ var _import_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(9193);
/* harmony import */ var _importMonster_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(9633);
/* harmony import */ var _DDBMonsterFactory_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(6870);








let totalTargets = 0;
let count = 0;

async function updateActorsWithActor(targetActors, sourceActor) {
  let results = [];
  count++;

  for (let targetActor of targetActors) {
    _DDBMuncher_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].munchNote */ .Z.munchNote(`Updating ${count}/${totalTargets} world monsters`);
    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug(`Updating ${count}/${totalTargets} world monsters`, targetActor);
    const monsterItems = sourceActor.items.toObject().map((item) => {
      delete item._id;
      return item;
    });
    const actorUpdate = duplicate(sourceActor);
    // pop items in later
    delete actorUpdate.items;


    const updateImages = game.settings.get("ddb-importer", "munching-policy-update-world-monster-update-images");
    if (!updateImages) {
      actorUpdate.img = targetActor.img;
      actorUpdate.prototypeToken.texture.src = targetActor.prototypeToken.texture.src;
      actorUpdate.prototypeToken.scale = targetActor.prototypeToken.scale;
      actorUpdate.prototypeToken.randomImg = targetActor.prototypeToken.randomImg;
      actorUpdate.prototypeToken.mirrorX = targetActor.prototypeToken.mirrorX;
      actorUpdate.prototypeToken.mirrorY = targetActor.prototypeToken.mirrorY;
      actorUpdate.prototypeToken.lockRotation = targetActor.prototypeToken.lockRotation;
      actorUpdate.prototypeToken.rotation = targetActor.prototypeToken.rotation;
      actorUpdate.prototypeToken.alpha = targetActor.prototypeToken.alpha;
      actorUpdate.prototypeToken.lightAlpha = targetActor.prototypeToken.lightAlpha;
      actorUpdate.prototypeToken.lightAnimation = targetActor.prototypeToken.lightAnimation;
      actorUpdate.prototypeToken.tint = targetActor.prototypeToken.tint;
      actorUpdate.prototypeToken.lightColor = targetActor.prototypeToken.lightColor;
    }

    const retainBiography = game.settings.get("ddb-importer", "munching-policy-update-world-monster-retain-biography");
    if (retainBiography) {
      actorUpdate.system.details.biography = targetActor.system.details.biography;
    }

    actorUpdate._id = targetActor.id;
    if (targetActor.folder) actorUpdate.folder = targetActor.folder._id;
    actorUpdate.sort = targetActor.sort;
    actorUpdate.ownership = targetActor.ownership;
    // eslint-disable-next-line no-await-in-loop
    await (0,_import_js__WEBPACK_IMPORTED_MODULE_4__/* .copySupportedItemFlags */ .uf)(targetActor, actorUpdate);

    // eslint-disable-next-line no-await-in-loop
    await targetActor.deleteEmbeddedDocuments("Item", [], { deleteAll: true });

    // eslint-disable-next-line no-await-in-loop
    await targetActor.update(actorUpdate);
    // console.warn("afterdelete", duplicate(targetActor));
    // eslint-disable-next-line no-await-in-loop
    await targetActor.createEmbeddedDocuments("Item", monsterItems);
    // console.warn("after create", duplicate(targetActor));

  };

  return Promise.all(results);
}

async function updateWorldMonsters() {
  let results = [];
  // get ddb monsters compendium
  const monsterCompendiumLabel = _lib_CompendiumHelper_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].getCompendiumLabel */ .Z.getCompendiumLabel("monster");
  const monsterCompendium = _lib_CompendiumHelper_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].getCompendium */ .Z.getCompendium(monsterCompendiumLabel);

  if (monsterCompendium) {
    const monsterIndices = ["name", "flags.ddbimporter.id"];
    const index = await monsterCompendium.getIndex({ fields: monsterIndices });
    totalTargets = game.actors.filter((a) => a.type === "npc" && hasProperty(a, "flags.ddbimporter.id")).length;
    count = 0;
    _DDBMuncher_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].munchNote */ .Z.munchNote(`Updating ${count}/${totalTargets} world monsters`);
    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug(`Checking ${totalTargets} world monsters`);

    for (const [key, value] of index.entries()) {

      const worldMatches = game.actors.filter((actor) =>
        actor.flags?.ddbimporter?.id
        && actor.name === value.name
        && actor.flags.ddbimporter.id == value.flags?.ddbimporter?.id
      );

      if (worldMatches.length > 0) {
        _DDBMuncher_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].munchNote */ .Z.munchNote(`Found ${value.name} world monster`, true);
        _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug(`Matched ${value.name} (${key})`);
        // eslint-disable-next-line no-await-in-loop
        const monster = await monsterCompendium.getDocument(value._id);
        // eslint-disable-next-line no-await-in-loop
        let updatedActors = await updateActorsWithActor(worldMatches, monster, count);
        results.push(updatedActors);
      }
    }
    _DDBMuncher_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].munchNote */ .Z.munchNote(`Finished updating ${totalTargets} world monsters`);
    _DDBMuncher_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].munchNote */ .Z.munchNote("", true);

  } else {
    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].error */ .Z.error("Error opening compendium, check your settings");
  }
  return results;
}

async function resetCompendiumActorImages(compendiumName = null, type = "monster") {
  const monsterCompendiumLabel = compendiumName ? compendiumName : _lib_CompendiumHelper_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].getCompendiumLabel */ .Z.getCompendiumLabel(type);
  const monsterCompendium = _lib_CompendiumHelper_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].getCompendium */ .Z.getCompendium(monsterCompendiumLabel);
  const fields = ["name", "flags.monsterMunch", "system.details.type.value", "img", "prototypeToken.texture.src"];
  const index = await monsterCompendium.getIndex({ fields });

  const otherDirectory = game.settings.get("ddb-importer", "other-image-upload-directory").replace(/^\/|\/$/g, "");
  await _lib_FileHelper_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].generateCurrentFiles */ .Z.generateCurrentFiles(otherDirectory);

  const updates = await Promise.all(index
    .filter((i) => i.name !== "#[CF_tempEntity]")
    .map(async (i) => {
      const options = { forceUpdate: true, disableAutoTokenizeOverride: true, type };
      const update = await (0,_importMonster_js__WEBPACK_IMPORTED_MODULE_5__/* .getNPCImage */ .xD)(duplicate(i), options);
      _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].info */ .Z.info(`Resetting ${i.name}`, update);
      return update;
    }));

  const results = await Actor.updateDocuments(updates, { pack: monsterCompendiumLabel });
  _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug("Reset results", results);
  return results;
}

async function parseCritters(ids = null) {
  const monsterFactory = new _DDBMonsterFactory_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z();
  const parsedExtras = await monsterFactory.processIntoCompendium(ids);
  return parsedExtras;
}


/***/ }),

/***/ 1187:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "f": () => (/* binding */ getVehicleData),
  "b": () => (/* binding */ parseTransports)
});

// EXTERNAL MODULE: ./src/logger.js
var logger = __webpack_require__(5259);
// EXTERNAL MODULE: ./src/lib/FileHelper.js
var FileHelper = __webpack_require__(2397);
// EXTERNAL MODULE: ./src/muncher/import.js
var muncher_import = __webpack_require__(9193);
// EXTERNAL MODULE: ./src/muncher/DDBMuncher.js + 13 modules
var DDBMuncher = __webpack_require__(1475);
// EXTERNAL MODULE: ./src/muncher/importMonster.js
var importMonster = __webpack_require__(9633);
// EXTERNAL MODULE: ./src/lib/Secrets.js
var Secrets = __webpack_require__(2048);
// EXTERNAL MODULE: ./src/lib/Settings.js
var Settings = __webpack_require__(5406);
// EXTERNAL MODULE: ./src/lib/DDBHelper.js
var DDBHelper = __webpack_require__(1438);
// EXTERNAL MODULE: ./src/lib/CompendiumHelper.js
var CompendiumHelper = __webpack_require__(3893);
;// CONCATENATED MODULE: ./src/parser/vehicle/templates/vehicle.js
async function newVehicle(name) {
  const options = {
    temporary: true,
    displaySheet: false,
  };
  const vehicleClass = await Actor.create({ name, type: "vehicle" }, options);
  let vehicle = vehicleClass.toObject();
  const flags = {
    dnd5e: {},
    monsterMunch: {},
    ddbimporter: {
      dndbeyond: {},
    },
  };
  setProperty(vehicle, "flags", flags);
  return vehicle;
};

// EXTERNAL MODULE: ./src/dictionary.js
var dictionary = __webpack_require__(37);
;// CONCATENATED MODULE: ./src/parser/vehicle/conditions.js


function getDamageImmunities(ddb) {
  const config = CONFIG.DDB.damageTypes;

  let values = [];
  let custom = [];

  const damageTypes = dictionary/* default.actions.damageType.filter */.Z.actions.damageType.filter((d) => d.name !== null).map((d) => d.name);

  ddb.damageImmunities.forEach((adj) => {
    const adjustment = config.find((cadj) => adj === cadj.id);
    if (adjustment && damageTypes.includes(adjustment.name.toLowerCase())) {
      values.push(adjustment.name.toLowerCase());
    } else if (adjustment && adjustment.slug === "bludgeoning-piercing-and-slashing-from-nonmagical-attacks") {
      values.push("physical");
    } else if (adjustment) {
      const midiQolInstalled = game.modules.get("midi-qol")?.active;
      if (midiQolInstalled) {
        if (adjustment.name.toLowerCase().includes("silvered")) {
          values.push("silver");
        } else if (adjustment.name.toLowerCase().includes("adamantine")) {
          values.push("adamant");
        } else if (adjustment.slug === "damage-from-spells") {
          values.push("spell");
        } else {
          custom.push(adjustment.name);
        }
      } else {
        custom.push(adjustment.name);
      }
    }
  });

  const adjustments = {
    value: values,
    custom: custom.join("; "),
  };

  return adjustments;
}

function getConditionImmunities(ddb) {
  const config = CONFIG.DDB.conditions.map((condition) => {
    return {
      id: condition.definition.id,
      name: condition.definition.name,
      type: condition.definition.type,
      slug: condition.definition.slug,
    };
  });

  let values = [];
  let custom = [];

  ddb.conditionImmunities.forEach((adj) => {
    const adjustment = config.find((cadj) => adj === cadj.id);
    const valueAdjustment = dictionary/* default.conditions.find */.Z.conditions.find((condition) => condition.label.toLowerCase() == adjustment.name.toLowerCase());
    if (adjustment && valueAdjustment) {
      values.push(valueAdjustment.foundry);
    } else if (adjustment) {
      custom.push(adjustment.name);
    }
  });

  const adjustments = {
    value: values,
    custom: custom.join("; "),
  };

  return adjustments;
}

;// CONCATENATED MODULE: ./src/parser/vehicle/abilities.js
const ABILITIES = [
  { id: 1, value: "str", long: "strength" },
  { id: 2, value: "dex", long: "dexterity" },
  { id: 3, value: "con", long: "constitution" },
  { id: 4, value: "int", long: "intelligence" },
  { id: 5, value: "wis", long: "wisdom" },
  { id: 6, value: "cha", long: "charisma" },
];

//     "abilities": {
// "str": {
//   "value": 27,
//   "proficient": 0,
//   "min": 3,
//   "mod": 8,
//   "save": 8,
//   "prof": 0,
//   "saveBonus": 0,
//   "checkBonus": 0,
//   "dc": 23
// },
// "dex": {
//   "value": 14,
//   "proficient": 1,
//   "min": 3,
//   "mod": 2,
//   "save": 9,
//   "prof": 7,
//   "saveBonus": 0,
//   "checkBonus": 0,
//   "dc": 17
// },
/**
 * Retrieves character abilities, including proficiency on saving throws
 * @param {obj} ddb JSON Import
 * @param {obj} CONFIG.DDB config
 */
function getAbilities(abilities, ddb) {
  // go through every ability
  ABILITIES.forEach((ability) => {
    const value = ddb.stats.find((stat) => stat.id === ability.id)?.value || 10;
    const mod = value === 0
      ? -5
      : CONFIG.DDB.statModifiers.find((s) => s.value == value).modifier;

    abilities[ability.value]['value'] = value;
    abilities[ability.value]['proficient'] = 0;
    abilities[ability.value]['mod'] = mod;

  });

  return abilities;
}


function getAbilityMods(ddb) {
  let abilities = {};

  ABILITIES.forEach((ability) => {
    const value = ddb.stats.find((stat) => stat.id === ability.id)?.value || 10;
    const mod = value === 0
      ? -5
      : CONFIG.DDB.statModifiers.find((s) => s.value == value).modifier;

    abilities[ability.value] = mod;
  });

  return abilities;

}

;// CONCATENATED MODULE: ./src/parser/vehicle/size.js


const SIZES = [
  { name: "Tiny", value: "tiny", size: 0.5 },
  { name: "Small", value: "sm", size: 0.8 },
  { name: "Medium", value: "med", size: 1 },
  { name: "Large", value: "lg", size: 2 },
  { name: "Huge", value: "huge", size: 3 },
  { name: "Gargantuan", value: "grg", size: 4 },
];

function getSizeFromId(sizeId) {
  const size = CONFIG.DDB.creatureSizes.find((s) => s.id == sizeId).name;
  const sizeData = SIZES.find((s) => size == s.name);

  if (!sizeData) {
    logger/* default.warn */.Z.warn(`No size found, using medium`, size);
    return { name: "Medium", value: "med", size: 1 };
  }
  return sizeData;
}

function getSize (ddb) {
  const sizeData = getSizeFromId(ddb.sizeId);
  const token = {
    scale: sizeData.size >= 1 ? 1 : sizeData.size,
    value: sizeData.size >= 1 ? sizeData.size : 1,
  };

  const data = {
    value: sizeData.value,
    token: token,
  };

  return data;

}

;// CONCATENATED MODULE: ./src/parser/vehicle/capacity.js
function getCapacity(ddb) {
  let capacity = {
    creature: "",
    cargo: null,
  };

  if (ddb.cargoCapacity) {
    capacity.cargo = ddb.cargoCapacity;
  }

  if (ddb.creatureCapacity && ddb.creatureCapacity.length > 0) {
    const capacityStrings = ddb.creatureCapacity.map((c) => {
      const size = c.sizeId
        ? `${CONFIG.DDB.creatureSizes.find((s) => s.id == c.sizeId).name.toLowerCase()} `
        : "";

      return `${c.capacity} ${size}${c.type}`;
    });
    capacity.creature = capacityStrings.join(", ");
  }

  return capacity;
}

;// CONCATENATED MODULE: ./src/parser/vehicle/movement.js
const FLIGHT_IDS = [
  "7",
  "8",
];

const MOVEMENT_DICT = {
  "land": "walk",
  "water": "swim",
  "air": "fly",
  "magical": "Magical",
};

function getMovement(ddb, configurations, movement) {

  // is it travel pace?
  if (configurations.ETP) {
    movement["units"] = "mi";
    const travelPaceMilesPerHour = ddb.travelPace / 5280;
    if (FLIGHT_IDS.includes(ddb.id) || configurations.DT === "spelljammer") {
      movement["fly"] = travelPaceMilesPerHour;
    } else {
      movement["swim"] = travelPaceMilesPerHour;
    }
  } else {
    const primaryComponent = ddb.components.find((c) => c.isPrimaryComponent);
    if (primaryComponent && primaryComponent.speeds && primaryComponent.speeds.length > 0) {
      movement["units"] = "ft";
      const type = MOVEMENT_DICT[primaryComponent.speeds[0].type];
      movement[type] = primaryComponent.speeds[0].modes[0].value;
    }

  }

  return movement;
}

// EXTERNAL MODULE: ./src/lib/utils.js
var utils = __webpack_require__(7669);
;// CONCATENATED MODULE: ./src/parser/vehicle/templates/component.js
// import logger from '../../../logger.js';


function newComponent(name, type) {
  // logger.debug("Generating new component:", { name, type });
  let feat = {
    name: name,
    type: type,
    system: JSON.parse(utils/* default.getTemplate */.Z.getTemplate(type)),
    flags: {
      ddbimporter: {
        dndbeyond: {
        },
      },
    },
  };
  return feat;
};

// EXTERNAL MODULE: ./src/lib/DDBTemplateStrings.js
var DDBTemplateStrings = __webpack_require__(258);
;// CONCATENATED MODULE: ./src/parser/vehicle/components.js





const TYPE_MAPPING = {
  hull: "equipment",
  helm: "equipment",
  weapon: "weapon",
  movement: "equipment",
  control: "equipment",
  // "crew" action: feat
  // "action", action: feat
  feature: "feat",
  // "loot": loot
};

// function getWeaponType(action) {
//   const entry = DICTIONARY.actions.attackTypes.find((type) => type.attackSubtype === action.attackSubtype);
//   const range = DICTIONARY.weapon.weaponRange.find((type) => type.attackType === action.attackTypeRange);
//   return entry ? entry.value : range ? `simple${range.value}` : "simpleM";
// }

function getActivation(action, crew = false) {
  const actionType = dictionary/* default.actions.activationTypes.find */.Z.actions.activationTypes.find((type) => type.id === action.activation?.activationType);
  const activation = {
    type: crew ? "crew" : actionType ? actionType.value : "action",
    cost: action.activation?.activationTime || 1,
    condition: "",
  };
  return activation;
}

function getLimitedUse(action) {
  if (
    action.limitedUse
    && (action.limitedUse.maxUses)
  ) {
    const resetType = dictionary/* default.resets.find */.Z.resets.find((type) => type.id === action.limitedUse.resetType);
    let maxUses = (action.limitedUse.maxUses && action.limitedUse.maxUses !== -1) ? action.limitedUse.maxUses : 0;

    const finalMaxUses = (maxUses) ? parseInt(maxUses) : null;

    return {
      value: (finalMaxUses !== null && finalMaxUses != 0) ? maxUses - action.limitedUse.numberUsed : null,
      max: (finalMaxUses != 0) ? finalMaxUses : null,
      per: resetType ? resetType.value : "",
    };
  } else {
    return {
      value: null,
      max: null,
      per: "",
    };
  }
}

function calculateRange(action, weapon) {
  if (action.range && action.range.aoeType && action.range.aoeSize) {
    weapon.system.range = { value: null, units: "self", long: "" };
    weapon.system.target = {
      value: action.range.aoeSize,
      type: dictionary/* default.actions.aoeType.find */.Z.actions.aoeType.find((type) => type.id === action.range.aoeType)?.value,
      units: "ft",
    };
  } else if (action.range && action.range.range) {
    weapon.system.range = {
      value: action.range.range,
      units: "ft",
      long: action.range.longRange || "",
    };
  } else {
    weapon.system.range = { value: 5, units: "ft", long: "" };
  }
  return weapon;
}


function getSaveAbility(description) {
  const save = description.match(/DC ([0-9]+) (.*?) saving throw|\(save DC ([0-9]+)\)/);
  if (save) {
    return save[2] ? save[2].toLowerCase().substr(0, 3) : "";
  } else {
    return "";
  }
}

function getActionType(action) {
  let actionType = "rwak";
  // lets see if we have a save stat for things like Dragon born Breath Weapon
  if (typeof action.saveStatId === "number" || action.fixedSaveDc) {
    actionType = "save";
  } else if (action.actionType === 1) {
    if (action.attackTypeRange === 2) {
      actionType = "rwak";
    } else {
      actionType = "mwak";
    }
  } else if (action.rangeId && action.rangeId === 1) {
    actionType = "mwak";
  } else if (action.rangeId && action.rangeId === 2) {
    actionType = "rwak";
  } else {
    actionType = "other";
  }
  return actionType;
}


function getWeaponProperties(action, weapon) {
  if (action.name) weapon.name += `: ${action.name}`;
  weapon.system.description.value += `\n${action.description}`;

  if (action.fixedToHit !== null) {
    weapon.system.attackBonus = `${action.fixedToHit}`;
  }
  // weapon.system.weaponType = getWeaponType(action);
  weapon.system.weaponType = "siege";
  weapon.system.target = {
    "value": 1,
    "width": null,
    "units": "",
    "type": "creature"
  };
  if (Number.isInteger(action.numberOfTargets)) weapon.system.target.value = action.numberOfTargets;

  const damageType = dictionary/* default.actions.damageType.find */.Z.actions.damageType.find((type) => type.id === action.damageTypeId).name;

  if (action.dice?.diceString) weapon.system.damage.parts = [[action.dice.diceString, damageType]];

  if (action.fixedSaveDc) {
    const saveAbility = (action.saveStatId)
      ? dictionary/* default.character.abilities.find */.Z.character.abilities.find((stat) => stat.id === action.saveStatId).value
      : getSaveAbility(action.description);
    weapon.system.save = {
      ability: saveAbility,
      dc: Number.parseInt(action.fixedSaveDc),
      scaling: "flat",
    };
  }

  weapon.system.equipped = true;
  weapon.system.actionType = getActionType(action);
  weapon.system.uses = getLimitedUse(action);
  weapon.system.activation = getActivation(action, weapon.system.activation.type === "crew");
  weapon = calculateRange(action, weapon);

  return weapon;

}

// eslint-disable-next-line complexity
function buildComponents(ddb, configurations, component) {
  const results = [];
  const types = component.definition.types.map((t) => t.type);
  const item = duplicate(newComponent(component.definition.name, TYPE_MAPPING[types[0]]));

  if (types[0] === "equipment") {
    setProperty(item, "data.armor.type", "vehicle");
  }

  if (component.description) item.system.description.value = (0,DDBTemplateStrings/* parseTags */.RN)(component.description);

  item.system.quantity = component.count;

  item.system.armor = {
    value: null,
    type: "vehicle",
    dex: null
  };
  item.system.hp = {
    value: null,
    max: null,
    dt: null,
    conditions: ""
  };

  if (component.groupType === "action-station") {
    item.system.activation.type = "crew";
    switch (component.definition.coverType) {
      case "full":
        item.system.cover = 1;
        break;
      case "half":
        item.system.cover = 0.5;
        break;
      case "three-quarters":
        item.system.cover = 0.75;
        break;
      default:
        item.system.cover = undefined;
        break;
    }

  } else if (component.definition.groupType === "component") {

    if (component.definition.speeds && component.definition.speeds.length > 0) {
      item.system.speed = {
        value: component.definition.speeds[0].modes[0].value,
        conditions: component.definition.speeds[0].modes[0].description
          ? component.definition.speeds[0].modes[0].description
          : "",
      };
      if (component.definition.speeds[0].modes.length > 1) {
        const speedConditions = [];
        for (let i = 1; i < component.definition.speeds[0].modes.length; i++) {
          const speedValue = component.definition.speeds[0].modes[i].value;
          const speedCondition = component.definition.speeds[0].modes[i].description
            ? component.definition.speeds[0].modes[i].description
            : "";
          const speedRestriction = component.definition.speeds[0].modes[i].restrictionsText
            ? component.definition.speeds[0].modes[i].restrictionsText
            : "";
          speedConditions.push(`${speedValue} ${speedCondition}${speedRestriction}`);
        }

        const speedAdjustment = component.definition.types.find((t) => t.type === "movement");
        if (speedAdjustment && speedAdjustment.adjustments && speedAdjustment.adjustments.length > 0) {
          speedAdjustment.adjustments.filter((a) => a.type === "speed").forEach((a) => {
            a.values.forEach((v) => {
              speedConditions.push(`-${v.perDamageValue}ft speed per ${v.perDamageTaken} damage taken`);
            });
          });
        }
        if (speedConditions.length > 0) {
          item.system.speed.conditions += speedConditions.join("; ");
        }
      }
    }

    if (Number.isInteger(component.definition.armorClass)) {
      item.system.armor = {
        value: parseInt(component.definition.armorClass),
        type: "vehicle",
        dex: null
      };
    }

    if (Number.isInteger(component.definition.hitPoints)) {
      item.system.hp = {
        value: parseInt(component.definition.hitPoints),
        max: parseInt(component.definition.hitPoints),
        dt: null,
        conditions: ""
      };
      if (component.definition.damageThreshold) {
        item.system.hp.dt = component.definition.damageThreshold;
      }
    }
  }

  if (types.includes("weapon") && component.definition.actions.length > 0) {
    logger/* default.debug */.Z.debug("processing weapon", component);
    component.definition.actions.forEach((action) => {
      const actionItem = getWeaponProperties(action, duplicate(item));
      logger/* default.debug */.Z.debug("action item", actionItem);
      results.push(actionItem);
    });
  } else {
    results.push(item);
  }

  return results;

}

function processComponents(ddb, configurations) {
  const components = ddb.components.sort((c) => c.displayOrder);

  const componentCount = {};
  const uniqueComponents = [];
  components.forEach((component) => {
    const key = component.definitionKey;
    const count = componentCount[key] || 0;
    if (count === 0) uniqueComponents.push(component);
    componentCount[key] = count + 1;
  });


  const componentItems = uniqueComponents
    .filter((f) => f.definition.name)
    .map((component) => {
      component.count = componentCount[component.definitionKey];
      const builtItems = buildComponents(ddb, configurations, component);
      return builtItems;
    })
    .flat();

  const featureItems = ddb.features
    .filter((f) => f.name)
    .map((feature) => {
      setProperty(feature, "definition.types", [{ type: "feature" }]);
      setProperty(feature, "definition.name", feature.name);
      const builtItems = buildComponents(ddb, configurations, feature);
      return builtItems;
    })
    .flat();

  return featureItems.concat(componentItems);
}

;// CONCATENATED MODULE: ./src/parser/vehicle/threshold.js
const ACTION_THRESHOLDS = [
  {
    id: "7",
    thresholds: {
      0: 1,
      1: 10,
      2: 20,
    },
  },
  {
    id: "11",
    thresholds: {
      0: null,
      1: null,
      2: null,
    },
  },
  {
    id: "9",
    thresholds: {
      0: null,
      1: null,
      2: null,
    },
  },
  {
    id: "1",
    thresholds: {
      0: 3,
      1: 20,
      2: 40,
    },
  },
  {
    id: "2",
    thresholds: {
      0: 1,
      1: null,
      2: 2,
    },
  },
  {
    id: "3",
    thresholds: {
      0: 20,
      1: null,
      2: 40,
    },
  },
  {
    id: "8",
    thresholds: {
      0: 1,
      1: null,
      2: 1,
    },
  },
  {
    id: "4",
    thresholds: {
      0: 1,
      1: null,
      2: 2,
    },
  },
  {
    id: "5",
    thresholds: {
      0: 3,
      1: 10,
      2: 20,
    },
  },
  {
    id: "12",
    thresholds: {
      0: null,
      1: null,
      2: null,
    },
  },
  {
    id: "10",
    thresholds: {
      0: null,
      1: null,
      2: null,
    },
  },
  {
    id: "6",
    thresholds: {
      0: 3,
      1: 10,
      2: 20,
    },
  },
];

;// CONCATENATED MODULE: ./src/parser/vehicle/vehicle.js














// eslint-disable-next-line complexity
async function parseVehicle(ddb, extra = {}) {

  logger/* default.debug */.Z.debug("Parsing vehicle", { extra });
  let vehicle = duplicate(await newVehicle(ddb.name));
  const configurations = {};
  ddb.configurations.forEach((c) => {
    configurations[c.key] = c.value;
  });

  let img = ddb.largeAvatarUrl;
  // foundry doesn't support gifs
  if (img && img.match(/.gif$/)) {
    img = null;
  }
  vehicle.prototypeToken.name = ddb.name;
  vehicle.flags.monsterMunch = {
    url: ddb.url,
    img: (img) ? img : ddb.avatarUrl,
    tokenImg: ddb.avatarUrl,
  };
  vehicle.flags.ddbimporter = {
    id: ddb.id,
    version: CONFIG.DDBI.version,
    configurations,
  };

  // const removedHitPoints = ddb.removedHitPoints ? ddb.removedHitPoints : 0;
  // const temporaryHitPoints = ddb.temporaryHitPoints ? ddb.removedHitPoints : 0;

  // abilities
  vehicle.system.abilities = getAbilities(vehicle.system.abilities, ddb);

  // Conditions
  vehicle.system.traits.di = getDamageImmunities(ddb);
  vehicle.system.traits.ci = getConditionImmunities(ddb);

  // size
  const size = getSize(ddb);
  vehicle.system.traits.size = size.value;
  vehicle.prototypeToken.width = size.token.value;
  vehicle.prototypeToken.height = size.token.value;
  vehicle.prototypeToken.scale = size.token.scale;

  vehicle.system.attributes.capacity = getCapacity(ddb);

  if (configurations.ST === "dimension") {
    vehicle.system.traits.dimensions = `(${ddb.length} ft. by ${ddb.width} ft.)`;
  }
  if (configurations.ST === "weight") {
    vehicle.system.traits.dimensions = `(${ddb.weight} lb.)`;
  }

  const movement = duplicate(vehicle.system.attributes.movement);
  vehicle.system.attributes.movement = getMovement(ddb, configurations, movement);

  const primaryComponent = ddb.components.find((c) => c.isPrimaryComponent);
  // // ac
  // if we are using actor level HP apply
  if (!configurations.ECCR && primaryComponent) {
    vehicle.system.attributes.hp.value = primaryComponent.definition.hitPoints;
    vehicle.system.attributes.hp.max = primaryComponent.definition.hitPoints;
    if (!configurations.ECMT && Number.isInteger(primaryComponent.definition.mishapThreshold)) {
      vehicle.system.attributes.hp.mt = primaryComponent.definition.mishapThreshold;
    }
    if (!configurations.ECDT && Number.isInteger(primaryComponent.definition.damageThreshold)) {
      vehicle.system.attributes.hp.dt = primaryComponent.definition.damageThreshold;
    }
  }

  // if we are using actor level AC apply
  if (configurations.PCMT === "vehicle" && primaryComponent) {
    const mods = getAbilityMods(ddb);
    if (configurations.DT === "spelljammer") {
      vehicle.system.attributes.ac.motionless = primaryComponent.definition.armorClassDescription;
      vehicle.system.attributes.ac.flat = primaryComponent.definition.armorClass;
    } else {
      vehicle.system.attributes.ac.motionless = primaryComponent.definition.armorClass;
      vehicle.system.attributes.ac.flat = primaryComponent.definition.armorClass + mods["dex"];
    }
  }

  vehicle.system.vehicleType = FLIGHT_IDS.includes(ddb.id) || configurations.DT === "spelljammer"
    ? "air"
    : configurations.DT === "ship"
      ? "water"
      : "land";

  vehicle.items = processComponents(ddb, configurations);

  // No 5e support for vehicles yet:
  // fuel data

  // details
  vehicle.system.details.source = DDBHelper/* default.parseSource */.Z.parseSource(ddb);
  vehicle.system.details.biography.value = (0,DDBTemplateStrings/* parseTags */.RN)(ddb.description);

  if (configurations.EAS) {
    vehicle.system.attributes.actions.stations = true;
  }

  if (ddb.actionsText) {
    vehicle.system.details.biography.value += `<h2>Actions</h2>\n<p>${ddb.actionsText}</p>`;
    const componentActionSummaries = ddb.componentActionSummaries.map((feature) => {
      return `<h3>${feature.name}</h3>\n<p>${feature.description}</p>`;
    }).join('\n');
    vehicle.system.details.biography.value += `\n<p>${componentActionSummaries}</p>`;

    const actionsRegex = /On its turn(?:,*) the (?:.*?) can take (\d+) action/g;
    const actionsMatch = ddb.actionsText.match(actionsRegex);
    const numberOfActions = actionsMatch ? parseInt(actionsMatch[1]) : 1;

    vehicle.system.attributes.actions.value = numberOfActions;
    const actionThreshold = ACTION_THRESHOLDS.find((t) => t.id === ddb.id);
    vehicle.system.attributes.actions.thresholds = actionThreshold ? actionThreshold.thresholds : [];

  } else if (ddb.features.length > 0) {
    const featuresText = ddb.features.map((feature) => {
      return `<h3>${feature.name}</h3>\n<p>${feature.description}</p>`;
    }).join('\n');
    vehicle.system.details.biography.value += `<h2>Features</h2>\n<p>${featuresText}</p>`;
  }

  vehicle = await CompendiumHelper/* default.existingActorCheck */.Z.existingActorCheck("vehicle", vehicle);

  return vehicle;
}


async function parseVehicles(ddbData, extra = false) {

  let foundryActors = [];
  let failedVehicleNames = [];

  ddbData.forEach((vehicle) => {
    try {
      logger/* default.debug */.Z.debug(`Attempting to parse ${vehicle.name}`);
      const foundryActor = parseVehicle(vehicle, extra);
      foundryActors.push(foundryActor);
    } catch (err) {
      logger/* default.error */.Z.error(`Failed parsing ${vehicle.name}`);
      logger/* default.error */.Z.error(err);
      logger/* default.error */.Z.error(err.stack);
      failedVehicleNames.push(vehicle.name);
    }
  });

  const result = {
    actors: await Promise.all(foundryActors),
    failedVehicleNames,
  };

  return result;
}

// EXTERNAL MODULE: ./src/settings.js
var settings = __webpack_require__(6451);
// EXTERNAL MODULE: ./src/lib/DDBProxy.js
var DDBProxy = __webpack_require__(546);
;// CONCATENATED MODULE: ./src/muncher/vehicles.js








// import { createCompendiumFolderStructure } from "./compendiumFolders.js";



/**
 *
 * @returns {Promise<Array<JSON>>} A promise that resolves to an array of JSON vehicles from DDB
 */
function getVehicleData(ids) {
  const cobaltCookie = (0,Secrets/* getCobalt */.HF)();
  const betaKey = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "beta-key");
  const parsingApi = DDBProxy/* default.getProxy */.Z.getProxy();

  const campaignId = (0,Settings/* getCampaignId */.F9)();
  const body = { cobalt: cobaltCookie, campaignId: campaignId, betaKey: betaKey };

  if (ids && ids.length > 0) {
    body.ids = [...new Set(ids)];
  } else {
    const searchFilter = $("#monster-munch-filter")[0];
    const searchTerm = searchFilter?.value || "";
    const enableSources = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "munching-policy-use-source-filter");
    const sources = enableSources
      ? game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "munching-policy-muncher-sources").flat()
      : [];
    body.sources = sources;
    body.search = searchTerm;
    body.homebrew = body.sources.length > 0 ? false : game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "munching-policy-monster-homebrew");
    body.homebrewOnly = body.sources.length > 0 ? false : game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "munching-policy-monster-homebrew-only");
    body.searchTerm = encodeURIComponent(searchTerm);
    body.exactMatch = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "munching-policy-monster-exact-match");
    body.excludeLegacy = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "munching-policy-exclude-legacy");
  }

  const url = ids && ids.length > 0
    ? `${parsingApi}/proxy/vehicles/ids`
    : `${parsingApi}/proxy/vehicles`;

  const debugJson = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "debug-json");

  return new Promise((resolve, reject) => {
    fetch(url, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(body),
    })
      .then((response) => response.json())
      .then((data) => {
        if (debugJson) {
          FileHelper/* default.download */.Z.download(JSON.stringify(data), `vehicles-raw.json`, "application/json");
        }
        if (!data.success) {
          DDBMuncher/* default.munchNote */.Z.munchNote(`Failure: ${data.message}`);
          reject(data.message);
        }
        return data;
      })
      .then((data) => resolve(data.data))
      .catch((error) => reject(error));
  });
}

/**
 *
 * @param {*} ddbData json data from DDB
 * @returns array of vehicles processed to Foundry
 */
async function processVehicleData(ddbData) {
  DDBMuncher/* default.munchNote */.Z.munchNote(`Retrieved ${ddbData.length} vehicles, starting parse...`, true, false);
  logger/* default.info */.Z.info(`Retrieved ${ddbData.length} vehicles`);
  const parsedVehicles = await parseVehicles(ddbData);

  DDBMuncher/* default.munchNote */.Z.munchNote(
    `Parsed ${parsedVehicles.actors.length} vehicles, failed ${parsedVehicles.failedVehicleNames.length} vehicles`,
    false,
    true
  );
  logger/* default.info */.Z.info(`Parsed ${parsedVehicles.actors.length} vehicles, failed ${parsedVehicles.failedVehicleNames.length} vehicles`);
  if (parsedVehicles.failedVehicleNames && parsedVehicles.failedVehicleNames.length !== 0) {
    logger/* default.error */.Z.error(`Failed to parse`, parsedVehicles.failedVehicleNames);
  }
  return parsedVehicles.actors;
}


async function parseTransports(ids = null) {
  setProperty(CONFIG.DDBI, "MUNCHER.TEMPORARY", {});
  const updateBool = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "munching-policy-update-existing");
  const updateImages = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "munching-policy-update-images");
  const uploadDirectory = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "other-image-upload-directory").replace(/^\/|\/$/g, "");
  const bulkImport = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "munching-policy-monster-bulk-import");

  // to speed up file checking we pregenerate existing files now.
  logger/* default.info */.Z.info("Checking for existing files...");
  DDBMuncher/* default.munchNote */.Z.munchNote(`Checking existing image files...`);
  await FileHelper/* default.generateCurrentFiles */.Z.generateCurrentFiles(uploadDirectory);
  logger/* default.info */.Z.info("Check complete getting vehicle data...");
  DDBMuncher/* default.munchNote */.Z.munchNote(`Getting vehicle data from DDB...`);
  let vehicleJSON = await getVehicleData(ids);
  let vehicles = await processVehicleData(vehicleJSON);

  if (!updateBool || !updateImages) {
    DDBMuncher/* default.munchNote */.Z.munchNote(`Calculating which vehicles to update...`, true);
    const existingVehicles = await (0,muncher_import/* getCompendiumItems */.pI)(vehicles, "npc", { keepDDBId: true });
    const existingVehiclesTotal = existingVehicles.length + 1;
    if (!updateBool) {
      logger/* default.debug */.Z.debug("Removing existing vehicles from import list");
      logger/* default.debug */.Z.debug(`Matched ${existingVehiclesTotal}`);
      DDBMuncher/* default.munchNote */.Z.munchNote(`Removing ${existingVehiclesTotal} from update...`);
      vehicles = await (0,muncher_import/* removeItems */.Er)(vehicles, existingVehicles, true);
    }
    if (!updateImages) {
      logger/* default.debug */.Z.debug("Copying vehicle images across...");
      DDBMuncher/* default.munchNote */.Z.munchNote(`Copying images for ${existingVehiclesTotal} vehicles...`);
      vehicles = (0,importMonster/* copyExistingMonsterImages */.ph)(vehicles, existingVehicles);
    }
  }
  DDBMuncher/* default.munchNote */.Z.munchNote("");
  DDBMuncher/* default.munchNote */.Z.munchNote(`Fiddling with the SRD data...`, true);
  const finalVehicles = await (0,muncher_import/* srdFiddling */.cC)(vehicles, "vehicles");

  DDBMuncher/* default.munchNote */.Z.munchNote(`Generating Icon Map..`, true);
  await (0,importMonster/* generateIconMap */.NM)(finalVehicles);

  // Compendium folders not yet in use for Vehicles
  // const addToCompendiumFolder = game.settings.get(SETTINGS.MODULE_ID, "munching-policy-use-compendium-folders");
  // const compendiumFoldersInstalled = game.modules.get("compendium-folders")?.active;
  // if (addToCompendiumFolder && compendiumFoldersInstalled) {
  //   DDBMuncher.munchNote(`Checking compendium folders..`, true);
  //   await createCompendiumFolderStructure("vehicles");
  //   DDBMuncher.munchNote("", true);
  // }

  let vehiclesParsed = [];
  let currentVehicle = 1;
  const vehicleCount = finalVehicles.length;
  DDBMuncher/* default.munchNote */.Z.munchNote(`Preparing to wax ${vehicleCount} vehicles!`, true);
  for (const vehicle of finalVehicles) {
    if (bulkImport) {
      DDBMuncher/* default.munchNote */.Z.munchNote(`[${currentVehicle}/${vehicleCount}] Checking servicing requirements for ${vehicle.name}`, false, true);
    } else {
      DDBMuncher/* default.munchNote */.Z.munchNote(`[${currentVehicle}/${vehicleCount}] Importing ${vehicle.name}`, false, true);
    }
    logger/* default.debug */.Z.debug(`Importing/second parse of ${vehicle.name} data`);
    // eslint-disable-next-line no-await-in-loop
    const munched = await (0,importMonster/* addNPC */.Fx)(vehicle, bulkImport, "vehicle");
    vehiclesParsed.push(munched);
    currentVehicle += 1;
  }
  logger/* default.debug */.Z.debug("Vehicles Parsed", vehiclesParsed);
  if (bulkImport) {
    DDBMuncher/* default.munchNote */.Z.munchNote(`Importing ${vehiclesParsed.length} vehicles`, false, true);
    logger/* default.debug */.Z.debug(`Importing ${vehiclesParsed.length} vehicles`);
    await (0,importMonster/* addNPCsToCompendium */.qp)(vehiclesParsed, "vehicle");
  }
  DDBMuncher/* default.munchNote */.Z.munchNote("", false, true);
  setProperty(CONFIG.DDBI, "MUNCHER.TEMPORARY", {});

  if (ids !== null) {
    return Promise.all(vehiclesParsed);
  }
  return vehicleCount;
}


/***/ }),

/***/ 1269:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "Z": () => (/* binding */ DDBCharacter)
});

// EXTERNAL MODULE: ./src/dictionary.js
var dictionary = __webpack_require__(37);
// EXTERNAL MODULE: ./src/logger.js
var logger = __webpack_require__(5259);
// EXTERNAL MODULE: ./src/lib/utils.js
var utils = __webpack_require__(7669);
// EXTERNAL MODULE: ./src/lib/DDBHelper.js
var DDBHelper = __webpack_require__(1438);
// EXTERNAL MODULE: ./src/parser/features/special.js
var special = __webpack_require__(2243);
// EXTERNAL MODULE: ./src/parser/item/infusions.js
var infusions = __webpack_require__(7336);
;// CONCATENATED MODULE: ./src/parser/features/actions.js







function getProperties(ddb, feature) {

  let result = {
    mgc: false,
  };

  const kiEmpowered = ddb.character.classes
    // is a martial artist
    .some((cls) =>
      cls.classFeatures.some((feature) =>
        feature.definition.name === "Ki-Empowered Strikes"
        && cls.level >= feature.definition.requiredLevel
      ));

  if (kiEmpowered && feature.flags.ddbimporter.originalName == "Unarmed Strike") {
    result.mgc = true;
  }

  return result;

}

function getResourceFlags(character, action, flags) {
  const linkItems = game.modules.get("link-item-resource-5e")?.active;
  const resourceType = getProperty(character, "flags.ddbimporter.resources.type");
  if (resourceType !== "disable" && linkItems) {
    const hasResourceLink = getProperty(flags, "link-item-resource-5e.resource-link");
    Object.keys(character.system.resources).forEach((resource) => {
      const detail = character.system.resources[resource];
      if (action.name === detail.label) {
        setProperty(flags, "link-item-resource-5e.resource-link", resource);
        character.system.resources[resource] = { value: 0, max: 0, sr: false, lr: false, label: "" };
      } else if (hasResourceLink === resource) {
        setProperty(flags, "link-item-resource-5e.resource-link", undefined);
      }
    });
  }
  return flags;
}

function addFlagHints(ddb, character, action, feature) {
  const klassAction = ddb.character.actions.class
    .filter((ddbAction) => DDBHelper/* default.findClassByFeatureId */.Z.findClassByFeatureId(ddb, ddbAction.componentId))
    .find((ddbAction) => {
      const name = DDBHelper/* default.getName */.Z.getName(ddb, ddbAction, character);
      return name === feature.name;
    });
  const raceAction = ddb.character.actions.race
    .some((ddbAction) => {
      const name = DDBHelper/* default.getName */.Z.getName(ddb, ddbAction, character);
      return name === feature.name;
    });
  const featAction = ddb.character.actions.feat
    .some((ddbAction) => {
      const name = DDBHelper/* default.getName */.Z.getName(ddb, ddbAction, character);
      return name === feature.name;
    });

  // obsidian and klass names (used in effect enrichment)
  if (klassAction) {
    const klass = DDBHelper/* default.findClassByFeatureId */.Z.findClassByFeatureId(ddb, klassAction.componentId);
    setProperty(feature.flags, "obsidian.source.type", "class");
    setProperty(feature.flags, "ddbimporter.type", "class");
    setProperty(feature.flags, "obsidian.source.text", klass.definition.name);
    setProperty(feature.flags, "ddbimporter.class", klass.definition.name);
    const subClassName = hasProperty(klass, "subclassDefinition.name") ? klass.subclassDefinition.name : undefined;
    setProperty(feature.flags, "ddbimporter.subclass", subClassName);
  } else if (raceAction) {
    setProperty(feature.flags, "obsidian.source.type", "race");
    setProperty(feature.flags, "ddbimporter.type", "race");
  } else if (featAction) {
    setProperty(feature.flags, "obsidian.source.type", "feat");
    setProperty(feature.flags, "ddbimporter.type", "feat");
  }

  // scaling details
  let klassActionComponent = DDBHelper/* default.findComponentByComponentId */.Z.findComponentByComponentId(ddb, action.id);
  if (!klassActionComponent) klassActionComponent = DDBHelper/* default.findComponentByComponentId */.Z.findComponentByComponentId(ddb, action.componentId);
  if (klassActionComponent) {
    setProperty(feature.flags, "ddbimporter.dndbeyond.levelScale", klassActionComponent.levelScale);
    setProperty(feature.flags, "ddbimporter.dndbeyond.levelScales", klassActionComponent.definition?.levelScales);
    setProperty(feature.flags, "ddbimporter.dndbeyond.limitedUse", klassActionComponent.definition?.limitedUse);
  }

  // resource flag hints
  feature.flags = getResourceFlags(character, action, feature.flags);

  return feature;
}

// get actions from ddb.character.customActions
function getCustomActions(ddb, displayedAsAttack) {
  const customActions = ddb.character.customActions
    .filter((action) => action.displayAsAttack === displayedAsAttack)
    .map((action) => {
      action.dice = {
        diceString: action.diceCount && action.diceType ? `${action.diceCount}d${action.diceType}` : null,
        fixedValue: action.fixedValue,
      };

      const range = {
        aoeType: action.aoeType,
        aoeSize: action.aoeSize,
        range: action.range,
        long: action.longRange,
      };
      action.range = range;

      if (action.statId) action.abilityModifierStatId = action.statId;

      action.activation = {
        activationTime: action.activationTime,
        activationType: action.activationType,
      };

      return action;
    });

  return customActions;
}

function isMartialArtists(classes) {
  return classes.some((cls) => cls.classFeatures.some((feature) => feature.definition.name === "Martial Arts"));
}

const LEVEL_SCALE_EXCLUSION = [
  "Fire Rune",
  "Cloud Rune",
  "Stone Rune",
  "Frost Rune",
  "Hill Rune",
  "Storm Rune",
];

// eslint-disable-next-line complexity
function getDamage(ddb, action, feat) {
  let damage = {};
  const damageType = action.damageTypeId
    ? dictionary/* default.actions.damageType.find */.Z.actions.damageType.find((type) => type.id === action.damageTypeId).name
    : null;

  // when the action type is not set to melee or ranged we don't apply the mod to damage
  const meleeOrRangedAction = action.attackTypeRange || action.rangeId;
  const modBonus = (action.statId || action.abilityModifierStatId) && !action.isOffhand && meleeOrRangedAction ? " + @mod" : "";
  const die = action.dice ? action.dice : action.die ? action.die : undefined;
  const fixedBonus = die?.fixedValue ? ` + ${die.fixedValue}` : "";
  const globalDamageHints = game.settings.get("ddb-importer", "use-damage-hints");

  const useScale = game.settings.get("ddb-importer", "character-update-policy-use-scalevalue");
  const scaleValueLink = DDBHelper/* default.getScaleValueString */.Z.getScaleValueString(ddb, action).value;
  const excludedScale = LEVEL_SCALE_EXCLUSION.includes(feat.name);

  const useScaleValueLink = useScale && !excludedScale && scaleValueLink && scaleValueLink !== "{{scalevalue-unknown}}";

  if (die || useScaleValueLink) {
    const damageTag = (globalDamageHints && damageType) ? `[${damageType}]` : "";
    if (useScaleValueLink) {
      damage = {
        parts: [[`${scaleValueLink}${damageTag}${modBonus}${fixedBonus}`, damageType]],
        versatile: "",
      };
    } else if (die.diceString) {
      const damageString = utils/* default.parseDiceString */.Z.parseDiceString(die.diceString, modBonus, damageTag).diceString;
      damage = {
        parts: [[damageString, damageType]],
        versatile: "",
      };
    } else if (fixedBonus) {
      damage = {
        parts: [[fixedBonus + modBonus, damageType]],
        versatile: "",
      };
    }
  }

  return damage;
}

const LEVEL_SCALE_INFUSIONS = [
  "Unarmed Strike",
  "Arms of the Astral Self (WIS)",
  "Arms of the Astral Self (DEX)",
  "Arms of the Astral Self (DEX/STR)",
  "Body of the Astral Self",
  "Starry Form: Archer",
  "Sneak Attack",
];

/**
 * Some features have actions that use dice and mods that are defined on the character class feature
 * this attempts to parse out the damage dice and any ability modifier.
 * This relies on the parsing of templateStrings for the ability modifier detection.
 * @param {*} ddb
 * @param {*} character
 * @param {*} action
 * @param {*} feat
 */
function getLevelScaleDice(ddb, character, action, feat) {
  const useScale = game.settings.get("ddb-importer", "character-update-policy-use-scalevalue");
  const excludedScale = LEVEL_SCALE_EXCLUSION.includes(feat.name);

  if (useScale) return feat;
  const parts = ddb.character.classes
    .filter((cls) => cls.classFeatures.some((feature) =>
      feature.definition.id == action.componentId
      && feature.definition.entityTypeId == action.componentTypeId
      && feature.levelScale?.dice?.diceString
    ))
    .map((cls) => {
      const feature = cls.classFeatures.find((feature) =>
        feature.definition.id == action.componentId
        && feature.definition.entityTypeId == action.componentTypeId
      );
      const parsedString = character.flags.ddbimporter.dndbeyond.templateStrings.find((templateString) =>
        templateString.id == action.id
        && templateString.entityTypeId == action.entityTypeId
      );
      const die = feature.levelScale.dice ? feature.levelScale.dice : feature.levelScale.die ? feature.levelScale.die : undefined;
      const scaleValueLink = DDBHelper/* default.getScaleValueString */.Z.getScaleValueString(ddb, action).value;
      let part = useScale && !excludedScale && scaleValueLink && scaleValueLink !== "{{scalevalue-unknown}}"
        ? scaleValueLink
        : die.diceString;
      if (parsedString) {
        const modifier = parsedString.definitions.find((definition) => definition.type === "modifier");
        if (modifier) {
          feat.system.ability = modifier.subType;
          part = `${part} + @mod`;
        }
      }
      return [part, ""];
    });

  if (parts.length > 0 && useScale) {
    feat.system.damage.parts = parts;
  } else if (parts.length > 0 && !LEVEL_SCALE_INFUSIONS.includes(action.name)) {
    const combinedParts = hasProperty(feat, "data.damage.parts") && feat.system.damage.parts.length > 0
      ? feat.system.damage.parts.concat(parts)
      : parts;
    feat.system.damage = {
      parts: combinedParts,
      versatile: "",
    };
  }

  return feat;
}

function martialArtsDamage(ddb, action) {
  const damageType = dictionary/* default.actions.damageType.find */.Z.actions.damageType.find((type) => type.id === action.damageTypeId).name;
  const globalDamageHints = game.settings.get("ddb-importer", "use-damage-hints");

  let damageBonus = DDBHelper/* default.filterBaseModifiers */.Z.filterBaseModifiers(ddb, "damage", "unarmed-attacks").reduce((prev, cur) => prev + cur.value, 0);
  if (damageBonus === 0) {
    damageBonus = "";
  } else {
    damageBonus = ` + ${damageBonus}`;
  }
  const actionDie = action.dice ? action.dice : action.die ? action.die : undefined;

  // are we dealing with martial arts?
  if (isMartialArtists(ddb.character.classes)) {
    const useScale = game.settings.get("ddb-importer", "character-update-policy-use-scalevalue");

    const dies = ddb.character.classes
      .filter((cls) => isMartialArtists([cls]))
      .map((cls) => {
        const feature = cls.classFeatures.find((feature) => feature.definition.name === "Martial Arts");
        const levelScaleDie = feature?.levelScale?.dice ? feature.levelScale.dice : feature?.levelScale.die ? feature.levelScale.die : undefined;

        if (levelScaleDie?.diceString) {

          const scaleValueLink = DDBHelper/* default.getScaleValueLink */.Z.getScaleValueLink(ddb, feature);
          const scaleString = useScale && scaleValueLink && scaleValueLink !== "{{scalevalue-unknown}}"
            ? scaleValueLink
            : levelScaleDie.diceString;

          if (actionDie?.diceValue > levelScaleDie.diceValue) {
            return actionDie.diceString;
          }
          return scaleString;
        } else if (actionDie !== null && actionDie !== undefined) {
          // On some races bite is considered a martial art, damage
          // is different and on the action itself
          return actionDie.diceString;
        } else {
          return "1";
        }
      });
    const die = dies.length > 0 ? dies[0] : "";
    const damageTag = (globalDamageHints && damageType) ? `[${damageType}]` : "";
    const damageString = useScale && die.includes("@")
      ? `${die}${damageTag}${damageBonus} + @mod`
      : utils/* default.parseDiceString */.Z.parseDiceString(die, `${damageBonus} + @mod`, damageTag).diceString;

    // set the weapon damage
    return {
      parts: [[damageString, damageType]],
      versatile: "",
    };
  } else if (actionDie !== null && actionDie !== undefined) {
    // The Lizardfolk jaws have a different base damage, its' detailed in
    // dice so lets capture that for actions if it exists
    const damageTag = (globalDamageHints && damageType) ? `[${damageType}]` : "";
    const damageString = utils/* default.parseDiceString */.Z.parseDiceString(actionDie.diceString, `${damageBonus} + @mod`, damageTag).diceString;
    return {
      parts: [[damageString, damageType]],
      versatile: "",
    };
  } else {
    // default to basics
    return {
      parts: [[`1${damageBonus} + @mod`, damageType]],
      versatile: "",
    };
  }
}

function getLimitedUse(action, character) {
  if (
    action.limitedUse
    && (action.limitedUse.maxUses || action.limitedUse.statModifierUsesId || action.limitedUse.useProficiencyBonus)
  ) {
    const resetType = dictionary/* default.resets.find */.Z.resets.find((type) => type.id === action.limitedUse.resetType);
    let maxUses = (action.limitedUse.maxUses && action.limitedUse.maxUses !== -1) ? action.limitedUse.maxUses : 0;

    if (action.limitedUse.statModifierUsesId) {
      const ability = dictionary/* default.character.abilities.find */.Z.character.abilities.find(
        (ability) => ability.id === action.limitedUse.statModifierUsesId
      ).value;

      switch (action.limitedUse.operator) {
        case 2: {
          maxUses *= character.flags.ddbimporter.dndbeyond.effectAbilities[ability].mod;
          break;
        }
        case 1:
        default:
          maxUses += character.flags.ddbimporter.dndbeyond.effectAbilities[ability].mod;
      }
    }

    if (action.limitedUse.useProficiencyBonus) {
      switch (action.limitedUse.proficiencyBonusOperator) {
        case 2: {
          maxUses *= character.system.attributes.prof;
          break;
        }
        case 1:
        default:
          maxUses += character.system.attributes.prof;
      }
    }

    const finalMaxUses = (maxUses) ? parseInt(maxUses) : null;

    return {
      value: (finalMaxUses !== null && finalMaxUses != 0) ? maxUses - action.limitedUse.numberUsed : null,
      max: (finalMaxUses != 0) ? finalMaxUses : null,
      per: resetType ? resetType.value : "",
    };
  } else {
    return {
      value: null,
      max: null,
      per: "",
    };
  }
}

function getActivation(action) {
  if (action.activation) {
    const actionType = dictionary/* default.actions.activationTypes.find */.Z.actions.activationTypes.find((type) => type.id === action.activation.activationType);
    const activation = !actionType
      ? {}
      : {
        type: actionType.value,
        cost: action.activation.activationTime || 1,
        condition: "",
      };
    return activation;
  }
  return {};
}

function getResource(character, action) {
  let consume = {
    "type": "",
    "target": "",
    "amount": null
  };

  Object.keys(character.system.resources).forEach((resource) => {
    const detail = character.system.resources[resource];
    if (action.name === detail.label) {
      consume = {
        type: "attribute",
        target: `resources.${resource}.value`,
        amount: 1,
      };
    }
  });

  return consume;
}

function getWeaponType(action) {
  const entry = dictionary/* default.actions.attackTypes.find */.Z.actions.attackTypes.find((type) => type.attackSubtype === action.attackSubtype);
  const range = dictionary/* default.weapon.weaponRange.find */.Z.weapon.weaponRange.find((type) => type.attackType === action.attackTypeRange);
  return entry ? entry.value : range ? `simple${range.value}` : "simpleM";
}

function calculateRange(action, weapon) {
  if (action.range && action.range.aoeType && action.range.aoeSize) {
    weapon.system.range = { value: null, units: "self", long: "" };
    weapon.system.target = {
      value: action.range.aoeSize,
      type: dictionary/* default.actions.aoeType.find */.Z.actions.aoeType.find((type) => type.id === action.range.aoeType)?.value,
      units: "ft",
    };
  } else if (action.range && action.range.range) {
    weapon.system.range = {
      value: action.range.range,
      units: "ft",
      long: action.range.long || "",
    };
  } else {
    weapon.system.range = { value: 5, units: "ft", long: "" };
  }
  return weapon;
}

function calculateSaveAttack(ddb, action, weapon) {
  weapon.system.actionType = "save";
  weapon.system.damage = getDamage(ddb, action, weapon);

  const fixedDC = (action.fixedSaveDc) ? action.fixedSaveDc : null;
  const scaling = (fixedDC) ? fixedDC : (action.abilityModifierStatId) ? dictionary/* default.character.abilities.find */.Z.character.abilities.find((stat) => stat.id === action.abilityModifierStatId).value : "spell";

  const saveAbility = (action.saveStatId)
    ? dictionary/* default.character.abilities.find */.Z.character.abilities.find((stat) => stat.id === action.saveStatId).value
    : "";

  weapon.system.save = {
    ability: saveAbility,
    dc: fixedDC,
    scaling: scaling,
  };
  if (action.abilityModifierStatId) {
    weapon.system.ability = dictionary/* default.character.abilities.find */.Z.character.abilities.find((stat) => stat.id === action.abilityModifierStatId).value;
  }
  return weapon;
}


function calculateActionAttackAbilities(ddb, character, action, weapon) {
  let defaultAbility;

  if (action.abilityModifierStatId && !([1, 2].includes(action.abilityModifierStatId) && action.isMartialArts)) {
    defaultAbility = dictionary/* default.character.abilities.find */.Z.character.abilities.find(
      (stat) => stat.id === action.abilityModifierStatId
    ).value;
    weapon.system.ability = defaultAbility;
  } else if (action.isMartialArts) {
    weapon.system.ability
      = action.isMartialArts && isMartialArtists(ddb.character.classes)
        ? character.flags.ddbimporter.dndbeyond.effectAbilities.dex.value >= character.flags.ddbimporter.dndbeyond.effectAbilities.str.value
          ? "dex"
          : "str"
        : "str";
  } else {
    weapon.system.ability = "";
  }
  if (action.isMartialArts) {
    weapon.system.damage = martialArtsDamage(ddb, action);
    weapon.system.attackBonus = DDBHelper/* default.filterBaseModifiers */.Z.filterBaseModifiers(ddb, "bonus", "unarmed-attacks").reduce((prev, cur) => prev + cur.value, 0);
  } else {
    weapon.system.damage = getDamage(ddb, action, weapon);
  }
  return weapon;
}

function getAttackType(ddb, character, action, weapon) {
  // lets see if we have a save stat for things like Dragon born Breath Weapon
  if (typeof action.saveStatId === "number") {
    weapon = calculateSaveAttack(ddb, action, weapon);
  } else if (action.actionType === 1) {
    if (action.attackTypeRange === 2) {
      weapon.system.actionType = "rwak";
    } else {
      weapon.system.actionType = "mwak";
    }
    weapon = calculateActionAttackAbilities(ddb, character, action, weapon);
  } else {
    if (action.rangeId && action.rangeId === 1) {
      weapon.system.actionType = "mwak";
    } else if (action.rangeId && action.rangeId === 2) {
      weapon.system.actionType = "rwak";
    } else {
      weapon.system.actionType = "other";
    }
    weapon = calculateActionAttackAbilities(ddb, character, action, weapon);
  }
  return weapon;
}

const excludedActionFeatures = ["Unarmed Strike"];

function getAttackAction(ddb, character, action) {
  const actionType = game.settings.get("ddb-importer", "character-update-policy-use-actions-as-features") && !excludedActionFeatures.includes(action.name)
    ? "feat"
    : "weapon";
  let feature = {
    name: DDBHelper/* default.getName */.Z.getName(ddb, action, character),
    type: actionType,
    system: JSON.parse(utils/* default.getTemplate */.Z.getTemplate(actionType)),
    flags: {
      ddbimporter: {
        id: action.id,
        entityTypeId: action.entityTypeId,
        action: true,
        componentId: action.componentId,
        componentTypeId: action.componentTypeId,
        originalName: DDBHelper/* default.getName */.Z.getName(ddb, action, character, false),
        type: "other",
      },
      infusions: { infused: false },
      obsidian: {
        source: {
          type: "other",
        },
      },
    },
  };
  logger/* default.debug */.Z.debug(`Parsing action: ${feature.name} as ${actionType}`);
  if (action.infusionFlags) {
    setProperty(feature, "flags.infusions", action.infusionFlags);
  }

  try {
    if (action.isMartialArts) {
      feature.flags.ddbimporter.dndbeyond = {
        type: "Martial Arts",
      };
    }

    feature.system.proficient = action.isProficient ? 1 : 0;
    feature.system.description = (0,special/* getDescription */.Eb)(ddb, character, action);
    feature.system.equipped = true;
    feature.system.rarity = "";
    feature.system.identified = true;
    feature.system.activation = getActivation(action);
    feature = calculateRange(action, feature);
    feature = getAttackType(ddb, character, action, feature);
    feature.system.weaponType = getWeaponType(action);
    feature.system.uses = getLimitedUse(action, character);
    feature.system.consume = getResource(character, action);
    feature.system.properties = getProperties(ddb, feature);

    feature = addFlagHints(ddb, character, action, feature);
    feature = (0,special/* addFeatEffects */.YL)(ddb, character, action, feature);
    feature = getLevelScaleDice(ddb, character, action, feature);

    feature = DDBHelper/* default.addCustomValues */.Z.addCustomValues(ddb, feature);

  } catch (err) {
    logger/* default.warn */.Z.warn(
      `Unable to Import Attack Action: ${action.name}, please log a bug report. Err: ${err.message}`,
      "extension"
    );
  }

  return feature;
}

/**
 * Everyone has an Unarmed Strike
 * @param {*} ddb
 */
function getUnarmedStrike(ddb, character) {
  const unarmedStrikeMock = {
    limitedUse: null,
    name: "Unarmed Strike",
    description: null,
    snippet:
      "Instead of using a weapon to make a melee weapon attack, you can use an unarmed strike: a punch, kick, head-butt, or similar forceful blow (none of which count as weapons). On a hit, an unarmed strike deals bludgeoning damage equal to 1 + your Strength modifier. You are proficient with your unarmed strikes.",
    abilityModifierStatId: null,
    attackTypeRange: 1,
    actionType: 1,
    attackSubtype: 3,
    dice: null,
    value: 1,
    damageTypeId: 1,
    isMartialArts: true,
    isProficient: true,
    displayAsAttack: true,
    range: {
      range: null,
      longRange: null,
      aoeType: null,
      aoeSize: null,
      hasAoeSpecialDescription: false,
    },
    activation: {
      activationTime: 1,
      activationType: 1,
    },
    id: "unarmedStrike",
  };
  const unarmedStrike = getAttackAction(ddb, character, unarmedStrikeMock);
  return unarmedStrike;
}

/**
 * Try and parse attack actions - this will at the moment only really support basic melee attacks
 * @param {*} ddb
 * @param {*} character
 */
function getAttackActions(ddb, character) {
  const attackActions = [
    // do class options here have a class id, needed for optional class features
    ddb.character.actions.class.filter((action) => DDBHelper/* default.findClassByFeatureId */.Z.findClassByFeatureId(ddb, action.componentId)),
    ddb.character.actions.race,
    ddb.character.actions.feat,
    getCustomActions(ddb, true),
    (0,infusions/* getInfusionActionData */.R)(ddb),
  ]
    .flat()
    .filter((action) => DDBHelper/* default.displayAsAttack */.Z.displayAsAttack(ddb, action, character))
    .map((action) => {
      return getAttackAction(ddb, character, action);
    });
  logger/* default.debug */.Z.debug("attack actions", attackActions);
  return attackActions;
}

function actionFilter(action, parsedActions) {
  const attacksAsFeatures = game.settings.get("ddb-importer", "character-update-policy-use-actions-as-features");
  const exists = parsedActions.some((attack) => attack.name === action.name);
  // console.warn("action filter", {actionName: action.name, parsedActions, attacksAsFeatures, exists, total: attacksAsFeatures && exists});

  return attacksAsFeatures && exists;
}

/**
 * Lets Parse remaining actions
 * @param {*} ddb
 * @param {*} parsedActions
 */
function getOtherActions(ddb, character, parsedActions) {
  const otherActions = [
    // do class options here have a class id, needed for optional class features
    ddb.character.actions.class.filter((action) => DDBHelper/* default.findClassByFeatureId */.Z.findClassByFeatureId(ddb, action.componentId)),
    ddb.character.actions.race,
    ddb.character.actions.feat,
    getCustomActions(ddb, false),
    (0,infusions/* getInfusionActionData */.R)(ddb),
  ]
    .flat()
    .filter((action) => action.name && action.name !== "")
    .filter(
      (action) =>
        // lets grab other actions and add, make sure we don't get attack based ones that haven't parsed
        (!DDBHelper/* default.displayAsAttack */.Z.displayAsAttack(ddb, action, character) && !actionFilter(action, parsedActions))
        || (DDBHelper/* default.displayAsAttack */.Z.displayAsAttack(ddb, action, character) && !parsedActions.some((attack) => attack.name === DDBHelper/* default.getName */.Z.getName(ddb, action, character)))
    )
    .map((action) => {
      logger/* default.debug */.Z.debug(`Getting Other Action ${action.name}`);
      let feature = {
        name: DDBHelper/* default.getName */.Z.getName(ddb, action, character),
        type: "feat",
        system: JSON.parse(utils/* default.getTemplate */.Z.getTemplate("feat")),
        flags: {
          ddbimporter: {
            id: action.id,
            entityTypeId: action.entityTypeId,
            componentId: action.componentId,
            componentTypeId: action.componentTypeId,
            type: "other",
          },
          infusions: { infused: false },
          obsidian: {
            source: {
              type: "other",
            },
          }
        },
      };
      if (action.infusionFlags) {
        setProperty(feature, "flags.infusions", action.infusionFlags);
      }
      feature.system.activation = getActivation(action);
      feature.system.description = (0,special/* getDescription */.Eb)(ddb, character, action);
      feature.system.uses = getLimitedUse(action, character);
      feature.system.consume = getResource(character, action);

      feature = calculateRange(action, feature);
      feature = getAttackType(ddb, character, action, feature);

      if (!feature.system.damage?.parts) {
        logger/* default.debug */.Z.debug("Running level scale parser");
        feature = getLevelScaleDice(ddb, character, action, feature);
      }

      feature = addFlagHints(ddb, character, action, feature);
      feature = (0,special/* addFeatEffects */.YL)(ddb, character, action, feature);

      feature = DDBHelper/* default.addCustomValues */.Z.addCustomValues(ddb, feature);

      return feature;
    });

  logger/* default.debug */.Z.debug("other actions", otherActions);
  return otherActions;
}

async function parseActions(ddb, character) {
  let actions = [
    // Get Attack Actions that we know about, typically natural attacks etc
    ...getAttackActions(ddb, character),
  ];
  // Everyone has an Unarmed Strike, but some choose not to use it - DDB option now always set to false
  // if (ddb.character.preferences.showUnarmedStrike) actions.push(getUnarmedStrike(ddb, character));
  actions.push(getUnarmedStrike(ddb, character));
  actions = [
    ...actions,
    // Try and parse other relevant actions
    ...getOtherActions(ddb, character, actions),
  ];

  // sort alphabetically, then by action type
  actions.sort().sort((a, b) => {
    if (!a.system.activation.activationType) {
      return 1;
    } else if (!b.system.activation.activationType) {
      return -1;
    } else {
      const aActionTypeID = dictionary/* default.actions.activationTypes.find */.Z.actions.activationTypes.find(
        (type) => type.value === a.system.activation.activationType
      ).id;
      const bActionTypeID = dictionary/* default.actions.activationTypes.find */.Z.actions.activationTypes.find(
        (type) => type.value === b.system.activation.activationType
      ).id;
      if (aActionTypeID > bActionTypeID) {
        return 1;
      } else if (aActionTypeID < bActionTypeID) {
        return -1;
      } else {
        return 0;
      }
    }
  });

  (0,special/* fixFeatures */.tC)(actions);
  const results = await (0,special/* addExtraEffects */.fg)(ddb, actions, character);
  return results;
}

// EXTERNAL MODULE: ./src/parser/classes/index.js + 1 modules
var classes = __webpack_require__(6103);
// EXTERNAL MODULE: ./src/parser/spells/metadata.js
var metadata = __webpack_require__(6721);
// EXTERNAL MODULE: ./src/parser/spells/special.js
var spells_special = __webpack_require__(1838);
// EXTERNAL MODULE: ./src/parser/spells/parseSpell.js + 12 modules
var parseSpell = __webpack_require__(1702);
// EXTERNAL MODULE: ./src/parser/spells/ability.js
var ability = __webpack_require__(2352);
;// CONCATENATED MODULE: ./src/parser/spells/CharacterSpellFactory.js
/* eslint-disable no-continue */



// Import parsing functions






class CharacterSpellFactory {

  constructor(ddb, character) {
    this.ddb = ddb;
    this.character = character;

    this.items = [];

    this.proficiencyModifier = character.system.attributes.prof;
    this.lookups = (0,metadata/* getLookups */.t)(ddb.character);

    logger/* default.debug */.Z.debug("Character spell lookups", this.lookups);
    this.characterAbilities = character.flags.ddbimporter.dndbeyond.effectAbilities;

    this.healingBoost = DDBHelper/* default.filterBaseModifiers */.Z.filterBaseModifiers(ddb, "bonus", "spell-group-healing").reduce((a, b) => a + b.value, 0);

  }

  async getClassSpells() {
    for (const playerClass of this.ddb.character.classSpells) {
      const classInfo = this.ddb.character.classes.find((cls) => cls.id === playerClass.characterClassId);
      const spellCastingAbility = (0,ability/* getSpellCastingAbility */.sX)(classInfo);
      const abilityModifier = utils/* default.calculateModifier */.Z.calculateModifier(this.characterAbilities[spellCastingAbility].value);

      logger/* default.debug */.Z.debug("Spell parsing, class info", classInfo);

      const cantripBoost
        = DDBHelper/* default.getChosenClassModifiers */.Z.getChosenClassModifiers(this.ddb).filter(
          (mod) =>
            mod.type === "bonus"
            && mod.subType === `${classInfo.definition.name.toLowerCase()}-cantrip-damage`
            && (mod.restriction === null || mod.restriction === "")
        ).length > 0;

      // parse spells chosen as spellcasting (playerClass.spells)
      for (const spell of playerClass.spells) {
        if (!spell.definition) continue;
        // add some data for the parsing of the spells into the data structure
        spell.flags = {
          ddbimporter: {
            dndbeyond: {
              lookup: "classSpell",
              class: classInfo.definition.name,
              level: classInfo.level,
              characterClassId: playerClass.characterClassId,
              spellLevel: spell.definition.level,
              // spellSlots: character.system.spells,
              ability: spellCastingAbility,
              mod: abilityModifier,
              dc: 8 + this.proficiencyModifier + abilityModifier,
              cantripBoost: cantripBoost,
              overrideDC: false,
              id: spell.id,
              entityTypeId: spell.entityTypeId,
              healingBoost: this.healingBoost,
              usesSpellSlot: spell.usesSpellSlot,
            },
          },
          "spell-class-filter-for-5e": {
            parentClass: classInfo.definition.name.toLowerCase(),
          },
          // "spellbook-assistant-manager": {
          //   class: classInfo.definition.name.toLowerCase(),
          // }
        };

        // Check for duplicate spells, normally domain ones
        // We will import spells from a different class that are the same though
        // as they may come from with different spell casting mods
        // eslint-disable-next-line no-await-in-loop
        const parsedSpell = await (0,parseSpell/* parseSpell */.T)(spell, this.character);
        const duplicateSpell = this.items.findIndex(
          (existingSpell) => {
            const existingName = (existingSpell.flags.ddbimporter.originalName ? existingSpell.flags.ddbimporter.originalName : existingSpell.name);
            const parsedName = (parsedSpell.flags.ddbimporter.originalName ? parsedSpell.flags.ddbimporter.originalName : parsedSpell.name);
            // some spells come from different classes but end up having the same ddb id
            const classIdMatch = (classInfo.definition.name === existingSpell.flags.ddbimporter.dndbeyond.class || spell.id === existingSpell.flags.ddbimporter.dndbeyond.id);
            return existingName === parsedName && classIdMatch;
          });
        const duplicateItem = this.items[duplicateSpell];
        if (!duplicateItem) {
          this.items.push(parsedSpell);
        } else if (spell.alwaysPrepared || parsedSpell.system.preparation.mode === "always"
          || (spell.alwaysPrepared === duplicateItem.alwaysPrepared && parsedSpell.system.preparation.mode === duplicateItem.system.preparation.mode && parsedSpell.prepared && !duplicateItem.prepared)) {
          // if our new spell is always known we overwrite!
          // it's probably domain
          this.items[duplicateSpell] = parsedSpell;
        } else {
          // we'll emit a console message if it doesn't match this case for future debugging
          logger/* default.info */.Z.info(`Duplicate Spell ${spell.definition.name} detected in class ${classInfo.definition.name}.`);
        }
      }
    }

  }

  async getSpecialClassSpells() {
    for (const spell of this.ddb.character.spells.class) {
      if (!spell.definition) continue;
      // If the spell has an ability attached, use that
      let spellCastingAbility = undefined;
      const featureId = DDBHelper/* default.determineActualFeatureId */.Z.determineActualFeatureId(this.ddb, spell.componentId);
      const classInfo = this.lookups.classFeature.find((clsFeature) => clsFeature.id == featureId);

      logger/* default.debug */.Z.debug("Class spell parsing, class info", classInfo);
      // Sometimes there are spells here which don't have an class Info
      // this seems to be part of the optional tasha's rules, lets not parse for now
      // as ddb implementation is not yet finished
      // / options.class.[].definition.id
      if (!classInfo) {
        logger/* default.warn */.Z.warn(`Unable to add ${spell.definition.name}`);
      }
      if (!classInfo) continue;
      let klass = DDBHelper/* default.getClassFromOptionID */.Z.getClassFromOptionID(this.ddb, spell.componentId);

      if (!klass) klass = DDBHelper/* default.findClassByFeatureId */.Z.findClassByFeatureId(this.ddb, spell.componentId);

      logger/* default.debug */.Z.debug("Class spell, class found?", klass);

      if ((0,ability/* hasSpellCastingAbility */.eO)(spell.spellCastingAbilityId)) {
        spellCastingAbility = (0,ability/* convertSpellCastingAbilityId */.f5)(spell.spellCastingAbilityId);
      } else if (klass) {
        spellCastingAbility = (0,ability/* getSpellCastingAbility */.sX)(klass);
        // force these spells to always be prepared
        spell.alwaysPrepared = true;
      } else {
        // if there is no ability on spell, we default to wis
        spellCastingAbility = "wis";
      }

      const abilityModifier = utils/* default.calculateModifier */.Z.calculateModifier(this.characterAbilities[spellCastingAbility].value);

      // add some data for the parsing of the spells into the data structure
      spell.flags = {
        ddbimporter: {
          dndbeyond: {
            class: (klass) ? klass.definition.name : undefined,
            lookup: "classFeature",
            lookupName: classInfo.name,
            lookupId: classInfo.id,
            level: this.character.flags.ddbimporter.dndbeyond.totalLevels,
            ability: spellCastingAbility,
            mod: abilityModifier,
            dc: 8 + this.proficiencyModifier + abilityModifier,
            overrideDC: false,
            id: spell.id,
            entityTypeId: spell.entityTypeId,
            healingBoost: this.healingBoost,
            usesSpellSlot: spell.usesSpellSlot,
          },
        },
      };

      // Check for duplicate spells, normally domain ones
      // We will import spells from a different class that are the same though
      // as they may come from with different spell casting mods
      const duplicateSpell = this.items.findIndex(
        (existingSpell) =>
          (existingSpell.flags.ddbimporter.originalName ? existingSpell.flags.ddbimporter.originalName : existingSpell.name) === spell.definition.name
          && klass
          && klass.definition.name === existingSpell.flags.ddbimporter.dndbeyond.class
          && spell.usesSpellSlot && existingSpell.flags.ddbimporter.dndbeyond.usesSpellSlot
      );
      if (!this.items[duplicateSpell]) {
        // eslint-disable-next-line no-await-in-loop
        const parsedSpell = await (0,parseSpell/* parseSpell */.T)(spell, this.character);
        this.items.push(parsedSpell);
      } else if (spell.alwaysPrepared) {
        // if our new spell is always known we overwrite!
        // it's probably domain
        // eslint-disable-next-line no-await-in-loop
        const parsedSpell = await (0,parseSpell/* parseSpell */.T)(spell, this.character);
        this.items[duplicateSpell] = parsedSpell;
      } else {
        // we'll emit a console message if it doesn't match this case for future debugging
        logger/* default.info */.Z.info(`Duplicate Spell ${spell.definition.name} detected in class ${classInfo.name}.`);
      }
    }
  }

  async getRaceSpells() {
    for (const spell of this.ddb.character.spells.race) {
      if (!spell.definition)
        continue;
      // for race spells the spell spellCastingAbilityId is on the spell
      // if there is no ability on spell, we default to wis
      let spellCastingAbility = "wis";
      if ((0,ability/* hasSpellCastingAbility */.eO)(spell.spellCastingAbilityId)) {
        spellCastingAbility = (0,ability/* convertSpellCastingAbilityId */.f5)(spell.spellCastingAbilityId);
      }

      const abilityModifier = utils/* default.calculateModifier */.Z.calculateModifier(this.characterAbilities[spellCastingAbility].value);

      let raceInfo = this.lookups.race.find((rc) => rc.id === spell.componentId);

      if (!raceInfo) {
        // for some reason we haven't matched the race option id with the spell
        // this happens with at least the SCAG optional spells casting half elf
        raceInfo = {
          name: "Racial spell",
          id: spell.componentId,
        };
      }

      // add some data for the parsing of the spells into the data structure
      spell.flags = {
        ddbimporter: {
          dndbeyond: {
            lookup: "race",
            lookupName: raceInfo.name,
            lookupId: raceInfo.id,
            race: this.ddb.character.race.fullName,
            level: spell.castAtLevel,
            ability: spellCastingAbility,
            mod: abilityModifier,
            dc: 8 + this.proficiencyModifier + abilityModifier,
            overrideDC: false,
            id: spell.id,
            entityTypeId: spell.entityTypeId,
            healingBoost: this.healingBoost,
            usesSpellSlot: spell.usesSpellSlot,
          },
        },
      };

      if (spell.alwaysPrepared && spell.limitedUse) {
        const dups = this.ddb.character.spells.race.filter((otherSpell) => otherSpell.definition.name === spell.definition.name).length > 1;
        const duplicateSpell = this.items.findIndex(
          (existingSpell) =>
            (existingSpell.flags.ddbimporter.originalName ? existingSpell.flags.ddbimporter.originalName : existingSpell.name) === spell.definition.name
            && existingSpell.flags.ddbimporter.dndbeyond.usesSpellSlot
        );
        if (!dups && !this.items[duplicateSpell]) {
          // also parse spell as non-limited use
          let unlimitedSpell = duplicate(spell);
          unlimitedSpell.limitedUse = null;
          unlimitedSpell.usesSpellSlot = true;
          unlimitedSpell.flags.ddbimporter.dndbeyond.usesSpellSlot = true;
          unlimitedSpell.flags.ddbimporter.dndbeyond.granted = true;
          unlimitedSpell.flags.ddbimporter.dndbeyond.lookup = "race";
          delete unlimitedSpell.id;
          delete unlimitedSpell.flags.ddbimporter.dndbeyond.id;
          // eslint-disable-next-line no-await-in-loop
          const parsedSpell = await (0,parseSpell/* parseSpell */.T)(spell, this.character);
          this.items.push(parsedSpell);
        }
      }

      // eslint-disable-next-line no-await-in-loop
      const parsedSpell = await (0,parseSpell/* parseSpell */.T)(spell, this.character);
      this.items.push(parsedSpell);
    }
  }

  async getFeatSpells() {
    for (const spell of this.ddb.character.spells.feat) {
      if (!spell.definition)
        continue;
      // If the spell has an ability attached, use that
      // if there is no ability on spell, we default to wis
      let spellCastingAbility = "wis";
      if ((0,ability/* hasSpellCastingAbility */.eO)(spell.spellCastingAbilityId)) {
        spellCastingAbility = (0,ability/* convertSpellCastingAbilityId */.f5)(spell.spellCastingAbilityId);
      }

      const abilityModifier = utils/* default.calculateModifier */.Z.calculateModifier(this.characterAbilities[spellCastingAbility].value);

      let featInfo = this.lookups.feat.find((ft) => ft.id === spell.componentId);

      if (!featInfo) {
        // for some reason we haven't matched the feat option id with the spell
        // we fiddle the result
        featInfo = {
          name: "Feat option spell",
          id: spell.componentId,
        };
      }

      // add some data for the parsing of the spells into the data structure
      spell.flags = {
        ddbimporter: {
          dndbeyond: {
            lookup: "feat",
            lookupName: featInfo.name,
            lookupId: featInfo.id,
            level: spell.castAtLevel,
            ability: spellCastingAbility,
            mod: abilityModifier,
            dc: 8 + this.proficiencyModifier + abilityModifier,
            overrideDC: false,
            id: spell.id,
            entityTypeId: spell.entityTypeId,
            healingBoost: this.healingBoost,
            usesSpellSlot: spell.usesSpellSlot,
          },
        },
      };

      // if (spell.alwaysPrepared && spell.limitedUse) {
      //   const dups = this.ddb.character.spells.feat.filter((otherSpell) => otherSpell.definition.name === spell.definition.name).length > 1;
      //   const duplicateSpell = this.items.findIndex(
      //     (existingSpell) =>
      //       (existingSpell.flags.ddbimporter.originalName ? existingSpell.flags.ddbimporter.originalName : existingSpell.name) === spell.definition.name
      //       && existingSpell.flags.ddbimporter.dndbeyond.usesSpellSlot
      //   );
      //   if (!dups && !this.items[duplicateSpell]) {
      //     // also parse spell as non-limited use
      //     let unlimitedSpell = duplicate(spell);
      //     unlimitedSpell.limitedUse = null;
      //     unlimitedSpell.usesSpellSlot = true;
      //     unlimitedSpell.flags.ddbimporter.dndbeyond.usesSpellSlot = true;
      //     unlimitedSpell.flags.ddbimporter.dndbeyond.lookup = "feat";
      //     unlimitedSpell.flags.ddbimporter.dndbeyond.granted = true;
      //     delete unlimitedSpell.id;
      //     delete unlimitedSpell.flags.ddbimporter.dndbeyond.id;
      //     // eslint-disable-next-line no-await-in-loop
      //     const parsedSpell = await parseSpell(spell, this.character);
      //     this.items.push(parsedSpell);
      //   }
      // }

      // eslint-disable-next-line no-await-in-loop
      const parsedSpell = await (0,parseSpell/* parseSpell */.T)(spell, this.character);
      this.items.push(parsedSpell);
    }
  }

  async getBackgroundSpells() {
    if (!this.ddb.character.spells.background) this.ddb.character.spells.background = [];
    for (const spell of this.ddb.character.spells.background) {
      if (!spell.definition)
        continue;
      // If the spell has an ability attached, use that
      // if there is no ability on spell, we default to wis
      let spellCastingAbility = "wis";
      if ((0,ability/* hasSpellCastingAbility */.eO)(spell.spellCastingAbilityId)) {
        spellCastingAbility = (0,ability/* convertSpellCastingAbilityId */.f5)(spell.spellCastingAbilityId);
      }

      const abilityModifier = utils/* default.calculateModifier */.Z.calculateModifier(this.characterAbilities[spellCastingAbility].value);

      // add some data for the parsing of the spells into the data structure
      spell.flags = {
        ddbimporter: {
          dndbeyond: {
            lookup: "background",
            lookupName: "Background",
            level: spell.castAtLevel,
            ability: spellCastingAbility,
            mod: abilityModifier,
            dc: 8 + this.proficiencyModifier + abilityModifier,
            overrideDC: false,
            id: spell.id,
            entityTypeId: spell.entityTypeId,
            healingBoost: this.healingBoost,
            usesSpellSlot: spell.usesSpellSlot,
          },
        },
      };

      if (spell.alwaysPrepared && spell.limitedUse) {
        const dups = this.ddb.character.spells.background.filter((otherSpell) => otherSpell.definition.name === spell.definition.name).length > 1;
        const duplicateSpell = this.items.findIndex(
          (existingSpell) =>
            (existingSpell.flags.ddbimporter.originalName ? existingSpell.flags.ddbimporter.originalName : existingSpell.name) === spell.definition.name
            && existingSpell.flags.ddbimporter.dndbeyond.usesSpellSlot
        );
        if (!dups && !this.items[duplicateSpell]) {
          // also parse spell as non-limited use
          let unlimitedSpell = duplicate(spell);
          unlimitedSpell.limitedUse = null;
          unlimitedSpell.usesSpellSlot = true;
          unlimitedSpell.flags.ddbimporter.dndbeyond.usesSpellSlot = true;
          unlimitedSpell.flags.ddbimporter.dndbeyond.lookup = "background";
          unlimitedSpell.flags.ddbimporter.dndbeyond.granted = true;
          delete unlimitedSpell.id;
          delete unlimitedSpell.flags.ddbimporter.dndbeyond.id;
          // eslint-disable-next-line no-await-in-loop
          const parsedSpell = await (0,parseSpell/* parseSpell */.T)(spell, this.character);
          this.items.push(parsedSpell);
        }
      }

      // eslint-disable-next-line no-await-in-loop
      const parsedSpell = await (0,parseSpell/* parseSpell */.T)(spell, this.character);
      this.items.push(parsedSpell);
    }
  }

  async getCharacterSpells() {
    // each class has an entry here, each entry has spells
    // we loop through each class and process
    await this.getClassSpells();

    // Parse any spells granted by class features, such as Barbarian Totem
    await this.getSpecialClassSpells();

    // Race spells are handled slightly differently
    await this.getRaceSpells();

    // feat spells are handled slightly differently
    await this.getFeatSpells();

    // background spells are handled slightly differently
    await this.getBackgroundSpells();

    (0,spells_special/* fixSpells */.F)(this.ddb, this.items);

    return this.items.sort((a, b) => a.name.localeCompare(b.name));
  }
}

// EXTERNAL MODULE: ./src/effects/macros.js
var macros = __webpack_require__(3752);
// EXTERNAL MODULE: ./src/lib/FileHelper.js
var FileHelper = __webpack_require__(2397);
// EXTERNAL MODULE: ./src/lib/Secrets.js
var Secrets = __webpack_require__(2048);
// EXTERNAL MODULE: ./src/lib/Settings.js
var Settings = __webpack_require__(5406);
// EXTERNAL MODULE: ./src/lib/DDBTemplateStrings.js
var DDBTemplateStrings = __webpack_require__(258);
// EXTERNAL MODULE: ./src/lib/DDBProxy.js
var DDBProxy = __webpack_require__(546);
// EXTERNAL MODULE: ./src/settings.js
var settings = __webpack_require__(6451);
;// CONCATENATED MODULE: ./src/parser/DDBCharacter.js













class DDBCharacter {
  constructor({ currentActor = null, characterId = null, resourceSelection = true, enableCompanions = false } = {}) {
    // the actor the data will be imported into/currently exists
    this.currentActor = currentActor;
    this.currentActorId = currentActor?.id;
    // DDBCharacter ID
    this.characterId = characterId;
    // show resource selection prompt?
    this.resourceSelection = resourceSelection;
    // raw data received from DDB
    this.source = null;
    // this is the raw items processed before filtering
    this.raw = {};
    // the data to act on following initial parse
    this.data = {};

    // Character data
    this.abilities = {
      overrides: {},
      core: {},
      withEffects: {},
    };
    this.spellSlots = {};
    this.totalLevels = 0;
    this.companionFactories = [];
    this.enableCompanions = enableCompanions;
  }

  /**
   * Retrieves the character ID from a given URL, which can be one of the following:
   * - regular character sheet
   * - public sharing link
   * - direct link to the endpoint already
   * @returns {string|null} DDB CharacterId
   * @param {String} url
   */
  static getCharacterId(url) {
    const ddbNamePattern = /(?:https?:\/\/)?(?:www\.dndbeyond\.com|ddb\.ac)(?:\/profile\/.+)?\/characters\/(\d+)\/?/;
    const matches = url.match(ddbNamePattern);
    return matches ? matches[1] : null;
  }

  /**
   * Creates the Character Endpoint URL from a given character ID
   * @returns {string|null} The API endpoint
   */
  getCharacterAPIEndpoint() {
    return this.characterId !== null ? `https://character-service.dndbeyond.com/character/v5/character/${this.characterId}` : null;
  }


  /**
   * Loads and parses character in the proxy
   * This will return an object containing the character, and items separated into arrays relating to their types
   * Additional processing is required after this step.
   * @param {String} syncId
   * @param {String} localCobaltPostFix
   * @returns {Object} Parsed Character Data and DDB data
   */

  async getCharacterData({ syncId = undefined, localCobaltPostFix = "" } = {}) {
    const cobaltCookie = (0,Secrets/* getCobalt */.HF)(localCobaltPostFix);
    const parsingApi = DDBProxy/* default.getProxy */.Z.getProxy();
    const betaKey = game.settings.get("ddb-importer", "beta-key");
    const campaignId = (0,Settings/* getCampaignId */.F9)();
    const proxyCampaignId = campaignId === "" ? null : campaignId;
    let body = { cobalt: cobaltCookie, betaKey, characterId: this.characterId, campaignId: proxyCampaignId };
    if (syncId) {
      body["updateId"] = syncId;
    }

    try {
      const response = await fetch(`${parsingApi}/proxy/v5/character`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        redirect: "follow", // manual, *follow, error
        body: JSON.stringify(body), // body data type must match "Content-Type" header
      });
      this.source = await response.json();
      if (!this.source.success) return this.source;

      // load some required content
      await (0,DDBTemplateStrings/* importCacheLoad */.uB)();

      logger/* default.debug */.Z.debug("DDB Data to parse:", duplicate(this.source.ddb));
      logger/* default.debug */.Z.debug("currentActorId", this.currentActorId);
      try {
        // this parses the json and sets the results as this.data
        await this._parseCharacter();
        const shouldChangeName = game.settings.get("ddb-importer", "character-update-policy-name");
        if (!shouldChangeName) {
          this.data.character.name = undefined;
          this.data.character.prototypeToken.name = undefined;
        }
        this.source["character"] = this.data;
        logger/* default.debug */.Z.debug("finalParsedData", duplicate(this.source));
        return this.source;
      } catch (error) {
        if (game.settings.get("ddb-importer", "debug-json")) {
          FileHelper/* default.download */.Z.download(JSON.stringify(this.source), `${this.characterId}-raw.json`, "application/json");
        }
        throw error;
      }
    } catch (error) {
      logger/* default.error */.Z.error("JSON Fetch and Parse Error");
      logger/* default.error */.Z.error(error);
      logger/* default.error */.Z.error(error.stack);
      throw error;
    }
  }

  /**
   * Removes duplicate features/actions based on import preferences
   */
  _filterActionFeatures() {
    const actionAndFeature = game.settings.get("ddb-importer", "character-update-policy-use-action-and-feature");

    this.data.actions = this.raw.actions.map((action) => {
      const featureMatch = this.raw.features.find((feature) => feature.name === action.name);
      if (featureMatch
        && action.effects && action.effects.length === 0
        && featureMatch.effects && featureMatch.effects.length > 0
      ) {
        action.effects = featureMatch.effects;
        const newFlags = duplicate(featureMatch.flags);
        delete newFlags.ddbimporter;
        mergeObject(action.flags, newFlags, { overwrite: true, insertKeys: true, insertValues: true });
      }
      return action;
    });

    this.data.features = this.raw.features
      .filter((feature) =>
        actionAndFeature
        || !this.data.actions.some((action) => action.name.trim().toLowerCase() === feature.name.trim().toLowerCase())
      )
      .map((feature) => {
        const actionMatch = actionAndFeature && this.data.actions.some((action) => feature.name === action.name);
        if (actionMatch) feature.effects = [];
        return feature;
      });

  }

  /**
   * Parses the collected Character JSON data into various foundry features.
   * Additional steps are needed after this based on the settings in the character import, but this will give the "raw" items
   *
   * @returns Object containing various parsed Foundry features
   *
   */
  async _parseCharacter() {
    try {
      if (game.settings.get("ddb-importer", "character-update-policy-add-spell-effects")) await (0,macros/* createGMMacros */.Kk)();
      logger/* default.debug */.Z.debug("Starting core character parse", { thisDDB: this.source.ddb });
      await this._generateCharacter();
      if (this.resourceSelection) {
        logger/* default.debug */.Z.debug("Character resources");
        await this.resourceSelectionDialog();
      }
      logger/* default.debug */.Z.debug("Character parse complete");
      this._generateRace();
      logger/* default.debug */.Z.debug("Race parse complete");
      this.raw.classes = await (0,classes/* getClasses */.k)(this.source.ddb, this.raw.character);
      logger/* default.debug */.Z.debug("Classes parse complete");
      await this._generateFeatures();
      logger/* default.debug */.Z.debug("Feature parse complete");
      const spellParser = new CharacterSpellFactory(this.source.ddb, this.raw.character);
      this.raw.spells = await spellParser.getCharacterSpells();
      logger/* default.debug */.Z.debug("Character Spells parse complete");
      this.raw.actions = await parseActions(this.source.ddb, this.raw.character, this.raw.classes);
      logger/* default.debug */.Z.debug("Action parse complete");
      await this._generateInventory();
      logger/* default.debug */.Z.debug("Inventory generation complete");

      this.data = {
        character: this.raw.character,
        features: this.raw.features,
        race: this.raw.race,
        classes: this.raw.classes,
        inventory: this.raw.inventory,
        spells: this.raw.spells,
        actions: this.raw.actions,
        itemSpells: this.raw.itemSpells,
      };

      this._filterActionFeatures();

      // this adds extras like a Divine Smite spell to this.data
      this._addSpecialAdditions();

      // find supported companion blocks
      if (this.enableCompanions && game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "character-update-policy-create-companions")) {
        await this.generateCompanions();
      }


    } catch (error) {
      logger/* default.error */.Z.error(error);
      logger/* default.error */.Z.error("Error during parse:", error.message);
      throw (error);
    }
  }

  async disableDynamicUpdates() {
    this.currentActor.flags.ddbimporter.activeUpdate = false;
    const activeUpdateData = { flags: { ddbimporter: { activeUpdate: false } } };
    await this.currentActor.update(activeUpdateData);
  }

  async enableDynamicUpdates() {
    this.currentActor.flags.ddbimporter.activeUpdate = true;
    const activeUpdateData = { flags: { ddbimporter: { activeUpdate: true } } };
    await this.currentActor.update(activeUpdateData);
  }

  async updateDynamicUpdates(state) {
    this.currentActor.flags.ddbimporter.activeUpdate = state;
    const activeUpdateData = { flags: { ddbimporter: { activeUpdate: state } } };
    await this.currentActor.update(activeUpdateData);
  }

  getCurrentDynamicUpdateState() {
    const activeUpdateState = this.currentActor.flags?.ddbimporter?.activeUpdate
      ? this.currentActor.flags.ddbimporter.activeUpdate
      : false;
    return activeUpdateState;
  }

  async setActiveSyncSpellsFlag(state) {
    this.currentActor.flags.ddbimporter.activeSyncSpells = state;
    const activeUpdateData = { flags: { ddbimporter: { activeSyncSpells: state } } };
    await this.currentActor.update(activeUpdateData);
  }

}


/***/ }),

/***/ 317:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "Z": () => (/* binding */ DDBMonster)
});

// EXTERNAL MODULE: ./src/parser/monster/templates/monster.js
var monster = __webpack_require__(1309);
;// CONCATENATED MODULE: ./src/parser/monster/special.js
// these are non-compliant monsters that currently don't meet parsing requirements
// these are temporary work arounds till parsing is fixed.
function specialCases(monster) {
  switch (monster.name) {
    case "Reduced-threat Aboleth":
    case "Aboleth": {
      monster.items.forEach(function(item, index) {
        if (item.name === "Tentacle") {
          this[index].system.formula = item.system.damage.parts[1][0];
          this[index].system.damage.parts.splice(1, 1);
        }
      }, monster.items);
      break;
    }
    case "Dullahan": {
      monster.items.forEach(function(item, index) {
        if (item.name === "Battleaxe") {
          this[index].system.damage.versatile += " + 2d10[necrotic]";
          this[index].system.damage.parts.push(["2d10[necrotic]", "necrotic"]);
        } else if (item.name === "Coordinated Assault") {
          this[index].system.activation.type = "legendary";
          this[index].system.consume = {
            type: "attribute",
            target: "resources.legact.value",
            amount: 1
          };
          this[index].system.activation.cost = 1;
        } else if (item.name.startsWith("Headless Wail")) {
          this[index].system.activation.cost = 2;
          this[index].system.activation.type = "legendary";
          this[index].system.consume = {
            type: "attribute",
            target: "resources.legact.value",
            amount: 2
          };
        }
      }, monster.items);
      break;
    }
    // flumph tendrils have weird syntax for damage over time.
    case "Flumph": {
      monster.items.forEach(function(item, index) {
        if (item.name === "Tendrils") {
          if (item.system.damage.parts.length > 2) {
            this[index].system.formula = item.system.damage.parts[2][0];
            this[index].system.damage.parts.splice(2, 1);
          }
          this[index].system.save.ability = "";
        }
      }, monster.items);
      break;
    }
    case "Hypnos Magen": {
      monster.flags.monsterMunch.spellList.atwill = ["Suggestion"];
      monster.flags.monsterMunch.spellList.material = false;
      monster.system.attributes.spellcasting = "int";
      break;
    }
    case "Nosferatu": {
      monster.items.forEach(function(item, index) {
        if (item.name === "Bite") {
          this[index].system.damage.versatile = `${item.system.damage.parts[0][0]} + ${item.system.damage.parts[2][0]}`;
          this[index].system.damage.parts.splice(2, 1);
        }
      }, monster.items);
      break;
    }
    case "Sephek Kaltro": {
      monster.flags.monsterMunch.spellList.innate = [{ name: "Misty Step", type: "day", value: 3 }];
      monster.flags.monsterMunch.spellList.material = false;
      break;
    }
    // no default
  }

  return monster;
}

// EXTERNAL MODULE: ./src/lib/CompendiumHelper.js
var CompendiumHelper = __webpack_require__(3893);
// EXTERNAL MODULE: ./src/effects/effects.js + 1 modules
var effects = __webpack_require__(5751);
// EXTERNAL MODULE: ./src/effects/macros.js
var macros = __webpack_require__(3752);
;// CONCATENATED MODULE: ./src/effects/monsterFeatures/absorbtion.js


function absorptionEffect(monster) {
  monster.items.forEach((item) => {
    const absRegEx = /is subjected to (\w+) damage, it takes no damage and instead regains a number of hit points equal to the (\w+) damage/;
    const match = absRegEx.exec(item.system.description.value);
    if (!item.effects) item.effects = [];
    if (match) {
      let effect = (0,effects/* baseItemEffect */.uT)(item, `${item.name}`);
      effect.changes.push(
        {
          key: `flags.midi-qol.absorption.${match[1]}`,
          value: "1",
          mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
          priority: 20,
        }
      );
      effect.icon = "icons/svg/downgrade.svg";
      item.effects.push(effect);
    }
  });
  return monster;
}

;// CONCATENATED MODULE: ./src/effects/monsterFeatures/legendary.js


function generateLegendaryEffect(document) {
  let effect = (0,effects/* baseItemEffect */.uT)(document, document.name);
  effect.changes.push(
    {
      key: "flags.midi-qol.optional.LegRes.save.fail",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: "success",
      priority: "20",
    },
    {
      key: "flags.midi-qol.optional.LegRes.count",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: "@resources.legres.value",
      priority: "20",
    },
    {
      key: "flags.midi-qol.optional.LegRes.label",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: "Use Legendary Resistance to Succeed?",
      priority: "20",
    }
  );

  document.effects.push(effect);
  return document;
}

// EXTERNAL MODULE: ./src/lib/utils.js
var utils = __webpack_require__(7669);
// EXTERNAL MODULE: ./src/dictionary.js
var dictionary = __webpack_require__(37);
// EXTERNAL MODULE: ./src/logger.js
var logger = __webpack_require__(5259);
// EXTERNAL MODULE: ./src/parser/monster/features/DDBFeature.js
var DDBFeature = __webpack_require__(2674);
;// CONCATENATED MODULE: ./src/effects/monsterFeatures/overTimeEffect.js







const DEFAULT_DURATION = 60;

function overTime({ document, turn, damage, damageType, saveAbility, saveRemove, saveDamage, dc }) {
  return {
    key: "flags.midi-qol.OverTime",
    mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
    value: `turn=end,label=${document.name} (${utils/* default.capitalize */.Z.capitalize(turn)} of Turn),damageRoll=${damage},damageType=${damageType},saveRemove=${saveRemove},saveDC=${dc},saveAbility=${saveAbility},saveDamage=${saveDamage}`,
    priority: "20",
  };
}

function startOrEnd(text) {
  const re = /at the (start|end) of each/i;
  const match = text.match(re);
  if (match) {
    return match[1];
  } else {
    return undefined;
  }
}

function getDuration(text) {
  const re = /for (\d+) (minute|hour)/;
  const match = text.match(re);
  if (match) {
    let minutes = parseInt(match[1]) * 60;
    if (match[2] === "hour") {
      minutes *= 60;
    }
    return minutes;
  } else {
    const reRounds = /for (\d+) round/;
    const roundMatch = text.match(reRounds);
    if (roundMatch) {
      return roundMatch[1] * 6;
    }
  }
  return DEFAULT_DURATION;
}


// A selection of example conditions
// DC 18 Strength saving throw or be knocked prone
// DC 14 Constitution saving throw or become poisoned for 1 minute.
// DC 12 Constitution saving throw or be poisoned for 1 minute
// DC 15 Wisdom saving throw or be frightened until the end of its next turn.
// DC 15 Charisma saving throw or be charmed
// DC 12 Charisma saving throw or become cursed
// DC 10 Intelligence saving throw or it canâ€™t take a reaction until the end of its next turn
// DC 12 Constitution saving throw or contract bluerot
// DC 17 Strength saving throw or be thrown up to 30 feet away in a straight line
// DC 13 Constitution saving throw or lose the ability to use reactions until the start of the weirdâ€™s
// DC 16 Wisdom saving throw or move 1 round forward in time
// DC 15 Constitution saving throw, or for 1 minute, its speed is reduced by 10 feet; it can take either an action or a bonus action on each of its turns, not both; and it canâ€™t take reactions.
// DC 15 Constitution saving throw or have disadvantage on its attack rolls until the end of its next turn
// DC 15 Wisdom saving throw or be frightened until the end of its next turn
// DC 13 Strength saving throw or take an extra 3 (1d6) piercing damage and be grappled (escape DC 13)
// DC 15 Constitution saving throw or gain 1 level of exhaustion
// DC 20 Constitution saving throw or be paralyzed for 1 minute
// DC 17 Constitution saving throw or be cursed with loup garou lycanthropy
// DC 12 Constitution saving throw or be cursed with mummy rot
// DC 18 Strength saving throw or be swallowed by the neothelid. A swallowed creature is blinded and restrained, it has total cover against attacks and other effects outside the neothelid, and it takes 35 (10d6) acid damage at the start of each of the neothelidâ€™s turns.</p><p>If the neothelid takes 30 damage or more on a single turn from a creature inside it, the neothelid must succeed on a DC 18 Constitution saving throw at the end of that turn or regurgitate all swallowed creatures, which fall prone in a space within 10 feet of the neothelid. If the neothelid dies, a swallowed creature is no longer restrained by it and can escape from the corpse by using 20 feet of movement, exiting prone.
// (before DC) it canâ€™t regain hit points for 1 minute
// DC 14 Dexterity saving throw or suffer one additional effect of the shadow dancerâ€™s choice:</p><ul>\n<li>The target is grappled (escape DC 14) if it is a Medium or smaller creature. Until the grapple ends, the target is restrained, and the shadow dancer canâ€™t grapple another target.</li>\n<li>The target is knocked prone.</li>\n<li>The target takes 22 (4d10) necrotic damage.</li>\n</ul>\n</section>\nThe Shadow Dancer attacks with its Spiked Chain.
// DC 15 Constitution saving throw or be stunned until the end of its next turn.
// DC 15 Constitution saving throw or die.
// DC 20 Strength saving throw or be pulled up to 25 feet toward the balor.
// DC 11 Constitution saving throw or be poisoned until the end of the targetâ€™s next turn.
// DC 14 Wisdom saving throw or be frightened of the quori for 1 minute.
// DC 13 Constitution saving throw or be poisoned for 1 hour. If the saving throw fails by 5 or more, the target is also unconscious while poisoned in this way. The target wakes up if it takes damage or if another creature takes an action to shake it awake.

function getSpecialDuration (effect, match) {
  // minutes
  if (match[7]
    && (match[7].includes("until the end of its next turn")
    || match[7].includes("until the end of the target's next turn"))
  ) {
    setProperty(effect, "flags.dae.specialDuration", ["turnEnd"]);
  } else if (match[7] && match[7].includes("until the start of the")) {
    setProperty(effect, "flags.dae.specialDuration", ["turnStartSource"]);
  }
  return effect;
}

function generateConditionEffect(effect, text) {
  let results = {
    success: false,
    effect,
  };
  text = text.replace("â€™", "'");
  const conditionSearch = /DC (\d+) (\w+) saving throw(?:,)? or (be |be cursed|become|die|contract|have|it can't|suffer|gain|lose the)\s?(?:knocked )?(\w+)?\s?(?:for (\d+) (minute))?(.*)?(?:.|$)/;
  const match = text.match(conditionSearch);
  // console.warn("condition status", match);
  if (match) {
    results.success = true;
    results.save = {
      dc: parseInt(match[1]),
      ability: match[2].toLowerCase().substr(0, 3),
      scaling: "flat",
    };
    // group 4 condition - .e.g. "DC 18 Strength saving throw or be knocked prone"
    const group4Condition = match[4]
      ? dictionary/* default.character.damageAdjustments.filter */.Z.character.damageAdjustments.filter((type) => type.type === 1)
        .find((type) => type.name.toLowerCase() === match[4].toLowerCase() || type.value.toLowerCase() === match[4].toLowerCase())
      : undefined;
    if (group4Condition) {
      results.condition = group4Condition.value;
      results.effect.changes.push((0,effects/* generateStatusEffectChange */.f6)(group4Condition.name));
      effect = getSpecialDuration(results.effect, match);
    } else if (match[3] && match[3] === "die") {
      results.effect.changes.push((0,effects/* generateStatusEffectChange */.f6)("Dead"));
    }
  }
  return results;
}

function getOvertimeDamage(text) {
  if (text.includes("taking") && (text.includes("on a failed save") || text.includes("damage on a failure"))) {
    const damageText = text.split("taking")[1];
    const feature = new DDBFeature/* default */.Z("overTimeFeature", { html: damageText });
    feature.prepare();
    feature.generateExtendedDamageInfo();
    return feature.actionInfo.damage;
  }
  return undefined;
}

function effectCleanup(document, actor, monster, effect) {
  if (effect.changes.length > 0) {
    document.effects.push(effect);
    let overTimeFlags = hasProperty(actor, "flags.monsterMunch.overTime") ? getProperty(actor, "flags.monsterMunch.overTime") : [];
    overTimeFlags.push(document.name);
    setProperty(actor, "flags.monsterMunch.overTime", overTimeFlags);
    // console.warn(`ITEM OVER TIME EFFECT: ${actor.name}, ${document.name}`);
    logger/* default.debug */.Z.debug(`Generating damage over time effect for ${actor.name}, ${actor.name}`);
  }
  return { document, actor, monster };
}

function generateOverTimeEffect(document, actor, monster) {
  logger/* default.debug */.Z.debug("Generating damage over time effect for", document.name);
  if (!document.effects) document.effects = [];
  let effect = specialMonsters_baseMonsterFeatureEffect(document, `${document.name}`);
  // add any condition effects
  const conditionResults = generateConditionEffect(effect, document.system.description.value);
  effect = conditionResults.effect;
  if (conditionResults.success) setProperty(document, "flags.midiProperties.fulldam", true);

  const durationSeconds = hasProperty(document.flags, "monsterMunch.overTime.durationSeconds")
    ? getProperty(document.flags, "monsterMunch.overTime.durationSeconds")
    : getDuration(document.system.description.value);
  setProperty(effect, "duration.seconds", durationSeconds);

  const turn = startOrEnd(document.system.description.value);
  if (!turn) return effectCleanup(document, actor, monster, effect);

  const saveFeature = new DDBFeature/* default */.Z("overTimeSaveFeature", { html: document.system.description.value });
  saveFeature.prepare();
  const save = saveFeature.getFeatSave();
  if (!Number.isInteger(Number.parseInt(save.dc))) return effectCleanup(document, actor, monster, effect);

  const saveAbility = save.ability;
  const dc = save.dc;

  const dmg = getOvertimeDamage(document.system.description.value);

  if (!dmg) return effectCleanup(document, actor, monster, effect);

  // overtime damage, revert any full damage flag, reset to default on save
  setProperty(document, "flags.midiProperties.fulldam", false);

  const damage = hasProperty(document.flags, "monsterMunch.overTime.damage")
    ? getProperty(document.flags, "monsterMunch.overTime.damage")
    : dmg.parts.reduce((total, current) => {
      total = [total, `${current[0]}[${current[1]}]`].join(" + ");
      return total;
    }, "");

  const damageType = hasProperty(document.flags, "monsterMunch.overTime.damageType")
    ? getProperty(document.flags, "monsterMunch.overTime.damageType")
    : dmg.parts.length > 0 ? dmg.parts[0][1] : "";

  const saveRemove = hasProperty(document.flags, "monsterMunch.overTime.saveRemove")
    ? getProperty(document.flags, "monsterMunch.overTime.saveRemove")
    : true;

  const saveDamage = hasProperty(document.flags, "monsterMunch.overTime.saveDamage")
    ? getProperty(document.flags, "monsterMunch.overTime.saveDamage")
    : "nodamage";

  effect.changes.push(overTime({ document, turn, damage, damageType, saveAbility, saveRemove, saveDamage, dc }));
  document.effects.push(effect);

  return effectCleanup(document, actor, monster, effect);
}


function damageOverTimeEffect({ document, startTurn = false, endTurn = false, durationSeconds, damage, damageType, saveAbility, saveRemove = true, saveDamage = "nodamage", dc }) {
  let effect = baseMonsterFeatureEffect(document, `${document.name}`);

  if (!startTurn && !endTurn) return document;

  if (startTurn) {
    effect.changes.push(overTime({ document, turn: "start", damage, damageType, saveAbility, saveRemove, saveDamage, dc }));
  }
  if (endTurn) {
    effect.changes.push(overTime({ document, turn: "end", damage, damageType, saveAbility, saveRemove, saveDamage, dc }));
  }

  setProperty(effect, "duration.seconds", durationSeconds);

  document.effects.push(effect);
  return document;
}

;// CONCATENATED MODULE: ./src/effects/monsterFeatures/packTactics.js



function generatePackTacticsEffect(document) {
  let effect = (0,effects/* baseItemEffect */.uT)(document, document.name);
  effect.changes.push(
    {
      key: "flags.midi-qol.advantage.attack.all",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: "findNearby(1, tokenUuid, 5, 0).length > 0",
      priority: "20",
    },
  );

  document.effects.push(effect);
  return document;
}

;// CONCATENATED MODULE: ./src/effects/specialMonsters.js









function specialMonsters_baseMonsterFeatureEffect(document, label) {
  return {
    label,
    icon: document.img,
    changes: [],
    duration: {},
    tint: "",
    transfer: false,
    disabled: false,
    flags: {
      dae: {
        transfer: false,
        stackable: "none",
      },
      ddbimporter: {
        disabled: false,
      },
      "midi-qol": { // by default force CE effect usage to off
        forceCEOff: true,
      },
    },
  };
}

function monsterFeatEffectModules() {
  if (CONFIG.DDBI.EFFECT_CONFIG.MONSTERS.installedModules) {
    return CONFIG.DDBI.EFFECT_CONFIG.MONSTERS.installedModules;
  }
  const midiQolInstalled = game.modules.get("midi-qol")?.active;
  const advancedMacrosInstalled = game.modules.get("advanced-macros")?.active;
  const itemMacroInstalled = game.modules.get("itemacro")?.active;
  const timesUp = game.modules.get("times-up")?.active;
  const daeInstalled = game.modules.get("dae")?.active;
  const convenientEffectsInstalled = game.modules.get("dfreds-convenient-effects")?.active;

  const activeAurasInstalled = game.modules.get("ActiveAuras")?.active;
  const atlInstalled = game.modules.get("ATL")?.active;
  const tokenAurasInstalled = game.modules.get("token-auras")?.active;
  const tokenMagicInstalled = game.modules.get("tokenmagic")?.active;
  const autoAnimationsInstalled = game.modules.get("autoanimations")?.active;
  CONFIG.DDBI.EFFECT_CONFIG.MONSTERS.installedModules = {
    hasCore:
      itemMacroInstalled
      && midiQolInstalled
      && advancedMacrosInstalled
      && timesUp
      && daeInstalled
      && convenientEffectsInstalled,
    midiQolInstalled,
    itemMacroInstalled,
    advancedMacrosInstalled,
    timesUp,
    daeInstalled,
    convenientEffectsInstalled,
    atlInstalled,
    tokenAurasInstalled,
    tokenMagicInstalled,
    activeAurasInstalled,
    autoAnimationsInstalled,
  };
  return CONFIG.DDBI.EFFECT_CONFIG.MONSTERS.installedModules;
}

function transferEffectsToActor(document) {
  if (!document.effects) document.effects = [];
  const compendiumLabel = CompendiumHelper/* default.getCompendiumLabel */.Z.getCompendiumLabel("monsters");

  // loop over items and item effect and transfer any effects to the actor
  document.items.forEach((item) => {
    item.effects.forEach((effect) => {
      if (effect.transfer) {
        const transferEffect = duplicate(effect);
        if (!hasProperty(item, "_id")) item._id = randomID();
        if (!hasProperty(effect, "_id")) effect._id = randomID();
        transferEffect._id = randomID();
        transferEffect.transfer = false;
        transferEffect.origin = `Compendium.${compendiumLabel}.${document._id}.Item.${item._id}`;
        document.effects.push(transferEffect);
      }
    });
  });

  return document;
}

/**
 * This function is mainly for effects that can't be dynamically generated
 * @param {*} document
 */
async function monsterFeatureEffectAdjustment(document, monster) {
  if (!document.effects) document.effects = [];

  const deps = monsterFeatEffectModules();
  if (!deps.hasCore) {
    return document;
  }
  if (!CONFIG.DDBI.EFFECT_CONFIG.MONSTERS.configured) {
    CONFIG.DDBI.EFFECT_CONFIG.MONSTERS.configured = (0,macros/* configureDependencies */.SI)();
  }

  // const name = document.flags.ddbimporter.originalName || document.name;

  // absorbtion on monster
  document = absorptionEffect(document);

  // damage over time effects
  document.items.forEach(function(item, index) {
    // Legendary Resistance Effects
    if (item.name.startsWith("Legendary Resistance")) item = generateLegendaryEffect(item);
    if (item.name.startsWith("Pack Tactics")) item = generatePackTacticsEffect(item);
    // auto overtime effect
    const overTimeResults = generateOverTimeEffect(item, document, monster);
    this[index] = overTimeResults.document;
    document = overTimeResults.actor;

    document = (0,effects/* forceItemEffect */.Wk)(document);
  }, document.items);

  document = transferEffectsToActor(document);
  return document;
}

// EXTERNAL MODULE: ./src/parser/monster/features/DDBFeatureFactory.js
var DDBFeatureFactory = __webpack_require__(6928);
// EXTERNAL MODULE: ./src/settings.js
var settings = __webpack_require__(6451);
// EXTERNAL MODULE: ./src/lib/FileHelper.js
var FileHelper = __webpack_require__(2397);
// EXTERNAL MODULE: ./src/lib/Secrets.js
var Secrets = __webpack_require__(2048);
// EXTERNAL MODULE: ./src/lib/DDBProxy.js
var DDBProxy = __webpack_require__(546);
;// CONCATENATED MODULE: ./src/parser/DDBMonster.js















class DDBMonster {

  setProperty(name, value) {
    if (this.overrides["name"]) {
      this[name] = this.overrides["name"];
    } else {
      this[name] = value;
    }
  }

  constructor(ddbObject = null, { existingNpc = null, extra = false, useItemAC = true,
    legacyName = true, addMonsterEffects = false } = {}, overrides = {}
  ) {
    this.source = ddbObject;

    // processing options
    this.extra = extra;
    this.npc = existingNpc;
    this.useItemAC = useItemAC;
    this.legacyName = legacyName;
    this.addMonsterEffects = addMonsterEffects;

    // some of this data can be overwritten, useful for mangling new actions
    this.overrides = overrides;

    // used by extra processing
    this.removedHitPoints = this.setProperty("removedHitPoints", (this.source?.removedHitPoints ?? 0));
    this.temporaryHitPoints = this.setProperty("temporaryHitPoints", (this.source?.temporaryHitPoints ?? 0));

    this.characterDescription = "";
    this.unexpectedDescription = null;

    // processing info
    this.name = overrides["name"] ?? (existingNpc ? existingNpc.name : null);
    this.abilities = null;
    this.proficiencyBonus = null;
    this.cr = 0;
    this.items = [];
    this.img = null;
    if (existingNpc) {
      this.proficiencyBonus = this.setProperty("proficiencyBonus", existingNpc.system.attributes.prof);
      this.cr = this.setProperty("cr", existingNpc.system.details.cr);
      this.abilities = this.setProperty("abilities", existingNpc.system.abilities);
      this.items = duplicate(existingNpc.items);
      this.img = existingNpc.img;
    }

    this.featureFactory = new DDBFeatureFactory/* DDBFeatureFactory */._({ ddbMonster: this });
  }

  _calculateImage() {
    if (this.source) {
      this.img = (this.source.basicAvatarUrl) ? this.source.basicAvatarUrl : this.source.largeAvatarUrl;
      // foundry doesn't support gifs
      if (this.img && this.img.match(/.gif$/)) {
        this.img = null;
      }
    } else {
      this.img = null;
    }
  }

  _generateFlags() {
    this.npc.flags.monsterMunch = {
      url: this.source.url,
      img: (this.img) ? this.img : this.source.avatarUrl,
      tokenImg: this.source.avatarUrl,
    };
    this.npc.flags.ddbimporter = {
      id: this.source.id,
      entityTypeId: this.source.entityTypeId,
      // creatureGroup: monster.creatureGroup ? monster.creatureGroup : null,
      creatureGroupId: this.source.creatureGroupId ? this.source.creatureGroupId : null,
      creatureFlags: this.source.creatureFlags ? this.source.creatureFlags : [],
      automatedEvcoationAnimation: this.source.automatedEvcoationAnimation ? this.source.automatedEvcoationAnimation : undefined,
      version: CONFIG.DDBI.version,
      isLegacy: this.source.isLegacy,
    };
  }


  async fetchMonsterSourceFromDDB(id) {
    if (!id && Number.isInteger(id) && Number.isInteger(Number.parseInt(id))) {
      throw new Error("Please provide a monster ID (number) to fetch");
    }
    const cobaltCookie = (0,Secrets/* getCobalt */.HF)();
    const betaKey = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "beta-key");
    const parsingApi = DDBProxy/* default.getProxy */.Z.getProxy();

    const body = {
      cobalt: cobaltCookie,
      betaKey: betaKey,
      ids: [Number.parseInt(id)],
    };

    const debugJson = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "debug-json");

    return new Promise((resolve, reject) => {
      fetch(`${parsingApi}/proxy/monsters/ids`, {
        method: "POST",
        mode: "cors",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(body), // body data type must match "Content-Type" header
      })
        .then((response) => response.json())
        .then((data) => {
          if (!data.success) {
            logger/* default.error */.Z.error(`API Failure:`, data.message);
            reject(data.message);
          }
          if (debugJson) {
            FileHelper/* default.download */.Z.download(JSON.stringify(data), `monsters-raw.json`, "application/json");
          }
          return data;
        })
        .then((data) => {
          logger/* default.info */.Z.info(`Retrieved monster`, { monster: data.data });
          this.source = data.data[0];
          return data.data[0];
        })
        .catch((error) => reject(error));
    });
  }

  async #linkResourcesConsumption() {
    if (this.items.some((item) => item.system.recharge?.value)) {
      logger/* default.debug */.Z.debug(`Resource linking for ${this.name}`);
      this.items.forEach((item) => {
        if (item.system?.recharge?.value) {
          const itemID = randomID(16);
          item._id = itemID;
          if (item.type === "weapon") {
            item.type = "feat";
            delete item.system.weaponType;
            item.system.type = {
              value: "monster",
              subtype: "",
            };
          }
          item.system.consume = {
            type: "charges",
            target: itemID,
            amount: null,
          };
        }
      });
    }
  }

  async parse() {
    if (!this.name) this.name = this.source.name;
    this.npc = duplicate(await (0,monster/* newNPC */.N)(this.name));
    this._calculateImage();

    this.npc.prototypeToken.name = this.name;
    this._generateFlags();


    this.proficiencyBonus = CONFIG.DDB.challengeRatings.find((cr) => cr.id == this.source.challengeRatingId).proficiencyBonus;
    this.npc.system.attributes.prof = this.proficiencyBonus;
    this._generateAbilities();

    // skills are different with extras, because DDB
    if (this.extra) {
      this._generateSkills();
    } else {
      this._generateSkillsHTML();
    }

    // Senses needed for actor and token
    this._generateSenses();
    this._generateTokenSenses();

    this._generateDamageImmunities();
    this._generateDamageResistances();
    this._generateDamageVulnerabilities();
    this._generateConditionImmunities();
    this._generateSize();
    this._generateLanguages();
    this._generateHitPoints();
    this._generateMovement();
    await this._generateAC();

    this.cr = CONFIG.DDB.challengeRatings.find((cr) => cr.id == this.source.challengeRatingId);
    this._generateType();

    const alignment = CONFIG.DDB.alignments.find((c) => this.source.alignmentId == c.id);
    this.npc.system.details.alignment = alignment ? alignment.name : "";
    this.npc.system.details.cr = this.cr.value;
    this.npc.system.details.xp = { value: this.cr.xp };

    this._generateSource();
    this._generateEnvironments();
    this.npc.system.details.biography.value = this.source.characteristicsDescription;

    this._generateFeatures();

    // Spellcasting
    this._generateSpells();
    await this.addSpells();

    const badItems = this.items.filter((i) => i.name === "" || !i.name);
    if (badItems.length > 0) {
      logger/* default.error */.Z.error(`${this.source.name} - ${badItems.length} items have no name.`, badItems);
      this.items = this.items.filter((i) => i.name && i.name !== "");
    }

    await this.#linkResourcesConsumption();
    this.npc.items = this.items;

    if (this.legacyName) {
      if (this.source.isLegacy) {
        this.npc.name += " (Legacy)";
        this.npc.prototypeToken.name += " (Legacy)";
      }
    }

    this.npc = await CompendiumHelper/* default.existingActorCheck */.Z.existingActorCheck("monster", this.npc);
    this.npc = specialCases(this.npc);

    if (this.addMonsterEffects) {
      this.npc = await monsterFeatureEffectAdjustment(this.npc, this.source);
    }

    logger/* default.debug */.Z.debug(`Generated ${this.name}`, this);
    return this.npc;

  }

}


/***/ }),

/***/ 2331:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "E": () => (/* binding */ generateBackground)
/* harmony export */ });
/* harmony import */ var _dictionary_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(37);
/* harmony import */ var _lib_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7669);
/* harmony import */ var _DDBCharacter_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1269);




_DDBCharacter_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].prototype.getBackgroundName */ .Z.prototype.getBackgroundName = function getBackgroundName() {
  if (this.source.ddb.character.background.hasCustomBackground === false) {
    if (this.source.ddb.character.background.definition !== null) {
      return this.source.ddb.character.background.definition.name || "";
    } else {
      return "";
    }
  } else {
    return this.source.ddb.character.background.customBackground.name || "";
  }
};

_DDBCharacter_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].prototype._generateTrait */ .Z.prototype._generateTrait = function _generateTrait() {
  this.raw.character.system.details.trait = this.source.ddb.character.traits.personalityTraits ?? "";
};

_DDBCharacter_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].prototype._generateIdeal */ .Z.prototype._generateIdeal = function _generateIdeal() {
  this.raw.character.system.details.ideal = this.source.ddb.character.traits.ideals ?? "";
};

_DDBCharacter_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].prototype._generateBond */ .Z.prototype._generateBond = function _generateBond() {
  this.raw.character.system.details.bond = this.source.ddb.character.traits.bonds ?? "";
};

_DDBCharacter_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].prototype._generateFlaw */ .Z.prototype._generateFlaw = function _generateFlaw() {
  this.raw.character.system.details.flaw = this.source.ddb.character.traits.flaws ?? "";
};

_DDBCharacter_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].prototype.getCharacteristics */ .Z.prototype.getCharacteristics = function getCharacteristics() {
  let characteristicBlurb = "";
  if (this.source.ddb.character.gender) characteristicBlurb += `Gender: ${this.source.ddb.character.gender}\n`;
  if (this.source.ddb.character.eyes) characteristicBlurb += `Eyes: ${this.source.ddb.character.eyes}\n`;
  if (this.source.ddb.character.height) characteristicBlurb += `Height: ${this.source.ddb.character.height}\n`;
  if (this.source.ddb.character.faith) characteristicBlurb += `Faith: ${this.source.ddb.character.faith}\n`;
  if (this.source.ddb.character.hair) characteristicBlurb += `Hair: ${this.source.ddb.character.hair}\n`;
  if (this.source.ddb.character.skin) characteristicBlurb += `Skin: ${this.source.ddb.character.skin}\n`;
  if (this.source.ddb.character.age) characteristicBlurb += `Age: ${this.source.ddb.character.age}\n`;
  if (this.source.ddb.character.weight) characteristicBlurb += `Weight: ${this.source.ddb.character.weight}\n`;
  return characteristicBlurb;
};

_DDBCharacter_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].prototype._generateAppearance */ .Z.prototype._generateAppearance = function _generateAppearance() {
  let result = this.getCharacteristics();
  if (result && result !== "") result += "\n";
  if (this.source.ddb.character.traits.appearance) result += this.source.ddb.character.traits.appearance;
  this.raw.character.system.details.appearance = result ?? "";
};

/**
 * Gets the character's alignment
 * Defaults to Neutral, if not set in DDB
 * @todo: returns .name right now, should switch to .value once the DND5E options are fully implemented
 */
_DDBCharacter_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].prototype._generateAlignment */ .Z.prototype._generateAlignment = function _generateAlignment() {
  const alignmentID = this.source.ddb.character.alignmentId || 5;
  const alignment = _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].character.alignments.find */ .Z.character.alignments.find((alignment) => alignment.id === alignmentID);
  if (alignment) this.raw.character.system.details.alignment = alignment.name;
};

function getBackgroundTemplate() {
  return {
    name: "Background",
    description: "",
    id: null,
    entityTypeId: null,
    featuresId: null,
    featuresEntityTypeId: null,
    characteristicsId: null,
    characteristicsEntityTypeId: null,
    definition: {
      name: "Background",
      description: "",
      id: null,
      entityTypeId: null,
    },
  };
}

function generateBackground(bg) {
  let result = getBackgroundTemplate();

  // console.warn(bg)

  if (bg.id) result.id = bg.id;
  if (bg.entityTypeId) result.entityTypeId = bg.entityTypeId;

  if (bg.name) {
    result.name = `Background: ${bg.name}`;
    result.description = `<h1>Background: ${bg.name}</h1>`;
  }

  if (bg.description) {
    result.description += `<p>${bg.description}</p>`;
  } else if (bg.shortDescription) {
    result.description += bg.shortDescription.replace("\r\n", "");
  }
  if (bg.definition) result.definition = bg.definition;

  if (bg.isHomebrew === true) {
    if (bg.featuresBackground) {
      result.description += `<h2>${bg.featuresBackground.name}</h2>`;
      result.description += bg.featuresBackground.shortDescription.replace("\r\n", "");
      result.description += `<h3>${bg.featuresBackground.featureName}</h3>`;
      result.description += bg.featuresBackground.featureDescription.replace("\r\n", "");
      result.featuresId = bg.featuresBackground.id;
      result.id = bg.featuresBackground.id;
      result.featuresEntityTypeId = bg.featuresBackground.entityTypeId;
      result.definition = bg.featuresBackground;
    }
    if (
      bg.characteristicsBackground
      && bg.featuresBackground
      && bg.featuresBackground.entityTypeId != bg.characteristicsBackground.entityTypeId
    ) {
      result.description += `<h2>${bg.characteristicsBackground.name}</h2>`;
      result.description += bg.characteristicsBackground.shortDescription.replace("\r\n", "");
      result.description += `<h3>${bg.characteristicsBackground.featureName}</h3>`;
      result.description += bg.characteristicsBackground.featureDescription.replace("\r\n", "");
      result.characteristicsId = bg.characteristicsBackground.id;
      result.characteristicsEntityTypeId = bg.characteristicsBackground.entityTypeId;
    }
  }

  if (bg.featureName) {
    result.description += `<h2>${bg.featureName}</h2>`;
    result.description += bg.featureDescription.replace("\r\n", "");
  }
  if (bg.spellListIds) result.spellListIds = bg.spellListIds;
  result.definition.name = result.name;
  result.description = _lib_utils_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].replaceHtmlSpaces */ .Z.replaceHtmlSpaces(result.description);
  result.definition.description = result.description;
  return result;
}

// WIP, not used
_DDBCharacter_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].prototype.getBackgroundFeature */ .Z.prototype.getBackgroundFeature = function getBackgroundFeature(bg) {
  let result = getBackgroundTemplate();
  result.name = "Background Feature";

  if (bg.isHomebrew === true) {
    if (bg.featuresBackground) {
      result.name = bg.featuresBackground.featureName;
      result.description += bg.featuresBackground.featureDescription.replace("\r\n", "");
      result.featuresId = bg.featuresBackground.id;
      result.id = bg.featuresBackground.id;
      result.featuresEntityTypeId = bg.featuresBackground.entityTypeId;
      result.definition = bg.featuresBackground;
    }
    if (
      bg.characteristicsBackground
      && bg.featuresBackground
      && bg.featuresBackground.entityTypeId != bg.characteristicsBackground.entityTypeId
    ) {
      result.name = bg.characteristicsBackground.featureName;
      result.description += bg.characteristicsBackground.featureDescription.replace("\r\n", "");
      result.characteristicsId = bg.characteristicsBackground.id;
      result.characteristicsEntityTypeId = bg.characteristicsBackground.entityTypeId;
    }
  }

  if (bg.featureName) {
    result.name = bg.featureName;
    result.description += bg.featureDescription.replace("\r\n", "");
  }

  return result;

};

_DDBCharacter_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].prototype.getBackgroundData */ .Z.prototype.getBackgroundData = function getBackgroundData() {
  let bg = null;
  if (this.source.ddb.character.background.hasCustomBackground === true) {
    bg = this.source.ddb.character.background.customBackground;
    bg.isHomebrew = true;
  } else if (this.source.ddb.character.background.definition !== null) {
    bg = this.source.ddb.character.background.definition;
  } else {
    bg = this.source.ddb.character.background.customBackground;
    let result = getBackgroundTemplate();
    if (bg.id) result.id = bg.id;
    if (bg.entityTypeId) result.entityTypeId = bg.entityTypeId;
    return result;
  }

  return generateBackground(bg);
};

_DDBCharacter_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].prototype._generateBiography */ .Z.prototype._generateBiography = function _generateBiography() {
  const backstory = this.source.ddb.character.notes.backstory
    ? "<h1>Backstory</h1><p>" + this.source.ddb.character.notes.backstory + "</p>"
    : "";

  this.raw.character.system.details.biography = {
    public: backstory,
    value: backstory,
  };
};

_DDBCharacter_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].prototype._generateDescription */ .Z.prototype._generateDescription = function _generateDescription() {
  this.raw.character.system.details["gender"] = this.source.ddb.character.gender || "";
  this.raw.character.system.details["age"] = this.source.ddb.character.age || "";
  this.raw.character.system.details["height"] = this.source.ddb.character.height || "";
  this.raw.character.system.details["weight"] = this.source.ddb.character.weight || "";
  this.raw.character.system.details["eyes"] = this.source.ddb.character.eyes || "";
  this.raw.character.system.details["skin"] = this.source.ddb.character.skin || "";
  this.raw.character.system.details["hair"] = this.source.ddb.character.hair || "";
};


/***/ }),

/***/ 6103:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "WX": () => (/* binding */ addSRDAdvancements),
  "k": () => (/* binding */ getClasses),
  "$D": () => (/* binding */ getHPAdvancement)
});

// EXTERNAL MODULE: ./src/logger.js
var logger = __webpack_require__(5259);
// EXTERNAL MODULE: ./src/dictionary.js
var dictionary = __webpack_require__(37);
// EXTERNAL MODULE: ./src/lib/utils.js
var utils = __webpack_require__(7669);
// EXTERNAL MODULE: ./src/lib/DDBHelper.js
var DDBHelper = __webpack_require__(1438);
// EXTERNAL MODULE: ./src/lib/CompendiumHelper.js
var CompendiumHelper = __webpack_require__(3893);
// EXTERNAL MODULE: ./src/parser/spells/ability.js
var ability = __webpack_require__(2352);
// EXTERNAL MODULE: ./src/lib/DDBTemplateStrings.js
var DDBTemplateStrings = __webpack_require__(258);
;// CONCATENATED MODULE: ./src/parser/classes/special.js
function convertToSingularDie(advancement) {
  advancement.title += ` (Die)`;
  for (const key of Object.keys(advancement.configuration.scale)) {
    advancement.configuration.scale[key].n = 1;
  }
  return advancement;
}

function renameTotal(advancement) {
  advancement.title += ` (Total)`;
  return advancement;
}

function addAdditionalUses (advancement) {
  const scaleValue = {
    _id: foundry.utils.randomID(),
    type: "ScaleValue",
    configuration: {
      distance: { units: "" },
      identifier: `${advancement.configuration.identifier}-uses`,
      type: "number",
      scale: {},
    },
    value: {},
    title: `${advancement.title} (Uses)`,
    icon: "",
  };

  for (const [key, value] of Object.entries(advancement.configuration.scale)) {
    scaleValue.configuration.scale[key] = {
      value: value.n,
    };
  }

  return scaleValue;
}

function addSingularDie (advancement) {
  const scaleValue = convertToSingularDie(duplicate(advancement));

  scaleValue._id = foundry.utils.randomID();
  scaleValue.configuration.identifier = `${advancement.configuration.identifier}-die`;

  return scaleValue;
}

const SPECIAL_ADVANCEMENTS = {
  "Combat Superiority": {
    fix: true,
    fixFunction: renameTotal,
    additionalAdvancements: true,
    additionalFunctions: [addAdditionalUses, addSingularDie],
  },
  "Rune Carver": {
    fix: true,
    fixFunction: renameTotal,
    additionalAdvancements: false,
    additionalFunctions: [],
  },
};

;// CONCATENATED MODULE: ./src/parser/classes/index.js









/**
 * Fetches the sources and pages for class and subclass
 * @param {obj} data item
 */
function getSources(data) {
  const classSource = DDBHelper/* default.getSourceData */.Z.getSourceData(data.definition);

  let sources = classSource.name;
  if (classSource.page) sources += ` (pg. ${classSource.page})`;

  if (data.subclassDefinition) {
    const subclassSource = DDBHelper/* default.getSourceData */.Z.getSourceData(data.subclassDefinition);
    if (subclassSource.name && classSource.name !== subclassSource.name) {
      sources += `, ${subclassSource.name}`;
    }
    if (subclassSource.page && classSource.page !== subclassSource.page) {
      sources += ` (pg. ${subclassSource.page})`;
    }
  }

  return sources;
}

function generateScaleValueAdvancement(feature) {
  // distance, number, dice, anything
  let type = "string";
  const die = feature.levelScales[0]?.dice ? feature.levelScales[0]?.dice : feature.levelScales[0]?.die ? feature.levelScales[0]?.die : undefined;

  if (die?.diceString && (!die.fixedValue || die.fixedValue === "")) {
    type = "dice";
  } else if (feature.levelScales[0].fixedValue
    && feature.levelScales[0].fixedValue !== ""
    && Number.isInteger(feature.levelScales[0].fixedValue)
  ) {
    type = "number";
  }

  const scaleValue = {
    _id: foundry.utils.randomID(),
    type: "ScaleValue",
    configuration: {
      distance: { units: "" },
      identifier: utils/* default.referenceNameString */.Z.referenceNameString(feature.name).toLowerCase(),
      type,
      scale: {},
    },
    value: {},
    title: feature.name,
    icon: "",
    // classRestriction: "",
  };

  feature.levelScales.forEach((scale) => {
    const die = scale.dice ? scale.dice : scale.die ? scale.die : undefined;
    if (type === "dice") {
      scaleValue.configuration.scale[scale.level] = {
        n: die.diceCount,
        die: die.diceValue,
      };
    } else if (type === "number") {
      scaleValue.configuration.scale[scale.level] = {
        value: scale.fixedValue,
      };
    } else {
      let value = (die.diceString && die.diceString !== "")
        ? die.diceString
        : "";
      if (die.fixedValue && die.fixedValue !== "") {
        value += ` + ${die.fixedValue}`;
      }
      if (value === "") {
        value = scale.description;
      }
      scaleValue.configuration.scale[scale.level] = {
        value,
      };
    }
  });

  return scaleValue;
}

function getHPAdvancement(klass) {
  // const value = "value": {
  //   "1": "max",
  //   "2": "avg"
  // },
  let value = {};
  if (klass) {
    for (let i = 1; i <= klass.system.levels; i++) {
      value[`${i}`] = i === 1 && getProperty(klass, "flags.ddbimporter.isStartingClass") === true ? "max" : "avg";
    };
  }
  return {
    _id: foundry.utils.randomID(),
    type: "HitPoints",
    configuration: {},
    value,
    title: "",
    icon: "",
    classRestriction: "",
  };
}

function getClassFeatures(ddb, klass, klassDefinition, excludedIds = []) {
  const excludedFeatures = ddb.character.optionalClassFeatures
    .filter((f) => f.affectedClassFeatureId)
    .map((f) => f.affectedClassFeatureId);

  const optionFeatures = ddb.classOptions
    ? ddb.classOptions
      .filter((feature) => feature.classId === klassDefinition.id && !excludedIds.includes(feature.id))
    : [];

  const classFeatures = klass.classFeatures
    .filter((feature) =>
      !excludedFeatures.includes(feature.definition.id)
      && !excludedIds.includes(feature.definition.id)
      && feature.definition.classId === klassDefinition.id
    )
    .map((feature) => feature.definition);

  return classFeatures.concat(optionFeatures)
    .sort((a, b) => a.displayOrder - b.displayOrder)
    .sort((a, b) => a.requiredLevel - b.requiredLevel);
}

function getFeatureCompendiumMatch(compendium, feature, klassDefinition) {
  return compendium.find((match) =>
    ((hasProperty(match, "flags.ddbimporter.featureName") && feature.name.trim().toLowerCase() == match.flags.ddbimporter.featureName.trim().toLowerCase())
      || (!hasProperty(match, "flags.ddbimporter.featureName")
        && (feature.name.trim().toLowerCase() == match.name.trim().toLowerCase()
        || `${feature.name} (${klassDefinition.name})`.trim().toLowerCase() == match.name.trim().toLowerCase()))
    )
    && hasProperty(match, "flags.ddbimporter")
    && (match.flags.ddbimporter.class == klassDefinition.name
      || match.flags.ddbimporter.parentClassId == klassDefinition.id
      || match.flags.ddbimporter.classId == klassDefinition.id)
  );
}

async function generateFeatureAdvancements(ddb, klass, klassDefinition, compendiumClassFeatures, ignoreIds = []) {
  logger/* default.debug */.Z.debug(`Parsing ${klass.name} features for advancement`);
  const compendiumLabel = CompendiumHelper/* default.getCompendiumLabel */.Z.getCompendiumLabel("features");

  let advancements = [];
  getClassFeatures(ddb, klass, klassDefinition, ignoreIds)
    .filter((feature) => !ignoreIds.includes(feature.id))
    .forEach((feature) => {
      const featureMatch = getFeatureCompendiumMatch(compendiumClassFeatures, feature, klassDefinition);

      if (featureMatch) {
        const levelAdvancement = advancements.findIndex((advancement) => advancement.level === feature.requiredLevel);

        if (levelAdvancement == -1) {
          const advancement = {
            _id: foundry.utils.randomID(),
            type: "ItemGrant",
            configuration: {
              items: [
                `Compendium.${compendiumLabel}.${featureMatch._id}`
              ]
            },
            value: {},
            level: feature.requiredLevel,
            title: "Features",
            icon: "",
            classRestriction: ""
          };
          advancements.push(advancement);
        } else {
          advancements[levelAdvancement].configuration.items.push(`Compendium.${compendiumLabel}.${featureMatch._id}`);
        }
      }
    });

  return advancements;
}

function parseFeaturesForScaleValues(ddb, klass, klassDefinition, ignoreIds = []) {
  let specialFeatures = [];
  const advancements = getClassFeatures(ddb, klass, klassDefinition, ignoreIds)
    .filter((feature) => feature.levelScales?.length > 0)
    .map((feature) => {
      let advancement = generateScaleValueAdvancement(feature);
      const specialLookup = SPECIAL_ADVANCEMENTS[advancement.title];
      if (specialLookup) {
        if (specialLookup.additionalAdvancements) {
          specialLookup.additionalFunctions.forEach((fn) => {
            specialFeatures.push(fn(advancement));
          });
        }
        if (specialLookup.fixFunction) advancement = specialLookup.fixFunction(advancement);
      }
      return advancement;
    });
  return advancements.concat(specialFeatures);
}

async function addSRDAdvancements(advancements, klass) {
  const rulesCompendium = "dnd5e.classes";
  const srdCompendium = CompendiumHelper/* default.getCompendium */.Z.getCompendium(rulesCompendium);
  await srdCompendium.getIndex();
  const klassMatch = srdCompendium.index.find((k) => k.name === klass.name);
  if (klassMatch) {
    const srdKlass = await srdCompendium.getDocument(klassMatch._id);
    const scaleAdvancements = srdKlass.system.advancement.filter((srdA) =>
      srdA.type === "ScaleValue"
      && !advancements.some((ddbA) => ddbA.configuration.identifier === srdA.configuration.identifier)
    ).map((advancement) => {
      return foundry.utils.isNewerVersion(game.system.version, "2.0.3") ? advancement.toObject() : advancement;
    });
    advancements.push(...scaleAdvancements);
  }

  return advancements;
}


async function buildClassFeatures(ddb, klass, klassDefinition, compendiumClassFeatures, ignoreIds = []) {
  logger/* default.debug */.Z.debug(`Parsing ${klassDefinition.name} features`);
  let description = "<h1>Class Features</h1>\n\n";
  let classFeatures = [];

  const compendiumLabel = CompendiumHelper/* default.getCompendiumLabel */.Z.getCompendiumLabel("features");

  getClassFeatures(ddb, klass, klassDefinition, ignoreIds).forEach((feature) => {
    const classFeaturesAdded = classFeatures.some((f) => f === feature.name);

    if (!classFeaturesAdded && !ignoreIds.includes(feature.id)) {
      const featureMatch = getFeatureCompendiumMatch(compendiumClassFeatures, feature, klassDefinition);
      const title = (featureMatch)
        ? `<p><b>@Compendium[${compendiumLabel}.${featureMatch._id}]{${feature.name}}</b></p>`
        : `<p><b>${feature.name}</b></p>`;

      // eslint-disable-next-line require-atomic-updates
      description += `${title}\n${feature.description}\n\n`;
      classFeatures.push(feature.name);
    }

  });

  return description;
}


async function parseSubclass(ddb, character, characterClass, featuresIndex) {
  let subKlass = {
    name: characterClass.subclassDefinition.name,
    type: 'subclass',
    system: JSON.parse(utils/* default.getTemplate */.Z.getTemplate('subclass')),
    flags: {
      ddbimporter: {
        subclassDefinitionId: characterClass.id,
        id: characterClass.subclassDefinition.id,
        type: "class",
      },
      obsidian: {
        source: {
          type: "class",
          text: characterClass.subclassDefinition.name,
        }
      },
    },
  };

  subKlass.system.classIdentifier = utils/* default.referenceNameString */.Z.referenceNameString(characterClass.definition.name.toLowerCase());
  subKlass.system.identifier = utils/* default.referenceNameString */.Z.referenceNameString(characterClass.subclassDefinition.name.toLowerCase());

  const castSpells = characterClass.subclassDefinition.canCastSpells;

  if (castSpells) {
    const spellProgression = dictionary/* default.spell.progression.find */.Z.spell.progression.find((cls) => cls.name === characterClass.definition.name);
    const spellCastingAbility = (0,ability/* getSpellCastingAbility */.sX)(characterClass, true, true);
    if (spellProgression) {
      subKlass.system.spellcasting = {
        progression: spellProgression.value,
        ability: spellCastingAbility,
      };
    }
    const spellSlotDivisor = characterClass.subclassDefinition.spellRules?.multiClassSpellSlotDivisor
      ? characterClass.subclassDefinition.spellRules?.multiClassSpellSlotDivisor
      : undefined;
    subKlass.flags.ddbimporter.spellSlotDivisor = spellSlotDivisor;
    subKlass.flags.ddbimporter.spellCastingAbility = spellCastingAbility;
  }

  subKlass.system.description.value += "<h1>Description</h1>";
  subKlass.system.description.value += characterClass.subclassDefinition.description;

  const baseClassFeatureIds = characterClass.definition.classFeatures.map((f) => f.id);
  // eslint-disable-next-line no-await-in-loop
  subKlass.system.description.value += await buildClassFeatures(ddb, characterClass, characterClass.subclassDefinition, featuresIndex, baseClassFeatureIds);

  subKlass.system.description.value = (0,DDBTemplateStrings/* default */.ZP)(ddb, character, subKlass.system.description.value, subKlass).text;

  subKlass.system.advancement = [
    ...parseFeaturesForScaleValues(ddb, characterClass, characterClass.subclassDefinition, baseClassFeatureIds),
    ...await generateFeatureAdvancements(ddb, characterClass, characterClass.subclassDefinition, featuresIndex, baseClassFeatureIds),
  ];

  return subKlass;
}

async function getClasses(ddb, character) {
  const featuresCompendium = CompendiumHelper/* default.getCompendiumType */.Z.getCompendiumType("features");
  const featuresIndex = featuresCompendium
    ? await featuresCompendium.getIndex({ fields: ["name", "flags.ddbimporter.classId", "flags.ddbimporter.class", "flags.ddbimporter.subClass", "flags.ddbimporter.parentClassId"] })
    : [];

  let items = [];

  for (const characterClass of ddb.character.classes) {
    let klass = {
      name: characterClass.definition.name,
      type: 'class',
      system: JSON.parse(utils/* default.getTemplate */.Z.getTemplate('class')),
      flags: {
        ddbimporter: {
          id: characterClass.id,
          definitionId: characterClass.definition.id,
          entityTypeId: characterClass.entityTypeId,
          type: "class",
          isStartingClass: characterClass.isStartingClass,
        },
        obsidian: {
          source: {
            type: "class",
            text: characterClass.definition.name,
          }
        },
      },
    };

    /* eslint-disable require-atomic-updates */
    klass.system.description.value = "<h1>Description</h1>";
    klass.system.description.value += characterClass.definition.description;
    // get class features
    const subClassFeatureIds = characterClass.subclassDefinition && characterClass.subclassDefinition.name
      ? characterClass.subclassDefinition.classFeatures.filter((f) => f.id === characterClass.subclassDefinition.id).map((f) => f.id)
      : [];
    // eslint-disable-next-line no-await-in-loop, require-atomic-updates
    klass.system.description.value += await buildClassFeatures(ddb, characterClass, characterClass.definition, featuresIndex, subClassFeatureIds);

    if (characterClass.definition.equipmentDescription) {
      // eslint-disable-next-line require-atomic-updates
      klass.system.description.value += `<h1>Starting Equipment</h1>\n${characterClass.definition.equipmentDescription}\n\n`;
    }

    klass.system.identifier = utils/* default.referenceNameString */.Z.referenceNameString(characterClass.definition.name.toLowerCase());
    klass.system.levels = characterClass.level;
    klass.system.source = getSources(characterClass);
    klass.system.hitDice = `d${characterClass.definition.hitDice}`;
    klass.system.hitDiceUsed = characterClass.hitDiceUsed;
    // eslint-disable-next-line no-await-in-loop
    klass.system.advancement = await addSRDAdvancements([
      getHPAdvancement(klass),
      ...parseFeaturesForScaleValues(ddb, characterClass, characterClass.definition, subClassFeatureIds),
      // eslint-disable-next-line no-await-in-loop
      ...await generateFeatureAdvancements(ddb, characterClass, characterClass.definition, featuresIndex, subClassFeatureIds),
    ], klass);


    // There class object supports skills granted by the class.
    // Lets find and add them for future compatibility.
    // const classFeatureIds = characterClass.definition.classFeatures
    //   .map((feature) => feature.id)
    //   .concat((characterClass.subclassDefinition)
    //     ? characterClass.subclassDefinition.classFeatures.map((feature) => feature.id)
    //     : []);

    const classProficiencyFeatureIds = characterClass.definition.classFeatures
      .filter((feature) => feature.name === "Proficiencies")
      .map((feature) => feature.id)
      .concat((characterClass.subclassDefinition)
        ? characterClass.subclassDefinition.classFeatures
          .filter((feature) => feature.name === "Proficiencies")
          .map((feature) => feature.id)
        : []);

    // const classSkillSubType = `choose-a-${characterClass.definition.name.toLowerCase()}-skill`;
    // const skillIds = DDBHelper.getChosenClassModifiers(ddb)
    //   .filter((mod) => mod.subType === classSkillSubType && mod.type === "proficiency")
    //   .map((mod) => mod.componentId);

    // "subType": 1,
    // "type": 2,

    // There class object supports skills granted by the class.
    let skillsChosen = [];
    let skillChoices = [];
    const choiceDefinitions = ddb.character.choices.choiceDefinitions;
    ddb.character.choices.class.filter((choice) =>
      classProficiencyFeatureIds.includes(choice.componentId)
      && choice.subType === 1
      && choice.type === 2
    ).forEach((choice) => {
      const optionChoice = choiceDefinitions.find((selection) => selection.id === `${choice.componentTypeId}-${choice.type}`);
      if (!optionChoice) return;
      const option = optionChoice.options.find((option) => option.id === choice.optionValue);
      if (!option) return;
      const smallChosen = dictionary/* default.character.skills.find */.Z.character.skills.find((skill) => skill.label === option.label);
      if (smallChosen && !skillsChosen.includes(smallChosen.name)) {
        skillsChosen.push(smallChosen.name);
      }
      const optionNames = optionChoice.options.filter((option) =>
        dictionary/* default.character.skills.some */.Z.character.skills.some((skill) => skill.label === option.label)
        && choice.optionIds.includes(option.id)
      ).map((option) =>
        dictionary/* default.character.skills.find */.Z.character.skills.find((skill) => skill.label === option.label).name
      );
      optionNames.forEach((skill) => {
        if (!skillChoices.includes(skill)) {
          skillChoices.push(skill);
        }
      });
    });

    klass.system.skills = {
      value: skillsChosen,
      number: skillsChosen.length,
      choices: skillChoices,
    };

    klass.system.saves = [];
    dictionary/* default.character.abilities.forEach */.Z.character.abilities.forEach((ability) => {
      const mods = DDBHelper/* default.getChosenClassModifiers */.Z.getChosenClassModifiers(ddb, true);
      const save = DDBHelper/* default.filterModifiers */.Z.filterModifiers(mods, "proficiency", `${ability.long}-saving-throws`, [null, ""], true).length > 0;
      if (save) klass.system.saves.push(ability.value);
    });

    const castSpells = characterClass.definition.canCastSpells;

    if (castSpells) {
      const spellProgression = dictionary/* default.spell.progression.find */.Z.spell.progression.find((cls) => cls.name === characterClass.definition.name);
      const spellCastingAbility = (0,ability/* getSpellCastingAbility */.sX)(characterClass, false, false);
      if (spellProgression) {
        klass.system.spellcasting = {
          progression: spellProgression.value,
          ability: spellCastingAbility,
        };
      }
      const spellSlotDivisor = characterClass.definition.spellRules?.multiClassSpellSlotDivisor
        ? characterClass.definition.spellRules.multiClassSpellSlotDivisor
        : characterClass.subclassDefinition.spellRules?.multiClassSpellSlotDivisor
          ? characterClass.subclassDefinition.spellRules?.multiClassSpellSlotDivisor
          : undefined;
      klass.flags.ddbimporter.spellSlotDivisor = spellSlotDivisor;
      klass.flags.ddbimporter.spellCastingAbility = spellCastingAbility;
    }

    if (characterClass.subclassDefinition && characterClass.subclassDefinition.name) {
      // eslint-disable-next-line no-await-in-loop
      items.push(await parseSubclass(ddb, character, characterClass, featuresIndex));
    }

    klass.system.description.value = (0,DDBTemplateStrings/* default */.ZP)(ddb, character, klass.system.description.value, klass).text;

    items.push(klass);
  }

  return items;
}


/***/ }),

/***/ 1126:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ DDBCompanion)
/* harmony export */ });
/* harmony import */ var _dictionary_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(37);
/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5259);
/* harmony import */ var _DDBMonster_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(317);
/* harmony import */ var _monster_features_DDBFeatureFactory_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(6928);
/* harmony import */ var _monster_templates_monster_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(1309);






class DDBCompanion {

  constructor(block, options = {}) {
    // console.warn("DDBCompanion", { block });
    this.options = options;
    this.block = block;
    this.blockDatas = this.block.querySelectorAll("p.Stat-Block-Styles_Stat-Block-Data");
    this.npc = null;
    this.data = {};
    this.parsed = false;
    this.type = this.options.type;

    this.useItemAC = false; // game.settings.get("ddb-importer", "munching-policy-monster-use-item-ac");
    this.legacyName = false; // game.settings.get("ddb-importer", "munching-policy-legacy-postfix");
    this.addMonsterEffects = true; // game.settings.get("ddb-importer", "munching-policy-add-monster-effects");
    this.removeSplitCreatureActions = true;
    this.removeCreatureOnlyNames = true;
  }

  #generateAbilities() {
    const abilityNodes = this.block.querySelector("div.stat-block-ability-scores");

    abilityNodes.querySelectorAll("div.stat-block-ability-scores-stat").forEach((aNode) => {
      const ability = aNode.querySelector("div.stat-block-ability-scores-heading").innerText.toLowerCase();

      const getFallbackAbility = () => {
        const clone = aNode.querySelector("div.stat-block-ability-scores-data").cloneNode(true);
        clone.getElementsByTagName("span")[0].innerHTML = "";
        return clone.innerText.trim();
      };

      const abilityScore = aNode.querySelector("span.stat-block-ability-scores-score")?.innerText
        ?? getFallbackAbility();

      const value = Number.parseInt(abilityScore);
      const mod = CONFIG.DDB.statModifiers.find((s) => s.value == value).modifier;

      this.npc.system.abilities[ability]['value'] = value;
      this.npc.system.abilities[ability]['mod'] = mod;
    });
  }

  getBlockData(type) {
    const block = Array.from(this.blockDatas).find((el) => {
      const elementName = el.innerText.trim();
      const elementStartsWith = elementName.startsWith(type);
      const isOnly = elementName.toLowerCase().includes("only")
        ? elementName.toLowerCase().includes(this.options.subType.toLowerCase())
        : true;
      return elementStartsWith && isOnly;
    });
    if (!block) return undefined;

    const header = block.getElementsByTagName("strong")[0].innerText.toLowerCase();
    if (header.includes("only") && !header.includes(this.options.subType.toLowerCase())) {
      return undefined;
    }

    const clone = block.cloneNode(true);
    clone.getElementsByTagName("strong")[0].innerHTML = "";
    return clone.innerText.trim();
  }

  // savings throws
  #generateSavingThrows() {
    const saveString = this.getBlockData("Saving Throws");
    if (!saveString) return;

    const saves = saveString.split(",");

    saves.forEach((save) => {
      const ability = save.trim().split(" ")[0].toLowerCase();
      if (save.includes("plus PB") || save.includes("+ PB")) {
        this.npc.system.abilities[ability]['proficient'] = 1;
      }
    });
  }

  #generateArmorClass() {
    const acString = this.getBlockData("Armor Class");
    if (!acString) return;

    const ac = Number.parseInt(acString.split(",")[0]);

    if (Number.isInteger(ac)) {
      this.npc.system.attributes.ac = {
        flat: ac,
        calc: "natural",
        formula: "",
      };

      if (acString.includes("plus PB") || acString.includes("+ PB")) {
        setProperty(this.npc, "flags.arbron-summoner.config.acFormula", `${ac} + @prof`);
      } else if (acString.includes("+ the level of the spell")) {
        setProperty(this.npc, "flags.arbron-summoner.config.acFormula", `${ac} + @details.level`);
      }
    }
  }

  #generateProficiencyBonus() {
    const profString = this.block.querySelector("p.Stat-Block-Styles_Stat-Block-Data-Last")
      ?? this.getBlockData("Challenge");

    if (profString && profString.innerText.includes("equals your bonus")) {
      setProperty(this.npc, "flags.arbron-summoner.config.matchProficiency", true);
    }
  }


  #getBaseHitPoints(hpString) {
    const baseString = this.options.subType && hpString.includes(" or ")
      ? hpString.split("or").find((s) => s.toLowerCase().includes(this.options.subType.toLowerCase()))
      : hpString.trim();

    const hpFind = baseString.trim().match(/(\d*)/);
    const hpInt = Number.parseInt(hpFind);
    return Number.isInteger(hpInt) ? hpInt : 0;
  }

  #generateHitPoints() {
    const hpString = this.getBlockData("Hit Points");
    if (!hpString) return;

    const hpInt = this.#getBaseHitPoints(hpString);
    this.npc.system.attributes.hp.max = hpInt;
    this.npc.system.attributes.hp.value = hpInt;

    // conditions
    // 5 + five times your druid level
    // 5 + five times your ranger level (the beast has a number of Hit Dice [d8s] equal to your ranger level)
    // 1 + your Intelligence modifier + your artificer level (the homunculus has a number of Hit Dice [d4s] equal to your artificer level)
    // 40 + 15 for each spell level above 4th
    // 20 (Air only) or 30 (Land and Water only) + 5 for each spell level above 2nd
    // 50 (Demon only) or 40 (Devil only) or 60 (Yugoloth only) + 15 for each spell level above 6th
    // 30 (Ghostly and Putrid only) or 20 (Skeletal only) + 10 for each spell level above 3rd

    // additional summon points
    const hpAdjustments = [hpInt];
    const modMatch = hpString.match(/\+ your (\w+) modifier/);

    if (modMatch) hpAdjustments.push(`@abilities.${modMatch[1].toLowerCase().substring(0, 3)}.mod`);

    // class level
    const klassMultiMatch = hpString.match(/\+ (\w+)?( times? )?your (\w+) level/);
    if (klassMultiMatch) {
      const klass = klassMultiMatch[3].trim().toLowerCase();
      const multiplier = klassMultiMatch[1]
        ? _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].numbers.find */ .Z.numbers.find((d) => d.natural === klassMultiMatch[1].trim().toLowerCase()).num
        : null;
      const multiplierString = multiplier ? ` * ${multiplier}` : "";
      hpAdjustments.push(`(@classes.${klass}.levels${multiplierString})`);
    }

    // spell level
    const spellLevelMatch = hpString.match(/\+ (\d+) for each spell level above (\d)/);
    if (spellLevelMatch) {
      hpAdjustments.push(`(${spellLevelMatch[1]} * (@item.level - ${spellLevelMatch[2]}))`);
    }

    if (hpAdjustments.length > 0) {
      setProperty(this.npc, "flags.arbron-summoner.config.hpFormula", hpAdjustments.join(" + "));
    }

  }

  #generateHitDie() {
    // (the beast has a number of Hit Dice [d8s] equal to your ranger level)
    // (the homunculus has a number of Hit Dice [d4s] equal to your artificer level)
    const hpString = this.getBlockData("Hit Points");
    if (!hpString || !hpString.includes("number of Hit Dice")) return;

    const hitDice = hpString.match(/Hit Dice \[d(\d)s\] equal to your (\w+) level/);
    if (hitDice) {
      const hitDiceAdjustment = {
        "key": "system.attributes.hp.formula",
        "value": `(@classes.${hitDice[2]}.levels)[d${hitDice[1]}]`
      };
      this.npc.flags["arbron-summoner"].config.actorChanges.push(hitDiceAdjustment);
    }
  }

  #generateSkills() {
    const skillString = this.getBlockData("Skills");
    if (!skillString) return;
    //  "History + 12, Perception +0 plus PB &times; 2"
    const skillsMaps = skillString.split(",").filter((str) => str != '').map((str) => {
      const skillMatch = str.trim().match(/(\w+ *\w* *\w*)(?: *)([+-])(?: *)(\d+) *(plus PB)? *(&times;|x|times)? *(\d*)?/);
      let result = {};
      if (skillMatch) {
        result = {
          name: skillMatch[1].trim(),
          value: skillMatch[2] + skillMatch[3],
          proficient: skillMatch[4] !== undefined,
          expertise: Number.isInteger(skillMatch[5]?.trim()),
          pbMultiplier: skillMatch[5],
        };
        _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Found skill for companion ${this.npc.name}`, result);
      } else {
        _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].error */ .Z.error(`Skill Parsing failed for ${this.npc.name}`);
        _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(skillString);
        _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(str);
        _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(skillMatch);
      }
      return result;
    });

    const keys = Object.keys(this.npc.system.skills);
    const validSkills = _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].character.skills.map */ .Z.character.skills.map((skill) => skill.name);
    keys
      .filter((key) => validSkills.includes(key))
      .forEach((key) => {
        let skill = this.npc.system.skills[key];
        const lookupSkill = _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].character.skills.find */ .Z.character.skills.find((s) => s.name == key);
        const skillData = skillsMaps.find((skl) => skl.name == lookupSkill.label);

        if (skillData) {
          skill.value = skillData.expertise ? 2 : skillData.proficient ? 1 : 0;
          const ability = this.npc.system.abilities[skill.ability];
          if (parseInt(ability.mod) !== parseInt(skillData.value.trim())) {
            skill.bonuses.check = parseInt(skillData.value.trim()) - parseInt(ability.mod);
            skill.bonuses.passive = parseInt(skillData.value.trim()) - parseInt(ability.mod);
          }

          this.npc.system.skills[key] = skill;
        }

      });
  }

  #generateSize() {
    const data = this.block.querySelector("p.Stat-Block-Styles_Stat-Block-Metadata").innerHTML;

    if (!data) return;
    const size = data.split(" ")[0];
    const sizeData = _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].sizes.find */ .Z.sizes.find((s) => size.toLowerCase() == s.name.toLowerCase())
      ?? { name: "Medium", value: "med", size: 1 };

    this.npc.system.traits.size = sizeData.value;
    this.npc.prototypeToken.width = sizeData.size >= 1 ? sizeData.size : 1;
    this.npc.prototypeToken.height = sizeData.size >= 1 ? sizeData.size : 1;
    this.npc.prototypeToken.scale = sizeData.size >= 1 ? 1 : sizeData.size;
  }

  #generateType() {
    const data = this.block.querySelector("p.Stat-Block-Styles_Stat-Block-Metadata").innerHTML;
    if (!data) return;
    const typeName = data.split(",")[0].split(" ").pop().toLowerCase();

    if (CONFIG.DND5E.creatureTypes[typeName]) {
      this.npc.system.details.type.value = typeName;
    } else {
      this.npc.system.details.type.value = "Unknown";
    }
  }

  #generateAlignment() {
    const data = this.block.querySelector("p.Stat-Block-Styles_Stat-Block-Metadata").innerHTML;
    if (!data) return;
    const alignment = data.split(",").pop().toLowerCase().trim();

    if (alignment && alignment !== "") this.npc.system.details.alignment = alignment;
  }

  static getDamageAdjustments(data) {
    const values = [];
    const custom = [];
    const damageTypes = _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].actions.damageType.filter */ .Z.actions.damageType.filter((d) => d.name !== null).map((d) => d.name);

    data.forEach((adj) => {
      if (damageTypes.includes(adj.toLowerCase())) {
        values.push(adj.toLowerCase());
      } else if (adj.includes("physical")) {
        values.push("physical");
      } else {
        custom.push(adj);
      }
    });

    const adjustments = {
      value: values,
      custom: custom.join("; "),
    };

    return adjustments;
  }

  filterDamageConditions(data) {
    const onlyFiltered = data.split(/[;,]/).filter((state) => {
      if (state.includes("only")) {
        if (state.toLowerCase().includes(this.options.subType.toLowerCase())) {
          return true;
        } else {
          return false;
        }
      } else {
        return true;
      }
    });

    const conditions = [];

    onlyFiltered.forEach((state) => {
      const results = state
        .split("and")
        .map((s) => {
          return s.split("(")[0].trim().toLowerCase();
        });
      conditions.push(...results);
    });

    return conditions;
  }

  // Damage Resistances acid (Water only); lightning and thunder (Air only); piercing and slashing (Earth only)
  // Damage Immunities poison; fire (Fire only)
  // Damage Immunities necrotic, poison
  // Condition Immunities exhaustion, frightened, paralyzed, poisoned
  #generateImmunities() {
    const data = this.getBlockData("Damage Immunities");
    if (!data) return;

    this.npc.system.traits.di = DDBCompanion.getDamageAdjustments(this.filterDamageConditions(data));
  }

  #generateResistances() {
    const data = this.getBlockData("Damage Resistances");
    if (!data) return;

    this.npc.system.traits.dr = DDBCompanion.getDamageAdjustments(this.filterDamageConditions(data));
  }

  #generateVulnerabilities() {
    const data = this.getBlockData("Damage Vulnerabilities");
    if (!data) return;

    this.npc.system.traits.dv = DDBCompanion.getDamageAdjustments(this.filterDamageConditions(data));
  }

  // Condition Immunities exhaustion, frightened, paralyzed, poisoned
  #generateConditions() {
    const data = this.getBlockData("Condition Immunities");
    if (!data) return;

    let values = [];
    let custom = [];

    data.split(",").forEach((adj) => {
      const valueAdjustment = _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].conditions.find */ .Z.conditions.find((condition) => condition.label.toLowerCase() == adj.trim().toLowerCase());
      if (valueAdjustment) {
        values.push(valueAdjustment.foundry);
      } else {
        custom.push(adj);
      }
    });

    // Condition Immunities charmed, exhaustion, frightened, incapacitated, paralyzed, petrified, poisoned
    this.npc.system.traits.ci = {
      value: values,
      custom: custom.join("; "),
    };
  }

  #generateSenses() {
    const data = this.getBlockData("Senses");
    if (!data) return;

    // darkvision 60 ft., passive Perception 10 + (PB &times; 2)
    // darkvision 60 ft., passive Perception 10 + (PB Ã— 2)

    data.split(",").forEach((sense) => {
      const match = sense.match(/(darkvision|blindsight|tremorsense|truesight)\s+(\d+)/i);

      if (match) {
        const value = parseInt(match[2]);
        this.npc.system.attributes.senses[match[1].toLowerCase()] = value;

        const senseType = _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].senseMap */ .Z.senseMap[match[1].toLowerCase()];

        if (value > 0 && value > this.npc.prototypeToken.sight.range && hasProperty(CONFIG.Canvas.visionModes, senseType)) {
          setProperty(this.npc.prototypeToken.sight, "visionMode", senseType);
          setProperty(this.npc.prototypeToken.sight, "range", value);
          this.npc.prototypeToken.sight = mergeObject(this.npc.prototypeToken.sight, CONFIG.Canvas.visionModes[senseType].vision.defaults);
        }
        if (value > 0 && hasProperty(_dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].detectionMap */ .Z.detectionMap, match[1].toLowerCase())) {
          const detectionMode = {
            id: _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].detectionMap */ .Z.detectionMap[match[1].toLowerCase()],
            range: value,
            enabled: true,
          };

          // only add duplicate modes if they don't exist
          if (!this.npc.prototypeToken.detectionModes.some((mode) => mode.id === detectionMode.id)) {
            this.npc.prototypeToken.detectionModes.push(detectionMode);
          }
        }
      }
    });
  }

  #generateLanguages() {
    const data = this.getBlockData("Languages");
    if (!data) return;

    // loop back to add small chance they have non-custom language support
    this.npc.system.traits.languages.custom = data;
  }

  #generateSpeed() {
    const data = this.getBlockData("Speed");
    if (!data) return;

    // 30 ft.; fly 40 ft. (hover) (Ghostly only)
    // 40 ft.; climb 40 ft. (Demon only); fly 60 ft. (Devil only)
    // 30 ft., fly 40 ft.

    const onlyFiltered = data.split(/[;,]/).filter((speed) => {
      if (speed.includes("only")) {
        if (speed.toLowerCase().includes(this.options.subType.toLowerCase())) {
          return true;
        } else {
          return false;
        }
      } else {
        return true;
      }
    });

    const speeds = [];
    onlyFiltered.forEach((state) => {
      const results = state
        .split("and")
        .map((s) => {
          return s.trim().toLowerCase();
        });
      speeds.push(...results);
    });

    speeds.forEach((speed) => {
      const match = speed.match(/(\w+ )*(\d+)/i);
      if (match) {
        const type = match[1]?.trim() ?? "walk";
        this.npc.system.attributes.movement[type] = parseInt(match[2]);
        if (speed.includes("hover")) this.npc.system.attributes.movement["hover"] = true;
      }
    });
  }


  async getFeature(text, type) {
    const options = { extra: true, useItemAC: this.useItemAC, legacyName: this.legacyName, addMonsterEffects: this.addMonsterEffects };
    const ddbMonster = new _DDBMonster_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z(null, options);
    ddbMonster.name = this.name;
    ddbMonster.npc = duplicate(this.npc);
    ddbMonster.abilities = ddbMonster.npc.system.abilities;
    ddbMonster.proficiencyBonus = 0;
    const featureFactory = new _monster_features_DDBFeatureFactory_js__WEBPACK_IMPORTED_MODULE_3__/* .DDBFeatureFactory */ ._({ ddbMonster, hideDescription: false, updateExisting: false });
    featureFactory.generateActions(text, type);
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug("Generating companion feature", { text, type, featureFactory });
    const toHitRegex = /(your spell attack modifier to hit)/i;
    if (toHitRegex.test(text)) {
      setProperty(this.npc, "flags.arbron-summoner.config.matchToHit", true);
    }
    const spellSaveRegex = /(against your spell save DC)/i;
    if (spellSaveRegex.test(text)) {
      setProperty(this.npc, "flags.arbron-summoner.config.matchSaveDCs", true);
    }
    return featureFactory.getFeatures(type);
  }


  async #processFeatureElement(element, featType) {
    let next = element.nextElementSibling;

    if (!next) return { next, featType };

    switch (next.innerText.trim().toLowerCase()) {
      case "action":
      case "actions":
        _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug("Companion parsing switching to actions");
        return { next, featType: "action" };
      case "reaction":
      case "reactions":
        _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug("Companion parsing switching to reactions");
        return { next, featType: "reaction" };
      case "bonus actions":
      case "bonus":
      case "bonus action":
        _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug("Companion parsing switching to bonus actions");
        return { next, featType: "bonus" };
      // no default
    }

    const features = await this.getFeature(next.outerHTML, featType);
    features.forEach((feature) => {
      if (this.removeSplitCreatureActions && feature.name.toLowerCase().includes("only")
        && feature.name.toLowerCase().includes(this.options.subType.toLowerCase())
      ) {
        if (this.removeCreatureOnlyNames) feature.name = feature.name.split("only")[0].split("(")[0].trim();
        this.npc.items.push(feature);
      } else if (!this.removeSplitCreatureActions || !feature.name.toLowerCase().includes("only")) {
        this.npc.items.push(feature);
      }
    });
    return { next, featType };
  }

  async #generateFeatures() {

    const data = this.block.querySelector("p.Stat-Block-Styles_Stat-Block-Data-Last");
    if (!data) {
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].error */ .Z.error(`Unable to parse ${this.npc.name} features and actions`, { this: this });
      return;
    }

    let now = data;
    let featType = "special";
    while (now !== null) {
      // eslint-disable-next-line no-await-in-loop
      const result = await this.#processFeatureElement(now, featType);
      now = result.next;
      featType = result.featType;
    }
  }

  // this parser creates actor data for a base actor
  // these are actors that are modified by the PB of the actor
  // these require the use of "arbron-summoner" module to run.
  // {
  //   "config": {
  //     "matchProficiency": true,
  //     "matchToHit": true,
  //     "matchSaveDCs": true,
  //     "acFormula": "22 + @prof",
  //     "hpFormula": "2 + @prof",
  //     "actorChanges": [
  //       {
  //         "key": "system.attributes.movement.fly",
  //         "value": "10"
  //       }
  //     ]
  //   }

  async parse() {
    // console.warn("PARSE COMPANION", { block: this.block, aThis: this });
    const name = this.options.name ?? this.block.querySelector("p.Stat-Block-Styles_Stat-Block-Title").innerHTML;
    const namePostfix = this.options.subType
      ? `(${this.options.subType})`
      : "";

    if (!name) return;
    this.name = name;
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Beginning companion parse for ${name}`, { name, block: this.block });

    const actorName = `${name} ${namePostfix}`.trim();
    this.npc = await (0,_monster_templates_monster_js__WEBPACK_IMPORTED_MODULE_4__/* .newNPC */ .N)(actorName);
    setProperty(this.npc, "flags.ddbimporter.companion.modifiers", {});
    this.npc.prototypeToken.name = actorName;

    setProperty(this.npc, "flags.arbron-summoner", {
      config: {
        matchProficiency: false,
        matchToHit: false,
        matchSaveDCs: false,
        acFormula: "",
        hpFormula: "",
        actorChanges: []
      }
    });

    setProperty(this.npc, "flags.ddbimporter.id", `companion-${actorName}`);
    setProperty(this.npc, "flags.ddbimporter.entityTypeId", `companion-${this.type}`);

    this.#generateSize();
    this.#generateType();
    this.#generateAbilities();
    this.#generateSavingThrows();
    this.#generateArmorClass();
    this.#generateProficiencyBonus();
    this.#generateHitPoints();
    this.#generateHitDie();
    this.#generateSkills();
    this.#generateImmunities();
    this.#generateResistances();
    this.#generateVulnerabilities();
    this.#generateConditions();
    this.#generateAlignment();
    this.#generateSenses();
    this.#generateLanguages();
    this.#generateSpeed();
    await this.#generateFeatures();

    // make friendly
    setProperty(this.npc, "prototypeToken.disposition", 1);

    this.data = duplicate(this.npc);
    this.parsed = true;

    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Finished companion parse for ${name}`, { name, block: this.block, data: this.data, npc: this.npc });
  }

}


/***/ }),

/***/ 3972:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ DDBCompanionFactory)
/* harmony export */ });
/* harmony import */ var _lib_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7669);
/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5259);
/* harmony import */ var _muncher_import_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9193);
/* harmony import */ var _muncher_importMonster_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(9633);
/* harmony import */ var _DDBCompanion_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(1126);






class DDBCompanionFactory {

  constructor(ddbCharacter, html, options = {}) {
    // console.warn("html", html);
    this.options = options;
    this.ddbCharacter = ddbCharacter;
    this.html = html;
    this.doc = new DOMParser().parseFromString(html.replaceAll("\n", ""), 'text/html');
    this.companions = [];
    this.actor = this.options.actor;
    this.folderIds = new Set();
    this.updateCompanions = true; //  game.settings.get("ddb-importer", "munching-policy-update-existing");
    this.updateImages = false; // game.settings.get("ddb-importer", "munching-policy-update-images");
    this.results = {
      created: [],
      updated: [],
    };
    this.originDocument = options.originDocument;
  }

  get data() {
    return this.options.data ?? this.companions.map((c) => c.data);
  }

  static MULTI = {
    "Aberrant Spirit": ["Slaad", "Beholderkin", "Star Spawn"],
    "Bestial Spirit": ["Air", "Land", "Water"],
    "Celestial Spirit": ["Avenger", "Defender"],
    "Construct Spirit": ["Clay", "Metal", "Stone"],
    "Elemental Spirit": ["Air", "Earth", "Fire", "Water"],
    "Fey Spirit": ["Fuming", "Mirthful", "Tricksy"],
    "Fiendish Spirit": ["Demon", "Devil", "Yugoloth"],
    "Shadow Spirit": ["Fury", "Despair", "Fear"],
    "Undead Spirit": ["Ghostly", "Putrid", "Skeletal"],
    "Drake Companion": ["Acid", "Cold", "Fire", "Lightning", "Poison"],
    "Draconic Spirit": ["Chromatic", "Gem", "Metallic"],
    // "Primal Companion": ["Beast of the Land", "Beast of the Sea", "Beast of the Sky"],
  };

  async #buildCompanion(block, options = {}) {
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug("Beginning companion parse", { block });
    const ddbCompanion = new _DDBCompanion_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z(block, mergeObject(options, { type: this.options.type }));
    // eslint-disable-next-line no-await-in-loop
    await ddbCompanion.parse();
    if (ddbCompanion.parsed) {
      this.companions.push(ddbCompanion);
    }
  }

  async parse() {
    // console.warn(this.doc);
    const statBlockDivs = this.doc.querySelectorAll("div.stat-block-background, div.stat-block-finder, div.basic-text-frame");

    // console.warn("statblkc divs", { statBlockDivs, athis: this });
    for (const block of statBlockDivs) {
      const name = block
        .querySelector("p.Stat-Block-Styles_Stat-Block-Title")
        .innerText
        .trim()
        .toLowerCase()
        .split(" ")
        .map((w) => _lib_utils_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].capitalize */ .Z.capitalize(w))
        .join(" ");

      if (name && name in DDBCompanionFactory.MULTI) {
        for (const subType of DDBCompanionFactory.MULTI[name]) {
          // eslint-disable-next-line no-await-in-loop
          await this.#buildCompanion(block, { name, subType });
        }
      } else {
        // eslint-disable-next-line no-await-in-loop
        await this.#buildCompanion(block, { name, subType: null });
      }

    }

    return this.data;
  }

  async #generateCompanionFolders(rootFolderName = "DDB Companions") {
    const rootFolder = await _lib_utils_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].getOrCreateFolder */ .Z.getOrCreateFolder(null, "Actor", rootFolderName);
    for (const companion of this.companions) {
      // eslint-disable-next-line no-await-in-loop
      const folder = await _lib_utils_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].getOrCreateFolder */ .Z.getOrCreateFolder(rootFolder, "Actor", _lib_utils_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].capitalize */ .Z.capitalize(companion.type ?? "other"));
      companion.data.folder = folder._id;
      this.folderIds.add(folder._id);
    }
  }

  async getExistingWorldCompanions({ folderOverride = null, rootFolderNameOverride = undefined, limitToFactory = false } = {}) {
    if (!folderOverride) await this.#generateCompanionFolders(rootFolderNameOverride);

    const companionNames = limitToFactory ? this.data.map((c) => c.name) : [];
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug("Matched companion names", companionNames);

    const existingCompanions = await game.actors.contents
      .filter((companion) => hasProperty(companion, "folder.id")
        && ((!folderOverride && this.folderIds.has(companion.folder.id))
          || folderOverride?.id === companion.folder.id)
        && (!limitToFactory || (limitToFactory && companionNames.includes(companion.name)))
      )
      .map((companion) => companion);
    return existingCompanions;
  }

  static async updateCompanions(companions, existingCompanions) {
    const updateCompanions = companions.filter((companion) =>
      existingCompanions.some(
        (exist) =>
          exist.flags?.ddbimporter?.id === companion.flags.ddbimporter.id
          && companion.flags?.ddbimporter?.entityTypeId === companion.flags.ddbimporter.entityTypeId
      ));

    const results = [];

    for (const companion of updateCompanions) {
      // eslint-disable-next-line no-await-in-loop
      const existingCompanion = await existingCompanions.find((exist) =>
        exist.flags?.ddbimporter?.id === companion.flags.ddbimporter.id
        && companion.flags?.ddbimporter?.entityTypeId === companion.flags.ddbimporter.entityTypeId
      );
      companion.folder = existingCompanion.folder?.id;
      companion._id = existingCompanion._id;
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].info */ .Z.info(`Updating companion ${companion.name}`);
      // eslint-disable-next-line no-await-in-loop
      await (0,_muncher_import_js__WEBPACK_IMPORTED_MODULE_2__/* .copySupportedItemFlags */ .uf)(existingCompanion, companion);
      // eslint-disable-next-line no-await-in-loop
      const npc = await (0,_muncher_importMonster_js__WEBPACK_IMPORTED_MODULE_3__/* .buildNPC */ .ln)(companion, "monster", false, true, true);
      results.push(npc);
    }

    return results;
  }

  static async createCompanions(companions, existingCompanions, folderId) {
    if (!game.user.can("ITEM_CREATE")) {
      ui.notifications.warn(`User is unable to create world items, and cannot create companions`);
      return [];
    }
    const newCompanions = companions.filter((companion) =>
      !existingCompanions.some(
        (exist) =>
          exist.flags?.ddbimporter?.id === companion.flags.ddbimporter.id
          && companion.flags?.ddbimporter?.entityTypeId === companion.flags.ddbimporter.entityTypeId
      ));

    const results = [];
    for (const companion of newCompanions) {
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].info */ .Z.info(`Creating Companion ${companion.name}`);
      if (folderId) companion.folder = folderId;
      // eslint-disable-next-line no-await-in-loop
      const importedCompanion = await (0,_muncher_importMonster_js__WEBPACK_IMPORTED_MODULE_3__/* .buildNPC */ .ln)(companion, "monster", false, false, true);
      results.push(importedCompanion);
    }
    return results;
  }

  async updateOrCreateCompanions({ folderOverride = null, rootFolderNameOverride = undefined } = {}) {
    const existingCompanions = await this.getExistingWorldCompanions({ folderOverride, rootFolderNameOverride });

    let companionData = this.data;

    if (!this.updateCompanions || !this.updateImages) {
      if (!this.updateImages) {
        _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug("Copying monster images across...");
        companionData = (0,_muncher_importMonster_js__WEBPACK_IMPORTED_MODULE_3__/* .copyExistingMonsterImages */ .ph)(companionData, existingCompanions);
      }
    }

    let finalCompanions = await (0,_muncher_import_js__WEBPACK_IMPORTED_MODULE_2__/* .srdFiddling */ .cC)(companionData, "monsters");
    await (0,_muncher_importMonster_js__WEBPACK_IMPORTED_MODULE_3__/* .generateIconMap */ .NM)(finalCompanions);

    if (this.updateCompanions) {
      this.results.updated = await DDBCompanionFactory.updateCompanions(finalCompanions, existingCompanions);
    }
    this.results.created = await DDBCompanionFactory.createCompanions(finalCompanions, existingCompanions, folderOverride?.id);

    // add companions to automated evocations list
    if (this.actor && game.modules.get("automated-evocations")?.active) {
      const currentAutomatedEvocationSettings = {
        isLocal: this.actor.getFlag("automated-evocations", "isLocal"),
        companions: this.actor.getFlag("automated-evocations", "isLocal"),
      };

      const companions = existingCompanions.concat(this.results.created).map((companion) => {
        return {
          id: companion.id ? companion.id : companion._id,
          number: 1,
          animation: companion.flags?.ddbimporter?.automatedEvcoationAnimation
            ? companion.flags?.ddbimporter?.automatedEvcoationAnimation
            : "magic1",
        };
      });
      const newAutomatedEvocationSettings = {
        isLocal: true,
        companions,
      };
      const mergedSettings = mergeObject(currentAutomatedEvocationSettings, newAutomatedEvocationSettings);

      this.actor.setFlag("automated-evocations", "isLocal", mergedSettings.isLocal);
      this.actor.setFlag("automated-evocations", "companions", mergedSettings.companions);
    }
  }

}


/***/ }),

/***/ 1634:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "_": () => (/* binding */ generateCharacterExtras)
/* harmony export */ });
/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5259);
/* harmony import */ var _lib_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7669);
/* harmony import */ var _muncher_DDBMonsterFactory_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(6870);
/* harmony import */ var _monster_helpers_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(5371);
/* harmony import */ var _dictionary_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(37);
/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(6451);
/* harmony import */ var _companions_DDBCompanionFactory_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(3972);








function getCustomValue(ddbCharacter, typeId, valueId, valueTypeId) {
  const characterValues = ddbCharacter.characterValues;
  const customValue = characterValues.find(
    (value) => value.valueId == valueId && value.valueTypeId == valueTypeId && value.typeId == typeId
  );

  if (customValue) {
    return customValue.value;
  }
  return null;
}

function generateBeastCompanionEffects(extra, characterProficiencyBonus) {
  // beast master get to add proficiency bonus to current attacks, damage, ac
  // and saving throws and skills it is proficient in.
  // extra.system.details.cr = actor.system.flags.ddbimporter.dndbeyond.totalLevels;

  let effect = {
    changes: [
      {
        key: "data.bonuses.rwak.attack",
        mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
        value: `+${characterProficiencyBonus}`,
        priority: 20,
      },
      {
        key: "data.bonuses.rwak.damage",
        mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
        value: `+${characterProficiencyBonus}`,
        priority: 20,
      },
      {
        key: "data.bonuses.mwak.attack",
        mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
        value: `+${characterProficiencyBonus}`,
        priority: 20,
      },
      {
        key: "data.bonuses.mwak.damage",
        mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
        value: `+${characterProficiencyBonus}`,
        priority: 20,
      },
    ],
    duration: {
      seconds: null,
      startTime: null,
      rounds: null,
      turns: null,
      startRound: null,
      startTurn: null,
    },
    label: "Beast Companion Effects",
    tint: "",
    disabled: false,
    selectedKey: [],
  };
  _dictionary_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].character.abilities.filter */ .Z.character.abilities.filter((ability) => extra.system.abilities[ability.value].proficient >= 1).forEach((ability) => {
    const boost = {
      key: `data.abilities.${ability.value}.save`,
      mode: CONST.ACTIVE_EFFECT_MODES.ADD,
      value: characterProficiencyBonus,
      priority: 20,
    };
    effect.selectedKey.push(`data.abilities.${ability.value}.save`);
    effect.changes.push(boost);
  });
  _dictionary_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].character.skills.filter */ .Z.character.skills.filter((skill) => extra.system.skills[skill.name].prof >= 1).forEach((skill) => {
    const boost = {
      key: `data.skills.${skill.name}.mod`,
      mode: CONST.ACTIVE_EFFECT_MODES.ADD,
      value: characterProficiencyBonus,
      priority: 20,
    };
    effect.selectedKey.push(`data.skills.${skill.name}.mod`);
    effect.changes.push(boost);
  });
  extra.effects = [effect];
  return extra;
}

function generateArtificerDamageEffect(actor, extra) {
  // artificer uses the actors spell attack bonus, so is a bit trickier
  // we remove damage bonus later, and will also have to calculate additional attack bonus for each attack
  extra.system.details.cr = actor.flags.ddbimporter.dndbeyond.totalLevels;

  let effect = {
    changes: [
      {
        key: "data.bonuses.rwak.damage",
        mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
        value: "+ @prof",
        priority: 20,
      },
      {
        key: "data.bonuses.mwak.damage",
        mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
        value: "+ @prof",
        priority: 20,
      },
    ],
    duration: {
      seconds: null,
      startTime: null,
      rounds: null,
      turns: null,
      startRound: null,
      startTurn: null,
    },
    label: "Artificer Extra Effects",
    tint: "",
    disabled: false,
    selectedKey: [],
  };
  extra.effects = [effect];
  return extra;
}

const creatureGroupMatrix = [
  {
    id: 1,
    name: "Wildshape",
    animation: "fourelements",
  },
  {
    id: 2,
    name: "Familiar",
    animation: "magic1",
  },
  {
    id: 3,
    name: "Beast Companion",
    animation: "fourelements",
  },
  {
    id: 4,
    name: "Mount",
    animation: "heart",
  },
  {
    id: 5,
    name: "Pet",
    animation: "heart",
  },
  {
    id: 6,
    name: "Summoned",
    animation: "magic1",
  },
  {
    id: 7,
    name: "Misc",
    animation: "magic1",
  },
  {
    id: 10,
    name: "Battle Smith Defender",
    animation: "energy1",
  },
  {
    id: 11,
    name: "Sidekick",
    animation: "energy1",
  },
  {
    id: 12,
    name: "Infusion",
    animation: "energy1",
  },
];

function getCreatureAnimationType(name, creatureGroup) {
  // "fire":
  // "air":
  // "lightning":
  // "water":
  // "energy1":
  // "magic1":
  // "heart":
  // "music":
  // "fourelements":
  const checkName = name.toLowerCase();
  let animation = "magic1";
  switch (name) {
    case checkName.includes("flame"):
    case checkName.includes("fire"):
      animation = "fire";
      break;
    case checkName.includes("air"):
    case checkName.includes("wind"):
      animation = "air";
      break;
    case checkName.includes("lightning"):
    case checkName.includes("thunder"):
      animation = "lightning";
      break;
    case checkName.includes("water"):
    case checkName.includes("aqua"):
      animation = "water";
      break;
    case checkName.includes("energy"):
    case checkName.includes("construct"):
      animation = "energy1";
      break;
    case checkName.includes("magic"):
    case checkName.includes("arcane"):
      animation = "magic1";
      break;
    default: {
      const match = creatureGroupMatrix.find((group) => group.id === creatureGroup.id);
      if (match) {
        animation = match.animation;
      }
    }
  }

  return animation;
}

function setExtraMunchDefaults() {
  let munchSettings = [];

  _settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MUNCH_DEFAULTS.forEach */ .Z.MUNCH_DEFAULTS.forEach((setting) => {
    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug(`Loading extras munch settings ${setting.name}`);
    setting["chosen"] = game.settings.get("ddb-importer", setting.name);
    munchSettings.push(setting);
  });

  munchSettings.forEach((setting) => {
    game.settings.set("ddb-importer", setting.name, setting.needed);
  });

  return munchSettings;

}

function revertExtraMunchDefaults(munchSettings) {
  munchSettings.forEach((setting) => {
    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug(`Returning ${setting.name} to ${setting.chosen}`);
    game.settings.set("ddb-importer", setting.name, setting.chosen);
  });
}

function addOwnerSkillProficiencies(ddbCharacter, mock) {
  let newSkills = [];
  const proficiencyBonus = CONFIG.DDB.challengeRatings.find(
    (cr) => cr.id == mock.challengeRatingId
  ).proficiencyBonus;

  _dictionary_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].character.skills.forEach */ .Z.character.skills.forEach((skill) => {
    const existingSkill = mock.skills.find((mockSkill) => skill.valueId === mockSkill.skillId);
    const characterProficient = ddbCharacter.source.character.character.system.skills[skill.name].value;
    const ability = _dictionary_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].character.abilities.find */ .Z.character.abilities.find((ab) => ab.value === skill.ability);
    const stat = mock.stats.find((stat) => stat.statId === ability.id).value || 10;
    const mod = CONFIG.DDB.statModifiers.find((s) => s.value == stat).modifier;

    if (existingSkill && characterProficient === 2) {
      const doubleProf = proficiencyBonus * 2;
      newSkills.push({
        skillId: skill.valueId,
        value: mod + doubleProf,
        additionalBonus: null,
      });
    } else if (existingSkill) {
      newSkills.push(existingSkill);
    } else if (characterProficient === 1) {
      newSkills.push({
        skillId: skill.valueId,
        value: mod + proficiencyBonus,
        additionalBonus: null,
      });
    }
  });
  mock.skills = newSkills;

  return mock;
}

function addOwnerSaveProficiencies(ddbCharacter, mock) {
// add owner save profs
  let newSaves = [];
  _dictionary_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].character.abilities.forEach */ .Z.character.abilities.forEach((ability) => {
    const existingProficient = mock.savingThrows.find((stat) => stat.statId === ability.id) ? 1 : 0;
    const characterProficient = ddbCharacter.abilities.withEffects[ability.value].proficient;

    if (existingProficient || characterProficient) {
      const bonus = {
        bonusModifier: null,
        statId: ability.id,
      };
      newSaves.push(bonus);
    }
  });
  mock.savingThrows = newSaves;
  return mock;
}

function addAverageHitPoints(ddbCharacterData, actor, creature, mock) {
  // hp
  const hpMaxChange = getCustomValue(ddbCharacterData, 43, creature.id, creature.entityTypeId);
  if (hpMaxChange) mock.averageHitPoints = hpMaxChange;

  // assume this is beast master
  if (mock.creatureFlags.includes("HPLM")) {
    const ranger = ddbCharacterData.classes.find((klass) => klass.definition.id === 5);
    const level = ranger ? ranger.level : 0;
    mock.averageHitPoints = Math.max(mock.averageHitPoints, 4 * level);
  }

  // homunculus servant
  // Max Hit Points Base Artificer Level
  if (mock.creatureFlags.includes("MHPBAL")) {
    const artificer = ddbCharacterData.classes.find((klass) => klass.definition.name === "Artificer");
    if (artificer) {
      mock.averageHitPoints = parseInt(artificer.level);
      setProperty(mock, "hitPointDice.diceCount", artificer.level);
      setProperty(mock, "hitPointDice.diceString", `${artificer.level}d${mock.hitPointDice.diceValue}`);
    }
  }

  if (mock.creatureFlags.includes("AHM")) {
    const artificer = ddbCharacterData.classes.find((klass) => klass.definition.name === "Artificer");
    if (artificer) {
      mock.averageHitPoints = parseInt(5 * artificer.level);
    }
  }

  // Max Hit Points Add Int Modifier
  if (mock.creatureFlags.includes("MHPAIM")) {
    mock.averageHitPoints += parseInt(actor.system.abilities.int.mod);
  }

  // Max Hit Points Add Monster CON Modifier
  if (mock.creatureFlags.includes("MHPAMCM")) {
    const monsterConModifier = (0,_monster_helpers_js__WEBPACK_IMPORTED_MODULE_3__/* .getAbilityMods */ .T)(mock, CONFIG.DDB);
    mock.averageHitPoints += parseInt(monsterConModifier.con);
  }

  return mock;
}

function addCreatureStats(mock, actor) {
  const creatureStats = mock.stats.filter((stat) => !mock.creatureGroup.ownerStats.includes(stat.statId));
  const characterStats = mock.stats
    .filter((stat) => mock.creatureGroup.ownerStats.includes(stat.statId))
    .map((stat) => {
      const value = actor.system.abilities[_dictionary_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].character.abilities.find */ .Z.character.abilities.find((a) => a.id === stat.statId).value].value;
      return { name: null, statId: stat.statId, value: value };
    });

  mock.stats = creatureStats.concat(characterStats);
  return mock;
}

function addCreatureFlags(creature, mock) {
  const creatureGroup = CONFIG.DDB.creatureGroups.find((group) => group.id == creature.groupId);
  let creatureFlags = creatureGroup.flags;

  if (creature.definition.name === "Homunculus Servant") {
    // Max Hit Points Add Monster CON Modifier
    // Max Hit Points Add Int Modifier
    // Max Hit Points Base Artificer Level
    // Attack Rolls Add Proficiency Bonus
    // Proficient Skills Add Proficiency Bonus
    creatureFlags = creatureFlags.concat(["MHPAMCM", "MHPAIM", "MHPBAL", "ARPB", "PSPB"]);
  }
  mock.creatureFlags = creatureFlags;
  mock.creatureGroupId = creature.groupId;
  mock.creatureGroup = creatureGroup;

  return mock;

}

function transformExtraToMonsterData(ddbCharacter, actor, creature) {
  let ddbCharacterData = ddbCharacter.source.ddb.character;
  _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug("Extra data", creature);
  let mock = duplicate(creature.definition);
  mock.id = creature.id;
  mock.entityTypeId = creature.entityTypeId;
  mock = addCreatureFlags(creature, mock);

  if (creature.name) mock.name = creature.name;

  // creature group
  mock.automatedEvcoationAnimation = getCreatureAnimationType(mock.name, mock.creatureGroup);

  // size
  const sizeChange = getCustomValue(ddbCharacterData, 46, creature.id, creature.entityTypeId);
  if (sizeChange) mock.sizeId = sizeChange;

  // hp
  mock = addAverageHitPoints(ddbCharacterData, actor, creature, mock);
  mock.removedHitPoints = creature.removedHitPoints;
  mock.temporaryHitPoints = creature.temporaryHitPoints;

  // creature type
  const typeChange = getCustomValue(ddbCharacterData, 44, creature.id, creature.entityTypeId);
  if (typeChange) mock.typeId = typeChange;

  // ac
  const acChange = getCustomValue(ddbCharacterData, 42, creature.id, creature.entityTypeId);
  if (acChange) mock.armorClass = acChange;

  // alignment
  const alignmentChange = getCustomValue(ddbCharacterData, 45, creature.id, creature.entityTypeId);
  if (alignmentChange) mock.alignmentId = alignmentChange;

  // notes
  const extraNotes = getCustomValue(ddbCharacterData, 47, creature.id, creature.entityTypeId);
  if (extraNotes) mock.characteristicsDescription += `\n\n${extraNotes}`;

  // stats
  mock = addCreatureStats(mock, actor);

  // ownership the same as actor
  mock.ownership = actor.ownership;

  if (mock.creatureGroup.description !== "") {
    mock.characteristicsDescription = `${mock.creatureGroup.description}\n\n${mock.characteristicsDescription}`;
  }

  if (mock.creatureGroup.specialQualityTitle) {
    mock.specialTraitsDescription = `${mock.specialTraitsDescription} <p><em><strong>${mock.creatureGroup.specialQualityTitle}.</strong></em> ${mock.creatureGroup.specialQualityText}</p>`;
  }

  // Armor Add Proficiency Bonus
  if (mock.creatureFlags.includes("ACPB")) {
    mock.armorClass += actor.system.attributes.prof;
  }

  // Evaluate Owner Skill Proficiencies
  if (mock.creatureFlags.includes("EOSKP")) {
    mock = addOwnerSkillProficiencies(ddbCharacter, mock);
  }

  // Evaluate Owner Save Proficiencies
  if (mock.creatureFlags.includes("EOSVP")) {
    mock = addOwnerSaveProficiencies(ddbCharacter, mock);
  }

  // Cannot Use Legendary Actions
  if (mock.creatureFlags.includes("CULGA")) {
    mock.isLegendary = false;
    mock.legendaryActionsDescription = "";
  }

  // Cannot Use Lair Actions
  if (mock.creatureFlags.includes("CULRA")) {
    mock.hasLair = false;
    mock.lairDescription = "";
  }

  _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug("mock creature", mock);
  return mock;

}

function enhanceParsedExtra(actor, extra) {
  const damageDiceExpression = /(\d*d\d+\s*\+*\s*)+/;
  const characterProficiencyBonus = actor.system.attributes.prof;
  const artificerBonusGroup = [10, 12];

  if (
    extra.flags?.ddbimporter?.creatureFlags?.includes("ARPB") // Attack Rolls Add Proficiency Bonus
    && extra.flags?.ddbimporter?.creatureFlags?.includes("PSPB") // Proficient Skills Add Proficiency Bonus
  ) {
    if (extra.flags?.ddbimporter?.creatureGroupId === 3) {
      extra = generateBeastCompanionEffects(extra, characterProficiencyBonus);
    } else if (artificerBonusGroup.includes(extra.flags?.ddbimporter?.creatureGroupId)) {
      // artificer uses the actors spell attack bonus, so is a bit trickier
      // we remove damage bonus later, and will also have to calculate additional attack bonus for each attack
      extra = generateArtificerDamageEffect(actor, extra, characterProficiencyBonus);
    } else {
      // who knows!
      extra.system.details.cr = actor.flags.ddbimporter.dndbeyond.totalLevels;
    }
  }

  if (
    // Damage Rolls Add Proficiency Bonus
    (extra.flags?.ddbimporter?.creatureFlags?.includes("DRPB") && extra.flags?.ddbimporter?.creatureGroupId !== 3)
    // is this a artificer infusion? the infusion call actually adds this creature group, but we don't fetch that yet.
    || extra.flags?.ddbimporter?.creatureGroupId === 12
  ) {
    extra.items = extra.items.map((item) => {
      if (item.type === "weapon") {
        let characterAbility;

        item.system.damage.parts = item.system.damage.parts.map((part) => {
          const match = part[0].match(damageDiceExpression);
          if (match) {
            let dice = match[0];
            // the artificer creatures have the initial prof built in, lets replace it
            if (artificerBonusGroup.includes(extra.flags?.ddbimporter?.creatureGroupId)) {
              characterAbility = "int";
              dice = match[1].trim().endsWith("+") ? match[1].trim().slice(0, -1) : match[1];
            }
            part[0] = `${dice.trim()}`;
          }

          return part;
        });

        if (characterAbility) {
          const ability = item.system.ability;
          const mod = parseInt(extra.system.abilities[ability].mod);
          const characterMod = parseInt(actor.system.abilities[characterAbility].mod);
          // eslint-disable-next-line no-eval
          const globalMod = parseInt(eval(actor.system.bonuses.rsak.attack || 0));
          item.system.attackBonus = characterMod + globalMod - mod;
        }
      }
      return item;
    });
  }

  return extra;
}

async function generateCharacterExtras(html, ddbCharacter, actor) {
  const munchSettings = setExtraMunchDefaults();

  try {
    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug("ddbCharacter", ddbCharacter);
    if (ddbCharacter.source.ddb.character.creatures.length === 0) return;

    const folder = await _lib_utils_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].getOrCreateFolder */ .Z.getOrCreateFolder(actor.folder, "Actor", `[Extras] ${actor.name}`);

    const extractedCreatures = ddbCharacter.source.ddb.character.creatures
      .map((creature) => transformExtraToMonsterData(ddbCharacter, actor, creature))
      .map((creature) => {
        creature.folder = folder.id;
        return creature;
      });

    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug("Extracted creatures", duplicate(extractedCreatures));
    const monsterFactory = new _muncher_DDBMonsterFactory_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z({ ddbData: extractedCreatures, extra: true });
    const parsedExtras = await monsterFactory.parse();
    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug("Parsed Extras:", duplicate(parsedExtras.actors));

    const enhancedExtras = parsedExtras.actors.map((extra) => enhanceParsedExtra(actor, extra));
    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug("Enhanced Parsed Extras:", duplicate(enhancedExtras));

    const ddbCompanionFactory = new _companions_DDBCompanionFactory_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z(ddbCharacter, "", { actor, data: enhancedExtras });
    await ddbCompanionFactory.updateOrCreateCompanions({ folderOverride: folder });

  } catch (err) {
    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].error */ .Z.error("Failure parsing extra", err);
    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].error */ .Z.error(err.stack);
  } finally {
    revertExtraMunchDefaults(munchSettings);
  }
}


/***/ }),

/***/ 2243:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Eb": () => (/* binding */ getDescription),
/* harmony export */   "OV": () => (/* binding */ setLevelScales),
/* harmony export */   "YL": () => (/* binding */ addFeatEffects),
/* harmony export */   "fg": () => (/* binding */ addExtraEffects),
/* harmony export */   "tC": () => (/* binding */ fixFeatures)
/* harmony export */ });
/* harmony import */ var _lib_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7669);
/* harmony import */ var _lib_DDBHelper_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1438);
/* harmony import */ var _effects_effects_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5751);
/* harmony import */ var _effects_acEffects_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(2877);
/* harmony import */ var _muncher_table_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(7967);
/* harmony import */ var _effects_specialFeats_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(9038);
/* harmony import */ var _lib_DDBTemplateStrings_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(258);
// import DICTIONARY from "../../dictionary.js";
// import logger from "../../logger.js";








function generateFeatModifiers(ddb, ddbItem, choice, type) {
  // console.warn(ddbItem);
  // console.log(choice);
  if (ddbItem.grantedModifiers) return ddbItem;
  let modifierItem = duplicate(ddbItem);
  const modifiers = [
    _lib_DDBHelper_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].getChosenClassModifiers */ .Z.getChosenClassModifiers(ddb, true, true),
    _lib_DDBHelper_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].getModifiers */ .Z.getModifiers(ddb, "race", true, true),
    _lib_DDBHelper_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].getModifiers */ .Z.getModifiers(ddb, "background", true, true),
    _lib_DDBHelper_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].getModifiers */ .Z.getModifiers(ddb, "feat", true, true),
  ].flat();

  // console.warn(modifiers);
  // console.log(ddb.character.options[type]);
  // console.warn(`${ddbItem.name} Adding modifiers`, { ddbItem, choice, type, modifiers });
  // console.log(type);
  // if (type === "race") console.log(modifiers);

  if (!modifierItem.definition) modifierItem.definition = {};
  modifierItem.definition.grantedModifiers = modifiers.filter((mod) => {
    if (mod.componentId === ddbItem.definition?.id && mod.componentTypeId === ddbItem.definition?.entityTypeId)
      return true;
    if (choice && ddb.character.options[type]?.length > 0) {
      // if it is a choice option, try and see if the mod matches
      const choiceMatch = ddb.character.options[type].some(
        (option) =>
          // id match
          choice.componentId == option.componentId // the choice id matches the option componentID
          && option.definition.id == mod.componentId // option id and mod id match
          && (choice.componentTypeId == option.componentTypeId // either the choice componenttype and optiontype match or
            || choice.componentTypeId == option.definition.entityTypeId) // the choice componentID matches the option definition entitytypeid
          && option.definition.entityTypeId == mod.componentTypeId // mod componentId matches option entity type id
          && choice.id == mod.componentId // choice id and mod id match
      );
      // console.log(`choiceMatch ${choiceMatch}`);
      if (choiceMatch) return true;
    } else if (choice) {
      // && choice.parentChoiceId
      const choiceIdSplit = choice.choiceId.split("-").pop();
      if (mod.id == choiceIdSplit) return true;
    }

    if (mod.componentId === ddbItem.id || mod.componentId === ddbItem.definition?.id) {
      if (type === "class") {
        // logger.log("Class check - feature effect parsing");
        const classFeatureMatch = ddb.character.classes.some((klass) =>
          klass.classFeatures.some(
            (f) => f.definition.entityTypeId == mod.componentTypeId && f.definition.id == ddbItem.id
          )
        );
        if (classFeatureMatch) return true;
      } else if (type === "feat") {
        const featMatch = ddb.character.feats.some(
          (f) => f.definition.entityTypeId == mod.componentTypeId && f.definition.id == ddbItem.id
        );
        if (featMatch) return true;
      } else if (type === "race") {
        const traitMatch = ddb.character.race.racialTraits.some(
          (t) =>
            t.definition.entityTypeId == mod.componentTypeId
            && t.definition.id == mod.componentId
            && t.definition.id == ddbItem.definition.id
        );
        if (traitMatch) return true;
      }
    }
    return false;
  });
  // console.warn("Modifier Item", modifierItem);
  return modifierItem;
}

function addFeatEffects(ddb, character, ddbItem, item, choice, type) {
  // can we apply any effects to this feature
  const daeInstalled = game.modules.get("dae")?.active;
  const compendiumItem = character.flags.ddbimporter.compendium;
  const addCharacterEffects = compendiumItem
    ? game.settings.get("ddb-importer", "munching-policy-add-effects")
    : game.settings.get("ddb-importer", "character-update-policy-add-character-effects");
  const modifierItem = generateFeatModifiers(ddb, ddbItem, choice, type);
  if (daeInstalled && addCharacterEffects) {
    item = (0,_effects_effects_js__WEBPACK_IMPORTED_MODULE_2__/* .generateEffects */ .K7)(ddb, character, modifierItem, item, compendiumItem, "feat");
    // console.log(item);
  }

  item = (0,_effects_acEffects_js__WEBPACK_IMPORTED_MODULE_3__/* .generateBaseACItemEffect */ .se)(ddb, character, modifierItem, item, compendiumItem);

  return item;
}

function setConsumeAmount(feature) {
  // ki point detection
  const kiPointRegex = /(?:spend|expend) (\d) ki point/;
  const match = feature.system.description.value.match(kiPointRegex);
  if (match) {
    setProperty(feature, "system.consume.amount", match[1]);
  }
  return feature;
}

function buildFullDescription(main, summary, title) {
  let result = "";

  if (summary && !_lib_utils_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].stringKindaEqual */ .Z.stringKindaEqual(main, summary) && summary.trim() !== "" && main.trim() !== "") {
    result += summary.trim();
    result += `
<details>
  <summary>
    ${title ? title : "More Details"}
  </summary>
  <p>
    ${main.trim()}
  </p>
</details>`;
  } else if (main.trim() === "") {
    result += summary.trim();
  } else {
    result += main.trim();
  }

  return result;
}

function getClassFeatureDescription(ddb, character, feat) {
  const componentId = feat.definition?.componentId
    ? feat.definition.componentId
    : feat.componentId;
  const componentTypeId = feat.definition?.componentTypeId
    ? feat.definition.componentTypeId
    : feat.componentTypeId;

  const findFeatureKlass = ddb.character.classes
    .find((cls) => cls.classFeatures.find((feature) =>
      feature.definition.id == componentId
      && feature.definition.entityTypeId == componentTypeId
    ));

  if (findFeatureKlass) {
    const feature = findFeatureKlass.classFeatures
      .find((feature) =>
        feature.definition.id == componentId
        && feature.definition.entityTypeId == componentTypeId
      );
    if (feature) {
      return (0,_lib_DDBTemplateStrings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .ZP)(ddb, character, feature.definition.description, feat).text;
    }
  }
  return "";

}


function getDescription(ddb, character, feat, forceFull = false) {
  // for now none actions probably always want the full text
  const useFullSetting = game.settings.get("ddb-importer", "character-update-policy-use-full-description");
  const useFull = forceFull || useFullSetting;
  const chatAdd = game.settings.get("ddb-importer", "add-description-to-chat");

  const rawSnippet = feat.definition?.snippet
    ? (0,_lib_DDBTemplateStrings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .ZP)(ddb, character, feat.definition.snippet, feat).text
    : feat.snippet
      ? (0,_lib_DDBTemplateStrings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .ZP)(ddb, character, feat.snippet, feat).text
      : "";

  const description = feat.definition?.description && feat.definition.description !== ""
    ? (0,_lib_DDBTemplateStrings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .ZP)(ddb, character, feat.definition.description, feat).text
    : feat.description && feat.description !== ""
      ? (0,_lib_DDBTemplateStrings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .ZP)(ddb, character, feat.description, feat).text
      : getClassFeatureDescription(ddb, character, feat);

  const snippet = _lib_utils_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].stringKindaEqual */ .Z.stringKindaEqual(description, rawSnippet) ? "" : rawSnippet;
  const fullDescription = buildFullDescription(description, snippet);
  const value = !useFull && snippet.trim() !== "" ? snippet : fullDescription;

  return {
    value: value,
    chat: chatAdd ? snippet : "",
    unidentified: "",
  };
}

function setLevelScales(classes, features) {
  const useScale = game.settings.get("ddb-importer", "character-update-policy-use-scalevalue");
  if (useScale) {
    features.forEach((feature) => {
      const featureName = _lib_utils_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].referenceNameString */ .Z.referenceNameString(feature.name.toLowerCase());
      const scaleKlass = classes.find((klass) =>
        klass.system.advancement
          .some((advancement) => advancement.type === "ScaleValue"
            && advancement.configuration.identifier === featureName
          ));

      if (scaleKlass) {
        if (hasProperty(feature, "system.damage.parts") && feature.system.damage.parts.length > 0) {
          feature.system.damage.parts[0][0] = `@scale.${scaleKlass.system.identifier}.${featureName}`;
        } else {
          setProperty(feature, "system.damage.parts", [[`@scale.${scaleKlass.system.identifier}.${featureName}`]]);
        }
      }
    });
  }
}

/**
 * Some features we need to fix up or massage because they are modified
 * in interesting ways
 * @param {*} ddb
 * @param {*} features
 */
function fixFeatures(features) {
  const useScale = game.settings.get("ddb-importer", "character-update-policy-use-scalevalue");
  // eslint-disable-next-line complexity
  features.forEach((feature) => {
    const name = feature.flags.ddbimporter.originalName || feature.name;
    switch (name) {
      case "Action Surge": {
        feature.system.damage = { parts: [], versatile: "", value: "" };
        break;
      }
      case "Arcane Propulsion Armor Gauntlet": {
        feature.system.damage.parts[0][0] += " + @mod";
        break;
      }
      case "Arms of the Astral Self: Summon": {
        feature.system.target.type = "enemy";
        feature.system.target.units = "all";
        feature.system.range.value = 10;
        feature.system.range.units = "ft";
        break;
      }
      case "Bardic Inspiration": {
        feature.system.actionType = "util";
        feature.system.duration = {
          value: 10,
          units: "minute",
        };
        feature.system.target = {
          value: 1,
          width: null,
          units: "",
          type: "creature",
        };
        feature.system.range.value = 60;
        feature.system.range.units = "ft";
        break;
      }
      case "Blessed Healer": {
        feature.system.activation.type = "special";
        feature.system.activation.cost = null;
        feature.system.actionType = "heal";
        feature.system["target"]["type"] = "self";
        feature.system.range = { value: null, units: "self", long: null };
        feature.system.uses = { value: null, max: "0", per: "", type: "" };
        break;
      }
      case "Celestial Revelation": {
        feature.system.activation.type = "";
        feature.system.actionType = "";
        feature.system.uses = {
          value: null,
          max: null,
          per: "",
        };
        break;
      }
      case "Channel Divinity: Radiance of the Dawn":
        feature.system.damage = {
          parts: [["2d10[radiant] + @classes.cleric.levels", "radiant"]],
          versatile: "",
          value: "",
        };
        break;
      case "Dark Oneâ€™s Blessing":
      case "Dark One's Blessing": {
        feature.system.damage = { parts: [["@classes.warlock.level + @mod", "temphp"]], versatile: "", value: "" };
        feature.system.actionType = "heal";
        feature.system.ability = "cha";
        feature.system.target.type = "self";
        feature.system.range.units = "self";
        feature.system.activation.condition = "Reduce a hostile creature to 0 HP";
        break;
      }
      case "Deflect Missiles": {
        feature.system.damage = { parts: [["1d10 + @mod + @classes.monk.levels"]], versatile: "", value: "" };
        break;
      }
      case "Divine Intervention":
        feature.system.damage = { parts: [["1d100", ""]], versatile: "", value: "" };
        feature.system.actionType = "other";
        break;
      case "Eldritch Cannon: Force Ballista":
        feature.system.target.value = 1;
        feature.system.target.type = "creature";
        feature.system.range.value = 120;
        feature.system.range.units = "ft";
        feature.system.ability = "int";
        feature.system.actionType = "rsak";
        feature.system.chatFlavor = "On hit pushed 5 ft away.";
        feature.system.damage = { parts: [["2d8[force]", "force"]], versatile: "", value: "" };
        break;
      case "Eldritch Cannon: Flamethrower":
        feature.system.damage = { parts: [["2d8[fire]", "fire"]], versatile: "", value: "" };
        break;
      case "Eldritch Cannon: Protector":
        feature.system.target.units = "any";
        feature.system.target.type = "ally";
        feature.system.range.value = 10;
        feature.system.ability = "int";
        feature.system.actionType = "heal";
        feature.system.damage = { parts: [["1d8 + @mod", "temphp"]], versatile: "", value: "" };
        break;
      case "Extra Attack": {
        feature.system.activation = { type: "", cost: 0, condition: "" };
        feature.system.actionType = "";
        feature.system.range.value = null;
        break;
      }
      case "Fighting Style: Interception":
        feature.system.damage = { parts: [["1d10 + @prof", ""]], versatile: "", value: "" };
        feature.system.target.type = "self";
        feature.system.range.units = "self";
        break;
      case "Genie's Vessel: Genie's Wrath (Dao)": {
        feature.system.activation.type = "special";
        feature.system.target.value = 1;
        feature.system.target.type = "creature";
        feature.system.range.units = "spec";
        feature.system.actionType = "util";
        feature.system.duration.units = "inst";
        feature.system.damage = { parts: [["@prof", "bludgeoning"]], versatile: "", value: "" };
        break;
      }
      case "Giant's Might": {
        feature.system["target"]["type"] = "self";
        feature.system.range = { value: null, units: "self", long: null };
        feature.system.duration = {
          value: 1,
          units: "minute",
        };
        break;
      }
      case "Hand of Healing": {
        feature.system.actionType = "heal";
        break;
      }
      case "Harness Divine Power": {
        feature.system.damage = { parts: [], versatile: "", value: "" };
        break;
      }
      case "Healing Hands": {
        feature.system.damage = {
          parts: [["@details.level[healing]", "healing"]],
          versatile: "",
          value: "",
        };
        feature.system.actionType = "heal";
        feature.system.target.type = "creature";
        feature.system.range = {
          type: "touch",
          value: null,
          long: null,
          units: "touch"
        };
        break;
      }
      case "Healing Light": {
        feature.system.damage = { parts: [["1d6"]], versatile: "", value: "" };
        break;
      }
      case "Metamagic - Heightened Spell": {
        feature.system.consume.amount = 3;
        break;
      }
      case "Metamagic - Quickened Spell": {
        feature.system.consume.amount = 2;
        break;
      }
      case "Momentary Stasis": {
        feature.system.actionType = "save";
        feature.system.save.ability = "con";
        break;
      }
      case "Polearm Master - Bonus Attack": {
        feature.system.actionType = "mwak";
        feature.system.range = { value: 10, long: null, units: "ft" };
        break;
      }
      case "Psionic Power: Recovery": {
        feature.system.damage = { parts: [], versatile: "", value: "" };
        setProperty(feature, "system.consume.amount", -1);
        break;
      }
      case "Quickened Healing": {
        feature.system.actionType = "heal";
        feature.system.target.type = "self";
        feature.system.range.units = "self";
        if (useScale) {
          feature.system.damage.parts[0][0] += " + @prof[healing]";
          feature.system.damage.parts[0][1] = "healing";
        }
        break;
      }
      case "Celestial Revelation (Radiant Soul)":
      case "Radiant Soul": {
        if (getProperty(feature, "flags.ddbimporter.type") == "race") {
          feature.system.uses = {
            value: 1,
            max: 1,
            per: "lr",
          };
        } else if (getProperty(feature, "flags.ddbimporter.type") == "class") {
          feature.system.activation.type = "special";
        }
        break;
      }
      case "Rage": {
        feature.system.duration = {
          value: 1,
          units: "minute",
        };
        break;
      }
      case "Second Wind":
        feature.system.damage = {
          parts: [["1d10[healing] + @classes.fighter.levels", "healing"]],
          versatile: "",
          value: "",
        };
        feature.system.actionType = "heal";
        feature.system.target.type = "self";
        feature.system.range.units = "self";
        break;
      case "Shifting": {
        feature.system.actionType = "heal";
        feature.system.target.type = "self";
        feature.system.range = { value: null, long: null, units: "self" };
        feature.system.duration.units = "inst";
        feature.system.ability = "con";
        feature.system.actionType = "heal";
        feature.system.damage = { parts: [["@details.level + max(1,@mod)", "temphp"]], versatile: "", value: "" };
        break;
      }
      case "Shift": {
        feature.system.actionType = "heal";
        feature.system.target.type = "self";
        feature.system.range = { value: null, long: null, units: "self" };
        feature.system.duration = {
          value: 1,
          units: "minute",
        };
        feature.system.ability = "con";
        feature.system.actionType = "heal";
        feature.system.damage = { parts: [["2 * @prof", "temphp"]], versatile: "", value: "" };
        break;
      }
      case "Sneak Attack": {
        if (!useScale) feature.system.damage = { parts: [["(ceil(@classes.rogue.levels /2))d6", ""]], versatile: "", value: "" };
        if (!feature.flags.ddbimporter.action) {
          feature.system.actionType = "other";
          feature.system.activation = { type: "special", cost: 0, condition: "" };
        }
        break;
      }
      case "Surprise Attack":
        feature.system.damage = { parts: [["2d6", ""]], versatile: "", value: "" };
        feature.system.activation.type = "special";
        break;
      case "Starry Form: Archer":
        feature.system.actionType = "rsak";
        feature.system.target.value = 1;
        feature.system.target.type = "creature";
        feature.system.range.units = "ft";
        break;
      case "Starry Form: Chalice":
        feature.system.damage.parts[0][1] = "healing";
        feature.system.actionType = "heal";
        feature.system.target.value = 1;
        feature.system.target.type = "ally";
        feature.system.range.value = 30;
        feature.system.range.units = "ft";
        feature.system.activation.type = "special";
        break;
      case "Starry Form: Dragon":
        break;
      case "Stone's Endurance":
      case "Stoneâ€™s Endurance":
        feature.system.damage = { parts: [["1d12 + @mod", ""]], versatile: "", value: "" };
        feature.system.actionType = "other";
        feature.system.ability = "con";
        feature.system.target.type = "self";
        feature.system.range.units = "self";
        break;
      case "Stunning Strike":
        feature.system.actionType = "save";
        feature.system.save = { ability: "con", dc: null, scaling: "wis" };
        feature.system.target = { value: null, width: null, units: "touch", type: "creature" };
        feature.system.range.units = "ft";
        break;
      case "Superiority Dice": {
        setProperty(feature.system, "damage.parts", [["@scale.battle-master.combat-superiority-die"]]);
        break;
      }
      // no default
    }

    const tableDescription = (0,_muncher_table_js__WEBPACK_IMPORTED_MODULE_4__/* .generateTable */ .p)(feature.name, feature.system.description.value, true, feature.type);
    feature.system.description.value = tableDescription;
    const chatAdd = game.settings.get("ddb-importer", "add-description-to-chat");
    feature.system.description.chat = chatAdd ? tableDescription : "";
    feature = setConsumeAmount(feature);


    // if (useScale) {
    //   feature = setLevelScale(feature);
    // }
  });
}

async function addExtraEffects(ddb, documents, character) {
  const compendiumItem = character.flags.ddbimporter.compendium;
  const addCharacterEffects = compendiumItem
    ? game.settings.get("ddb-importer", "munching-policy-add-effects")
    : game.settings.get("ddb-importer", "character-update-policy-add-character-effects");

  if (addCharacterEffects) {
    const results = await Promise.all(documents.map((document) => {
      return (0,_effects_specialFeats_js__WEBPACK_IMPORTED_MODULE_5__/* .featureEffectAdjustment */ .MD)(ddb, character, document);
    }));
    return results;
  } else {
    return documents;
  }

}


/***/ }),

/***/ 7336:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "P": () => (/* binding */ parseInfusion),
/* harmony export */   "R": () => (/* binding */ getInfusionActionData)
/* harmony export */ });
/* harmony import */ var _lib_DDBHelper_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1438);
/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5259);
/* harmony import */ var _effects_effects_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5751);





// function isInfused(ddb, item) {
//   return ddb.infusions.item.some((mapping) =>
//     mapping.itemId === item.flags.ddbimporter.definitionId &&
//     mapping.inventoryMappingId === item.flags.ddbimporter.id &&
//     mapping.itemTypeId === item.flags.ddbimporter.definitionEntityTypeId
//   );
// }

// function getInfusionId(item, infusionMap) {
//   const infusionInMap = infusionMap.find((mapping) =>
//     mapping.itemId === item.flags.ddbimporter.definitionId &&
//     mapping.inventoryMappingId === item.flags.ddbimporter.id &&
//     mapping.itemTypeId === item.flags.ddbimporter.definitionEntityTypeId
//   );

//   if (infusionInMap) {
//     return infusionInMap.definitionKey.replace("infusion:", "");
//   } else {
//     return undefined;
//   }
// }


function getInfusionItemMap(ddb, item) {
  if (!ddb.infusions?.item) return undefined;
  return ddb.infusions.item.find((mapping) =>
    mapping.itemId === item.flags.ddbimporter.definitionId
    && mapping.inventoryMappingId === item.flags.ddbimporter.id
    && mapping.itemTypeId === item.flags.ddbimporter.definitionEntityTypeId
  );
}

function getInfusionDetail(ddb, definitionKey) {
  if (!ddb.infusions?.infusions?.definitionData) return undefined;
  return ddb.infusions.infusions.definitionData.find(
    (infusion) => infusion.definitionKey === definitionKey
  );
}


function getInfusionModifiers(infusionItemMap, infusionDetail) {
  let modifiers = [];

  switch (infusionDetail.modifierDataType) {
    case "class-level":
    case "damage-type-choice": {
      const damageMods = infusionDetail.modifierData.find(
        (data) => data.id === infusionItemMap.modifierGroupId
      );
      if (damageMods) modifiers = damageMods.modifiers;
      break;
    }
    case "granted":
    default: {
      modifiers = infusionDetail.modifierData.map((data) => data.modifiers).flat();
    }
  }

  // logger.debug(`${infusionDetail.name} ${infusionDetail.modifierDataType}`, modifiers);

  return modifiers;
}

function addMagicBonus(character, item, modifiers) {
  const filteredModifiers = _lib_DDBHelper_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].filterModifiers */ .Z.filterModifiers(modifiers, "bonus", "magic");
  const magicBonus = _lib_DDBHelper_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].getModifierSum */ .Z.getModifierSum(filteredModifiers, character);

  if (magicBonus && magicBonus !== 0 && magicBonus !== "") {
    item.system.damage.parts[0][0] += ` + ${magicBonus}`;
    item.system.attackBonus += magicBonus;
    setProperty(item, "system.properties.mgc", true);
    // to do add infusion description to item
  }
  return item;
}

function getInfusionActionData(ddb) {
  if (!ddb.infusions?.item) return [];
  const generatedInfusionMap = ddb.infusions.item
    .filter((mapping) => getInfusionDetail(ddb, mapping.definitionKey) !== undefined)
    .map((mapping) => {
      return getInfusionDetail(ddb, mapping.definitionKey);
    });

  const infusionActions = generatedInfusionMap
    .filter((infusionDetail) => infusionDetail.type === "augment" && infusionDetail.actions.length > 0)
    .map((infusionDetail) => {
      const actions = infusionDetail.actions.map((action) => {
        const itemLookup = ddb.infusions.item.find((mapping) => mapping.definitionKey === infusionDetail.definitionKey);
        if (!action.name) {
          const itemLookup = ddb.infusions.item.find((mapping) => mapping.definitionKey === infusionDetail.definitionKey);
          const item = ddb.character.inventory.find((item) => item.id === itemLookup.inventoryMappingId);
          const itemName = item?.definition?.name ? `${item.definition.name} : ` : ``;
          action.name = `${itemName}[Infusion] ${infusionDetail.name}`;
        }
        action.infusionFlags = {
          maps: [duplicate(itemLookup)],
          applied: [duplicate(infusionDetail)],
          infused: true,
        };
        return action;
      });
      return actions;
    })
    .flat();

  _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Infusions Actions Map`, generatedInfusionMap);
  _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Generated Infusions Actions`, infusionActions);
  return infusionActions;
}

function parseInfusion(ddb, character, foundryItem, ddbItem, compendiumItem) {
  // get item mapping
  const infusionItemMap = getInfusionItemMap(ddb, foundryItem);
  foundryItem.flags.infusions = { maps: [], applied: [], infused: false };
  // sometimes ddb keeps dead infusions around - notably homonculus
  const infusionDetail = infusionItemMap
    ? getInfusionDetail(ddb, infusionItemMap.definitionKey)
    : undefined;

  if (infusionItemMap && infusionDetail) {
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Infusion detected for ${foundryItem.name}`);
    // console.warn(ddb);
    // console.warn(ddbItem);
    // console.warn(foundryItem);

    // get modifiers && generate effects
    const ddbInfusionItem = duplicate(ddbItem);
    ddbInfusionItem.definition.grantedModifiers = getInfusionModifiers(infusionItemMap, infusionDetail);

    foundryItem = (0,_effects_effects_js__WEBPACK_IMPORTED_MODULE_2__/* .generateEffects */ .K7)(ddb, character, ddbInfusionItem, foundryItem, compendiumItem, "infusion");
    // magic bonuses can't be added as effects as it's real hard to pin to one item
    foundryItem = addMagicBonus(character, foundryItem, ddbInfusionItem.definition.grantedModifiers);

    // add infusion flags
    foundryItem.flags.infusions.infused = true;
    foundryItem.flags.infusions.applied.push(infusionDetail);
    foundryItem.flags.infusions.maps.push(infusionItemMap);

    // set magic properties
    setProperty(foundryItem, "system.properties.mgc", true);

    // Update Item description
    foundryItem.system.description.value += `<div class="infusion-description"><p><b>Infusion: ${infusionDetail.name}</b></p><p>${infusionDetail.description}</p></div>`;
    foundryItem.system.description.chat += `<div class="infusion-description"><p><b>Infusion: ${infusionDetail.name}</b></p><p>${infusionDetail.snippet ? infusionDetail.snippet : ""}</p></div>`;

    // adjust name for infused item
    if (!foundryItem.name.includes("[Infusion]")) foundryItem.name += " [Infusion]";
    // if item is loot, lets move it to equipment/trinket so effects will apply
    if (foundryItem.type === "loot") {
      foundryItem.type = "equipment";
      foundryItem.system.armor = {
        type: "trinket",
        value: 10,
        dex: null,
      };
      // infusions will over ride the can equip status, so just check for equipped
      foundryItem.system.equipped = ddbItem.equipped;
    }

    // check to see if we need to fiddle attack modifiers on infused weapons
    if (foundryItem.type === "weapon") {
      const intSwap = _lib_DDBHelper_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].filterBaseModifiers */ .Z.filterBaseModifiers(ddb, "bonus", "magic-item-attack-with-intelligence").length > 0;
      if (intSwap) {
        const characterAbilities = character.flags.ddbimporter.dndbeyond.effectAbilities;
        const mockAbility = foundryItem.system.ability === null
          ? foundryItem.system.properties.fin ? "dex" : "str"
          : foundryItem.system.ability;
        if (characterAbilities.int.value > characterAbilities[mockAbility].value) {
          foundryItem.system.ability = "int";
        }
      }
    }
  } else if (infusionItemMap && !infusionDetail) {
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].warn */ .Z.warn(`${foundryItem.name} marked as infused but no infusion info found`);
  }
  return foundryItem;

}


/***/ }),

/***/ 2674:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ DDBFeature)
/* harmony export */ });
/* harmony import */ var _lib_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7669);
/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5259);
/* harmony import */ var _dictionary_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(37);
/* harmony import */ var _muncher_table_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(7967);
/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(6451);






class DDBFeature {

  #generateAdjustedName() {
    if (!this.stripName) return;
    const regex = /(.*)\s*\((:?costs \d actions|\d\/day|recharge \d-\d)\)/i;
    const nameMatch = this.name.replace(/[â€“-â€“âˆ’]/g, "-").match(regex);
    if (nameMatch) {
      this.feature.name = nameMatch[1];
      this.nameSplit = nameMatch[2];
    }
  }

  createBaseFeature() {
    this.feature = {
      name: this.name,
      type: this.templateType,
      system: JSON.parse(_lib_utils_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].getTemplate */ .Z.getTemplate(this.templateType)),
      effects: [],
      flags: {
        ddbimporter: {
          dndbeyond: {
          },
        },
        monsterMunch: {
          titleHTML: this.titleHTML,
          fullName: this.fullName,
          actionCopy: this.actionCopy,
        }
      },
    };
    // these templates not good
    this.feature.system.duration.value = "";
    this.feature.system.requirements = "";
  }

  // prepare the html in this.html for a parse, runs some checks and pregen to calculate values
  prepare() {
    this.strippedHtml = _lib_utils_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].stripHtml */ .Z.stripHtml(`${this.html}`).trim();

    const matches = this.strippedHtml.match(
      /(Melee|Ranged|Melee\s+or\s+Ranged)\s+(|Weapon|Spell)\s*Attack:\s*([+-]\d+|your (?:\w+\s*)*)\s+to\s+hit/i
    );

    // set calc flags
    this.isAttack = matches ? matches[1] !== undefined : false;
    this.weaponAttack = matches
      ? (matches[2].toLowerCase() === "weapon" || matches[2] === "")
      : false;
    this.spellAttack = matches ? matches[2].toLowerCase() === "spell" : false;
    this.meleeAttack = matches ? matches[1].indexOf("Melee") !== -1 : false;
    this.rangedAttack = matches ? matches[1].indexOf("Ranged") !== -1 : false;
    this.toHit = matches
      ? Number.isInteger(parseInt(matches[3]))
        ? parseInt(matches[3])
        : 0
      : 0;
    this.templateType = this.isAttack ? "weapon" : "feat";
    this.yourSpellAttackModToHit = matches ? matches[3]?.startsWith("your spell") : false;

    if (!this.feature) this.createBaseFeature();
    this.#generateAdjustedName();

    // if not attack set to a monster type action
    if (!this.isAttack) setProperty(this.feature, ".system.type.value", "monster");

  }

  constructor(name, { ddbMonster, html, type, titleHTML, fullName, actionCopy, updateExisting, hideDescription } = {}) {

    this.name = name;
    this.ddbMonster = ddbMonster;
    this.type = type;
    this.html = html ?? "";
    this.titleHTML = titleHTML ?? undefined;
    this.fullName = fullName ?? this.name;
    this.actionCopy = actionCopy ?? false;

    this.hideDescription = hideDescription ?? game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-hide-description");
    this.updateExisting = updateExisting ?? game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-update-existing");
    this.stripName = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-monster-strip-name");

    this.prepare();

    // copy source details from parent
    if (this.ddbMonster) this.feature.system.source = this.ddbMonster.npc.system.details.source;

    this.actionInfo = {
      damage: {
        parts: [],
        versatile: ""
      },
      formula: "",
      damageSave: {
        dc: null,
        ability: null
      },
      target: {
        "value": null,
        "width": null,
        "units": "",
        "type": ""
      },
      duration: {
        "value": "",
        "units": "inst"
      },
      extraAttackBonus: 0,
      baseAbility: null,
      proficient: false,
      properties: {
        "amm": false,
        "fin": false,
        "fir": false,
        "foc": false,
        "hvy": false,
        "lgt": false,
        "lod": false,
        "rch": false,
        "rel": false,
        "ret": false,
        "spc": false,
        "thr": false,
        "two": false,
        "ver": false
      },
      reach: "",
      range: {
        value: null,
        long: null,
        units: "",
      },
      recharge: { value: null, charged: true },
      activation: {
        type: "",
        cost: null,
        condition: ""
      },
      save: {
        dc: null,
        ability: "",
        scaling: "flat",
      },
      uses: {
        value: null,
        max: "",
        per: null,
        recovery: "",
      },
    };

  }

  damageModReplace(text, damageType) {
    let result;
    const globalDamageHints = game.settings.get("ddb-importer", "use-damage-hints");
    const damageHint = globalDamageHints && damageType ? `[${damageType}]` : "";
    const diceParse = _lib_utils_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].parseDiceString */ .Z.parseDiceString(text, null, damageHint);
    if (this.actionInfo.baseAbility) {
      const baseAbilityMod = this.ddbMonster.abilities[this.actionInfo.baseAbility].mod;
      const bonusMod = (diceParse.bonus && diceParse.bonus !== 0) ? diceParse.bonus - baseAbilityMod : "";
      const useMod = (diceParse.bonus && diceParse.bonus !== 0) ? " + @mod " : "";
      const reParse = _lib_utils_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].diceStringResultBuild */ .Z.diceStringResultBuild(diceParse.diceMap, diceParse.dice, bonusMod, useMod, damageHint);
      result = reParse.diceString;
    } else {
      result = diceParse.diceString;
    }

    return result;
  }

  // eslint-disable-next-line complexity
  generateExtendedDamageInfo() {
    const hitIndex = this.strippedHtml.indexOf("Hit:");
    let hit = (hitIndex > 0) ? this.strippedHtml.slice(hitIndex) : `${this.strippedHtml}`;
    hit = hit.split("At the end of each")[0].split("At the start of each")[0];
    hit = hit.replace(/[â€“-â€“âˆ’]/g, "-");
    // console.warn(hit);
    // Using match with global modifier then map to regular match because RegExp.matchAll isn't available on every browser
    // eslint-disable-next-line no-useless-escape
    const damageExpression = new RegExp(/((?:takes|saving throw or take\s+)|(?:[\w]*\s+))(?:([0-9]+))?(?:\s*\(?([0-9]*d[0-9]+(?:\s*[-+]\s*(?:[0-9]+|PB|the spell[â€™']s level))*(?:\s+plus [^\)]+)?)\)?)?\s*([\w ]*?)\s*damage(?: when used with | if used with )?(\s?two hands|\s?at the start of|\son a failed save)?/gi);
    const matches = [...hit.matchAll(damageExpression)];
    const regainExpression = new RegExp(/(regains)\s+?(?:([0-9]+))?(?: *\(?([0-9]*d[0-9]+(?:\s*[-+]\s*[0-9]+)??)\)?)?\s+hit\s+points/);
    const regainMatch = hit.match(regainExpression);

    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`${this.name} Damage matches`, { hit, matches, regainMatch });
    let versatile = false;
    for (const dmg of matches) {
      let other = false;
      if (dmg[1] == "DC " || dmg[4] == "hit points by this") {
        continue; // eslint-disable-line no-continue
      }
      // check for versatile
      if (dmg[1] == "or " || dmg[5] == "two hands") {
        versatile = true;
      }
      // check for other
      if (dmg[5] && dmg[5].trim() == "at the start of") other = true;
      const profBonus = dmg[3]?.includes(" + PB") ? "@prof" : "";
      const levelBonus = dmg[3] && (/the spell[â€™']s level/i).test(dmg[3]) ? "@summoner.item.level" : "";
      const damage = profBonus !== "" || levelBonus !== ""
        ? `${dmg[2]}${dmg[3].replace(" + PB", "").replace(" + the spellâ€™s level", "").replace(" + the spell's level", "")}`
        : dmg[3] ?? dmg[2];

      // Make sure we did match a damage
      if (damage) {
        const includesDiceRegExp = /[0-9]*d[0-9]+/;
        const includesDice = includesDiceRegExp.test(damage);
        const parsedDiceDamage = (this.actionInfo && includesDice)
          ? this.damageModReplace(damage.replace("plus", "+"), dmg[4])
          : damage.replace("plus", "+");

        const finalDamage = [parsedDiceDamage, profBonus, levelBonus].filter((t) => t !== "").join(" + ");

        // if this is a save based attack, and multiple damage entries, we assume any entry beyond the first is going into
        // versatile for damage
        if (((dmg[5] && dmg[5].trim() == "on a failed save")
            || (dmg[1] && dmg[1].includes("saving throw")))
          && this.actionInfo.damage.parts.length >= 1
        ) {
          versatile = true;
        }
        // assumption here is that there is just one field added to versatile. this is going to be rare.
        if (other) {
          if (this.actionInfo.formula == "") this.actionInfo.formula = finalDamage;
        } else if (versatile) {
          if (this.actionInfo.damage.versatile == "") this.actionInfo.damage.versatile = finalDamage;
          // so things like the duergar mind master have oddity where we might want to use a different thing
          // } else {
          //   result.damage.versatile += ` + ${finalDamage}`;
          // }
        } else {
          this.actionInfo.damage.parts.push([finalDamage, dmg[4]]);
        }
      }
    }

    if (regainMatch) {
      const globalDamageHints = game.settings.get("ddb-importer", "use-damage-hints");
      const damageHint = globalDamageHints ? `[healing]` : "";
      this.actionInfo.damage.parts.push([_lib_utils_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].parseDiceString */ .Z.parseDiceString(regainMatch[3], null, damageHint).diceString, 'healing']);
    }

    const save = hit.match(/DC ([0-9]+) (.*?) saving throw|\(save DC ([0-9]+)\)/);
    if (save) {
      this.actionInfo.damageSave.dc = save[1];
      this.actionInfo.damageSave.ability = save[2] ? save[2].toLowerCase().substr(0, 3) : "";
    } else {
      const escape = hit.match(/escape DC ([0-9]+)/);
      if (escape) {
        this.actionInfo.damageSave.dc = escape[1];
        this.actionInfo.damageSave.ability = "Escape";
      }
    }
  }

  getAction() {
    let action = this.type;
    // foundry doesn't support mythic actions pre 1.6
    if (this.type === "mythic") action = "mythic";
    const actionAction = this.strippedHtml.toLowerCase().match(/as (a|an) action/);
    const bonusAction = this.strippedHtml.toLowerCase().match(/as a bonus action/);
    const reAction = this.strippedHtml.toLowerCase().match(/as a reaction/);
    // e.g. mephit death
    const specialDie = this.strippedHtml.toLowerCase().match(/dies/);
    if (bonusAction) {
      action = "bonus";
    } else if (reAction) {
      action = "reaction";
    } else if (specialDie) {
      action = "special";
    } else if (actionAction) {
      action = "action";
    }
    return action;
  }

  getUses(name = false) {
    let uses = {
      value: null,
      max: "",
      per: null,
      recovery: "",
    };

    const usesSearch = name ? /(\d+)\/(\w+)\)/ : /\((\d+)\/(\w+)\)/;
    const usesMatch = this.strippedHtml.match(usesSearch);
    // console.log(usesMatch);
    if (usesMatch && usesMatch[2].toLowerCase() !== "turn") {
      uses.value = Number.parseInt(usesMatch[1]);
      uses.max = usesMatch[1];
      uses.per = "day";
      const perMatch = _dictionary_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].monsters.resets.find */ .Z.monsters.resets.find((reset) => reset.id === usesMatch[2]);
      if (perMatch) uses.per = perMatch.value;
    }

    return uses;
  }

  getRecharge() {
    const matches = this.name.toLowerCase().match(/\(recharge ([0-9â€“â€“âˆ’-]+)\)/);
    if (matches) {
      const value = matches[1].replace(/[â€“â€“âˆ’-]/, "-").split("-").shift();
      return {
        value: parseInt(value),
        charged: true
      };
    }

    return {
      value: null,
      charged: false
    };
  }

  getActivation() {
    const matches = this.strippedHtml.match(/\(costs ([0-9]+) actions\)/i);
    if (matches) return parseInt(matches[1]);
    const nameMatch = this.name.match(/\(costs ([0-9]+) actions\)/i);
    if (nameMatch) return parseInt(nameMatch[1]);
    return null;
  }

  getFeatSave() {
    const saveSearch = /DC (\d+) (\w+) (saving throw|check)/i;
    const match = this.strippedHtml.match(saveSearch);
    if (match) {
      this.actionInfo.save.dc = parseInt(match[1]);
      this.actionInfo.save.ability = match[2].toLowerCase().substr(0, 3);
      this.actionInfo.save.scaling = "flat";
    } else {
      const saveSelfSearch = /(\w+) saving throw against your spell save DC/i;
      const selfMatch = this.strippedHtml.match(saveSelfSearch);
      if (selfMatch) {
        this.feature.system.actionType = "save";
        this.actionInfo.save.dc = 10;
        this.actionInfo.save.ability = selfMatch[1].toLowerCase().substr(0, 3);
        this.actionInfo.save.scaling = "flat";
      }
    }
    return this.actionInfo.save;
  }

  getReach() {
    const reachSearch = /reach\s*(\s*\d+\s*)\s*ft/;
    const match = this.strippedHtml.match(reachSearch);
    if (match) {
      return match[1];
    }
    return "";
  }

  getRange() {
    let range = {
      value: null,
      long: null,
      units: "",
    };

    const rangeSearch1 = /range\s*(\d+)\s*\/\s*(\d+)\s*ft/;
    const rangeSearch2 = /range\s*(\d+)\s*ft[.]*\s*\/\s*(\d+)\s*ft/;
    const rangeSearch3 = /range\s*(\d+)\s*(:?ft|feet)/;
    const reachSearch = /reach\s*(\d+)\s*(:?ft|feet)/;
    const withinSearch = /within\s*(\d+)\s*(:?ft|feet)/;

    const matches1 = this.strippedHtml.match(rangeSearch1);
    const matches2 = this.strippedHtml.match(rangeSearch2);
    const matches3 = this.strippedHtml.match(rangeSearch3);
    const reachMatch = this.strippedHtml.match(reachSearch);
    const withinMatch = this.strippedHtml.match(withinSearch);

    if (matches1) {
      range.value = parseInt(matches1[1]);
      range.long = parseInt(matches1[2]);
      range.units = "ft";
    } else if (matches2) {
      range.value = parseInt(matches2[1]);
      range.long = parseInt(matches2[2]);
      range.units = "ft";
    } else if (matches3) {
      range.value = parseInt(matches3[1]);
      range.units = "ft";
    } else if (reachMatch) {
      range.value = parseInt(reachMatch[1]);
      range.units = "ft";
    } else if (withinMatch) {
      range.value = parseInt(withinMatch[1]);
      range.units = "ft";
    }

    return range;
  }

  checkAbility(abilitiesToCheck) {
    let result = {
      success: false,
      ability: null,
      proficient: null
    };

    for (const ability of abilitiesToCheck) {
      if (this.toHit == this.ddbMonster.proficiencyBonus + this.ddbMonster.abilities[ability].mod) {
        result.success = true;
        result.ability = ability;
        result.proficient = true;
        break;
      } else if (result.toHit == this.ddbMonster.abilities[ability].mod) {
        result.success = true;
        result.ability = ability;
        result.proficient = false;
        break;
      }
    }

    return result;
  }

  checkAbilities(abilitiesToCheck, negatives = false) {
    const results = abilitiesToCheck.map((ability) => {
      let result = {
        success: false,
        ability,
        proficient: null,
        bonus: 0
      };
      if (this.toHit > this.ddbMonster.proficiencyBonus + this.ddbMonster.abilities[ability].mod) {
        result.success = true;
        result.proficient = true;
        result.bonus = this.toHit - this.ddbMonster.proficiencyBonus - this.ddbMonster.abilities[ability].mod;
      } else if (result.toHit > this.ddbMonster.abilities[ability].mod) {
        result.success = true;
        result.proficient = false;
        result.bonus = this.toHit - this.ddbMonster.abilities[ability].mod;
      } else if (negatives) {
        result.success = true;
        result.proficient = false;
        result.bonus = this.toHit - this.ddbMonster.abilities[ability].mod;
      }
      return result;
    });

    return results;
  }

  // eslint-disable-next-line complexity
  generateWeaponAttackInfo() {
    const abilities = ["str", "dex", "int", "wis", "cha", "con"];
    let initialAbilities = [];
    let weaponAbilities = ["str", "dex"];
    let spellAbilities = ["cha", "wis", "int"];

    const lookup = _dictionary_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].monsters.weapons.find */ .Z.monsters.weapons.find((weapon) => this.name.startsWith(weapon.name));
    // we have a weapon name match so we can infer a bit more
    if (lookup) {
      for (const [key, value] of Object.entries(lookup.properties)) {
        // logger.info(`${key}: ${value}`);
        this.actionInfo.properties[key] = value;
      }
      const versatileWeapon = this.actionInfo.properties.ver && this.ddbMonster.abilities['dex'].mod > this.ddbMonster.abilities['str'].mod;
      if (versatileWeapon || lookup.actionType == "rwak") {
        weaponAbilities = ["dex"];
      } else if (lookup.actionType == "mwak") {
        weaponAbilities = ["str"];
      }
      this.actionInfo.weaponType = lookup.weaponType;
    } else if (this.meleeAttack) {
      this.actionInfo.weaponType = "simpleM";
    } else if (this.rangedAttack) {
      this.actionInfo.weaponType = "simpleR";
    }

    if (this.spellAttack) {
      initialAbilities = spellAbilities;
    } else if (this.weaponAttack) {
      initialAbilities = weaponAbilities;
    } else {
      initialAbilities = abilities;
    }

    // force companions to null and proficient
    if (this.yourSpellAttackModToHit) {
      this.actionInfo.baseAbility = null;
      this.actionInfo.proficient = true;
    } else if (this.weaponAttack || this.spellAttack) {
      // check most likely initial attacks - str and dex based weapon, mental for spell
      const checkInitialAbilities = this.checkAbility(initialAbilities);
      if (checkInitialAbilities.success) {
        this.actionInfo.baseAbility = checkInitialAbilities.ability;
        this.actionInfo.proficient = checkInitialAbilities.proficient;
      }

      // okay lets see if its one of the others then!
      if (!this.actionInfo.baseAbility) {
        const checkAllAbilities = this.checkAbility(abilities);
        if (checkAllAbilities.success) {
          this.actionInfo.baseAbility = checkAllAbilities.ability;
          this.actionInfo.proficient = checkAllAbilities.proficient;
        }
      }

      // okay, some oddity, maybe magic bonus, lets calculate one!
      // we are going to assume it's dex or str based.
      if (!this.actionInfo.baseAbility) {
        const magicAbilities = this.checkAbilities(initialAbilities);

        const filteredAbilities = magicAbilities.filter((ab) => ab.success == true).sort((a, b) => {
          if (a.proficient == !b.proficient) return -1;
          if (b.proficient == !a.proficient) return 1;
          if (a.proficient == b.proficient) {
            if (a.bonus > b.bonus) return 1;
            if (b.bonus > a.bonus) return -1;
          }
          return 0;
        });

        // fine lets use the first hit
        if (filteredAbilities.length >= 1 && filteredAbilities[0].success) {
          this.actionInfo.baseAbility = filteredAbilities[0].ability;
          this.actionInfo.proficient = filteredAbilities[0].proficient;
          this.actionInfo.extraAttackBonus = filteredAbilities[0].bonus;
        }
      }

      // negative mods!
      if (!this.actionInfo.baseAbility) {
        _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].info */ .Z.info(`Negative ability parse for ${this.ddbMonster.npc.name}, to hit ${this.toHit} with ${this.name}`);

        const magicAbilities = this.checkAbilities(initialAbilities, true);

        const filteredAbilities = magicAbilities.filter((ab) => ab.success == true).sort((a, b) => {
          if (a.proficient == !b.proficient) return -1;
          if (b.proficient == !a.proficient) return 1;
          if (a.proficient == b.proficient) {
            if (a.bonus < b.bonus) return 1;
            if (b.bonus < a.bonus) return -1;
          }
          return 0;
        });
        _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug("Filtered abilities", { filteredAbilities, html: this.strippedHtml });
        // fine lets use the first hit
        if (filteredAbilities.length >= 1 && filteredAbilities[0].success) {
          this.actionInfo.baseAbility = filteredAbilities[0].ability;
          this.actionInfo.proficient = filteredAbilities[0].proficient;
          this.actionInfo.extraAttackBonus = filteredAbilities[0].bonus;
        } else {
          _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].error */ .Z.error("Unable to calculate attack!", { filteredAbilities, html: this.strippedHtml, ddbFeature: this });
        }
      }
    }
  }

  getTarget() {
    let target = {
      value: null,
      width: null,
      units: "",
      type: ""
    };

    // 90-foot line that is 10 feet wide
    // in a 90-foot cone
    const matchText = this.strippedHtml.replace(/[Â­â€“â€“âˆ’-]/gu, "-").replace(/-+/g, "-");
    // console.warn(matchText);
    const lineSearch = /(\d+)-foot line/;
    const coneSearch = /(\d+)-foot cone/;
    const cubeSearch = /(\d+)-foot cube/;
    const sphereSearch = /(\d+)-foot-radius sphere/;

    const coneMatch = matchText.match(coneSearch);
    const lineMatch = matchText.match(lineSearch);
    const cubeMatch = matchText.match(cubeSearch);
    const sphereMatch = matchText.match(sphereSearch);

    if (coneMatch) {
      target.value = parseInt(coneMatch[1]);
      target.units = "ft";
      target.type = "cone";
    } else if (lineMatch) {
      target.value = parseInt(lineMatch[1]);
      target.units = "ft";
      target.type = "line";
    } else if (cubeMatch) {
      target.value = parseInt(cubeMatch[1]);
      target.units = "ft";
      target.type = "cube";
    } else if (sphereMatch) {
      target.value = parseInt(sphereMatch[1]);
      target.units = "ft";
      target.type = "sphere";
    }

    return target;
  }

  #getHiddenDescription() {
    let description = `<section class="secret">\n${this.html}`;
    if (["rwak", "mwak"].includes(this.feature.system.actionType)) {
      description += `\n</section>\nThe ${this.ddbMonster.npc.name} attacks with its ${this.feature.name}.`;
    } else if (["rsak", "msak"].includes(this.feature.system.actionType)) {
      description += `\n</section>\nThe ${this.ddbMonster.npc.name} casts ${this.feature.name}.`;
    } else if (["save"].includes(this.feature.system.actionType)) {
      description += `\n</section>\nThe ${this.ddbMonster.npc.name} uses ${this.feature.name} and a save is required.`;
    } else {
      description += `\n</section>\nThe ${this.ddbMonster.npc.name} uses ${this.feature.name}.`;
    }
    return description;
  }

  #generateDescription() {
    let description = this.hideDescription ? this.#getHiddenDescription() : `${this.html}`;
    description = description.replaceAll("<em><strong></strong></em>", "");
    this.feature.system.description.value = (0,_muncher_table_js__WEBPACK_IMPORTED_MODULE_3__/* .generateTable */ .p)(this.ddbMonster.npc.name, description, this.updateExisting);
  }


  #buildAction() {
    if (Number.isInteger(this.actionInfo.activation)) {
      this.feature.system.activation.cost = this.actionInfo.activation;
      this.feature.system.consume.amount = this.actionInfo.activation;
    } else {
      this.feature.system.activation.cost = 1;
    }
    this.feature.system.activation.type = this.getAction();

    this.feature.system.recharge = this.actionInfo.recharge;
    this.feature.system.save = this.actionInfo.save;
    // assumption - if we have parsed a save dc set action type to save
    if (this.feature.system.save.dc && !this.isAttack) {
      this.feature.system.actionType = "save";
    }

    this.feature.system.damage = this.actionInfo.damage;
    this.feature.system.formula = this.actionInfo.formula;
    this.feature.system.properties = this.actionInfo.properties;
    this.feature.system.proficient = this.actionInfo.proficient;
    this.feature.system.ability = this.actionInfo.baseAbility;
    this.feature.system.attackBonus = `${this.actionInfo.extraAttackBonus}`;

    if (this.weaponAttack) {
      if (this.templateType !== "feat") {
        this.feature.system.weaponType = this.actionInfo.weaponType;
        this.feature.system.equipped = true;
      }
      // console.log(actionInfo.weaponAttack);
      // console.log(actionInfo.meleeAttack);
      // console.log(actionInfo.rangedAttack);
      if (this.meleeAttack) {
        this.feature.system.actionType = "mwak";
      } else if (this.rangedAttack) {
        this.feature.system.actionType = "rwak";
      }
    } else if (this.spellAttack) {
      if (this.meleeAttack) {
        this.feature.system.actionType = "msak";
      } else if (this.rangedAttack) {
        this.feature.system.actionType = "rsak";
      } else {
        this.feature.system.actionType = "save";
      }
    } else if (this.actionInfo.save.dc) {
      this.feature.system.actionType = "save";
    }

    this.feature.system.range = this.actionInfo.range;
    this.feature.system.target = this.actionInfo.target;
    this.feature.system.duration = this.actionInfo.duration;
    this.feature.system.uses = this.actionInfo.uses;

    if (this.name.includes("/Day")) {
      this.feature.system.uses = this.getUses(true);
    }

    return this.feature;
  }

  #buildLair() {
    if (this.feature.name.trim() === "Lair Actions") {
      this.feature.system.activation.cost = 1;
    }
    return this.feature;
  }

  #buildLegendary() {
    // for the legendary actions feature itself we don't want to do most processing
    if (this.name === "Legendary Actions") {
      this.feature.system.activation.type = "";
      return;
    }

    this.feature.system.activation.type = "legendary";

    this.feature.system.consume = {
      type: "attribute",
      target: "resources.legact.value",
      amount: 1
    };

    if (Number.isInteger(this.actionInfo.activation)) {
      this.feature.system.activation.cost = this.actionInfo.activation;
      this.feature.system.consume.amount = this.actionInfo.activation;
    } else {
      this.feature.system.activation.cost = 1;
    }

    // only attempt to update these if we don't parse an action
    // most legendary actions are just do x thing, where thing is an existing action
    // these have been copied from the existing actions so we don't change
    if (!this.feature.flags.monsterMunch.actionCopy) {
      this.feature.system.recharge = this.actionInfo.recharge;
      this.feature.system.save = this.actionInfo.save;
      // assumption - if we have parsed a save dc set action type to save
      if (this.feature.system.save.dc) {
        this.feature.system.actionType = "save";
      // action.type = "weapon";
      }
      this.feature.system.range = this.actionInfo.range;
      this.feature.system.target = this.actionInfo.target;
      this.feature.system.damage = this.actionInfo.damage;

      if (!this.feature.system.actionType && !this.isAttack && this.feature.system.damage.parts.length > 0) {
        this.feature.system.actionType = "other";
      }
    }

  }

  #buildSpecial() {
    this.feature.system.activation.type = this.getAction();
    if (Number.isInteger(this.actionInfo.activation)) {
      this.feature.system.activation.cost = this.actionInfo.activation;
      this.feature.system.consume.amount = this.actionInfo.activation;
    } else if (this.feature.system.activation.type !== "") {
      this.feature.system.activation.cost = 1;
    }

    this.feature.system.uses = this.actionInfo.uses;
    this.feature.system.recharge = this.actionInfo.recharge;
    this.feature.system.save = this.actionInfo.save;
    this.feature.system.target = this.actionInfo.target;
    // assumption - if we have parsed a save dc set action type to save
    if (this.feature.system.save.dc) {
      this.feature.system.actionType = "save";
    }
    this.feature.system.damage = this.actionInfo.damage;
    // assumption - if the action type is not set but there is damage, the action type is other
    if (!this.feature.system.actionType && this.feature.system.damage.parts.length != 0) {
      this.feature.system.actionType = "other";
    }

    // legendary resistance check
    const resistanceMatch = this.name.match(/Legendary Resistance \((\d+)\/Day/i);
    if (resistanceMatch) {
      this.feature.system.activation.type = "special";
      this.feature.system.activation.cost = null;
      this.feature.system.consume = {
        type: "attribute",
        target: "resources.legres.value",
        amount: 1
      };
    }

    // if this special action has nothing to do, then we remove the activation type
    if (this.feature.system.actionType === null
      && (this.feature.system.uses.value === null || this.feature.system.uses.value === 0)
      && this.feature.system.recharge.value === null
    ) {
      this.feature.system.activation = {
        cost: null,
        type: "",
        condition: "",
      };
    }
  }

  #generateActionInfo() {
    if (this.weaponAttack || this.spellAttack) {
      this.generateWeaponAttackInfo();
    }
    this.generateExtendedDamageInfo();

    this.actionInfo.reach = this.getReach();
    this.actionInfo.range = this.getRange();
    if (this.actionInfo.reach != "") this.actionInfo.properties.rch = true;
    this.actionInfo.recharge = this.getRecharge();
    this.actionInfo.activation = this.getActivation();
    this.actionInfo.save = this.getFeatSave();
    this.actionInfo.target = this.getTarget();
    this.actionInfo.uses = this.getUses();
  }

  parse() {
    this.#generateActionInfo();
    switch (this.type) {
      case "action":
      case "mythic":
      case "reaction":
      case "bonus":
        this.#buildAction();
        break;
      case "lair":
        this.#buildLair();
        break;
      case "legendary":
        this.#buildLegendary();
        break;
      case "special":
        this.#buildSpecial();
        break;
      default:
        _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].error */ .Z.error(`Unknown action parsing type ${this.type}`, { DDBFeature: this });
        throw new Error(`Unknown action parsing type ${this.type}`);
    }

    this.#generateDescription();

    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Parsed Feature ${this.name} for ${this.ddbMonster.name}`, { feature: this });

  }

}


/***/ }),

/***/ 6928:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "_": () => (/* binding */ DDBFeatureFactory)
/* harmony export */ });
/* harmony import */ var _lib_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7669);
/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5259);
/* harmony import */ var _DDBFeature_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(2674);




class DDBFeatureFactory {

  // some monsters now have [rollable] tags - if these exist we need to parse them out
  // in the future we may be able to use them, but not consistent yet
  static replaceRollable(text) {
    const rollableRegex = new RegExp(/(\[rollable\])([^;]*);(.*)(\[\/rollable\])/g);
    return text.replaceAll(rollableRegex, "$2");
  }

  constructor({ ddbMonster, hideDescription, updateExisting } = {}) {
    this.ddbMonster = ddbMonster;

    this.hideDescription = hideDescription;
    this.updateExisting = updateExisting;

    this.featureBlocks = {
      action: [],
      reaction: [],
      bonus: [],
      mythic: [],
      lair: [],
      legendary: [],
      special: [],
    };

    this.features = {
      action: [],
      reaction: [],
      bonus: [],
      mythic: [],
      lair: [],
      legendary: [],
      special: [],
    };

    this.characterDescription = {
      action: "",
      reaction: "",
      bonus: "",
      mythic: "",
      lair: "",
      legendary: "",
      special: "",
      unexpected: null,
    };

    this.html = {
      action: "",
      reaction: "",
      bonus: "",
      mythic: "",
      lair: "",
      legendary: "",
      special: "",
    };

    this.resources = {
      legendary: {
        value: 3,
        max: 3
      },
      lair: {
        value: false,
        initiative: null
      },
      resistance: {
        value: 0,
        max: 0
      },
    };

    this.resistance = {};
  }

  getFeatures(type) {
    return this.features[type].map((feature) => deepClone(feature.feature));
  }

  get actions() {
    return this.getFeatures("action");
  }

  get reactions() {
    return this.getFeatures("reaction");
  }

  get bonus() {
    return this.getFeatures("bonus");
  }

  get mythic() {
    return this.getFeatures("mythic");
  }

  get lair() {
    return this.getFeatures("lair");
  }

  get legendary() {
    return this.getFeatures("legendary");
  }

  get special() {
    return this.getFeatures("special");
  }

  #buildDom(type) {
    let dom = new DocumentFragment();
    $.parseHTML(this.html[type]).forEach((element) => {
      dom.appendChild(element);
    });
    dom.childNodes.forEach((node) => {
      if (node.textContent == "\n" || node.textContent == "\r\n") {
        dom.removeChild(node);
      }
    });
    return dom;
  }

  #generateActionActions(type) {
    let splitActions = this.html[type].split("<h3>Roleplaying Information</h3>");
    if (splitActions.length > 1) {
      this.characterDescription[type] = `<h3>Roleplaying Information</h3>${splitActions[1]}`;
    }
    this.html[type] = splitActions[0];

    let dom = this.#buildDom(type);

    // build out skeleton actions
    dom.querySelectorAll("p").forEach((node) => {

      let pDom = new DocumentFragment();
      $.parseHTML(node.outerHTML).forEach((element) => {
        pDom.appendChild(element);
      });
      const query = pDom.querySelector("strong");
      if (!query) return;
      let name = query.textContent.trim().replace(/\./g, '');
      if (!name.includes("Spell;") && !name.includes("Mythic Trait;")) {
        name = name.split(";").pop().trim();
      }
      const action = { name, options: { html: "", ddbMonster: this.ddbMonster, type, titleHTML: query.outerHTML, fullName: query.textContent } };
      this.featureBlocks[type].push(action);
    });

    // there is inconsistent formatting
    if (this.featureBlocks[type].length == 0) {
      dom.querySelectorAll("p").forEach((node) => {

        let pDom = new DocumentFragment();
        $.parseHTML(node.outerHTML).forEach((element) => {
          pDom.appendChild(element);
        });
        const query = pDom.querySelector("b");
        if (!query) return;
        let name = query.textContent.trim().replace(/\./g, '');
        if (!name.includes("Spell;") && !name.includes("Mythic Trait;")) {
          name = name.split(";").pop().trim();
        }
        const action = { name, options: { html: "", ddbMonster: this.ddbMonster, type, titleHTML: query.outerHTML, fullName: query.textContent } };
        this.featureBlocks[type].push(action);
      });
    }


    // there is inconsistent formatting
    if (this.featureBlocks[type].length == 0) {
      dom.querySelectorAll("p").forEach((node) => {

        let pDom = new DocumentFragment();
        $.parseHTML(node.outerHTML).forEach((element) => {
          pDom.appendChild(element);
        });
        const title = pDom.textContent.split('.')[0];
        const name = title.trim();
        if (name && name.length > 0) {
          const titleHTML = pDom.outerHTML ? pDom.outerHTML.split('.')[0] : undefined;
          const action = { name, options: { html: "", ddbMonster: this.ddbMonster, type, titleHTML } };
          this.featureBlocks[type].push(action);
        }
      });
    }

    // homebrew fun
    if (this.featureBlocks[type].length == 0) {
      dom.querySelectorAll("div").forEach((node) => {

        let pDom = new DocumentFragment();
        $.parseHTML(node.outerHTML).forEach((element) => {
          pDom.appendChild(element);
        });
        const title = pDom.textContent.split('.')[0];
        const name = title.trim();
        if (name && name.length > 0) {
          const titleHTML = pDom.outerHTML ? pDom.outerHTML.split('.')[0] : undefined;
          const action = { name, options: { html: "", ddbMonster: this.ddbMonster, type, titleHTML } };
          this.featureBlocks[type].push(action);
        }
      });
    }

    let action = this.featureBlocks[type][0];

    dom.childNodes.forEach((node) => {
      const nodeContextSplit = node.textContent.split('.');
      const nodeName = nodeContextSplit[0].trim();
      const longNodeName = (nodeContextSplit.length > 2 && nodeContextSplit[1].trim().startsWith('('))
        ? `${nodeName} ${nodeContextSplit[1].trim()}`
        : nodeName;
      let switchAction = this.featureBlocks[type].find((act) => nodeName === act.name || longNodeName === act.name);

      if (!switchAction) {
        switchAction = this.featureBlocks[type].find((act) =>
          act.options?.fullName
          && node.textContent.startsWith(act.options.fullName)
        );
      }
      let startFlag = false;
      if (switchAction) {
        action = switchAction;
        if (action.options.html === "") {
          startFlag = true;
        }
      }

      if (!action) return;

      if (node.outerHTML) {
        let outerHTML = `${node.outerHTML}`;
        if (switchAction && startFlag) {
          const replaceName = getProperty(action, "fullName") ?? nodeName;
          outerHTML = outerHTML.replace(replaceName, "");

          const titleDom = new DocumentFragment();
          $.parseHTML(outerHTML).forEach((element) => {
            titleDom.appendChild(element);
          });
          if (titleDom.textContent.startsWith(".")) outerHTML = outerHTML.replace(".", "");
        }
        action.options.html += outerHTML;
      }
    });
  }

  #generateLairActions(type = "lair") {
    let dom = this.#buildDom(type);

    const defaultAction = { name: "Lair Actions", options: { html: "", ddbMonster: this.ddbMonster, type } };
    this.featureBlocks[type].push(defaultAction);

    dom.querySelectorAll("h4").forEach((node) => {
      const name = node.textContent.trim();
      if (name !== "") {
        const action = { name, options: { html: "", ddbMonster: this.ddbMonster, type } };
        if (node.textContent == "Lair Actions" || node.textContent == "") {
          return;
        }
        this.featureBlocks[type].push(action);
      }
    });

    dom.querySelectorAll("h3").forEach((node) => {
      const name = node.textContent.trim();
      if (name !== "") {
        const action = { name, options: { html: "", ddbMonster: this.ddbMonster, type } };
        if (node.textContent == "Lair Actions" || action.name == "") {
          return;
        }
        this.featureBlocks[type].push(action);
      }
    });

    let actionType = "Lair Actions";
    let action = this.featureBlocks[type].find((act) => act.name == actionType);

    if (!action) {
      action = this.featureBlocks[type][0];
    }

    dom.childNodes.forEach((node) => {
      // const switchAction = dynamicActions.find((act) => act.name == node.textContent);
      const nodeName = node.textContent.split('.')[0].trim();
      const switchAction = this.featureBlocks[type].find((act) => nodeName === act.name);
      let startFlag = false;
      if (switchAction) {
        actionType = node.textContent;
        action = switchAction;
        if (action.options.html === "") startFlag = true;
      }
      if (node.outerHTML) {
        let outerHTML = node.outerHTML;
        if (switchAction && startFlag) {
          outerHTML = outerHTML.replace(`${nodeName}.`, "");
        }
        action.options.html += outerHTML;
      }

      const initiativeMatch = node.textContent.match(/initiative count (\d+)/);
      if (initiativeMatch) {
        this.resources.lair = {
          value: true,
          initiative: parseInt(initiativeMatch[1]),
        };
      }
    });
  }

  #generateLegendaryActions(type) {
    let dom = this.#buildDom(type);

    // Base feat
    const feat = { name: "Legendary Actions", options: { html: "", ddbMonster: this.ddbMonster, type, actionCopy: false } };
    feat.options.html = `${this.html[type]}`;
    this.featureBlocks[type].push(feat);


    // build out skeleton actions
    dom.querySelectorAll("strong").forEach((node) => {
      const name = node.textContent.trim().replace(/\.$/, '').trim();
      const action = { name, options: { html: "", ddbMonster: this.ddbMonster, type, actionCopy: false } };

      const actionMatch = this.features["action"].concat(
        this.features.reaction,
        this.features.reaction,
        this.features.bonus,
      ).find((mstAction) =>
        name == mstAction.name
        || name == `${mstAction.name} Attack`
        || name == `${mstAction.name}`.split('(', 1)[0].trim()
        || name == `${mstAction.name} Attack`.split('(', 1)[0].trim()
      );

      if (actionMatch) {
        const dupFeature = new _DDBFeature_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z(name, { ddbMonster: this.ddbMonster, html: actionMatch.html, type, actionCopy: true });
        dupFeature.feature = duplicate(actionMatch.feature);
        dupFeature.feature.name = action.name; // fix up name to make sure things like Attack are included
        this.features[type].push(dupFeature);
        action.options.actionCopy = true;
      }
      this.featureBlocks[type].push(action);

    });

    let action = this.featureBlocks[type].find((act) => act.name == "Legendary Actions");

    dom.childNodes
      .forEach((node) => {
      // check for action numbers
      // can take 3 legendary actions
        let startFlag = false;
        const actionMatch = node.textContent.match(/can take (d+) legendary actions/);
        if (actionMatch) {
          this.resource.legendary.value = parseInt(actionMatch[1]);
          this.resource.legendary.max = parseInt(actionMatch[1]);
        }

        const nodeName = node.textContent.split('.')[0].trim();
        const switchAction = this.featureBlocks[type].find((act) => nodeName === act.name);
        if (action.name !== "Legendary Actions" || switchAction) {

          if (switchAction) {
            action = switchAction;
            if (action.options.html === "") {
              startFlag = true;
            }
          }

          if (action.options.actionCopy) return;
          if (node.outerHTML) {
            let outerHTML = node.outerHTML;
            if (switchAction && startFlag) {
              outerHTML = outerHTML.replace(`${nodeName}.`, "");
            }
            action.options.html += outerHTML;
          }
        }
      });
  }

  #generateSpecialActions(type) {
    let splitActions = this.html[type].split("<h3>Roleplaying Information</h3>");
    if (splitActions.length > 1) {
      this.characterDescription[type] = `<h3>Roleplaying Information</h3>${splitActions[1]}`;
    }

    this.html[type] = splitActions[0];
    let dom = this.#buildDom(type);

    // build out skeleton actions
    dom.querySelectorAll("p").forEach((node) => {
      let pDom = new DocumentFragment();
      $.parseHTML(node.outerHTML).forEach((element) => {
        pDom.appendChild(element);
      });
      const query = pDom.querySelector("em");
      if (!query) return;
      let name = query.textContent.trim().replace(/\./g, '');
      if (!name.includes("Spell;") && !name.includes("Mythic Trait;")) {
        name = name.split(";").pop().trim();
      }
      if (name) {
        const action = { name, options: { html: "", ddbMonster: this.ddbMonster, type, titleHTML: query.outerHTML, fullName: query.textContent } };
        this.featureBlocks[type].push(action);
      }
    });

    if (this.featureBlocks[type].length == 0) {
      dom.querySelectorAll("p").forEach((node) => {
        let pDom = new DocumentFragment();
        $.parseHTML(node.outerHTML).forEach((element) => {
          pDom.appendChild(element);
        });
        const query = pDom.querySelector("strong");
        if (!query) return;
        let name = query.textContent.trim().replace(/\./g, '');
        if (!name.includes("Spell;") && !name.includes("Mythic Trait;")) {
          name = name.split(";").pop().trim();
        }
        if (name) {
          const action = { name, options: { html: "", ddbMonster: this.ddbMonster, type, titleHTML: query.outerHTML, fullName: query.textContent } };
          this.featureBlocks[type].push(action);
        }
      });
    }

    if (this.featureBlocks[type].length == 0) {
      dom.querySelectorAll("em").forEach((node) => {
        const name = node.textContent.trim().replace(/\.$/, '').trim();
        if (name) {
          const action = { name, options: { html: "", ddbMonster: this.ddbMonster, type, titleHTML: node.outerHTML, fullName: node.textContent } };
          this.featureBlocks[type].push(action);
        }
      });
    }

    if (this.featureBlocks[type].length == 0) {
      dom.querySelectorAll("strong").forEach((node) => {
        const name = node.textContent.trim().replace(/\.$/, '').trim();
        if (name) {
          const action = { name, options: { html: "", ddbMonster: this.ddbMonster, type, titleHTML: node.outerHTML, fullName: node.textContent } };
          this.featureBlocks[type].push(action);
        }
      });
    }

    if (this.featureBlocks[type].length == 0) {
      const action = { name: "Special Traits", options: { html: "", ddbMonster: this.ddbMonster, type } };
      this.featureBlocks[type].push(action);
    }

    if (this.featureBlocks[type].length === 0) return;

    let action = this.featureBlocks[type][0];

    dom.childNodes.forEach((node) => {
      const nodeName = node.textContent.split('.')[0].trim();
      let switchAction = this.featureBlocks[type].find((act) => nodeName === act.name);
      if (action.name.includes("; Recharges after a Short or Long Rest")) action.name = action.name.replace("; Recharges after a Short or Long Rest", "");
      if (!switchAction) {
        switchAction = this.featureBlocks[type].find((act) => node.textContent.startsWith(act.options.fullName));
      }
      let startFlag = false;
      if (switchAction) {
        action = switchAction;
        if (action.options.html === "") {
          startFlag = true;
        }
      }

      if (node.outerHTML) {
        let outerHTML = node.outerHTML;
        if (switchAction && startFlag) {
          if (action.options.fullName) {
            outerHTML = outerHTML.replace(action.fullName, "");
          } else {
            outerHTML = outerHTML.replace(nodeName, "");
          }
        }
        const titleDom = new DocumentFragment();
        $.parseHTML(outerHTML).forEach((element) => {
          titleDom.appendChild(element);
        });
        if (titleDom.textContent.startsWith(". ")) outerHTML = outerHTML.replace(". ", "");
        action.options.html += outerHTML;
      }

      const resistanceMatch = node.textContent.match(/Legendary Resistance \((\d+)\/Day/i);
      if (resistanceMatch) {
        this.resources.resistance.value = parseInt(resistanceMatch[1]);
        this.resources.resistance.max = parseInt(resistanceMatch[1]);
      }
    });
  }

  // possible regular types:
  // action, reaction, bonus, mythic
  // this.ddbMonster.source.actionsDescription
  // this.ddbMonster.source.reactionsDescription
  // this.ddbMonster.source.bonusActionsDescription
  // this.ddbMonster.source.mythicActionsDescription

  generateActions(html, type = "action") {
    if (!html || html.trim() == "") return;

    this.html[type] = DDBFeatureFactory.replaceRollable(_lib_utils_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].replaceHtmlSpaces */ .Z.replaceHtmlSpaces(`${html}`))
      .replace(/<\/strong> <strong>/g, "")
      .replace(/<\/strong><strong>/g, "")
      .replace(/&shy;/g, "");

    switch (type) {
      case "action":
      case "bonus":
      case "mythic":
      case "reaction":
        this.#generateActionActions(type);
        break;
      case "lair":
        this.#generateLairActions(type);
        break;
      case "legendary":
        this.#generateLegendaryActions(type);
        break;
      case "special":
        this.#generateSpecialActions(type);
        break;
      default:
        _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].error */ .Z.error(`Unknown action parsing type ${this.type}`, { DDBFeatureFactory: this });
        throw new Error(`Unknown action parsing type ${this.type}`);
    }

    // some features are duplicated and we parse these first
    this.features[type].forEach((feature) => {
      feature.parse();
    });

    // parse remaining feature blocks
    this.featureBlocks[type]
      .filter((feature) => !feature.options.actionCopy)
      .forEach((feature) => {
        feature.options["hideDescription"] = this.hideDescription;
        feature.options["updateExisting"] = this.updateExisting;
        const ddbFeature = new _DDBFeature_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z(feature.name, feature.options);
        ddbFeature.parse();
        this.features[type].push(ddbFeature);
      });

  }

}



/***/ }),

/***/ 5371:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "T": () => (/* binding */ getAbilityMods)
/* harmony export */ });
/* harmony import */ var _dictionary_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(37);


function getAbilityMods(monster) {
  let abilities = {};

  _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].character.abilities.forEach */ .Z.character.abilities.forEach((ability) => {
    const value = monster.stats.find((stat) => stat.statId === ability.id).value || 0;
    const mod = CONFIG.DDB.statModifiers.find((s) => s.value == value).modifier;
    abilities[ability.value] = mod;
  });

  return abilities;

}


/***/ }),

/***/ 1309:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "N": () => (/* binding */ newNPC)
/* harmony export */ });
async function newNPC(name) {
  const options = {
    temporary: true,
    displaySheet: false,
  };
  const npcClass = await Actor.create({ name, type: "npc" }, options);
  let npc = npcClass.toObject();
  const flags = {
    dnd5e: {},
    monsterMunch: {},
    ddbimporter: {
      dndbeyond: {},
    },
  };
  setProperty(npc, "flags", flags);
  // delete npc._id;
  return npc;
};


/***/ }),

/***/ 1434:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ DDBRace)
/* harmony export */ });
/* harmony import */ var _lib_DDBTemplateStrings_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(258);
/* harmony import */ var _lib_DDBHelper_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1438);
/* harmony import */ var _lib_CompendiumHelper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3893);
/* harmony import */ var _lib_FileHelper_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(2397);






class DDBRace {

  constructor(race, compendiumRacialTraits) {
    this.race = race;
    this.compendiumRacialTraits = compendiumRacialTraits;
    this.data = {
      "name": "",
      "type": "feat",
      "system": {
        "description": {
          "value": "",
          "chat": "",
          "unidentified": ""
        },
        "source": "",
        "type": {
          "value": "race",
        },
      },
      "sort": 2600000,
      "flags": {
        "ddbimporter": {
          "type": "race",
        },
        "obsidian": {
          "source": {
            "type": "race"
          }
        },
      },
      "img": null
    };
  }

  buildBase() {
    this.data.name = (this.race.fullName) ? this.race.fullName.replace("â€™", "'") : this.race.name.replace("â€™", "'");
    this.data.system.description.value += `${this.race.description}\n\n`;

    this.data.flags.ddbimporter = {
      entityRaceId: this.race.entityRaceId,
      version: CONFIG.DDBI.version,
      sourceId: this.race.sources.length > 0 ? [0].sourceId : -1, // is homebrew
      baseName: (this.race.fullName) ? this.race.fullName.replace("â€™", "'") : this.race.name.replace("â€™", "'")
    };

    if (this.race.moreDetailsUrl) {
      this.data.flags.ddbimporter['moreDetailsUrl'] = this.race.moreDetailsUrl;
    }

    this.data.system.source = _lib_DDBHelper_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].parseSource */ .Z.parseSource(this.race);

    if (this.race.isSubRace && this.race.baseRaceName) this.data.system.requirements = this.race.baseRaceName;
    const legacyName = game.settings.get("ddb-importer", "munching-policy-legacy-postfix");
    if (legacyName && this.race.isLegacy) {
      this.data.name += " (Legacy)";
    }
    return this.data;
  }

  async buildRace() {
    this.buildBase();

    let avatarUrl;
    let largeAvatarUrl;
    let portraitAvatarUrl;

    this.data.flags.ddbimporter.baseRaceId = this.race.baseRaceId;
    this.data.flags.ddbimporter.baseName = this.race.baseName;
    this.data.flags.ddbimporter.baseRaceName = this.race.baseRaceName;
    this.data.flags.ddbimporter.fullName = this.race.fullName;
    this.data.flags.ddbimporter.subRaceShortName = this.race.subRaceShortName;
    this.data.flags.ddbimporter.isHomebrew = this.race.isHomebrew;
    this.data.flags.ddbimporter.isLegacy = this.race.isLegacy;
    this.data.flags.ddbimporter.isSubRace = this.race.isSubRace;
    this.data.flags.ddbimporter.moreDetailsUrl = this.race.moreDetailsUrl;
    this.data.flags.ddbimporter.featIds = this.race.featIds;

    if (this.race.portraitAvatarUrl) {
      const downloadOptions = { type: "race-portrait", name: this.race.fullName };
      portraitAvatarUrl = await _lib_FileHelper_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].getImagePath */ .Z.getImagePath(this.race.portraitAvatarUrl, downloadOptions);
      this.data.img = portraitAvatarUrl;
      this.data.flags.ddbimporter['portraitAvatarUrl'] = this.race.portraitAvatarUrl;
    }

    if (this.race.avatarUrl) {
      const downloadOptions = { type: "race-avatar", name: this.race.fullName };
      avatarUrl = await _lib_FileHelper_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].getImagePath */ .Z.getImagePath(this.race.avatarUrl, downloadOptions);
      this.data.flags.ddbimporter['avatarUrl'] = this.race.avatarUrl;
      if (!this.data.img) {
        this.data.img = avatarUrl;
      }
    }

    if (this.race.largeAvatarUrl) {
      const downloadOptions = { type: "race-large", name: this.race.fullName };
      largeAvatarUrl = await _lib_FileHelper_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].getImagePath */ .Z.getImagePath(this.race.largeAvatarUrl, downloadOptions);
      // eslint-disable-next-line require-atomic-updates
      this.data.flags.ddbimporter['largeAvatarUrl'] = this.race.largeAvatarUrl;
      if (!this.data.img) {
        this.data.img = largeAvatarUrl;
      }
    }

    const image = (avatarUrl) ? `<img src="${avatarUrl}">\n\n` : (largeAvatarUrl) ? `<img src="${largeAvatarUrl}">\n\n` : "";
    this.data.system.description.value += image;

    const compendiumLabel = _lib_CompendiumHelper_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].getCompendiumLabel */ .Z.getCompendiumLabel("traits");

    this.race.racialTraits.forEach((f) => {
      const feature = f.definition;
      const featureMatch = this.compendiumRacialTraits.find((match) =>
        hasProperty(match, "flags.ddbimporter.baseName") && hasProperty(match, "flags.ddbimporter.entityRaceId")
        && feature.name.replace("â€™", "'") === match.flags.ddbimporter.baseName
        && match.flags.ddbimporter.entityRaceId === feature.entityRaceId
      );
      const title = (featureMatch) ? `<p><b>@Compendium[${compendiumLabel}.${featureMatch._id}]{${feature.name}}</b></p>` : `<p><b>${feature.name}</b></p>`;
      this.data.system.description.value += `${title}\n${feature.description}\n\n`;
    });

    this.data.system.description.value = (0,_lib_DDBTemplateStrings_js__WEBPACK_IMPORTED_MODULE_0__/* .parseTags */ .RN)(this.data.system.description.value);

    return this.data;
  }

  static async getRacialTraitsLookup(racialTraits, fail = true) {
    const compendium = _lib_CompendiumHelper_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].getCompendiumType */ .Z.getCompendiumType("traits", fail);
    if (compendium) {
      const flags = ["name", "flags.ddbimporter.entityRaceId", "flags.ddbimporter.baseName"];
      const index = await compendium.getIndex({ fields: flags });
      const traitIndex = await index.filter((i) => racialTraits.some((orig) => i.name === orig.name));
      return traitIndex;
    } else {
      return [];
    }
  }

}



/***/ }),

/***/ 2352:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "eO": () => (/* binding */ hasSpellCastingAbility),
/* harmony export */   "f5": () => (/* binding */ convertSpellCastingAbilityId),
/* harmony export */   "sX": () => (/* binding */ getSpellCastingAbility)
/* harmony export */ });
/* harmony import */ var _dictionary_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(37);


// is there a spell casting ability?
function hasSpellCastingAbility(spellCastingAbilityId) {
  return _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].character.abilities.find */ .Z.character.abilities.find((ability) => ability.id === spellCastingAbilityId) !== undefined;
}

// convert spellcasting ability id to string used by foundry
function convertSpellCastingAbilityId(spellCastingAbilityId) {
  return _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].character.abilities.find */ .Z.character.abilities.find((ability) => ability.id === spellCastingAbilityId).value;
}

// search through classinfo and determine spellcasting ability
function getSpellCastingAbility(classInfo, checkSubclass = true, onlySubclass = false) {
  let spellCastingAbility = undefined;
  if (!onlySubclass && hasSpellCastingAbility(classInfo.definition.spellCastingAbilityId)) {
    spellCastingAbility = convertSpellCastingAbilityId(classInfo.definition.spellCastingAbilityId);
  } else if (
    checkSubclass
    && classInfo.subclassDefinition
    && hasSpellCastingAbility(classInfo.subclassDefinition.spellCastingAbilityId)
  ) {
    // e.g. Arcane Trickster has spellcasting ID granted here
    spellCastingAbility = convertSpellCastingAbilityId(classInfo.subclassDefinition.spellCastingAbilityId);
  } else {
    // special cases: No spellcaster, but can cast spells like totem barbarian, default to wis
    spellCastingAbility = "wis";
  }
  return spellCastingAbility;
}


/***/ }),

/***/ 6721:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "t": () => (/* binding */ getLookups)
/* harmony export */ });
/**
 * Generates some meta data for a character to use to determine what to do
 * with a spell.
 * We use this like a quick lookup table
 * @param {*} character
 */
function getLookups(character) {
  // racialTraits
  let lookups = {
    race: [],
    feat: [],
    class: [],
    classFeature: [],
    item: [],
  };
  character.race.racialTraits.forEach((trait) => {
    lookups.race.push({
      id: trait.definition.id,
      name: trait.definition.name,
    });
  });

  character.classes.forEach((playerClass) => {
    lookups.class.push({
      id: playerClass.definition.id,
      name: playerClass.definition.name,
    });

    if (playerClass.subclassDefinition) {
      lookups.class.push({
        id: playerClass.subclassDefinition.id,
        name: playerClass.subclassDefinition.name,
      });
    }

    if (playerClass.classFeatures) {
      playerClass.classFeatures.forEach((trait) => {
        lookups.classFeature.push({
          id: trait.definition.id,
          name: trait.definition.name,
          classId: trait.definition.classId,
          componentId: trait.definition.componentId,
        });
      });
    }
  });

  character.options.class.forEach((trait) => {
    lookups.classFeature.push({
      id: trait.definition.id,
      name: trait.definition.name,
      componentId: trait.componentId,
    });
  });

  character.feats.forEach((trait) => {
    lookups.feat.push({
      id: trait.definition.id,
      name: trait.definition.name,
      componentId: trait.componentId,
    });
  });

  character.inventory.forEach((trait) => {
    lookups.item.push({
      id: trait.definition.id,
      name: trait.definition.name,
      limitedUse: trait.limitedUse,
      equipped: trait.equipped,
      isAttuned: trait.isAttuned,
      canAttune: trait.definition.canAttune,
      canEquip: trait.definition.canEquip,
    });
  });

  return lookups;
}


/***/ }),

/***/ 1702:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "T": () => (/* binding */ parseSpell)
});

// EXTERNAL MODULE: ./src/lib/utils.js
var utils = __webpack_require__(7669);
// EXTERNAL MODULE: ./src/dictionary.js
var dictionary = __webpack_require__(37);
// EXTERNAL MODULE: ./src/lib/DDBHelper.js
var DDBHelper = __webpack_require__(1438);
;// CONCATENATED MODULE: ./src/parser/spells/components.js
function getComponents (data) {
  return {
    value: data.definition.componentsDescription,
    vocal: data.definition.components.includes(1),
    somatic: data.definition.components.includes(2),
    material: data.definition.components.includes(3),
    ritual: data.definition.ritual,
    concentration: data.definition.concentration,
  };
}

function getMaterials(data) {
  // this is mainly guessing
  if (data.definition.componentsDescription && data.definition.componentsDescription.length > 0) {
    let cost = 0;
    let matches = data.definition.componentsDescription.toLowerCase().match(/([\d.,]+)\s*gp/);
    if (matches) {
      cost = parseInt(matches[1].replace(/,|\./g, ""));
    }

    return {
      value: data.definition.componentsDescription,
      consumed: data.definition.componentsDescription.toLowerCase().indexOf("consume") !== -1,
      cost: cost,
      supply: 0,
    };
  } else {
    return {
      value: "",
      consumed: false,
      cost: 0,
      supply: 0,
    };
  }
}

;// CONCATENATED MODULE: ./src/parser/spells/prepartion.js




function classSpell(data, result) {
  const classPrepMode = utils/* default.findByProperty */.Z.findByProperty(
    dictionary/* default.spell.preparationModes */.Z.spell.preparationModes,
    "name",
    data.flags.ddbimporter.dndbeyond.class
  );
  if (data.restriction === "As Ritual Only") {
    result.mode = "prepared";
    result.prepared = false;
  } else if (!data.usesSpellSlot && data.definition.level !== 0) {
    // some class features such as druid circle of stars grants x uses of a spell
    // at the lowest level. for these we add as an innate.
    result.mode = "innate";
  } else if (data.alwaysPrepared) {
    result.mode = "always";
  } else if (result.mode && classPrepMode) {
    result.mode = classPrepMode.value;
  }
  // Warlocks should use Pact spells
  // but lets mark level 0 as regular spells so they show up as cantrips
  if (result.mode === "pact" && data.definition.level === 0) {
    result.mode = "prepared";
    result.prepared = true;
  } else if (result.mode === "pact" && game.settings.get("ddb-importer", "pact-spells-prepared")) {
    result.prepared = true;
  }
  return result;
}

/**
 * Retrieves the spell preparation mode, depending on the location this spell came from
 *
 */
function getSpellPreparationMode(data) {
  // default values
  let result = {
    mode: "prepared",
    // If always prepared mark as such, if not then check to see if prepared
    prepared: data.alwaysPrepared || data.prepared,
  };

  // handle classSpells
  const featureClass = data.flags.ddbimporter.dndbeyond.lookup === "classFeature"
    && data.flags.ddbimporter.dndbeyond.class;

  if (data.flags.ddbimporter.dndbeyond.lookup === "classSpell" || featureClass) {
    result = classSpell(data, result);
  } else if (data.flags.ddbimporter.dndbeyond.lookup === "race" && data.definition.level !== 0) {
    // set race spells as innate
    result.mode = "innate";
    if (data.usesSpellSlot) {
      // some racial spells allow the spell to also be added to spell lists
      result.mode = "always";
    }
  } else if (
    // Warlock Mystic Arcanum are passed in as Features
    data.flags.ddbimporter.dndbeyond.lookupName.startsWith("Mystic Arcanum")
  ) {
    // these have limited uses (set with getUses())
    result.mode = "pact";
    result.prepared = false;
  } else if (data.flags.ddbimporter.dndbeyond.lookup === "item " && data.definition.level !== 0) {
    result.mode = "prepared";
    result.prepared = false;
  } else {
    // If spell doesn't use a spell slot and is not a cantrip, mark as always preped
    let always = !data.usesSpellSlot && data.definition.level !== 0;
    let ritaulOnly = data.ritualCastingType !== null || data.castOnlyAsRitual; // e.g. Book of ancient secrets & totem barb
    if (always && ritaulOnly) {
      // in this case we want the spell to appear in the spell list unprepared
      result.prepared = false;
    } else if (always) {
      // these spells are always prepared, and have a limited use that's
      // picked up by getUses() later
      // this was changed to "atwill"
      result.mode = "atwill";
    }
    if (data.flags.ddbimporter.dndbeyond.lookup === "classFeature") {
      if (data.alwaysPrepared) {
        result.mode = "always";
      }
    }
  }

  return result;
}

;// CONCATENATED MODULE: ./src/parser/spells/uses.js


const DEFAULT_USE = {
  value: null,
  max: null,
  per: "",
};

/**
 * Get the reset condition of the spell, if uses restricted
 * @param {*} data Spell data
 * @param {*} character Character data
 */
function getUses(data, character) {
  // we check this, as things like items have useage attached to the item, not spell
  const limitedUse = hasProperty(data, "flags.ddbimporter.dndbeyond.limitedUse")
    ? data.flags.ddbimporter.dndbeyond.limitedUse
    : data.limitedUse;

  if (!limitedUse) return DEFAULT_USE;
  const resetType = dictionary/* default.resets.find */.Z.resets.find((reset) => reset.id == limitedUse.resetType);
  if (!resetType) return DEFAULT_USE;

  if (limitedUse.maxUses || limitedUse.statModifierUsesId || limitedUse.useProficiencyBonus) {
    let maxUses = (limitedUse.maxUses && limitedUse.maxUses !== -1) ? limitedUse.maxUses : 0;

    if (limitedUse.statModifierUsesId) {
      const ability = dictionary/* default.character.abilities.find */.Z.character.abilities.find(
        (ability) => ability.id === limitedUse.statModifierUsesId
      ).value;

      switch (limitedUse.operator) {
        case 2: {
          maxUses *= character.flags.ddbimporter.dndbeyond.effectAbilities[ability].mod;
          break;
        }
        case 1:
        default:
          maxUses += character.flags.ddbimporter.dndbeyond.effectAbilities[ability].mod;
      }
    }

    if (limitedUse.useProficiencyBonus) {
      switch (limitedUse.proficiencyBonusOperator) {
        case 2: {
          maxUses *= character.system.attributes.prof;
          break;
        }
        case 1:
        default:
          maxUses += character.system.attributes.prof;
      }
    }

    const finalMaxUses = (maxUses) ? parseInt(maxUses) : null;

    return {
      value: (finalMaxUses !== null && finalMaxUses != 0) ? maxUses - limitedUse.numberUsed : null,
      max: (finalMaxUses != 0) ? finalMaxUses : null,
      per: resetType ? resetType.value : "",
    };
  } else {
    return DEFAULT_USE;
  }
}

;// CONCATENATED MODULE: ./src/parser/spells/activation.js


/**
 * Gets the activation information of this spell
 */
function getActivation(data) {
  // for newer override spells, activation is at higher level
  const activation = data.activation ? data.activation : data.definition.activation;
  const activationType = dictionary/* default.spell.activationTypes.find */.Z.spell.activationTypes.find(
    (type) => type.activationType === activation.activationType
  );
  if (activationType && activation.activationTime) {
    return {
      type: activationType.value,
      cost: activation.activationTime,
      condition: data.definition.castingTimeDescription || "",
    };
  } else {
    return {
      type: "action",
      cost: 1,
      condition: data.definition.castingTimeDescription || "",
    };
  }
}

;// CONCATENATED MODULE: ./src/parser/spells/duration.js
/**
 * Retrieves the spell duration
 */
function getDuration(data) {
  if (data.definition.duration) {
    let units = "";
    if (data.definition.duration.durationUnit !== null) {
      units = data.definition.duration.durationUnit.toLowerCase();
    } else {
      units = data.definition.duration.durationType.toLowerCase().substring(0, 4);
    }
    return {
      value: data.definition.duration.durationInterval || "",
      units: units,
    };
  } else {
    return {};
  }
}

;// CONCATENATED MODULE: ./src/parser/spells/target.js


/**
 * Does the spell target creatures?
 * @param {*} data
 */
let doesTargetCreature = (data) => {
  const creature = /a creature you|creature( that)? you can see|interrupt a creature|would strike a creature|creature of your choice|creature or object within range|cause a creature|creature must be within range/gi;
  const creaturesRange = /(humanoid|monster|creature|target)(s)? (or loose object )?(of your choice )?(that )?(you can see )?within range/gi;
  return data.definition.description.match(creature) || data.definition.description.match(creaturesRange);
};

/**
 * Get Target Values
 * Uses regex magic to try and determine the number of creatures affected
 * @param {*} data
 */
let getTargetValues = (data) => {
  const numCreatures = /(?!At Higher Levels.*)(\w*) (falling )?(willing )?(creature|target|monster|celestial|fiend|fey|corpse(s)? of|humanoid)(?!.*you have animated)/gim;
  const targets = [...data.definition.description.matchAll(numCreatures)];
  const targetValues = targets
    .filter((target) => {
      const matches = dictionary/* default.numbers.filter */.Z.numbers.filter((n) => n.natural === target[1].toLowerCase());
      return Array.isArray(matches) && !!matches.length;
    })
    .map((target) => dictionary/* default.numbers.find */.Z.numbers.find((n) => n.natural === target[1].toLowerCase()).num);

  if (Array.isArray(targetValues) && !!targetValues.length) {
    return Math.max(...targetValues);
  } else {
    return null;
  }
};

/**
 * Spell targets
 */
// eslint-disable-next-line complexity
function getTarget(data) {
  const result = {
    value: null,
    units: null,
    type: null,
    width: null,
  };

  // if spell is an AOE effect get some details
  if (data.definition.range.aoeType && data.definition.range.aoeValue) {
    result.value = parseInt(data.definition.range.aoeValue);
    result.type = data.definition.range.aoeType.toLowerCase();
    result.units = "ft";
    return result;
  }

  // does the spell target a creature?
  const creatures = doesTargetCreature(data);

  if (creatures) {
    result.value = getTargetValues(data);
  }

  switch (data.definition.range.origin) {
    case "Touch":
      result.units = "touch";
      if (creatures) result.type = "creature";
      break;
    case "Self": {
      const dmgSpell = data.definition.modifiers.some((mod) => mod.type === "damage");
      result.type = (dmgSpell) ? "creature" : "self";
      break;
    }
    case "None":
      result.type = "none";
      break;
    case "Ranged":
      if (creatures) result.type = "creature";
      break;
    case "Feet":
      if (creatures) result.type = "creature";
      break;
    case "Miles":
      if (creatures) result.type = "creature";
      break;
    case "Sight":
    case "Special":
      result.units = "special";
      break;
    case "Any":
      result.units = "any";
      break;
    case undefined:
      result.type = null;
      break;
    // no default
  }

  // wall type spell?
  if (data.definition.name.includes("Wall")) {
    result.type = "wall";
    result.units = "ft";

    if (data.definition.description.includes("ten 10-foot-")) {
      result.value = 100;
    } else {
      const wallReg = new RegExp(/ (\d*) feet long/);
      const matches = data.definition.description.match(wallReg);
      if (matches) {
        result.value = parseInt(matches[1]);
      }
    }
    const thickReg = new RegExp(/ (\d*) foot (thick|wide)/);
    const thickMatch = data.definition.description.match(thickReg);
    if (thickMatch && thickMatch[1] > 5) {
      result.width = parseInt(thickMatch[1]);
    }
  }

  return result;
}

;// CONCATENATED MODULE: ./src/parser/spells/range.js
/** Spell range */
function getRange(data) {
  // else lets try and fill in some target details
  let value = data.definition.range.rangeValue ? data.definition.range.rangeValue : null;
  let units = "ft";
  let long = null;

  switch (data.definition.range.origin) {
    case "Touch":
      value = null;
      units = "touch";
      break;
    case "Self":
      value = null;
      units = "self";
      break;
    case "None":
      units = "none";
      break;
    case "Ranged":
      units = "ft";
      break;
    case "Feet":
      units = "ft";
      break;
    case "Miles":
      units = "ml";
      break;
    case "Sight":
    case "Special":
      units = "special";
      break;
    case "Any":
      units = "any";
      break;
    case undefined:
      units = null;
      break;
    // no default
  }

  return {
    value: value,
    long: long,
    units: units,
  };
}

;// CONCATENATED MODULE: ./src/parser/spells/action.js
function getActionType(data) {
  if (data.definition.requiresSavingThrow && !data.definition.requiresAttackRoll) {
    return "save";
  }

  if (
    data.definition.tags.includes("Damage")
    && data.definition.range.rangeValue
    && data.definition.range.rangeValue > 0
  ) {
    return "rsak";
  }

  if (data.definition.tags.includes("Damage")) {
    return "msak";
  }

  if (data.definition.tags.includes("Healing")) {
    return "heal";
  }

  if (data.definition.tags.includes("Buff")) {
    return "util";
  }

  return "other";
}

;// CONCATENATED MODULE: ./src/parser/spells/damage.js


let getAlternativeFormula = (data) => {
  // this might be specificially for Toll the Dead only, but it's better than nothing

  let description = data.definition.description;
  let match = description.match(/instead[\w\s]+(\d+d\d+) (\w+) damage/);
  if (match) {
    return match[1];
  } else {
    return "";
  }
};

function getDamage(data, spell) {
  let result = {
    parts: [],
    versatile: "",
  };
  let chatFlavor = [];

  const globalDamageHints = game.settings.get("ddb-importer", "use-damage-hints");
  const spellEffects = getProperty(data, "flags.ddbimporter.addSpellEffects");
  const damageRestrictionHints = game.settings.get("ddb-importer", "add-damage-restrictions-to-hints") && !spellEffects;
  const hintOrRestriction = globalDamageHints || damageRestrictionHints;

  // damage
  const attacks = data.definition.modifiers.filter((mod) => mod.type === "damage");
  if (attacks.length !== 0) {
    const cantripBoost = data.definition.level === 0 && !!data.flags.ddbimporter.dndbeyond.cantripBoost;
    attacks.forEach((attack) => {
      const restrictionText = attack.restriction && attack.restriction !== "" ? attack.restriction : "";
      const restriction = damageRestrictionHints && restrictionText !== "" ? restrictionText : "";
      const damageHintText = attack.subType || "";
      if (!damageRestrictionHints && restrictionText !== "") {
        const damageText = attack.die.diceString ? `${attack.die.diceString} - ` : "";
        chatFlavor.push(`[${damageText}${damageHintText}] ${restrictionText}`);
      }
      const hintAndRestriction = globalDamageHints && restriction !== "" ? " - " : "";
      const damageHint = globalDamageHints ? damageHintText : "";
      const damageTag = hintOrRestriction ? `[${damageHint}${hintAndRestriction}${restriction}]` : "";
      const addMod = attack.usePrimaryStat || cantripBoost ? " + @mod" : "";
      let diceString = utils/* default.parseDiceString */.Z.parseDiceString(attack.die.diceString, addMod, damageTag).diceString;
      if (diceString && diceString.trim() !== "" && diceString.trim() !== "null") result.parts.push([diceString, attack.subType]);
    });

    // This is probably just for Toll the dead.
    const alternativeFormula = getAlternativeFormula(data);
    result.versatile = cantripBoost && alternativeFormula && alternativeFormula != "" ? `${alternativeFormula} + @mod` : alternativeFormula;
  }

  // healing
  const heals = data.definition.modifiers.filter((mod) => mod.type === "bonus" && mod.subType === "hit-points");
  if (heals.length !== 0) {
    const healingBonus = (spell.flags.ddbimporter.dndbeyond.healingBoost) ? ` + ${spell.flags.ddbimporter.dndbeyond.healingBoost} + @item.level` : "";
    heals.forEach((heal) => {
      const restrictionText = heal.restriction && heal.restriction !== "" ? heal.restriction : "";
      const restriction = damageRestrictionHints && restrictionText !== "" ? restrictionText : "";
      if (!damageRestrictionHints && restrictionText !== "") {
        const damageText = heal.die.diceString ? `${heal.die.diceString} - ` : "";
        chatFlavor.push(`[${damageText}healing] ${restrictionText}`);
      }
      const hintAndRestriction = globalDamageHints && restriction !== "" ? " - " : "";
      const damageHint = globalDamageHints ? "healing" : "";
      const damageTag = hintOrRestriction ? `[${damageHint}${hintAndRestriction}${restriction}]` : "";
      const healValue = (heal.die.diceString) ? `${heal.die.diceString}${damageTag}` : heal.die.fixedValue;
      const diceString = heal.usePrimaryStat
        ? `${healValue} + @mod${healingBonus}`
        : `${healValue}${healingBonus}`;
      if (diceString && diceString.trim() !== "" && diceString.trim() !== "null") result.parts.push([diceString, "healing"]);
    });
  }

  return [result, chatFlavor.join(", ")];
}

;// CONCATENATED MODULE: ./src/parser/spells/save.js


function getSave(data) {
  if (data.definition.requiresSavingThrow && data.definition.saveDcAbilityId) {
    const saveAbility = dictionary/* default.character.abilities.find */.Z.character.abilities.find((ability) => ability.id === data.definition.saveDcAbilityId)
      .value;
    if (data.overrideSaveDc) {
      return {
        ability: saveAbility,
        dc: data.overrideSaveDc,
        scaling: "flat",
      };
    } else {
      return {
        ability: saveAbility,
        dc: null,
        scaling: "spell",
      };
    }
  } else {
    return {
      ability: "",
      dc: null,
    };
  }
}

// EXTERNAL MODULE: ./src/logger.js
var logger = __webpack_require__(5259);
;// CONCATENATED MODULE: ./src/parser/spells/scaling.js


/**
 * Get the scaling type for a spell mod
 * This is complex logic and is broken out to help simplify
 * @param {*} name
 * @param {*} mod
 */
let getScaleType = (name, data, mod) => {
  // scaleTypes:
  // SPELLSCALE - typical spells that scale
  // SPELLLEVEL - these spells have benefits that come in at particular levels e.g. bestow curse, hex. typically  duration changes
  // CHARACTERLEVEL - typical cantrip based levelling, some expections (eldritch blast)
  let scaleType = null;
  const modScaleType = mod.atHigherLevels.scaleType ? mod.atHigherLevels.scaleType : data.definition.scaleType;
  const isHigherLevelDefinitions
    = mod.atHigherLevels.higherLevelDefinitions
    && Array.isArray(mod.atHigherLevels.higherLevelDefinitions)
    && mod.atHigherLevels.higherLevelDefinitions.length >= 1;

  if (isHigherLevelDefinitions && modScaleType === "spellscale") {
    const definition = mod.atHigherLevels.higherLevelDefinitions[0];
    if (definition) {
      scaleType = modScaleType;
    } else {
      logger/* default.warn */.Z.warn("No spell definition found for " + name);
    }
  } else if (modScaleType === "spellscale") {
    // lets handle cases where there is a spellscale type but no damage
    // increase/ higherleveldefinitins e.g. chain lighting
    // these type of spells typically increase targets so we set the
    // scaling to null as we don't want to increase damage when upcast.
    // this also deals with cases like Ice Knife where the upscale damage
    // is in one of the two mods provided.
    // we are capturing this else because we don't want to trigger
    // an update to scaleType or a warning.
  } else if (modScaleType === "characterlevel") {
    // lets handle odd cantrips like Eldritch Blast
    // (in fact this might be the only case)
    if (mod.atHigherLevels.higherLevelDefinitions.length === 0) {
      // if this array is empty it does not contain levelling information
      // the only case found is Eldritch Blast.
      // this does have some info around multiple beams in
      // data.atHigherLevels but we ignore this. we will set the scaling
      // to null as each beam is best modelled by "casting" the cantrip again/
      // pressing the attack/damage buttons in FVTT
      scaleType = null;
    } else {
      scaleType = modScaleType;
    }
  } else if (modScaleType === "spelllevel") {
    // spells that have particular level associated benefits
    // these seem to be duration increases or target increases for
    // the most part we can't handle these in FVTT right now (we could
    // in theory create a new spell at a higher level).
    // some duration upcasting (like bestow curse) affects concentration
    // for now we will do nothing with these spells.
    // examples include: hex, shadowblade, magic weapon, bestow curse
    scaleType = modScaleType;
  } else {
    logger/* default.warn */.Z.warn(`${name} parse failed: `, modScaleType);
    scaleType = modScaleType; // if this is new/unknow will use default
  }

  return scaleType;
};

function getSpellScaling(data) {
  let baseDamage = "";
  let scaleDamage = "";
  let scaleType = null; // defaults to null, so will be picked up as a None scaling spell.

  // spell scaling
  if (data.definition.canCastAtHigherLevel) {
    // iterate over each spell modifier
    data.definition.modifiers
      .filter((mod) => mod.type === "damage" || (mod.type === "bonus" && mod.subType === "hit-points"))
      // eslint-disable-next-line complexity
      .forEach((mod) => {
        // if the modifier has a die for damage, lets use the string or fixed value
        // for the base damage
        if (mod && mod.die) {
          if (mod.die.diceString !== null) {
            baseDamage = mod.die.diceString;
          }

          if (mod.die.fixedValue !== null && baseDamage === "") {
            baseDamage = mod.die.fixedValue;
          }
        }

        // defines some details about higher level casting
        if (mod.atHigherLevels) {
          // scaleTypes:
          // SPELLSCALE - typical spells that scale
          // SPELLLEVEL - these spells have benefits that come in at particular levels e.g. bestow curse, hex. typically  duration changes
          // CHARACTERLEVEL - typical cantrip based levelling, some expections (eldritch blast)

          // mod.atHigherLevels.higherLevelDefinitions contains info about the
          // spells damage die at higher levels, but we can't use this for cantrips as
          // FVTT use a formula to work out the scaling (ddb has a fixed value structure)
          const isHigherLevelDefinitions
            = mod.atHigherLevels.higherLevelDefinitions
            && Array.isArray(mod.atHigherLevels.higherLevelDefinitions)
            && mod.atHigherLevels.higherLevelDefinitions.length >= 1;

          // lets handle normal spell leveling first
          const modScaleType = mod.atHigherLevels.scaleType ? mod.atHigherLevels.scaleType : data.definition.scaleType;
          if (isHigherLevelDefinitions && modScaleType === "spellscale") {
            const definition = mod.atHigherLevels.higherLevelDefinitions[0];
            if (definition) {
              const die = definition.dice ? definition.dice : definition.die ? definition.die : undefined;
              const modScaleDamage
                = die?.diceString // if dice string
                  ? die.diceString // use dice string
                  : die?.fixedValue // else if fixed value
                    ? die.fixedValue // use fixed value
                    : definition.value; // else use value

              // some spells have multiple scaling damage (e.g. Wall of Ice,
              // Glyph of warding, Acid Arrow, Arcane Hand, Dragon's Breath,
              // Chromatic Orb, Absorb Elements, Storm Sphere, Spirit Guardians)
              // it's hard to model most of these in FVTT, and for some it makes
              // no difference. so...
              // lets optimistically use the highest
              // assumptions: these are going to be dice strings, and we don't care
              // about dice value, just number of dice
              const diceFormula = /(\d*)d\d*/;
              const existingMatch = diceFormula.exec(scaleDamage);
              const modMatch = diceFormula.exec(modScaleDamage);

              const modMatchValue = modMatch
                ? modMatch.length > 1 ? modMatch[1] : modMatch[0]
                : undefined;

              if (!existingMatch && !modMatch) {
                scaleDamage = modScaleDamage;
              } else if (!existingMatch || modMatchValue > existingMatch[1]) {
                scaleDamage = modScaleDamage;
              }
            } else {
              logger/* default.warn */.Z.warn("No definition found for " + data.definition.name);
            }
          } else if (isHigherLevelDefinitions && modScaleType === "characterlevel") {
            // cantrip support, important to set to a fixed value if using abilities like potent spellcasting
            scaleDamage = baseDamage;
          }

          scaleType = getScaleType(data.definition.name, data, mod);
        }
      });
  }

  switch (scaleType) {
    case "characterlevel":
      return {
        mode: "cantrip",
        formula: scaleDamage,
      };
    case "spellscale":
      return {
        mode: "level",
        formula: scaleDamage,
      };
    case "spelllevel":
    case null:
      return {
        mode: "none",
        formula: "",
      };
    default:
      return {
        mode: "level",
        formula: "",
      };
  }
}

// EXTERNAL MODULE: ./src/muncher/table.js + 2 modules
var table = __webpack_require__(7967);
// EXTERNAL MODULE: ./src/effects/specialSpells.js + 114 modules
var specialSpells = __webpack_require__(7980);
;// CONCATENATED MODULE: ./src/parser/spells/name.js
function getCustomName(data, character) {
  if (!character || (character && !hasProperty(character, "flags.ddbimporter.dndbeyond.characterValues"))) return null;
  const characterValues = character.flags.ddbimporter.dndbeyond.characterValues;
  const customValue = characterValues.filter((value) => value.valueId == data.id && value.valueTypeId == data.entityTypeId);

  if (customValue) {
    const customName = customValue.find((value) => value.typeId == 8);

    if (customName) {
      data.name = customName.vale;
      return customName.value;
    }
    if (customName) return customName.value;
  }
  return null;
}


function getName(data, character) {
  // spell name
  const customName = getCustomName(data, character);
  if (customName) {
    return customName;
  } else if (data.flags.ddbimporter.dndbeyond.nameOverride !== undefined) {
    return data.flags.ddbimporter.dndbeyond.nameOverride;
  } else {
    return data.definition.name.replace("â€™", "'");
  }
}

// EXTERNAL MODULE: ./src/lib/DDBTemplateStrings.js
var DDBTemplateStrings = __webpack_require__(258);
;// CONCATENATED MODULE: ./src/parser/spells/parseSpell.js




// Import parsing functions
















async function parseSpell(data, character) {
  let spell = {
    type: "spell",
    system: JSON.parse(utils/* default.getTemplate */.Z.getTemplate("spell")),
    name: getName(data, character),
    flags: {
      ddbimporter: {
        id: data.id,
        definitionId: data.definition.id,
        entityTypeId: data.entityTypeId,
        dndbeyond: data.flags.ddbimporter.dndbeyond,
        originalName: data.definition.name.replace(/â€™/g, "'"),
        sources: data.definition.sources,
        tags: data.definition.tags,
        version: CONFIG.DDBI.version,
      },
      midiProperties: {
        magicdam: true,
        magiceffect: true,
      },
      // "spellbook-assistant-manager": data.flags["spellbook-assistant-manager"],
      "spell-class-filter-for-5e": data.flags["spell-class-filter-for-5e"],
    },
  };

  const isGeneric = getProperty(data, "flags.ddbimporter.generic");
  const addSpellEffects = isGeneric
    ? game.settings.get("ddb-importer", "munching-policy-add-spell-effects")
    : game.settings.get("ddb-importer", "character-update-policy-add-spell-effects");
  setProperty(data, "flags.ddbimporter.addSpellEffects", addSpellEffects);

  // spell level
  spell.system.level = data.definition.level;

  // get the spell school
  const school = dictionary/* default.spell.schools.find */.Z.spell.schools.find((s) => s.name === data.definition.school.toLowerCase());
  spell.system.school = (school) ? school.id : null;

  /**
   * Gets the necessary spell components VSM + material
   */
  spell.system.components = getComponents(data);
  spell.system.materials = getMaterials(data);
  spell.system.preparation = getSpellPreparationMode(data);

  const updateExisting = data.flags.ddbimporter.generic
    ? game.settings.get("ddb-importer", "munching-policy-update-existing")
    : false;
  data.definition.description = (0,table/* generateTable */.p)(spell.name, data.definition.description, updateExisting);

  spell.system.description = {
    value: (0,DDBTemplateStrings/* parseTags */.RN)(data.definition.description),
    chat: "",
    unidentified: data.definition.type,
  };

  spell.system.source = DDBHelper/* default.parseSource */.Z.parseSource(data.definition);
  spell.system.activation = getActivation(data);
  spell.system.duration = getDuration(data);
  spell.system.target = getTarget(data);
  spell.system.range = getRange(data);
  spell.system.actionType = getActionType(data);
  const [damage, chatFlavor] = getDamage(data, spell);
  spell.system.damage = damage;
  spell.system.chatFlavor = chatFlavor;
  spell.system.save = getSave(data);
  spell.system.scaling = getSpellScaling(data);
  spell.system.uses = getUses(data, character);
  spell.system.consume.target = "";

  // attach the spell ability id to the spell data so VTT always uses the
  // correct one, useful if multi-classing and spells have different
  // casting abilities
  if (character && character.system.attributes.spellcasting !== data.flags.ddbimporter.dndbeyond.ability) {
    spell.system.ability = data.flags.ddbimporter.dndbeyond.ability;
    if (spell.system.save.scaling == "spell") {
      spell.system.save.scaling = data.flags.ddbimporter.dndbeyond.ability;
    }
  }
  if (spell.system.ability === null) spell.system.ability = "";

  if (addSpellEffects) {
    await (0,specialSpells/* spellEffectAdjustment */.xo)(spell);
    setProperty(spell, "flags.ddbimporter.effectsApplied", true);
  }

  return spell;
}


/***/ }),

/***/ 1838:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "F": () => (/* binding */ fixSpells)
/* harmony export */ });
/* harmony import */ var _dictionary_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(37);
/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5259);
/* harmony import */ var _lib_DDBHelper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1438);




let getEldritchInvocations = (ddb) => {
  let damage = "";
  let range = 0;

  const eldritchBlastMods = _lib_DDBHelper_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].filterBaseModifiers */ .Z.filterBaseModifiers(ddb, "eldritch-blast").filter((modifier) => modifier.isGranted);

  eldritchBlastMods.forEach((mod) => {
    switch (mod.subType) {
      case "bonus-damage": {
        // almost certainly CHA :D
        const abilityModifierLookup = _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].character.abilities.find */ .Z.character.abilities.find((ability) => ability.id === mod.statId);
        if (abilityModifierLookup) {
          if (damage !== "") damage += " + ";
          damage += `@abilities.${abilityModifierLookup.value}.mod`;
        } else if (mod.fixedValue) {
          if (damage !== "") damage += " + ";
          damage += `${mod.fixedValue}`;
        }
        break;
      }
      case "bonus-range":
        range = mod.value;
        break;
      default:
        _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].warn */ .Z.warn(`Not yet able to process ${mod.subType}, please raise an issue.`);
    }
  });

  return {
    damage: damage,
    range: range,
  };
};

function getRangeAdjustmentMultiplier(ddb) {
  const rangeAdjustmentMods = _lib_DDBHelper_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].filterBaseModifiers */ .Z.filterBaseModifiers(ddb, "bonus", "spell-attack-range-multiplier").filter((modifier) => modifier.isGranted);

  const multiplier = rangeAdjustmentMods.reduce((current, mod) => {
    if (Number.isInteger(mod.fixedValue) && mod.fixedValue > current) {
      current = mod.fixedValue;
    } else if (Number.isInteger(mod.value) && mod.value > current) {
      current = mod.value;
    }
    return current;
  }, 1);

  return multiplier;
}

function adjustRange(multiplier, spell) {
  if (spell.system.actionType === "rsak" && Number.isInteger(spell.system.range?.value)) {
    setProperty(spell, "system.range.value", spell.system.range.value * multiplier);
  }
  return spell;
}

/**
 * Some spells we need to fix up or massage because they are modified
 * in interesting ways
 * @param {*} ddb
 * @param {*} items
 */
/* eslint-disable complexity */
function fixSpells(ddb, items) {
  // because the effect parsing happens before this, we need to fix some of the spell changes here
  const usingEffects = ddb === null
    ? game.settings.get("ddb-importer", "munching-policy-add-spell-effects")
    : game.settings.get("ddb-importer", "character-update-policy-add-spell-effects");

  const rangeMultiplier = ddb ? getRangeAdjustmentMultiplier(ddb) : 1;

  items.forEach((spell) => {
    const name = spell.flags.ddbimporter.originalName || spell.name;
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Checking spell ${name} for corrections...`);
    switch (name) {
      case "Melf's Acid Arrow":
      case "Acid Arrow": {
        const baseDamage = duplicate(spell.system.damage.parts[0]);
        const otherDamage = duplicate(spell.system.damage.parts[1]);
        spell.system.damage.parts = [baseDamage];
        spell.system.formula = otherDamage[0];
        break;
      }
      // Eldritch Blast is a special little kitten and has some fun Eldritch
      // Invocations which can adjust it.
      case "Eldritch Blast": {
        if (!ddb) break;
        const eldritchBlastMods = getEldritchInvocations(ddb);
        spell.system.damage.parts[0][0] += " + " + eldritchBlastMods["damage"];
        spell.system.range.value += eldritchBlastMods["range"];
        break;
      }
      case "Light": {
        spell.system.target = { value: 1, width: null, units: "", type: "object" };
        break;
      }
      case "Guidance": {
        spell.system.target = { value: 1, units: "", type: "creature" };
        break;
      }
      case "Aid": {
        spell.system.scaling = { mode: "level", formula: "(@item.level - 2) * 5" };
        break;
      }
      case "Darkvision": {
        spell.system.target.type = "creature";
        break;
      }
      // The target/range input data are incorrect on some AOE spells centred
      // on self.
      // Range is self with an AoE target of 15 ft cube
      // i.e. affects all creatures within 5 ft of caster
      case "Thunderclap":
      case "Word of Radiance":
        spell.system.range = { value: null, units: "spec", long: null };
        spell.system.target = { value: 15, units: "ft", type: "cube" };
        break;
      case "Thunder Step":
        spell.system.range = { value: null, units: "spec", long: null };
        break;
      case "Sleep": {
        if (!usingEffects) {
          spell.system.damage = { parts: [["5d8", ""]], versatile: "", value: "" };
        }
        spell.system.scaling = { mode: "level", formula: "2d8" };
        break;
      }
      case "Ray of Enfeeblement":
        spell.system.actionType = "rsak";
        break;
      case "Color Spray": {
        if (!usingEffects) {
          spell.system.damage = { parts: [["6d10", ""]], versatile: "", value: "" };
        }
        spell.system.scaling = { mode: "level", formula: "2d10" };
        break;
      }
      case "Gust of Wind":
        spell.system.target = { value: 60, units: "ft", type: "line", width: 10 };
        break;
      case "Produce Flame":
        spell.system.range = { value: 30, units: "ft", long: null };
        break;
      case "Hex": {
        spell.system.actionType = "other";
        if (usingEffects) {
          spell.system.damage = { parts: [], versatile: "", value: "" };
        }
        break;
      }
      case "Shadow of Moil":
      case "Cloud of Daggers":
      case "Magic Missile":
        spell.system.actionType = "other";
        break;
      // dnd beyond lists a damage for each type
      case "Chaos Bolt":
        spell.system.damage = { parts: [["2d8", ""], ["1d6", ""]], versatile: "", value: "", };
        break;
      // dnd beyond lists a damage for each type
      case "Chromatic Orb":
        spell.system.damage = { parts: [["3d8", ""]], versatile: "", value: "" };
        spell.system.chatFlavor = "Choose from Acid, Cold, Fire, Lightning, Poison, Thunder, or Acid";
        break;
      case "Dragon's Breath":
        spell.system.damage = { parts: [["3d6", ""]], versatile: "", value: "" };
        spell.system.chatFlavor = "Choose one of Acid, Cold, Fire, Lightning, or Poison.";
        break;
      case "Hunter's Mark":
      case "Hunterâ€™s Mark": {
        spell.system.actionType = "other";
        if (usingEffects) {
          spell.system.damage = { parts: [], versatile: "", value: "" };
        } else {
          spell.system.damage = { parts: [["1d6", ""]], versatile: "", value: "" };
        }
        break;
      }
      case "Call Lightning": {
        if (usingEffects) {
          spell.system.damage = { parts: [], versatile: "", value: "" };
          spell.system.save.ability = "";
        }
        break;
      }
      case "Control Weather": {
        spell.system.target.type = "self";
        spell.system.range = { value: 5, units: "mi", long: null };
        break;
      }
      case "Pyrotechnics":
        spell.system.target["value"] = 15;
        break;
      case "Absorb Elements":
        spell.system.damage = { parts: [["1d6", ""]], versatile: "", value: "" };
        spell.system.chatFlavor = "Uses the damage type of the triggered attack: Acid, Cold, Fire, Lightning, or Poison.";
        spell.system.target["value"] = 1;
        break;
      case "Booming Blade":
        if (!usingEffects) {
          spell.system.damage = { parts: [["0", "thunder"]], versatile: "1d8", value: "" };
        }
        spell.system.scaling = { mode: "cantrip", formula: "1d8" };
        spell.system.actionType = "other";
        break;
      case "Green-Flame Blade":
        if (!usingEffects) {
          spell.system.damage = { parts: [["0", "fire"]], versatile: "@mod", value: "" };
        }
        spell.system.scaling = { mode: "cantrip", formula: "1d8" };
        spell.system.actionType = "other";
        break;
      case "Toll the Dead":
        spell.system.scaling = { mode: "cantrip", formula: "" };
        break;
      case "Goodberry":
        spell.system.damage = { parts: [["1", "healing"]], versatile: "", value: "" };
        break;
      case "Flaming Sphere":
        spell.system.target["value"] = 2.5;
        break;
      case "Heat Metal":
        spell.system.actionType = "save";
        break;
      case "Searing Smite": {
        if (spell.system.damage.parts.length > 1) {
          spell.system.formula = spell.system.damage.parts[1][0];
          spell.system.damage.parts = [spell.system.damage.parts[0]];
        }
        spell.system.scaling = { mode: "level", formula: "1d6" };
        break;
      }
      case "Spirit Guardians": {
        if (!ddb) break;
        const radiantAlignments = [1, 2, 3, 4, 5, 6, 10, 14];
        const necroticAlignments = [7, 8, 9, 11];
        if (radiantAlignments.includes(ddb.character.alignmentId)) {
          setProperty(spell, "flags.ddbimporter.damageType", "radiant");
          spell.system.damage = { parts: [["3d8", "radiant"]], versatile: "", value: "" };
        } else if (necroticAlignments.includes(ddb.character.alignmentId)) {
          setProperty(spell, "flags.ddbimporter.damageType", "necrotic");
          spell.system.damage = { parts: [["3d8", "necrotic"]], versatile: "", value: "" };
        }
        break;
      }
      case "Spike Growth": {
        spell.system.actionType = "other";
        break;
      }
      case "Armor of Agathys": {
        spell.system.actionType = "heal";
        spell.system.target.type = "self";
        spell.system.damage.parts[0] = ["5", "temphp"];
        spell.system.scaling = { mode: "level", formula: "(@item.level - 1) * 5" };
        break;
      }
      case "Arms of Hadar": {
        spell.system.target.type = "special";
        break;
      }
      case "False Life": {
        spell.system.actionType = "heal";
        spell.system.target.type = "self";
        spell.system.damage.parts[0] = ["1d4 + 4", "temphp"];
        spell.system.scaling = { mode: "level", formula: "(@item.level - 1) * 5" };
        break;
      }
      case "Divine Favor": {
        spell.system.actionType = "util";
        spell.system.target.type = "self";
        break;
      }
      case "Bones of the Earth": {
        spell.system.target.value = 2.5;
        break;
      }
      case "Heroes Feast": {
        spell.system.duration = { value: 1, units: "day" };
        break;
      }
      case "Heroism": {
        spell.system.damage.parts[0] = ["@mod", "temphp"];
        break;
      }
      case "Protection from Energy": {
        spell.system.target.type = "creature";
        break;
      }
      case "Vitriolic Sphere": {
        spell.system.scaling = { mode: "level", formula: "2d4" };
        break;
      }
      // no default
    }

    if (rangeMultiplier != 1) {
      spell = adjustRange(rangeMultiplier, spell);
    }
    if (ddb) _lib_DDBHelper_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].addCustomValues */ .Z.addCustomValues(ddb, spell);
  });
}
/* eslint-enable complexity */


/***/ }),

/***/ 6451:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_DirectoryPicker_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4222);


const COMPENDIUMS = [
  { title: "Backgrounds", setting: "entity-background-compendium", type: "Item" },
  { title: "Classes", setting: "entity-class-compendium", type: "Item" },
  { title: "Subclasses", setting: "entity-subclass-compendium", type: "Item" },
  { title: "Class Features", setting: "entity-feature-compendium", type: "Item" },
  { title: "Feats", setting: "entity-feat-compendium", type: "Item" },
  { title: "Items", setting: "entity-item-compendium", type: "Item" },
  { title: "Monsters", setting: "entity-monster-compendium", type: "Actor" },
  { title: "Vehicles", setting: "entity-vehicle-compendium", type: "Actor" },
  { title: "Races", setting: "entity-race-compendium", type: "Item" },
  { title: "Racial Traits", setting: "entity-trait-compendium", type: "Item" },
  { title: "Spells", setting: "entity-spell-compendium", type: "Item" },
  { title: "Tables", setting: "entity-table-compendium", type: "RollTable" },
  { title: "Override", setting: "entity-override-compendium", type: "Item" },
  { title: "Adventures", setting: "entity-adventure-compendium", type: "Adventure" },
];

const SRD_COMPENDIUM_LOOKUPS = [
  { type: "inventory", name: "dnd5e.items" },
  { type: "spells", name: "dnd5e.spells" },
  { type: "features", name: "dnd5e.classfeatures" },
  { type: "races", name: "dnd5e.races" },
  { type: "traits", name: "dnd5e.races" },
  { type: "features", name: "dnd5e.classfeatures" },
  { type: "feat", name: "dnd5e.classfeatures" },
  { type: "feats", name: "dnd5e.classfeatures" },
  { type: "classes", name: "dnd5e.classes" },
  { type: "subclasses", name: "dnd5e.subclasses" },
  { type: "weapon", name: "dnd5e.items" },
  { type: "consumable", name: "dnd5e.items" },
  { type: "tool", name: "dnd5e.items" },
  { type: "loot", name: "dnd5e.items" },
  { type: "backpack", name: "dnd5e.items" },
  { type: "spell", name: "dnd5e.spells" },
  { type: "equipment", name: "dnd5e.items" },
  { type: "monsters", name: "dnd5e.monsters" },
  { type: "monsterfeatures", name: "dnd5e.monsterfeatures" },
  { type: "backgrounds", name: "dnd5e.backgrounds" },
];

const SUPPORTED_FLAG_GROUPS = [
  "dae",
  "maestro",
  "mess",
  "favtab",
  "midi-qol",
  "itemacro",
  "itemmacro",
  "autoanimations",
  "enhancedcombathud",
  "cf",
  "automated-evocations",
  "automated-polymorpher",
  "inventory-plus",
  "obsidian",
  "siftoolkit",
  "advancedspelleffects",
  "gm-notes",
  "greenFlameBladeChoice",
  "boomingBladeChoice",
  "GritNGlory",
  "gng",
  "spellbook-assistant-manager",
  "spell-class-filter-for-5e",
  "forien-unidentified-items",
  "arbron-summoner",
];

const EFFECTS_IGNORE_FLAG_GROUPS = [
  "dae",
  "midi-qol",
  "itemacro",
  "itemmacro",
];

const GAME_FOLDER_LOOKUPS = [
  {
    type: "itemSpells",
    folder: "magic-item-spells",
    itemType: "spell",
  },
  {
    type: "magicItems",
    folder: "magic-items",
    itemType: "item",
  },
  {
    type: "spells",
    folder: "spell",
    itemType: "spell",
  },
  {
    type: "monsters",
    folder: "npc",
    itemType: "actor",
  },
];

const COMPENDIUM_REMOVE_FLAGS = [
  "flags.ddbimporter.overrideId",
  "flags.ddbimporter.ignoreItemImport",
  "flags.ddbimporter.retainResourceConsumption",
  "flags.ddbimporter.ignoreIcon",
];

const URLS = {
  BASE: "ddb.mrprimate.co.uk",
  PROXY: "https://proxy.ddb.mrprimate.co.uk",
  CORS: "https://images.ddb.mrprimate.co.uk/",
  DYNAMIC: "https://dynamic.ddb.mrprimate.co.uk",
};

const MUNCH_DEFAULTS = [
  { name: "munching-policy-update-existing", needed: true },
  { name: "munching-policy-use-srd", needed: false },
  { name: "munching-policy-use-inbuilt-icons", needed: true },
  { name: "munching-policy-use-srd-icons", needed: false },
  { name: "munching-policy-download-images", needed: true },
  { name: "munching-policy-remote-images", needed: false },
  { name: "munching-policy-use-dae-effects", needed: false },
  { name: "munching-policy-hide-description", needed: false },
  { name: "munching-policy-monster-items", needed: false },
  { name: "munching-policy-update-images", needed: false },
  { name: "munching-policy-dae-copy", needed: false },
];

const FILTER_SECTIONS = ["classes", "race", "features", "actions", "inventory", "spells"];

const COMPANION_SPELLS = [
  "Summon Aberration",
  "Summon Beast",
  "Summon Celestial",
  "Summon Construct",
  "Summon Elemental",
  "Summon Fey",
  "Summon Fiend",
  "Summon Shadowspawn",
  "Summon Undead",
  "Summon Draconic Spirit",
];
const COMPANION_FEATURES = [
  "Steel Defender",
  "Artificer Infusions",
  "Summon Wildfire Spirit",
  // "Primal Companion",
  "Drake Companion",
  "Drake Companion: Summon",
];
const COMPANION_OPTIONS = {
  "Primal Companion": [
    "Beast of the Land",
    "Beast of the Sea",
    "Beast of the Sky",
  ],
};

const DISABLE_FOUNDRY_UPGRADE = {
  applyFeatures: false,
  addFeatures: false,
  promptAddFeatures: false,
};

// reference to the D&D Beyond popup
const POPUPS = {
  json: null,
  web: null,
};

const MODULE_ID = "ddb-importer";

function activeUpdate() {
  const dynamicSync = game.settings.get(MODULE_ID, "dynamic-sync");
  const updateUser = game.settings.get(MODULE_ID, "dynamic-sync-user");
  const gmSyncUser = game.user.isGM && game.user.id == updateUser;
  return dynamicSync && gmSyncUser;
}

const SETTINGS = {
  MODULE_ID: "ddb-importer",
  FLAG_NAME: "ddbimporter",
  MODULE_NAME: "D&D Beyond Importer",
  COMPENDIUMS: COMPENDIUMS,
  SRD_COMPENDIUMS: SRD_COMPENDIUM_LOOKUPS,
  EFFECTS_IGNORE_FLAG_GROUPS,
  SUPPORTED_FLAG_GROUPS,
  GAME_FOLDER_LOOKUPS,
  COMPENDIUM_REMOVE_FLAGS,
  ADVENTURE_FLAG: "isDDBAdventure",
  ADVENTURE_CSS: "ddbAdventure",
  COMPANIONS: {
    COMPANION_FEATURES,
    COMPANION_SPELLS,
    COMPANION_OPTIONS,
  },
  URLS,
  POPUPS,
  DISABLE_FOUNDRY_UPGRADE,
  FILTER_SECTIONS,
  MUNCH_DEFAULTS,
  DEFAULT_SETTINGS: {
    // these settigs are loaded during renderSidebarTab
    EARLY: {
      "log-level": {
        name: "ddb-importer.settings.log-level.name",
        hint: "ddb-importer.settings.log-level.hint",
        scope: "world",
        config: true,
        type: String,
        choices: {
          DEBUG: "DEBUG",
          INFO: "INFO",
          WARN: "WARN",
          ERR: "ERROR ",
          OFF: "OFF",
        },
        default: "INFO",
      },
      "show-munch-top": {
        name: "ddb-importer.settings.show-munch-top.name",
        hint: "ddb-importer.settings.show-munch-top.hint",
        scope: "world",
        config: true,
        type: Boolean,
        default: true,
      },
      "patreon-tier": {
        scope: "world",
        config: false,
        type: String,
        default: null,
      },
      "custom-proxy": {
        name: "ddb-importer.settings.custom-proxy.name",
        hint: "ddb-importer.settings.custom-proxy.hint",
        scope: "world",
        config: false,
        type: Boolean,
        default: false,
      },
      "encounter-muncher-enabled": {
        scope: "world",
        config: false,
        type: Boolean,
        default: true,
      },
      "developer-mode": {
        scope: "world",
        config: false,
        type: Boolean,
        default: false,
      },
    },
    // ready settings
    READY: {
      // settings for settings management
      SETTINGS: {
        "auto-create-compendium": {
          type: Boolean,
          default: true,
        },
      },
      COMPENDIUMS: Object.fromEntries(
        COMPENDIUMS.map((comp) => [comp.setting, {
          name: comp.title,
          type: String,
          default: `DDB ${comp.title}`,
        }])
      ),
      // dir locations
      DIRECTORIES: {
        "image-upload-directory": {
          name: "ddb-importer.settings.image-upload-directory.name",
          hint: "ddb-importer.settings.image-upload-directory.hint",
          type: _lib_DirectoryPicker_js__WEBPACK_IMPORTED_MODULE_0__/* .DirectoryPicker.Directory */ .B.Directory,
          default: "[data] ddb-images/characters",
        },
        "other-image-upload-directory": {
          name: "ddb-importer.settings.other-image-upload-directory.name",
          hint: "ddb-importer.settings.other-image-upload-directory.hint",
          type: _lib_DirectoryPicker_js__WEBPACK_IMPORTED_MODULE_0__/* .DirectoryPicker.Directory */ .B.Directory,
          default: "[data] ddb-images/other",
        },
        "frame-image-upload-directory": {
          name: "ddb-importer.settings.frame-image-upload-directory.name",
          hint: "ddb-importer.settings.frame-image-upload-directory.hint",
          type: _lib_DirectoryPicker_js__WEBPACK_IMPORTED_MODULE_0__/* .DirectoryPicker.Directory */ .B.Directory,
          default: "[data] ddb-images/frames",
        },
        "adventure-import-path": {
          name: "ddb-importer.settings.adventure-import-path.name",
          hint: "ddb-importer.settings.adventure-import-path.hint",
          default: "[data] adventures/import",
          type: _lib_DirectoryPicker_js__WEBPACK_IMPORTED_MODULE_0__/* .DirectoryPicker.Directory */ .B.Directory,
        },
        "adventure-upload-path": {
          name: "ddb-importer.settings.adventure-upload-path.name",
          hint: "ddb-importer.settings.adventure-upload-path.hint",
          default: "[data] ddb-images/adventures",
          type: _lib_DirectoryPicker_js__WEBPACK_IMPORTED_MODULE_0__/* .DirectoryPicker.Directory */ .B.Directory,
        },
        "adventure-misc-path": {
          name: "ddb-importer.settings.adventure-misc-path.name",
          hint: "ddb-importer.settings.adventure-misc-path.hint",
          default: "[data] ddb-images/adventures/misc",
          type: _lib_DirectoryPicker_js__WEBPACK_IMPORTED_MODULE_0__/* .DirectoryPicker.Directory */ .B.Directory,
        },
      },
      UI: {
        "monster-link-title": {
          name: "ddb-importer.settings.monster-link-title.name",
          hint: "ddb-importer.settings.monster-link-title.hint",
          config: true,
          type: Boolean,
          default: true,
        },
        "character-link-title": {
          name: "ddb-importer.settings.character-link-title.name",
          hint: "ddb-importer.settings.character-link-title.hint",
          config: true,
          type: Boolean,
          default: false,
        },
        "link-title-colour-white": {
          name: "ddb-importer.settings.link-title-colour-white.name",
          hint: "ddb-importer.settings.link-title-colour-white.hint",
          config: true,
          type: Boolean,
          default: false,
        },
        "show-munch-top": {
          name: "ddb-importer.settings.show-munch-top.name",
          hint: "ddb-importer.settings.show-munch-top.hint",
          config: true,
          type: Boolean,
          default: true,
        },
        "show-image-to-players": {
          name: "ddb-importer.settings.show-image-to-players.name",
          hint: "ddb-importer.settings.show-image-to-players.hint",
          config: true,
          type: Boolean,
          default: true,
        },
        "show-read-alouds-button": {
          name: "ddb-importer.settings.show-read-alouds-button.name",
          hint: "ddb-importer.settings.show-read-alouds-button.hint",
          config: true,
          type: Boolean,
          default: true,
        },
      },
      PERMISSIONS: {
        "restrict-to-trusted": {
          name: "ddb-importer.settings.restrict-to-trusted.name",
          hint: "ddb-importer.settings.restrict-to-trusted.hint",
          config: true,
          type: Boolean,
          default: false,
        },
        "allow-all-sync": {
          name: "ddb-importer.settings.allow-all-sync.name",
          hint: "ddb-importer.settings.allow-all-sync.hint",
          config: true,
          type: Boolean,
          default: false,
        },
      },
      PARSING: {
        "use-full-source": {
          name: "ddb-importer.settings.use-full-source.name",
          hint: "ddb-importer.settings.use-full-source.hint",
          config: true,
          type: Boolean,
          default: true,
        },
        "use-damage-hints": {
          name: "ddb-importer.settings.use-damage-hints.name",
          hint: "ddb-importer.settings.use-damage-hints.hint",
          config: true,
          type: Boolean,
          default: true,
        },
        "add-damage-restrictions-to-hints": {
          name: "ddb-importer.settings.add-damage-restrictions-to-hints.name",
          hint: "ddb-importer.settings.add-damage-restrictions-to-hints.hint",
          config: true,
          type: Boolean,
          default: true,
        },
        "embed-macros": {
          name: "ddb-importer.settings.embed-macros.name",
          hint: "ddb-importer.settings.embed-macros.hint",
          config: true,
          type: Boolean,
          default: true,
        },
        "add-description-to-chat": {
          name: "ddb-importer.settings.add-description-to-chat.name",
          hint: "ddb-importer.settings.add-description-to-chat.hint",
          type: Boolean,
          default: false,
        },
        "apply-conditions-with-ce": {
          name: "ddb-importer.settings.apply-conditions-with-ce.name",
          hint: "ddb-importer.settings.apply-conditions-with-ce.hint",
          config: true,
          type: Boolean,
          default: true,
        },
      },
      // ????
      MISC: {
        "use-webp": {
          name: "ddb-importer.settings.use-webp.name",
          hint: "ddb-importer.settings.use-webp.hint",
          type: Boolean,
          default: false,
        },
        "webp-quality": {
          name: "ddb-importer.settings.webp-quality.name",
          hint: "ddb-importer.settings.webp-quality.hint",
          type: Number,
          default: 0.9,
        },
        "settings-call-muncher": {
          type: Boolean,
          default: false,
        },
        "update-check": {
          name: "ddb-importer.settings.update-check.name",
          config: true,
          type: Boolean,
          default: true,
        },
      },
      // character settings
      CHARACTER: {
        IMPORT: {
          "character-update-policy-use-item-containers": {
            scope: "player",
            type: Boolean,
            default: true,
          },
          "character-update-policy-create-companions": {
            scope: "player",
            type: Boolean,
            default: false,
          },
          "pact-spells-prepared": {
            type: Boolean,
            default: false,
          },
          "character-update-policy-add-character-effects": {
            scope: "player",
            type: Boolean,
            default: false,
          },
          "character-update-policy-effect-race-damages": {
            scope: "player",
            type: Boolean,
            default: false,
          },
          "character-update-policy-effect-race-speed": {
            scope: "player",
            type: Boolean,
            default: false,
          },
          "character-update-policy-effect-race-senses": {
            scope: "player",
            type: Boolean,
            default: false,
          },
          "character-update-policy-effect-race-hp": {
            scope: "player",
            type: Boolean,
            default: false,
          },
          "character-update-policy-effect-race-spell-bonus": {
            scope: "player",
            type: Boolean,
            default: true,
          },
          "character-update-policy-effect-class-damages": {
            scope: "player",
            type: Boolean,
            default: false,
          },
          "character-update-policy-effect-class-speed": {
            scope: "player",
            type: Boolean,
            default: false,
          },
          "character-update-policy-effect-class-senses": {
            scope: "player",
            type: Boolean,
            default: false,
          },
          "character-update-policy-effect-class-hp": {
            scope: "player",
            type: Boolean,
            default: false,
          },
          "character-update-policy-effect-class-spell-bonus": {
            scope: "player",
            type: Boolean,
            default: true,
          },
          "character-update-policy-effect-feat-proficiencies": {
            scope: "player",
            type: Boolean,
            default: false,
          },
          "character-update-policy-effect-feat-languages": {
            scope: "player",
            type: Boolean,
            default: false,
          },
          "character-update-policy-effect-feat-damages": {
            scope: "player",
            type: Boolean,
            default: false,
          },
          "character-update-policy-effect-feat-speed": {
            scope: "player",
            type: Boolean,
            default: false,
          },
          "character-update-policy-effect-feat-senses": {
            scope: "player",
            type: Boolean,
            default: false,
          },
          "character-update-policy-effect-feat-hp": {
            scope: "player",
            type: Boolean,
            default: false,
          },
          "character-update-policy-effect-feat-spell-bonus": {
            scope: "player",
            type: Boolean,
            default: true,
          },
          "character-update-policy-effect-feat-ability-bonus": {
            scope: "player",
            type: Boolean,
            default: false,
          },
          "character-update-policy-effect-background-proficiencies": {
            scope: "player",
            type: Boolean,
            default: false,
          },
          "character-update-policy-effect-background-languages": {
            scope: "player",
            type: Boolean,
            default: false,
          },
          "character-update-policy-effect-background-damages": {
            scope: "player",
            type: Boolean,
            default: false,
          },
          "character-update-policy-effect-background-speed": {
            scope: "player",
            type: Boolean,
            default: false,
          },
          "character-update-policy-effect-background-senses": {
            scope: "player",
            type: Boolean,
            default: false,
          },
          "character-update-policy-effect-background-hp": {
            scope: "player",
            type: Boolean,
            default: false,
          },
          "character-update-policy-effect-background-spell-bonus": {
            scope: "player",
            type: Boolean,
            default: true,
          },
          "character-update-policy-effect-background-ability-bonus": {
            scope: "player",
            type: Boolean,
            default: false,
          },
          "character-update-policy-use-scalevalue": {
            scope: "player",
            type: Boolean,
            default: true,
          },
          "character-update-policy-use-scalevalue-description": {
            scope: "player",
            type: Boolean,
            default: false,
          },
          "character-update-policy-add-item-effects": {
            scope: "player",
            type: Boolean,
            default: false,
          },
          "character-update-policy-add-spell-effects": {
            scope: "player",
            type: Boolean,
            default: false,
          },
          "character-update-policy-generate-ac-feature-effects": {
            scope: "player",
            type: Boolean,
            default: false,
          },
          "character-update-policy-use-existing": {
            scope: "player",
            type: Boolean,
            default: false,
          },
          "character-update-policy-ignore-non-ddb-items": {
            scope: "player",
            type: Boolean,
            default: false,
          },
          "character-update-policy-use-override": {
            scope: "player",
            type: Boolean,
            default: false,
          },
          "character-update-policy-use-srd": {
            scope: "player",
            type: Boolean,
            default: false,
          },
          "character-update-policy-name": {
            scope: "player",
            type: Boolean,
            default: true,
          },
          "character-update-policy-hp": {
            scope: "player",
            type: Boolean,
            default: true,
          },
          "character-update-policy-hit-die": {
            scope: "player",
            type: Boolean,
            default: true,
          },
          "character-update-policy-class": {
            scope: "player",
            type: Boolean,
            default: true,
          },
          "character-update-policy-feat": {
            scope: "player",
            type: Boolean,
            default: true,
          },
          "character-update-policy-weapon": {
            scope: "player",
            type: Boolean,
            default: true,
          },
          "character-update-policy-equipment": {
            scope: "player",
            type: Boolean,
            default: true,
          },
          "character-update-policy-bio": {
            scope: "player",
            type: Boolean,
            default: true,
          },
          "character-update-policy-spell-use": {
            scope: "player",
            type: Boolean,
            default: true,
          },
          "character-update-policy-languages": {
            scope: "player",
            type: Boolean,
            default: true,
          },
          "character-update-policy-import-extras": {
            scope: "player",
            type: Boolean,
            default: true,
          },
          "character-update-policy-inventory": {
            scope: "player",
            type: Boolean,
            default: true,
          },
          "character-update-policy-currency": {
            scope: "player",
            type: Boolean,
            default: true,
          },
          "character-update-policy-spell": {
            scope: "player",
            type: Boolean,
            default: true,
          },
          "character-update-policy-image": {
            scope: "player",
            type: Boolean,
            default: false,
          },
          "character-update-policy-use-ddb-spell-icons": {
            scope: "player",
            type: Boolean,
            default: true,
          },
          "character-update-policy-use-ddb-generic-item-icons": {
            scope: "player",
            type: Boolean,
            default: true,
          },
          "character-update-policy-use-ddb-item-icons": {
            scope: "player",
            type: Boolean,
            default: true,
          },
          "character-update-policy-use-inbuilt-icons": {
            scope: "player",
            type: Boolean,
            default: true,
          },
          "character-update-policy-use-srd-icons": {
            scope: "player",
            type: Boolean,
            default: false,
          },
          "character-update-policy-use-full-description": {
            scope: "player",
            type: Boolean,
            default: true,
          },
          "character-update-policy-use-action-and-feature": {
            scope: "player",
            type: Boolean,
            default: false,
          },
          "character-update-policy-use-actions-as-features": {
            scope: "player",
            type: Boolean,
            default: true,
          },
          "character-update-policy-dae-effect-copy": {
            scope: "player",
            type: Boolean,
            default: false,
          },
          "character-update-policy-active-effect-copy": {
            scope: "player",
            type: Boolean,
            default: false,
          },
          "character-update-policy-active-effect-character-copy": {
            scope: "player",
            type: Boolean,
            default: false,
          },
        },
        SYNC: {
          "sync-policy-currency": {
            name: "ddb-importer.settings.sync-policy-currency.name",
            hint: "ddb-importer.settings.sync-policy-currency.hint",
            scope: "player",
            type: Boolean,
            default: true,
          },
          "sync-policy-hitpoints": {
            name: "ddb-importer.settings.sync-policy-hitpoints.name",
            hint: "ddb-importer.settings.sync-policy-hitpoints.hint",
            scope: "player",
            type: Boolean,
            default: true,
          },
          "sync-policy-hitdice": {
            name: "ddb-importer.settings.sync-policy-hitdice.name",
            hint: "ddb-importer.settings.sync-policy-hitdice.hint",
            scope: "player",
            type: Boolean,
            default: true,
          },
          "sync-policy-action-use": {
            name: "ddb-importer.settings.sync-policy-action-use.name",
            hint: "ddb-importer.settings.sync-policy-action-use.hint",
            scope: "player",
            type: Boolean,
            default: true,
          },
          "sync-policy-inspiration": {
            name: "ddb-importer.settings.sync-policy-inspiration.name",
            hint: "ddb-importer.settings.sync-policy-inspiration.hint",
            scope: "player",
            type: Boolean,
            default: true,
          },
          "sync-policy-condition": {
            name: "ddb-importer.settings.sync-policy-condition.name",
            hint: "ddb-importer.settings.sync-policy-condition.hint",
            scope: "player",
            type: Boolean,
            default: true,
          },
          "sync-policy-deathsaves": {
            name: "ddb-importer.settings.sync-policy-deathsaves.name",
            hint: "ddb-importer.settings.sync-policy-deathsaves.hint",
            scope: "player",
            type: Boolean,
            default: true,
          },
          "sync-policy-spells-prepared": {
            name: "ddb-importer.settings.sync-policy-spells-prepared.name",
            hint: "ddb-importer.settings.sync-policy-spells-prepared.hint",
            scope: "player",
            type: Boolean,
            default: true,
          },
          "sync-policy-spells-slots": {
            name: "ddb-importer.settings.sync-policy-spells-slots.name",
            hint: "ddb-importer.settings.sync-policy-spells-slots.hint",
            scope: "player",
            type: Boolean,
            default: true,
          },
          "sync-policy-spells-sync": {
            name: "ddb-importer.settings.sync-policy-spells-sync.name",
            hint: "ddb-importer.settings.sync-policy-spells-sync.hint",
            scope: "player",
            type: Boolean,
            default: true,
          },
          "sync-policy-equipment": {
            name: "ddb-importer.settings.sync-policy-equipment.name",
            hint: "ddb-importer.settings.sync-policy-equipment.hint",
            scope: "player",
            type: Boolean,
            default: true,
          },
          "sync-policy-xp": {
            name: "ddb-importer.settings.sync-policy-xp.name",
            hint: "ddb-importer.settings.sync-policy-xp.hint",
            scope: "player",
            type: Boolean,
            default: true,
          },
        },
        DYNAMIC_SYNC: {
          "dynamic-sync-policy-currency": {
            type: Boolean,
            default: true,
          },
          "dynamic-sync-policy-hitpoints": {
            type: Boolean,
            default: true,
          },
          "dynamic-sync-policy-hitdice": {
            type: Boolean,
            default: true,
          },
          "dynamic-sync-policy-action-use": {
            type: Boolean,
            default: true,
          },
          "dynamic-sync-policy-inspiration": {
            type: Boolean,
            default: true,
          },
          "dynamic-sync-policy-condition": {
            type: Boolean,
            default: true,
          },
          "dynamic-sync-policy-deathsaves": {
            type: Boolean,
            default: true,
          },
          "dynamic-sync-policy-spells-prepared": {
            type: Boolean,
            default: true,
          },
          "dynamic-sync-policy-spells-slots": {
            type: Boolean,
            default: true,
          },
          "dynamic-sync-policy-spells-sync": {
            type: Boolean,
            default: true,
          },
          "dynamic-sync-policy-equipment": {
            type: Boolean,
            default: true,
          },
          "dynamic-sync-policy-xp": {
            type: Boolean,
            default: true,
          },
        },
      },
      // muncher settings
      MUNCHER: {
        COMPENDIUM_FOLDERS: {
          "munching-selection-compendium-folders-monster": {
            name: "ddb-importer.settings.munching-selection-compendium-folders-monster.name",
            hint: "ddb-importer.settings.munching-selection-compendium-folders-monster.hint",
            config: true,
            type: String,
            choices: {
              TYPE: "Creature type, e.g. Undead",
              CR: "Challenge Rating",
              ALPHA: "Alphabetical",
            },
            default: "TYPE",
          },
          "munching-selection-compendium-folders-spell": {
            name: "ddb-importer.settings.munching-selection-compendium-folders-spell.name",
            hint: "ddb-importer.settings.munching-selection-compendium-folders-spell.hint",
            config: true,
            type: String,
            choices: {
              SCHOOL: "School of Magic",
              LEVEL: "Level",
            },
            default: "SCHOOL",
          },
          "munching-selection-compendium-folders-item": {
            name: "ddb-importer.settings.munching-selection-compendium-folders-item.name",
            hint: "ddb-importer.settings.munching-selection-compendium-folders-item.hint",
            config: true,
            type: String,
            choices: {
              TYPE: "Item Type",
              RARITY: "Rarity",
            },
            default: "TYPE",
          },
        },
        ADVENTURE: {
          "adventure-policy-all-scenes": {
            scope: "player",
            type: Boolean,
            default: true,
          },
          "adventure-policy-all-actors-into-world": {
            scope: "player",
            type: Boolean,
            default: false,
          },
          "adventure-policy-journal-world-actors": {
            scope: "player",
            type: Boolean,
            default: false,
          },
        },
        MUNCH: {
          "munching-policy-update-existing": {
            scope: "player",
            type: Boolean,
            default: false,
          },
          "munching-policy-use-srd": {
            scope: "player",
            type: Boolean,
            default: false,
          },
          "munching-policy-exclude-legacy": {
            type: Boolean,
            default: false,
          },
          "munching-policy-legacy-postfix": {
            type: Boolean,
            default: false,
          },
          "munching-policy-use-compendium-folders": {
            scope: "player",
            type: Boolean,
            default: false,
          },
          "munching-policy-use-srd-icons": {
            name: "ddb-importer.settings.munching-policy-use-srd-icons.name",
            hint: "ddb-importer.settings.munching-policy-use-srd-icons.hint",
            scope: "player",
            type: Boolean,
            default: false,
          },
          "munching-policy-use-inbuilt-icons": {
            name: "ddb-importer.settings.munching-policy-use-inbuilt-icons.name",
            hint: "ddb-importer.settings.munching-policy-use-inbuilt-icons.hint",
            scope: "player",
            type: Boolean,
            default: true,
          },
          "munching-policy-use-ddb-item-icons": {
            name: "ddb-importer.settings.munching-policy-use-ddb-item-icons.name",
            hint: "ddb-importer.settings.munching-policy-use-ddb-item-icons.hint",
            scope: "player",
            type: Boolean,
            default: true,
          },
          "munching-policy-use-ddb-spell-icons": {
            name: "ddb-importer.settings.munching-policy-use-ddb-spell-icons.name",
            hint: "ddb-importer.settings.munching-policy-use-ddb-spell-icons.hint",
            scope: "player",
            type: Boolean,
            default: true,
          },
          "munching-policy-use-ddb-generic-item-icons": {
            name: "ddb-importer.settings.munching-policy-use-ddb-generic-item-icons.name",
            hint: "ddb-importer.settings.munching-policy-use-ddb-generic-item-icons.hint",
            scope: "player",
            type: Boolean,
            default: true,
          },
          "munching-policy-use-full-token-image": {
            name: "ddb-importer.settings.munching-policy-use-full-token-image.name",
            hint: "ddb-importer.settings.munching-policy-use-full-token-image.hint",
            scope: "player",
            type: Boolean,
            default: false,
          },
          "munching-policy-use-token-avatar-image": {
            name: "ddb-importer.settings.munching-policy-use-token-avatar-image.name",
            hint: "ddb-importer.settings.munching-policy-use-token-avatar-image.hint",
            scope: "player",
            type: Boolean,
            default: false,
          },
          "munching-policy-remote-images": {
            name: "ddb-importer.settings.munching-policy-remote-images.name",
            hint: "ddb-importer.settings.munching-policy-remote-images.hint",
            scope: "player",
            type: Boolean,
            default: true,
          },
          "munching-policy-add-effects": {
            name: "ddb-importer.settings.munching-policy-add-effects.name",
            hint: "ddb-importer.settings.munching-policy-add-effects.hint",
            scope: "player",
            type: Boolean,
            default: true,
          },
          "munching-policy-add-spell-effects": {
            scope: "player",
            type: Boolean,
            default: false,
          },
          "munching-policy-add-monster-effects": {
            scope: "player",
            type: Boolean,
            default: false,
          },
          "munching-policy-add-ac-armor-effects": {
            scope: "player",
            type: Boolean,
            default: false,
          },
          "munching-policy-download-images": {
            name: "ddb-importer.settings.munching-policy-download-images.name",
            hint: "ddb-importer.settings.munching-policy-download-images.hint",
            scope: "player",
            type: Boolean,
            default: false,
          },
          "munching-policy-dae-copy": {
            name: "ddb-importer.settings.munching-policy-dae-copy.name",
            hint: "ddb-importer.settings.munching-policy-dae-copy.hint",
            scope: "player",
            type: Boolean,
            default: false,
          },
          "munching-policy-use-dae-effects": {
            name: "ddb-importer.settings.munching-policy-use-dae-effects.name",
            hint: "ddb-importer.settings.munching-policy-use-dae-effects.hint",
            scope: "player",
            type: Boolean,
            default: false,
          },
          "munching-policy-hide-description": {
            name: "ddb-importer.settings.munching-policy-hide-description.name",
            hint: "ddb-importer.settings.munching-policy-hide-description.hint",
            scope: "player",
            type: Boolean,
            default: false,
          },
          "munching-policy-monster-items": {
            name: "ddb-importer.settings.munching-policy-monster-items.name",
            hint: "ddb-importer.settings.munching-policy-monster-items.hint",
            scope: "player",
            type: Boolean,
            default: false,
          },
          "munching-policy-monster-homebrew": {
            name: "ddb-importer.settings.munching-policy-monster-homebrew.name",
            hint: "ddb-importer.settings.munching-policy-monster-homebrew.hint",
            scope: "player",
            type: Boolean,
            default: false,
          },
          "munching-policy-monster-homebrew-only": {
            name: "ddb-importer.settings.munching-policy-monster-homebrew-only.name",
            hint: "ddb-importer.settings.munching-policy-monster-homebrew-only.hint",
            scope: "player",
            type: Boolean,
            default: false,
          },
          "munching-policy-monster-tokenize": {
            scope: "player",
            type: Boolean,
            default: false,
          },
          "munching-policy-update-images": {
            name: "ddb-importer.settings.munching-policy-update-images.name",
            hint: "ddb-importer.settings.munching-policy-update-images.hint",
            scope: "player",
            type: Boolean,
            default: true,
          },
          "munching-policy-monster-exact-match": {
            name: "ddb-importer.settings.munching-policy-monster-match.name",
            hint: "ddb-importer.settings.munching-policy-monster-match.hint",
            scope: "player",
            type: Boolean,
            default: false,
          },
          "munching-policy-use-source-filter": {
            scope: "player",
            type: Boolean,
            default: false,
          },
          "munching-policy-muncher-sources": {
            scope: "player",
            type: Array,
            default: [],
          },
          "munching-policy-monster-use-item-ac": {
            scope: "player",
            type: Boolean,
            default: true,
          },
          "munching-policy-monster-retain-biography": {
            type: Boolean,
            default: false,
          },
          "munching-policy-monster-set-legendary-resource-bar": {
            type: Boolean,
            default: true,
          },
          "munching-policy-update-world-monster-update-images": {
            type: Boolean,
            default: true,
          },
          "munching-policy-update-world-monster-retain-biography": {
            type: Boolean,
            default: true,
          },
          "munching-policy-monster-bulk-import": {
            type: Boolean,
            default: false,
          },
          "munching-policy-monster-strip-name": {
            type: Boolean,
            default: true,
          },
          "munching-policy-item-homebrew": {
            type: Boolean,
            default: false,
          },
          "munching-policy-item-homebrew-only": {
            type: Boolean,
            default: false,
          },
          "munching-policy-spell-homebrew": {
            scope: "player",
            type: Boolean,
            default: false,
          },
          "munching-policy-spell-homebrew-only": {
            type: Boolean,
            default: false,
          },
        },
        ENCOUNTER: {
          "encounter-import-policy-create-scene": {
            type: Boolean,
            default: true,
          },
          "encounter-import-policy-existing-scene": {
            type: Boolean,
            default: false,
          },
          "encounter-import-policy-missing-characters": {
            type: Boolean,
            default: true,
          },
          "encounter-import-policy-missing-monsters": {
            type: Boolean,
            default: true,
          },
          "encounter-import-policy-create-journal": {
            type: Boolean,
            default: true,
          },
          "encounter-import-policy-roll-monster-initiative": {
            type: Boolean,
            default: false,
          },
          "encounter-import-policy-use-ddb-save": {
            type: Boolean,
            default: false,
          },
        },
      },
      DYNAMIC_SYNC: {
        "dynamic-sync": {
          type: Boolean,
          default: false,
        },
        "dynamic-sync-user": {
          type: String,
          default: "",
        },
      },
      PROXY: {
        "api-endpoint": {
          type: String,
          default: "http://localhost:3000",
        },
        "cors-endpoint": {
          type: String,
          default: URLS.CORS,
        },
        "dynamic-api-endpoint": {
          type: String,
          default: URLS.DYNAMIC,
        },
        "cors-encode": {
          type: Boolean,
          default: false,
        },
        "beta-key": {
          type: String,
          default: "",
        },
        "patreon-user": {
          type: String,
          default: null,
        },
        "cobalt-cookie": {
          name: "ddb-importer.settings.cobalt-cookie.name",
          hint: "ddb-importer.settings.cobalt-cookie.hint",
          type: String,
          default: "",
        },
        "cobalt-cookie-local": {
          name: "ddb-importer.settings.cobalt-cookie-local.name",
          hint: "ddb-importer.settings.cobalt-cookie-local.hint",
          type: Boolean,
          default: true,
        },
        "campaign-id": {
          name: "ddb-importer.settings.campaign-id.name",
          hint: "ddb-importer.settings.campaign-id.hint",
          type: String,
          default: "",
        },
      },
      // dev settings
      DEV: {
        "allow-scene-download": {
          type: Boolean,
          default: false,
        },
        "allow-third-party-scene-download": {
          type: Boolean,
          default: false,
        },
        "third-party-scenes-partial": {
          type: Boolean,
          default: false,
        },
        "third-party-scenes-notes-merged": {
          type: Boolean,
          default: true,
        },
        "allow-note-generation": {
          type: Boolean,
          default: false,
        },
        "debug-json": {
          scope: "player",
          type: Boolean,
          default: false,
        },
        "adventure-muncher-full-config": {
          type: Boolean,
          default: false,
        },
      },
    },
  },
  APPLY_GLOBAL_DEFAULTS(settings) {
    for (const [name, data] of Object.entries(settings)) {
      settings[name] = mergeObject({ scope: "world", config: false }, data);
    }
    return settings;
  },
  GET_DEFAULT_SETTINGS(early = false) {
    const clone = foundry.utils.deepClone(SETTINGS.DEFAULT_SETTINGS);
    const defaultLocationSource = !early && typeof ForgeVTT !== "undefined" && ForgeVTT?.usingTheForge
      ? "[forgevtt]"
      : "[data]";

    for (const [name, data] of Object.entries(clone.READY.DIRECTORIES)) {
      clone.READY.DIRECTORIES[name].default = data.default.replace("[data]", defaultLocationSource);
    }
    let defaultSettings = early
      ? clone.EARLY
      : {
        ...clone.READY.DEV,
        ...clone.READY.SETTINGS,
        ...clone.READY.PROXY,
        ...clone.READY.COMPENDIUMS,
        ...clone.READY.DIRECTORIES,
        ...clone.READY.UI,
        ...clone.READY.PERMISSIONS,
        ...clone.READY.PARSING,
        ...clone.READY.MISC,
        ...clone.READY.CHARACTER.IMPORT,
        ...clone.READY.CHARACTER.SYNC,
        ...clone.READY.DYNAMIC_SYNC,
        ...clone.READY.CHARACTER.DYNAMIC_SYNC,
        ...clone.READY.MUNCHER.COMPENDIUM_FOLDERS,
        ...clone.READY.MUNCHER.ADVENTURE,
        ...clone.READY.MUNCHER.MUNCH,
        ...clone.READY.MUNCHER.ENCOUNTER,
      };

    return SETTINGS.APPLY_GLOBAL_DEFAULTS(defaultSettings);
  },
  STATUS: {
    activeUpdate,
  },
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SETTINGS);


/***/ }),

/***/ 846:
/***/ ((module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "X": () => (/* binding */ isEqual)
/* harmony export */ });
/* module decorator */ module = __webpack_require__.hmd(module);
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used to compose bitmasks for comparison styles. */
var UNORDERED_COMPARE_FLAG = 1,
    PARTIAL_COMPARE_FLAG = 2;

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && "object" == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    return freeProcess && freeProcess.binding('util');
  } catch (e) {}
}());

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array ? array.length : 0;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function isHostObject(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;
  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }
  return result;
}

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

/** Used for built-in method references. */
var arrayProto = Array.prototype,
    funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/** Built-in value references. */
var Symbol = root.Symbol,
    Uint8Array = root.Uint8Array,
    propertyIsEnumerable = objectProto.propertyIsEnumerable,
    splice = arrayProto.splice;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView'),
    Map = getNative(root, 'Map'),
    Promise = getNative(root, 'Promise'),
    Set = getNative(root, 'Set'),
    WeakMap = getNative(root, 'WeakMap'),
    nativeCreate = getNative(Object, 'create');

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  return this.has(key) && delete this.__data__[key];
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
}

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  return getMapData(this, key)['delete'](key);
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  getMapData(this, key).set(key, value);
  return this;
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values ? values.length : 0;

  this.__data__ = new MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  this.__data__ = new ListCache(entries);
}

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
}

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  return this.__data__['delete'](key);
}

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var cache = this.__data__;
  if (cache instanceof ListCache) {
    var pairs = cache.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      return this;
    }
    cache = this.__data__ = new MapCache(pairs);
  }
  cache.set(key, value);
  return this;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  // Safari 9 makes `arguments.length` enumerable in strict mode.
  var result = (isArray(value) || isArguments(value))
    ? baseTimes(value.length, String)
    : [];

  var length = result.length,
      skipIndexes = !!length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (key == 'length' || isIndex(key, length)))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/**
 * The base implementation of `getTag`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  return objectToString.call(value);
}

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {boolean} [bitmask] The bitmask of comparison flags.
 *  The bitmask may be composed of the following flags:
 *     1 - Unordered comparison
 *     2 - Partial comparison
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, customizer, bitmask, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
}

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {number} [bitmask] The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = arrayTag,
      othTag = arrayTag;

  if (!objIsArr) {
    objTag = getTag(object);
    objTag = objTag == argsTag ? objectTag : objTag;
  }
  if (!othIsArr) {
    othTag = getTag(other);
    othTag = othTag == argsTag ? objectTag : othTag;
  }
  var objIsObj = objTag == objectTag && !isHostObject(object),
      othIsObj = othTag == objectTag && !isHostObject(other),
      isSameTag = objTag == othTag;

  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack);
    return (objIsArr || isTypedArray(object))
      ? equalArrays(object, other, equalFunc, customizer, bitmask, stack)
      : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);
  }
  if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new Stack);
      return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack);
  return equalObjects(object, other, equalFunc, customizer, bitmask, stack);
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
}

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} customizer The function to customize comparisons.
 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
  var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(array);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var index = -1,
      result = true,
      seen = (bitmask & UNORDERED_COMPARE_FLAG) ? new SetCache : undefined;

  stack.set(array, other);
  stack.set(other, array);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, arrValue, index, other, array, stack)
        : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!arraySome(other, function(othValue, othIndex) {
            if (!seen.has(othIndex) &&
                (arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
              return seen.add(othIndex);
            }
          })) {
        result = false;
        break;
      }
    } else if (!(
          arrValue === othValue ||
            equalFunc(arrValue, othValue, customizer, bitmask, stack)
        )) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  stack['delete'](other);
  return result;
}

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} customizer The function to customize comparisons.
 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
  switch (tag) {
    case dataViewTag:
      if ((object.byteLength != other.byteLength) ||
          (object.byteOffset != other.byteOffset)) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if ((object.byteLength != other.byteLength) ||
          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }
      return true;

    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == (other + '');

    case mapTag:
      var convert = mapToArray;

    case setTag:
      var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= UNORDERED_COMPARE_FLAG;

      // Recursively compare objects (susceptible to call stack limits).
      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} customizer The function to customize comparisons.
 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
  var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
      objProps = keys(object),
      objLength = objProps.length,
      othProps = keys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
      return false;
    }
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(object);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, objValue, key, other, object, stack)
        : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined
          ? (objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack))
          : compared
        )) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor &&
        ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  stack['delete'](other);
  return result;
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11,
// for data views in Edge < 14, and promises in Node.js.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map && getTag(new Map) != mapTag) ||
    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    (Set && getTag(new Set) != setTag) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
  getTag = function(value) {
    var result = objectToString.call(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : undefined;

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length &&
    (typeof value == 'number' || reIsUint.test(value)) &&
    (value > -1 && value % 1 == 0 && value < length);
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
function isArguments(value) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

/**
 * Performs a deep comparison between two values to determine if they are
 * equivalent.
 *
 * **Note:** This method supports comparing arrays, array buffers, booleans,
 * date objects, error objects, maps, numbers, `Object` objects, regexes,
 * sets, strings, symbols, and typed arrays. `Object` objects are compared
 * by their own, not inherited, enumerable properties. Functions and DOM
 * nodes are **not** supported.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.isEqual(object, other);
 * // => true
 *
 * object === other;
 * // => false
 */
function isEqual(value, other) {
  return baseIsEqual(value, other);
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}



/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/harmony module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.hmd = (module) => {
/******/ 			module = Object.create(module);
/******/ 			if (!module.children) module.children = [];
/******/ 			Object.defineProperty(module, 'exports', {
/******/ 				enumerable: true,
/******/ 				set: () => {
/******/ 					throw new Error('ES Modules may not assign module.exports or exports.*, Use ESM export syntax, instead: ' + module.id);
/******/ 				}
/******/ 			});
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {

// EXTERNAL MODULE: ./src/parser/DDBMonster.js + 6 modules
var DDBMonster = __webpack_require__(317);
// EXTERNAL MODULE: ./src/dictionary.js
var dictionary = __webpack_require__(37);
;// CONCATENATED MODULE: ./src/parser/monster/abilities.js



//     "abilities": {
// "str": {
//   "value": 27,
//   "proficient": 0,
//   "min": 3,
//   "mod": 8,
//   "save": 8,
//   "prof": 0,
//   "saveBonus": 0,
//   "checkBonus": 0,
//   "dc": 23
// },
// "dex": {
//   "value": 14,
//   "proficient": 1,
//   "min": 3,
//   "mod": 2,
//   "save": 9,
//   "prof": 7,
//   "saveBonus": 0,
//   "checkBonus": 0,
//   "dc": 17
// },
/**
 * Retrieves character abilities, including proficiency on saving throws
 */
DDBMonster/* default.prototype._generateAbilities */.Z.prototype._generateAbilities = function _generateAbilities() {
  // go through every ability
  dictionary/* default.character.abilities.forEach */.Z.character.abilities.forEach((ability) => {
    const value = this.source.stats.find((stat) => stat.statId === ability.id).value || 0;
    const proficient = this.source.savingThrows.find((stat) => stat.statId === ability.id) ? 1 : 0;
    const proficiencyBonus = CONFIG.DDB.challengeRatings.find((cr) => cr.id == this.source.challengeRatingId).proficiencyBonus;
    const mod = CONFIG.DDB.statModifiers.find((s) => s.value == value).modifier;

    this.npc.system.abilities[ability.value]['value'] = value;
    this.npc.system.abilities[ability.value]['proficient'] = proficient;
    this.npc.system.abilities[ability.value]['mod'] = mod;

    if (proficient) {
      this.npc.system.abilities[ability.value]['prof'] = proficiencyBonus;
      this.npc.system.abilities[ability.value]['saveBonus'] = this.source.savingThrows.find((stat) => stat.statId === ability.id).bonusModifier || 0;
      this.npc.system.abilities[ability.value]['save'] = mod + proficiencyBonus + this.npc.system.abilities[ability.value]['saveBonus'];
    }

    this.npc.system.abilities[ability.value]['dc'] = mod + proficiencyBonus + 8;
  });

  this.abilities = this.npc.system.abilities;
};

// EXTERNAL MODULE: ./src/logger.js
var src_logger = __webpack_require__(5259);
// EXTERNAL MODULE: ./src/lib/CompendiumHelper.js
var CompendiumHelper = __webpack_require__(3893);
// EXTERNAL MODULE: ./src/muncher/import.js
var muncher_import = __webpack_require__(9193);
;// CONCATENATED MODULE: ./src/parser/monster/ac.js





DDBMonster/* default.prototype.BAD_AC_MONSTERS */.Z.prototype.BAD_AC_MONSTERS = [
  "arkhan the cruel"
];

DDBMonster/* default.prototype._generateAC */.Z.prototype._generateAC = async function _generateAC() {

  const ac = {
    "flat": this.source.armorClass,
    "calc": "",
    "formula": "",
    "label": this.source.armorClassDescription ? this.source.armorClassDescription.replace("(", "").replace(")", "") : "",
  };

  let flatAC = true;

  const stat = this.source.stats.find((stat) => stat.statId === 2).value || 10;
  const dexBonus = CONFIG.DDB.statModifiers.find((s) => s.value == stat).modifier;

  let acItems = [];

  const lowerDescription = this.source.armorClassDescription
    ? this.source.armorClassDescription.toLowerCase()
    : "";
  const descriptionItems = this.source.armorClassDescription
    ? lowerDescription.replace("(", "").replace(")", "")
      .split(";")[0]
      .split(",").map((item) => item.trim())
    : [];

  // arkhan the cruel has Armor Class 23 (obsidian flint dragon plate, shield)

  // archmage 12 (15 with mage armor)

  // Jarlaxle Baenre 24 (+3 leather armor, Suave Defense)
  // Suave Defense. While Jarlaxle is wearing light or no armor and wielding no shield, his AC includes his Charisma modifier.

  // Eternal flame guardian 17 (breastplate, shield; 15 while using a crossbow)

  let itemsToCheck = [];
  if (descriptionItems.length > 0) {
    descriptionItems.forEach((item) => {
      if (item == "natural" || item == "natural armor") {
        ac.calc = "natural";
        flatAC = false;

        if (lowerDescription.includes("shield")) ac.flat = parseInt(ac.flat) - 2;
        if (lowerDescription.includes("ring of protection")) ac.flat = parseInt(ac.flat) - 1;
        if (lowerDescription.includes("cloak of protection")) ac.flat = parseInt(ac.flat) - 1;
        if (lowerDescription.includes("+1") || lowerDescription.includes("+ 1")) ac.flat = parseInt(ac.flat) - 1;
        if (lowerDescription.includes("+2") || lowerDescription.includes("+ 2")) ac.flat = parseInt(ac.flat) - 2;
        if (lowerDescription.includes("+3") || lowerDescription.includes("+ 3")) ac.flat = parseInt(ac.flat) - 3;
      } else if (!item.includes("with mage armor")) {
        if (item === "leather armor") {
          item = "leather";
        } else if (item === "hide armor") {
          item = "hide";
        } else if (item.startsWith("+")) {
          const bonusRegex = /(\+\d+)(?:\s+)(.*)/;
          const matches = item.match(bonusRegex);
          if (matches) {
            item = `${matches[2]}, ${matches[1]}`;
          }
        }
        // const type = item.includes("ring") || item.includes("cloak") ? "trinket" : "equipment";
        itemsToCheck.push({ name: item, type: "equipment", flags: {}, system: { equipped: true } });
      };
    });
  }

  src_logger/* default.debug */.Z.debug("Checking for items", itemsToCheck);
  const compendium = await CompendiumHelper/* default.getCompendiumType */.Z.getCompendiumType("inventory");
  const unAttunedItems = await (0,muncher_import/* loadPassedItemsFromCompendium */.ao)(compendium, itemsToCheck, "inventory", { monsterMatch: true });
  const attunedItems = unAttunedItems.map((item) => {
    if (item.system.attunement === 1) item.system.attunement = 2;
    return item;
  });

  src_logger/* default.debug */.Z.debug("Found items", { unAttunedItems, attunedItems });
  const allItemsMatched = attunedItems.length > 0 && attunedItems.length == itemsToCheck.length;
  const badACMonster = this.BAD_AC_MONSTERS.includes(this.source.name.toLowerCase());

  if (allItemsMatched && this.useItemAC && ac.calc !== "natural" && !badACMonster) {
    ac.flat = null;
    ac.calc = "default";
    ac.formula = "";
    flatAC = false;
  } else if (!this.useItemAC && ac.calc !== "natural") {
    // default monsters with no ac equipment to natural
    ac.calc = "natural";
    flatAC = false;
  }

  this.ac = {
    ac,
    flatAC,
    acItems,
    dexBonus,
    ddbItems: this.useItemAC ? attunedItems : [], // only add items if we are told too
    attunedItems,
    allItemsMatched,
    badACMonster,
  };

  src_logger/* default.debug */.Z.debug(`${this.source.name} ac calcs`, this.ac);
  this.npc.system.attributes.ac = ac;
  this.npc.flags.ddbimporter.flatAC = flatAC;
  if (this.useItemAC) this.items.push(...attunedItems);

};

;// CONCATENATED MODULE: ./src/parser/monster/conditions.js



DDBMonster/* default.prototype.getAdjustmentsConfig */.Z.prototype.getAdjustmentsConfig = function getAdjustmentsConfig(type) {
  const damageAdjustments = CONFIG.DDB.damageAdjustments;

  switch (type) {
    case "resistances":
      return damageAdjustments.filter((adj) => adj.type == 1);
    case "immunities":
      return damageAdjustments.filter((adj) => adj.type == 2);
    case "vulnerabilities":
      return damageAdjustments.filter((adj) => adj.type == 3);
    case "conditions":
      return CONFIG.DDB.conditions.map((condition) => {
        return {
          id: condition.definition.id,
          name: condition.definition.name,
          type: condition.definition.type,
          slug: condition.definition.slug,
        };
      });
    default:
      return null;
  }
};

DDBMonster/* default.prototype.getDamageAdjustments */.Z.prototype.getDamageAdjustments = function getDamageAdjustments(type) {
  const config = this.getAdjustmentsConfig(type);

  let values = [];
  let custom = [];

  const damageTypes = dictionary/* default.actions.damageType.filter */.Z.actions.damageType.filter((d) => d.name !== null).map((d) => d.name);

  this.source.damageAdjustments.forEach((adj) => {
    const adjustment = config.find((cadj) => adj === cadj.id);
    if (adjustment && damageTypes.includes(adjustment.name.toLowerCase())) {
      values.push(adjustment.name.toLowerCase());
    } else if (adjustment && adjustment.slug === "bludgeoning-piercing-and-slashing-from-nonmagical-attacks") {
      values.push("physical");
    } else if (adjustment) {
      const midiQolInstalled = game.modules.get("midi-qol")?.active;
      if (midiQolInstalled) {
        if (adjustment.name.toLowerCase().includes("silvered")) {
          values.push("silver");
        } else if (adjustment.name.toLowerCase().includes("adamantine")) {
          values.push("adamant");
        } else if (adjustment.slug === "damage-from-spells") {
          values.push("spell");
        } else {
          custom.push(adjustment.name);
        }
      } else {
        custom.push(adjustment.name);
      }
    }
  });

  const adjustments = {
    value: values,
    custom: custom.join("; "),
  };

  return adjustments;
};

DDBMonster/* default.prototype._generateDamageImmunities */.Z.prototype._generateDamageImmunities = function _generateDamageImmunities() {
  this.npc.system.traits.di = this.getDamageAdjustments("immunities");
};

DDBMonster/* default.prototype._generateDamageResistances */.Z.prototype._generateDamageResistances = function _generateDamageResistances() {
  this.npc.system.traits.dr = this.getDamageAdjustments("resistances");
};

DDBMonster/* default.prototype._generateDamageVulnerabilities */.Z.prototype._generateDamageVulnerabilities = function _generateDamageVulnerabilities() {
  this.npc.system.traits.dv = this.getDamageAdjustments("vulnerabilities");
};

DDBMonster/* default.prototype._generateConditionImmunities */.Z.prototype._generateConditionImmunities = function _generateConditionImmunities() {
  const config = this.getAdjustmentsConfig("conditions");

  let values = [];
  let custom = [];

  this.source.conditionImmunities.forEach((adj) => {
    const adjustment = config.find((cadj) => adj === cadj.id);
    const valueAdjustment = dictionary/* default.conditions.find */.Z.conditions.find((condition) => condition.label.toLowerCase() == adjustment.name.toLowerCase());
    if (adjustment && valueAdjustment) {
      values.push(valueAdjustment.foundry);
    } else if (adjustment) {
      custom.push(adjustment.name);
    }
  });

  this.npc.system.traits.ci = {
    value: values,
    custom: custom.join("; "),
  };

};

;// CONCATENATED MODULE: ./src/parser/monster/size.js
// "creatureSizes": [{
//   "id": 2,
//   "entityTypeId": 127108918,
//   "name": "Tiny",
//   "weightType": 1
// }, {


//   "traits": {
//     "size": "grg",


//     "sizeId": 7,





DDBMonster/* default.prototype.getSizeFromId */.Z.prototype.getSizeFromId = function getSizeFromId(sizeId) {
  const size = CONFIG.DDB.creatureSizes.find((s) => s.id == sizeId).name;
  const sizeData = dictionary/* default.sizes.find */.Z.sizes.find((s) => size == s.name);

  if (!sizeData) {
    src_logger/* default.warn */.Z.warn(`No size found for, using medium`, size);
    return { name: "Medium", value: "med", size: 1 };
  }
  return sizeData;
};

DDBMonster/* default.prototype._generateSize */.Z.prototype._generateSize = function _generateSize () {
  const sizeData = this.getSizeFromId(this.source.sizeId);
  const token = {
    scale: sizeData.size >= 1 ? 1 : sizeData.size,
    value: sizeData.size >= 1 ? sizeData.size : 1,
  };

  this.npc.system.traits.size = sizeData.value;
  this.npc.prototypeToken.width = token.value;
  this.npc.prototypeToken.height = token.value;
  this.npc.prototypeToken.scale = token.scale;

};

;// CONCATENATED MODULE: ./src/parser/monster/type.js


//   "value": "",
//   "subtype": "",
//   "swarm": {
//     "isSwarm": false,
//     "size": ""
//   },
//   "custom": ""


DDBMonster/* default.prototype._generateType */.Z.prototype._generateType = function _generateType() {

  if (this.source.swarm) {
    // result.swarm.isSwarm = true;
    // result.swarm.size = getSizeFromId(monster.swarm.sizeId).value;
    this.npc.system.details.type.swarm = this.getSizeFromId(this.source.swarm.sizeId).value;
  }

  const type = CONFIG.DDB.monsterTypes.find((c) => this.source.typeId == c.id);
  if (!type) {
    this.npc.system.details.type.custom = "Unknown";
  }

  const typeName = type.name.toLowerCase();

  if (CONFIG.DND5E.creatureTypes[typeName]) this.npc.system.details.type.value = typeName;

  this.npc.system.details.type.subtype = CONFIG.DDB.monsterSubTypes
    .filter((c) => this.source.subTypes.includes(c.id))
    .map((c) => c.name)
    .join(", ");

};

;// CONCATENATED MODULE: ./src/parser/monster/skills.js




// skills: [
//   { skillId: 5, value: 9, additionalBonus: null },
//   { skillId: 14, value: 9, additionalBonus: null }
// ],

// "skills": [{
//   "skillId": 7, # History
//   "value": 8,
//   "additionalBonus": null
// }, {
//   "skillId": 14, # Perception
//   "value": 6,
//   "additionalBonus": null
// }],

// "ste": {
//   "value": 1,
//   "ability": "dex",
//   "bonus": 0,
//   "mod": 2,
//   "passive": 19,
//   "prof": 7,
//   "total": 9
// },
DDBMonster/* default.prototype._generateSkills */.Z.prototype._generateSkills = function _generateSkills () {
  const proficiencyBonus = CONFIG.DDB.challengeRatings.find((cr) => cr.id == this.source.challengeRatingId).proficiencyBonus;
  const validSkills = dictionary/* default.character.skills.map */.Z.character.skills.map((skill) => skill.name);

  const keys = Object.keys(this.npc.system.skills);
  keys
    .filter((key) => validSkills.includes(key))
    .forEach((key) => {
      let skill = this.npc.system.skills[key];
      const ability = dictionary/* default.character.abilities.find */.Z.character.abilities.find((ab) => ab.value === skill.ability);
      const stat = this.source.stats.find((stat) => stat.statId === ability.id).value || 10;
      const mod = CONFIG.DDB.statModifiers.find((s) => s.value == stat).modifier;
      const lookupSkill = dictionary/* default.character.skills.find */.Z.character.skills.find((s) => s.name == key);
      const monsterSkill = this.source.skills.find((s) => s.skillId == lookupSkill.valueId);

      this.npc.system.skills[key].mod = mod;

      const calculatedScore = proficiencyBonus + mod;

      if (monsterSkill) {
        this.npc.system.skills[key].value = 1;
        this.npc.system.skills[key].prof = proficiencyBonus;
        this.npc.system.skills[key].bonus = monsterSkill.additionalBonus || 0;
      }

      this.npc.system.skills[key].total = calculatedScore;
      this.npc.system.skills[key].passive = 10 + calculatedScore;

      if (monsterSkill && monsterSkill.value != calculatedScore) {
        if (monsterSkill.value == calculatedScore + proficiencyBonus) {
          this.npc.system.skills[key].passive += proficiencyBonus;
          this.npc.system.skills[key].value = 2;
          this.npc.system.skills[key].total += proficiencyBonus;
          this.npc.system.skills[key].prof += proficiencyBonus;
          this.npc.system.skills[key].bonus = 0;
        } else if (monsterSkill.value > calculatedScore + proficiencyBonus) {
          this.npc.system.skills[key].passive += proficiencyBonus;
          this.npc.system.skills[key].value = 2;
          this.npc.system.skills[key].total += proficiencyBonus;
          this.npc.system.skills[key].prof += proficiencyBonus;
        }
      }

    });

  return this.npc.system.skills;
};


DDBMonster/* default.prototype._generateSkillsHTML */.Z.prototype._generateSkillsHTML = function _generateSkillsHTML () {
  const proficiencyBonus = CONFIG.DDB.challengeRatings.find((cr) => cr.id == this.source.challengeRatingId).proficiencyBonus;
  //  "skillsHtml": "History + 12, Perception + 10"
  const skillsHTML = this.source.skillsHtml.split(',');
  const skillsMaps = skillsHTML.filter((str) => str != '').map((str) => {
    const skillMatch = str.match(/(\w+\s*\w*\s*\w*)(?:\s*)([+-])(?:\s*)(\d+)/);
    let result = {};
    if (skillMatch) {
      result = {
        name: skillMatch[1].trim(),
        value: skillMatch[2] + skillMatch[3],
      };
    } else {
      src_logger/* default.error */.Z.error(`Skill Parsing failed for ${this.source.name}`);
      src_logger/* default.debug */.Z.debug(skillsHTML);
      src_logger/* default.debug */.Z.debug(str);
      src_logger/* default.debug */.Z.debug(skillMatch);
    }
    return result;
  });

  const keys = Object.keys(this.npc.system.skills);
  const validSkills = dictionary/* default.character.skills.map */.Z.character.skills.map((skill) => skill.name);
  keys
    .filter((key) => validSkills.includes(key))
    .forEach((key) => {
      let skill = this.npc.system.skills[key];
      const ability = dictionary/* default.character.abilities.find */.Z.character.abilities.find((ab) => ab.value === skill.ability);
      const stat = this.source.stats.find((stat) => stat.statId === ability.id).value || 10;
      const mod = CONFIG.DDB.statModifiers.find((s) => s.value == stat).modifier;
      const lookupSkill = dictionary/* default.character.skills.find */.Z.character.skills.find((s) => s.name == key);
      const monsterSkill = this.source.skills.find((s) => s.skillId == lookupSkill.valueId);

      this.npc.system.skills[key].mod = mod;

      if (monsterSkill) {
        this.npc.system.skills[key].value = 1;
        this.npc.system.skills[key].prof = proficiencyBonus;
        this.npc.system.skills[key].bonus = monsterSkill.additionalBonus || 0;
      }
      const calculatedScore = this.npc.system.skills[key].prof + mod + this.npc.system.skills[key].bonus;
      this.npc.system.skills[key].total = calculatedScore;
      this.npc.system.skills[key].passive = 10 + calculatedScore;

      const htmlSkill = skillsMaps.find((skl) => skl.name == lookupSkill.label);

      if (htmlSkill) {
        if (htmlSkill.value > calculatedScore) {
          this.npc.system.skills[key].passive += proficiencyBonus;
          this.npc.system.skills[key].value = 2;
          this.npc.system.skills[key].total += proficiencyBonus;
          this.npc.system.skills[key].prof += proficiencyBonus;
        }
      }

    });

  return this.npc.system.skills;
};

;// CONCATENATED MODULE: ./src/parser/monster/senses.js



DDBMonster/* default.prototype.getTextSenses */.Z.prototype.getTextSenses = function getTextSenses() {
  return this.source.sensesHtml;
};

//   "senses": [{
//   "id": 1,
//   "entityTypeId": 668550506,
//   "name": "Blindsight"
// }, {
//   "id": 2,
//   "entityTypeId": 668550506,
//   "name": "Darkvision"
// }, {
//   "id": 3,
//   "entityTypeId": 668550506,
//   "name": "Tremorsense"
// }, {
//   "id": 4,
//   "entityTypeId": 668550506,
//   "name": "Truesight"
// }, {
//   "id": 5,
//   "entityTypeId": 668550506,
//   "name": "Unknown"
// }],

DDBMonster/* default.prototype._generateTokenSenses */.Z.prototype._generateTokenSenses = function _generateTokenSenses() {
  const senseLookup = CONFIG.DDB.senses;

  this.source.senses.forEach((sense) => {
    const senseMatch = senseLookup.find((l) => l.id == sense.senseId);
    if (senseMatch && sense.notes) {
      const senseType = dictionary/* default.senseMap */.Z.senseMap[senseMatch.name.toLowerCase()];
      const rangeMatch = sense.notes.trim().match(/^(\d+)/);
      if (rangeMatch) {
        const value = parseInt(rangeMatch[1]);
        if (value > 0 && value > this.npc.prototypeToken.sight.range && hasProperty(CONFIG.Canvas.visionModes, senseType)) {
          setProperty(this.npc.prototypeToken.sight, "visionMode", senseType);
          setProperty(this.npc.prototypeToken.sight, "range", value);
          this.npc.prototypeToken.sight = mergeObject(this.npc.prototypeToken.sight, CONFIG.Canvas.visionModes[senseType].vision.defaults);
        }
        if (value > 0 && hasProperty(dictionary/* default.detectionMap */.Z.detectionMap, senseMatch.name.toLowerCase())) {
          const detectionMode = {
            id: dictionary/* default.detectionMap */.Z.detectionMap[senseMatch.name.toLowerCase()],
            range: value,
            enabled: true,
          };

          // only add duplicate modes if they don't exist
          if (!this.npc.prototypeToken.detectionModes.some((mode) => mode.id === detectionMode.id)) {
            this.npc.prototypeToken.detectionModes.push(detectionMode);
          }
        }
      }
    }
  });
};


DDBMonster/* default.prototype._generateSenses */.Z.prototype._generateSenses = function _generateSenses() {
  let senses = {
    darkvision: 0,
    blindsight: 0,
    tremorsense: 0,
    truesight: 0,
    units: "ft",
    special: ""
  };
  const senseLookup = CONFIG.DDB.senses;

  this.source.senses.forEach((sense) => {
    const senseMatch = senseLookup.find((l) => l.id == sense.senseId);
    if (senseMatch && sense.notes && senseMatch.name.toLowerCase() in senses) {
      const rangeMatch = sense.notes.trim().match(/^(\d+)/);
      if (rangeMatch) {
        senses[senseMatch.name.toLowerCase()] = parseInt(rangeMatch[1]);
      } else {
        senses.special += `${senseMatch.name}: ${sense.notes}; `;
      }
    } else {
      senses.special += `${senseMatch.name}: ${sense.notes}; `;
    }
  });

  this.npc.system.attributes.senses = senses;

};

// "senses": [
//   {
//       "senseId": 1,
//       "notes": "60 ft."
//   },
//   {
//       "senseId": 2,
//       "notes": "120 ft."
//   }
// ],

// "senses": [{
//   "senseId": 1,
//   "notes": " 60 ft. (blind beyond this radius)"
// }],


;// CONCATENATED MODULE: ./src/parser/monster/environments.js


DDBMonster/* default.prototype._generateEnvironments */.Z.prototype._generateEnvironments = function _generateEnvironments() {
  this.npc.system.details.environment = this.source.environments.filter((env) =>
    CONFIG.DDB.environments.some((c) => env == c.id)
  ).map((env) => {
    return CONFIG.DDB.environments.find((c) => env == c.id).name;
  }).join(", ");
};

;// CONCATENATED MODULE: ./src/parser/monster/languages.js



//      "languages": {
//   "value": [
//     "common",
//     "draconic"
//   ],
//   "custom": ""
// },

DDBMonster/* default.prototype._generateLanguages */.Z.prototype._generateLanguages = function _generateLanguages () {
  const config = CONFIG.DDB.languages;

  let values = [];
  let custom = [];

  this.source.languages.forEach((lng) => {
    const language = config.find((cfg) => lng.languageId == cfg.id);
    const foundryLanguage = dictionary/* default.character.languages.find */.Z.character.languages.find((lang) => lang.name == language.name);
    if (foundryLanguage && lng.notes == '') {
      values.push(foundryLanguage.value);
    } else if (language) {
      const notes = (lng.notes !== '') ? ` ${lng.notes}` : "";
      custom.push(language.name + notes);
    }
  });

  if (this.source.languageNote && !this.source.languageNote.includes("--")) custom.push(this.source.languageNote);

  this.npc.system.traits.languages = {
    value: values,
    custom: custom.join("; "),
  };
};

;// CONCATENATED MODULE: ./src/parser/monster/hp.js


// "hp": {
//   "value": 367,
//   "min": 0,
//   "max": 367,
//   "temp": 0,
//   "tempmax": 0,
//   "formula": "21d20 + 147"
// },

// "hitPointDice": {
//   "diceCount": 21,
//   "diceValue": 20,
//   "diceMultiplier": 0,
//   "fixedValue": 147,
//   "diceString": "21d20 + 147"
// },

DDBMonster/* default.prototype._generateHitPoints */.Z.prototype._generateHitPoints = function _generateHitPoints () {
  this.npc.system.attributes.hp = {
    value: this.source.averageHitPoints - (this.removedHitPoints ?? 0),
    min: 0,
    max: this.source.averageHitPoints,
    temp: this.temporaryHitPoints ?? 0,
    tempmax: 0,
    formula: this.source.hitPointDice.diceString,
  };
};

;// CONCATENATED MODULE: ./src/parser/monster/movement.js


// "movements": [
//   {
//     "movementId": 1,
//     "speed": 40,
//     "notes": null
// },
// {
//     "movementId": 4,
//     "speed": 80,
//     "notes": null
// },
// {
//     "movementId": 5,
//     "speed": 40,
//     "notes": null
// }
// ],

// "speed": {
//   "value": "40 ft.",
//   "special": "Fly 80 ft., Swim 40 ft."
// },
DDBMonster/* default.prototype._generateMovement */.Z.prototype._generateMovement = function () {
  let special = [];

  this.npc.system.attributes.movement.units = "ft";

  this.source.movements.forEach((monsterMovement) => {
    const movement = CONFIG.DDB.movements.find((mv) => mv.id == monsterMovement.movementId);
    this.npc.system.attributes.movement[movement.name.toLowerCase()] = monsterMovement.speed;

    if (monsterMovement.notes && monsterMovement.notes.toLowerCase().includes('hover')) {
      this.npc.system.attributes.movement.hover = true;
    }

    if (monsterMovement.notes?.trim() !== "") {
      const specialMovement = `${monsterMovement.speed}ft ${movement.description} (${monsterMovement.notes})`;
      special.push(specialMovement);
    }
  });

  this.movement = {
    movement: this.npc.system.attributes.movement,
    special,
  };

};

;// CONCATENATED MODULE: ./src/parser/monster/source.js


DDBMonster/* default.prototype._generateSource */.Z.prototype._generateSource = function _generateSource() {
  const fullSource = game.settings.get("ddb-importer", "use-full-source");
  const sourceObject = CONFIG.DDB.sources.find((cnf) => cnf.id == this.source.sourceId);
  const sourceBook = (sourceObject)
    ? (fullSource) ? sourceObject.description : sourceObject.name
    : "Homebrew";
  const page = (this.source.sourcePageNumber) ? ` pg ${this.source.sourcePageNumber}` : "";
  this.npc.system.details.source = `${sourceBook}${page}`;
};

// EXTERNAL MODULE: ./src/settings.js
var settings = __webpack_require__(6451);
;// CONCATENATED MODULE: ./src/parser/monster/features.js




// extracts various attacks and features (not spells)
// generates and extra descriptions found in these fields
// feature parsing is handled in a separate class, the DDBFeatureFactory
// that class breaks down the html into possible actions which it passes to the
// DDBFeature class which tries to parse the feature for details
DDBMonster/* default.prototype._generateFeatures */.Z.prototype._generateFeatures = function () {

  this.featureFactory.generateActions(this.source.actionsDescription, "action");

  if (this.source.hasLair && this.source.lairDescription != "") {
    this.featureFactory.generateActions(this.source.lairDescription, "lair");
    this.npc.system.resources["lair"] = this.featureFactory.resources["lair"];
  }

  if (this.source.legendaryActionsDescription != "") {
    this.featureFactory.generateActions(this.source.legendaryActionsDescription, "legendary");
    this.npc.system.resources["legact"] = this.featureFactory.resources["legendary"];
    if (game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "munching-policy-monster-set-legendary-resource-bar")) {
      this.npc.prototypeToken.bar2 = { attribute: "resources.legact" };
    }
  }

  if (this.source.specialTraitsDescription != "") {
    this.featureFactory.generateActions(this.source.specialTraitsDescription, "special");
    this.npc.system.resources["legres"] = this.featureFactory.resources["resistance"];
  }

  this.featureFactory.generateActions(this.source.reactionsDescription, "reaction");
  this.featureFactory.generateActions(this.source.bonusActionsDescription, "bonus");
  this.featureFactory.generateActions(this.source.mythicActionsDescription, "mythic");

  this.items.push(
    ...this.featureFactory.actions,
    ...this.featureFactory.lair,
    ...this.featureFactory.legendary,
    ...this.featureFactory.special,
    ...this.featureFactory.reactions,
    ...this.featureFactory.bonus,
    ...this.featureFactory.mythic,
  );

  // add any actor descriptions found in action blocks into the biography
  if (this.featureFactory.characterDescription.unexpected) {
    src_logger/* default.warn */.Z.warn(`Unexpected description for ${this.source.name}`, { description: this.featureFactory.characterDescription });
  }
  this.characterDescription += this.featureFactory.characterDescription.action;
  this.characterDescription += this.featureFactory.characterDescription.reaction;
  this.characterDescription += this.featureFactory.characterDescription.special;
  this.npc.system.details.biography.value += this.characterDescription;
};

// EXTERNAL MODULE: ./src/parser/monster/helpers.js
var helpers = __webpack_require__(5371);
;// CONCATENATED MODULE: ./src/parser/monster/spells.js








DDBMonster/* default.prototype.getSpellcasting */.Z.prototype.getSpellcasting = function(text) {
  let spellcasting = "";
  const abilitySearch = /((?:spellcasting ability) (?:is|uses|using) (\w+)| (\w+)(?: as \w+ spellcasting ability))/;
  const match = text.match(abilitySearch);
  if (match) {
    const abilityMatch = match[2] || match[3];
    spellcasting = abilityMatch.toLowerCase().substr(0, 3);
  }
  return spellcasting;
};

DDBMonster/* default.prototype._generateSpellcasting */.Z.prototype._generateSpellcasting = function(text) {
  let spellcasting = this.getSpellcasting(text);
  this.spellcasting.spellcasting = spellcasting;
  this.npc.system.attributes.spellcasting = spellcasting;
};

DDBMonster/* default.prototype._generateSpellLevel */.Z.prototype._generateSpellLevel = function(text) {
  let spellLevel = 0;
  const levelSearch = /is (?:a|an) (\d+)(?:th|nd|rd|st)(?:-| )level spellcaster/;
  const match = text.match(levelSearch);
  if (match) {
    spellLevel = parseInt(match[1]);
  }
  this.spellcasting.spellLevel = spellLevel;
  this.npc.system.attributes.spellLevel = spellLevel;
  this.npc.system.details.spellLevel = spellLevel;
};

DDBMonster/* default.prototype._generateSpelldc */.Z.prototype._generateSpelldc = function(text) {
  let dc = 10;
  const dcSearch = "spell\\s+save\\s+DC\\s*(\\d+)(?:,|\\)|\\s)";
  const match = text.match(dcSearch);
  // console.log("Â£Â£Â£Â£Â£")
  // console.log(match);
  if (match) {
    dc = parseInt(match[1]);
  }
  this.spellcasting.spelldc = dc;
  this.npc.system.attributes.spelldc = dc;
};

DDBMonster/* default.prototype._generateSpellAttackBonus */.Z.prototype._generateSpellAttackBonus = function(text) {
  let spellAttackBonus = 0;
  const dcSearch = "([+-]\\d+)\\s+to\\s+hit\\s+with\\s+spell\\s+attacks";
  const match = text.match(dcSearch);
  if (match) {
    const toHit = match[1];
    const proficiencyBonus = CONFIG.DDB.challengeRatings.find((cr) => cr.id == this.source.challengeRatingId).proficiencyBonus;
    const abilities = (0,helpers/* getAbilityMods */.T)(this.source);
    const castingAbility = this.getSpellcasting(text);
    spellAttackBonus = toHit - proficiencyBonus - abilities[castingAbility];
  }
  this.spellcasting.spellAttackBonus = spellAttackBonus;
};


DDBMonster/* default.prototype.parseOutInnateSpells */.Z.prototype.parseOutInnateSpells = function(text) {
  // handle innate style spells here
  // 3/day each: charm person (as 5th-level spell), color spray, detect thoughts, hold person (as 3rd-level spell)
  // console.log(text);
  const innateSearch = /^(\d+)\/(\w+)(?:\s+each)?:\s+(.*$)/;
  const innateMatch = text.match(innateSearch);
  // console.log(innateMatch);
  if (innateMatch) {
    const spellArray = innateMatch[3].split(",").map((spell) => spell.trim());
    spellArray.forEach((spell) => {
      this.spellList.innate.push({ name: spell, type: innateMatch[2], value: innateMatch[1], innate: this.spellList.innateMatch });
    });
  }

  // At will: dancing lights
  const atWillSearch = /^At (?:Will|will):\s+(.*$)/;
  const atWillMatch = text.match(atWillSearch);
  if (atWillMatch) {
    const spellArray = atWillMatch[1].split(",").map((spell) => spell.trim());
    spellArray.forEach((spell) => {
      if (this.spellList.innateMatch) {
        this.spellList.innate.push({ name: spell, type: "atwill", value: null, innate: this.spellList.innateMatch });
      } else {
        this.spellList.atwill.push(spell);
      }

    });
  }

  // last ditch attempt, mephits have some weird formating
  if (!innateMatch && !atWillMatch) {
    const mephitMatch = text.match(/(\d+)\/(\w+)(?:.*)?cast (.*),/);
    if (mephitMatch) {
      const spell = mephitMatch[3].trim();
      this.spellList.innate.push({ name: spell, type: mephitMatch[2], value: mephitMatch[1], innate: this.spellList.innateMatch });
    }
  }
};


// e.g. The archmage can cast disguise self and invisibility at will and has the following wizard spells prepared:
DDBMonster/* default.prototype.parseAdditionalAtWillSpells */.Z.prototype.parseAdditionalAtWillSpells = function(text) {
  const atWillSearch = /can cast (.*?) at will/;
  const atWillMatch = text.match(atWillSearch);
  let atWillSpells = [];
  if (atWillMatch) {
    atWillSpells = atWillMatch[1].replace(" and", ",").split(",").map((spell) => spell.split('(', 1)[0].trim());
  }

  this.spellList.atwill.push(...atWillSpells);
};


/**
 * First pass at breaking out spells to cast
 * @param text spell text block
 * @returns
 */
DDBMonster/* default.prototype.parseOutSpells */.Z.prototype.parseOutSpells = function(text) {
  // console.log(text);
  const spellLevelSearch = /^(Cantrip|\d)(?:st|th|nd|rd)?(?:\s*(?:Level|level))?(?:s)?\s+\((at will|at-will|\d)\s*(?:slot|slots)?\):\s+(.*$)/;
  const match = text.match(spellLevelSearch);
  // console.log(match);

  const warlockLevelSearch = /^1stâ€“(\d)(?:st|th|nd|rd)\s+level\s+\((\d)\s+(\d)(?:st|th|nd|rd)?\s*(?:Level|level|-level)\s*(?:slot|slots)?\):\s+(.*$)/;
  const warlockMatch = text.match(warlockLevelSearch);

  if (!match && !warlockMatch) {
    this.parseOutInnateSpells(text);
    return;
  }

  const spellLevel = (match) ? match[1] : 'pact';
  const slots = (match) ? match[2] : warlockMatch[2];
  const spellMatches = (match) ? match[3] : warlockMatch[4];

  if (Number.isInteger(parseInt(spellLevel)) && Number.isInteger(parseInt(slots))) {
    this.npc.system.spells[`spell${spellLevel}`]['value'] = parseInt(slots);
    this.npc.system.spells[`spell${spellLevel}`]['max'] = slots ?? "";
    this.npc.system.spells[`spell${spellLevel}`]['override'] = parseInt(slots) ?? null;
    const spellArray = spellMatches.split(",").map((spell) => spell.trim());
    this.spellList.class.push(...spellArray);
  } else if (spellLevel === 'pact' && Number.isInteger(parseInt(slots))) {
    this.npc.system.spells[spellLevel]['value'] = parseInt(slots);
    this.npc.system.spells[spellLevel]['max'] = slots ?? "";
    this.npc.system.spells[spellLevel]['override'] = parseInt(slots) ?? null;
    this.npc.system.spells[spellLevel]['level'] = warlockMatch[3];
    const spellArray = spellMatches.split(",").map((spell) => spell.trim());
    this.spellList.pact.push(...spellArray);
  } else if (["at will", "at-will"].includes(slots)) {
    // at will spells
    const spellArray = spellMatches.replace(/\*/g, '').split(",").map((spell) => spell.trim());
    this.spellList.atwill.push(...spellArray);
  }

};


function splitEdgeCase(spell) {
  let result = {
    name: spell,
    edge: null,
  };

  const splitSpell = spell.split("(");
  if (splitSpell.length > 1) {
    result.name = splitSpell[0].trim();
    result.edge = splitSpell[1].split(")")[0].trim();
  }

  return result;
}

DDBMonster/* default.prototype._generateSpellEdgeCases */.Z.prototype._generateSpellEdgeCases = function() {
  ["pact", "class", "atwill"].forEach((spellType) => {
    this.spellList[spellType].forEach((spellName) => {
      const edgeCheck = splitEdgeCase(`${spellName}`);
      if (edgeCheck.edge) {
        const edgeEntry = {
          name: edgeCheck.name,
          type: spellType,
          edge: edgeCheck.edge,
        };
        this.spellList.edgeCases.push(edgeEntry);
      }
      spellName = edgeCheck.name;
    });
  });

  // innate
  this.spellList.innate.forEach((spellMap) => {
    const edgeCheck = splitEdgeCase(spellMap.name);
    spellMap.name = edgeCheck.name;
    if (edgeCheck.edge) {
      const edgeEntry = {
        name: edgeCheck.name,
        type: "innate",
        edge: edgeCheck.edge,
      };
      this.spellList.edgeCases.push(edgeEntry);
    }
  });
};


// <p><em><strong>Innate Spellcasting.</strong></em> The oblex&rsquo;s innate spellcasting ability is Intelligence (spell save DC 15). It can innately cast the following spells, requiring no components:</p>\r\n<p>3/day each: charm person (as 5th-level spell), color spray, detect thoughts, hold person (as 3rd-level spell)</p>

DDBMonster/* default.prototype._generateSpells */.Z.prototype._generateSpells = function() {

  this.spellcasting = {
    spelldc: 10,
    spellcasting: "", // ability associated
    spellLevel: 0,
    spellAttackBonus: 0,
  };
  this.spellList = {
    class: [],
    pact: [],
    atwill: [],
    // {name: "", type: "srt/lng/day", value: 0} // check these values
    innate: [],
    edgeCases: [], // map { name: "", type: "", edge: "" }
    material: true,
    innateMatch: false,
  };

  let dom = new DocumentFragment();

  // some monsters have poor spell formating, reported and might be able to remove in future
  // https://www.dndbeyond.com/forums/d-d-beyond-general/bugs-support/91228-sir-godfrey-gwilyms-spell-statblock
  const possibleSpellSources = this.source.specialTraitsDescription + this.source.actionsDescription;
  let specialTraits = possibleSpellSources.replace(/<br \/>/g, "</p><p>");

  $.parseHTML(specialTraits).forEach((element) => {
    dom.appendChild(element);
  });

  dom.childNodes.forEach((node) => {
    if (node.textContent == "\n") {
      dom.removeChild(node);
    }
  });

  dom.childNodes.forEach((node) => {
    const spellText = node.textContent.replace(/â€™/g, "'");
    const trimmedText = spellText.trim();

    const spellCastingRegEx = new RegExp(/^Spellcasting/);
    const innateSpellCastingRegEx = new RegExp(/^Innate Spellcasting/);
    const spellcastingMatch = spellCastingRegEx.test(trimmedText);
    const innateSpellcastingMatch = innateSpellCastingRegEx.test(trimmedText);

    if (spellcastingMatch || innateSpellcastingMatch) {
      this._generateSpellcasting(spellText);
      this._generateSpelldc(spellText);
      this._generateSpellLevel(spellText);
      this._generateSpellAttackBonus(spellText);
    }

    const noMaterialSearch = new RegExp(/no material component|no component/);
    const noMaterialMatch = noMaterialSearch.test(trimmedText);

    if (noMaterialMatch) {
      this.spellList.material = false;
    }

    // lets see if the spell block is innate
    if (innateSpellcastingMatch) {
      this.spellList.innateMatch = true;
    } else if (spellcastingMatch) {
      this.spellList.innateMatch = false;
    }

    this.parseOutSpells(spellText);
    this.parseAdditionalAtWillSpells(spellText);
  });

  this._generateSpellEdgeCases();

  src_logger/* default.debug */.Z.debug("Parsed spell list", this.spellList);

  // this.spellcasting = {
  //   spelldc,
  //   spellcasting,
  //   spellLevel,
  //   spells,
  //   spellList,
  //   spellAttackBonus,
  // };

  this.npc.flags.monsterMunch['spellList'] = this.spellList;

};

/**
 *
 * @param {[items]} spells Array of Strings or items
 */
DDBMonster/* default.prototype.retrieveCompendiumSpells */.Z.prototype.retrieveCompendiumSpells = async function(spells) {
  const compendiumName = await game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "entity-spell-compendium");
  const compendiumItems = await CompendiumHelper/* default.retrieveMatchingCompendiumItems */.Z.retrieveMatchingCompendiumItems(spells, compendiumName);
  const itemData = compendiumItems.map((i) => {
    let spell = i.toObject();
    delete spell._id;
    return spell;
  });

  return itemData;
};

DDBMonster/* default.prototype.getSpellEdgeCase */.Z.prototype.getSpellEdgeCase = function(spell, type, spellList) {
  const edgeCases = spellList.edgeCases;
  const edgeCase = edgeCases.find((edge) => edge.name.toLowerCase() === spell.name.toLowerCase() && edge.type === type);

  if (edgeCase) {
    src_logger/* default.debug */.Z.debug(`Spell edge case for ${spell.name}`);
    switch (edgeCase.edge.toLowerCase()) {
      case "self":
      case "self only":
        spell.system.target.type = "self";
        src_logger/* default.debug */.Z.debug("spell target changed to self");
        break;
      // no default
    }
    spell.name = `${spell.name} (${edgeCase.edge})`;
    // spell.system.description.chat = `<p><b>Special Notes: ${edgeCase.edge}.</b></p>\n\n${spell.system.description.chat}`;
    spell.system.description.value = `<p><b>Special Notes: ${edgeCase.edge}.</b></p>\n\n${spell.system.description.value}`;

    const diceSearch = /(\d+)d(\d+)/;
    const diceMatch = edgeCase.edge.match(diceSearch);
    if (diceMatch) {
      if (spell.system.damage.parts[0] && spell.system.damage.parts[0][0]) {
        spell.system.damage.parts[0][0] = diceMatch[0];
      } else if (spell.system.damage.parts[0]) {
        spell.system.damage.parts[0] = [diceMatch[0]];
      } else {
        spell.system.damage.parts = [[diceMatch[0]]];
      }
    }

    // save DC 12
    const saveSearch = /save DC (\d+)/;
    const saveMatch = edgeCase.edge.match(saveSearch);
    if (saveMatch) {
      spell.system.save.dc = parseInt(saveMatch[1]);
      spell.system.save.scaling = "flat";
    }

  }

  // remove material components?
  if (!spellList.material) {
    spell.system.materials = {
      value: "",
      consumed: false,
      cost: 0,
      supply: 0
    };
    spell.system.components.material = false;
  }

};

DDBMonster/* default.prototype.addSpells */.Z.prototype.addSpells = async function() {
  // check to see if we have munched flags to work on
  if (!this.spellList) {
    return;
  }

  src_logger/* default.debug */.Z.debug(`Spell List for edgecases`, this.spellList);
  const atWill = this.spellList.atwill;
  const klass = this.spellList.class;
  const innate = this.spellList.innate;
  const pact = this.spellList.pact;

  if (atWill.length !== 0) {
    src_logger/* default.debug */.Z.debug("Retrieving at Will spells:", atWill);
    let spells = await this.retrieveCompendiumSpells(atWill);
    spells = spells.filter((spell) => spell !== null).map((spell) => {
      if (spell.system.level == 0) {
        spell.system.preparation = {
          mode: "prepared",
          prepared: false,
        };
      } else {
        spell.system.preparation = {
          mode: "atwill",
          prepared: false,
        };
        spell.system.uses = {
          value: null,
          max: "",
          per: null,
          recovery: "",
        };
      }
      this.getSpellEdgeCase(spell, "atwill", this.spellList);
      return spell;
    });
    this.items.push(...spells);
  }

  // class spells
  if (klass.length !== 0) {
    src_logger/* default.debug */.Z.debug("Retrieving class spells:", klass);
    let spells = await this.retrieveCompendiumSpells(klass);
    spells = spells.filter((spell) => spell !== null).map((spell) => {
      spell.system.preparation = {
        mode: "prepared",
        prepared: true,
      };
      this.getSpellEdgeCase(spell, "class", this.spellList);
      return spell;
    });
    this.items.push(...spells);
  }

  // pact spells
  if (pact.length !== 0) {
    src_logger/* default.debug */.Z.debug("Retrieving pact spells:", pact);
    let spells = await this.retrieveCompendiumSpells(pact);
    spells = spells.filter((spell) => spell !== null).map((spell) => {
      spell.system.preparation = {
        mode: "pact",
        prepared: true,
      };
      this.getSpellEdgeCase(spell, "pact", this.spellList);
      return spell;
    });
    this.items.push(...spells);
  }

  // innate spells
  if (innate.length !== 0) {
    // innate:
    // {name: "", type: "srt/lng/day", value: 0}
    src_logger/* default.debug */.Z.debug("Retrieving innate spells:", innate);
    const spells = await this.retrieveCompendiumSpells(innate);
    const innateSpells = spells.filter((spell) => spell !== null)
      .map((spell) => {
        const spellInfo = innate.find((w) => w.name.toLowerCase() == spell.name.toLowerCase());
        if (spellInfo) {
          const isAtWill = hasProperty(spellInfo, "innate") && !spellInfo.innate;
          if (spell.system.level == 0) {
            spell.system.preparation = {
              mode: "prepared",
              prepared: false,
            };
          } else {
            spell.system.preparation = {
              mode: isAtWill ? "atwill" : "innate",
              prepared: !isAtWill,
            };
          }
          if (isAtWill && spellInfo.type === "atwill") {
            spell.system.uses = {
              value: null,
              max: "",
              per: null,
              recovery: "",
            };
          } else {
            const perLookup = dictionary/* default.resets.find */.Z.resets.find((d) => d.id == spellInfo.type);
            const per = spellInfo.type === "atwill"
              ? null
              : (perLookup && perLookup.type)
                ? perLookup.type
                : "day";
            spell.system.uses = {
              value: parseInt(spellInfo.value),
              max: spellInfo.value ?? "",
              per,
              recovery: "",
            };
          }
          this.getSpellEdgeCase(spell, "innate", this.spellList);
        }
        return spell;
      });
    this.items.push(...innateSpells);
  }
};

// EXTERNAL MODULE: ./src/parser/DDBCharacter.js + 2 modules
var DDBCharacter = __webpack_require__(1269);
// EXTERNAL MODULE: ./src/lib/utils.js
var utils = __webpack_require__(7669);
;// CONCATENATED MODULE: ./src/parser/character/index.js


// import { fixCharacterLevels } from "./filterModifiers.js";

DDBCharacter/* default.prototype._newPCSkeleton */.Z.prototype._newPCSkeleton = async function _newPCSkeleton() {
  const name = (this.source.ddb.character.name === "") ? "Hero With No Name" : this.source.ddb.character.name;

  this.raw.character = {
    system: JSON.parse(utils/* default.getTemplate */.Z.getTemplate("character")),
    type: "character",
    effects: [],
    name: name,
    // items: [],  // modified to check inventory analysis on update
    flags: {
      ddbimporter: {
        compendium: false,
        acEffects: [],
        baseAC: 10,
        dndbeyond: {
          totalLevels: null,
          proficiencies: null,
          proficienciesIncludingEffects: null,
          roUrl: this.source.ddb.character.readonlyUrl,
          characterValues: this.source.ddb.character.characterValues,
          templateStrings: [],
          campaign: this.source.ddb.character.campaign,
        },
      },
    },
  };

  // generate a prototype token
  this._generateToken();

  return this.raw.character;
};

DDBCharacter/* default.prototype._generateCharacter */.Z.prototype._generateCharacter = async function _generateCharacter() {
  // *************************************
  // PARSING THE CHARACTER
  // **************************************
  //
  // ddb = fixCharacterLevels(ddb);

  // build skeleton this.raw.character
  await this._newPCSkeleton();

  this.totalLevels = this.source.ddb.character.classes.reduce((prev, cur) => prev + cur.level, 0);
  this.raw.character.flags.ddbimporter.dndbeyond.totalLevels = this.totalLevels;
  this._generateProficiencies();

  // proficiency
  // prettier-ignore
  this.raw.character.system.attributes.prof = Math.ceil(1 + (0.25 * this.totalLevels));

  // Get supported 5e feats and abilities
  // We do this first so we can check for them later
  this._setSpecialTraitFlags();

  this._generateAbilities();
  this._generateHitDice();
  this._generateDeathSaves();
  this._generateExhaustion();
  this.raw.character.system.attributes.inspiration = this.source.ddb.character.inspiration;
  this._generateArmorClass();
  this._generateHitPoints();
  this._generateInitiative();
  this._generateSpeed();
  this._generateSenses();
  this._generateSpellCasting();
  this._generateSpellDC();
  // resources
  this._generateResources();
  this._generateMaxPreparedSpells();
  this.raw.character.system.details.xp.value = this.source.ddb.character.currentXp;
  this._generateTrait();
  this._generateIdeal();
  this._generateFlaw();
  this._generateBond();
  this._generateAppearance();
  this._generateDescription();
  this._generateAlignment();
  this._generateBiography();
  this.raw.character.system.details.race = this.source.ddb.character.race.fullName;
  this._generateSize();
  // immunities, resistances, vuls and condition immunities
  this._generateConditions();
  this._generateCurrency();
  await this._generateSkills();
  this._generateSpellSlots();

  // Extra global bonuses
  this._generateBonusAbilities();
  this._generateBonusSpellAttacks();
  this._generateBonusSpellDC();
  this._generateBonusWeaponAttacks();
};


;// CONCATENATED MODULE: ./src/parser/character/token.js




DDBCharacter/* default.prototype._generateToken */.Z.prototype._generateToken = function _generateToken() {
  try {
    // Default to the most basic token setup.
    // everything else can be handled by the user / Token Mold
    let tokenData = {
      actorLink: true,
      name: this.source.ddb.character.name,
      sight: {
        enabled: true,
        range: 0,
        angle: 360,
        color: null,
        attenuation: 0,
        brightness: 0,
        saturation: 0,
        contrast: 0,
        visionMode: "basic",
      },
      detectionModes: [],
    };
    const senses = this.getSenses();
    // darkvision: 0,
    // blindsight: 0,
    // tremorsense: 0,
    // truesight: 0,

    for (const [key, value] of Object.entries(senses)) {
      if (value > 0 && value > tokenData.sight.range && hasProperty(dictionary/* default.senseMap */.Z.senseMap, key)) {
        const visionMode = dictionary/* default.senseMap */.Z.senseMap[key];
        setProperty(tokenData, "sight.visionMode", visionMode);
        setProperty(tokenData, "sight.range", value);
        tokenData.sight = mergeObject(tokenData.sight, CONFIG.Canvas.visionModes[visionMode].vision.defaults);
      }
      if (value > 0 && hasProperty(dictionary/* default.detectionMap */.Z.detectionMap, key)) {
        const detectionMode = {
          id: dictionary/* default.detectionMap */.Z.detectionMap[key],
          range: value,
          enabled: true,
        };

        // only add duplicate modes if they don't exist
        if (!tokenData.detectionModes.some((mode) => mode.id === detectionMode.id)) {
          tokenData.detectionModes.push(detectionMode);
        }
      }
    }

    // devilsight? we set the vision mode back to basic
    const devilSight = senses.special.includes("You can see normally in darkness");
    if (devilSight) {
      setProperty(tokenData, "sight.visionMode", "basic");
      tokenData.sight = mergeObject(tokenData.sight, CONFIG.Canvas.visionModes.basic.vision.defaults);
    }

    this.raw.character.prototypeToken = tokenData;
  } catch (err) {
    src_logger/* default.error */.Z.error(err);
    src_logger/* default.error */.Z.error(err.stack);
    throw new Error("Please update your D&D 5e system to a newer version");
  }
};

// EXTERNAL MODULE: ./src/lib/DDBHelper.js
var DDBHelper = __webpack_require__(1438);
// EXTERNAL MODULE: ./src/effects/acEffects.js
var acEffects = __webpack_require__(2877);
;// CONCATENATED MODULE: ./src/parser/character/filterModifiers.js


/**
 * UTILITY
 * Returns a string representation of friendlyTypename and friendlySubtypeName for an obj[]
 * @param {object[]} arr array of objects
 */
function extractInfo(arr) {
  return arr.map((e) => `${e.friendlyTypeName} (${e.friendlySubtypeName})`);
}

/**
 * Extracts basic character information
 * @param {object} data Character JSON
 * returns information about the classes this character chose, including
 * - {string} name
 * - {number} level
 * - {boolean} isStartingClass
 * - {object[]} modifiers (empty, will be filled later)
 * }
 */
function getClassInfo(data) {
  return data.classes.map((cls) => {
    return {
      name:
        cls.subclassDefinition && cls.subclassDefinition.name
          ? `${cls.definition.name} (${cls.subclassDefinition.name})`
          : cls.definition.name,
      level: cls.level,
      isStartingClass: cls.isStartingClass,
      modifiers: [],
    };
  });
}

/**
 * Gets all class features up to a certain class level
 * @param {obj} cls character.classes[] entry
 * @param {*} classLevel level requirement up to which the class features should be extracted
 */
function getClassFeatures(cls, classLevel = 20) {
  if (
    cls.subclassDefinition
    && cls.subclassDefinition.classFeatures
    && Array.isArray(cls.subclassDefinition.classFeatures)
  ) {
    const subclassFeatures = cls.subclassDefinition.classFeatures.map((subclassFeature) => {
      subclassFeature.className = cls.definition.name;
      subclassFeature.subclassName = cls.subclassDefinition.name;
      return subclassFeature;
    });
    const result = cls.classFeatures
      .map((feature) => {
        const f = feature.definition;
        f.className = cls.definition.name;
        f.subclassName = null;
        return f;
      })
      .concat(subclassFeatures)
      .filter((classFeature) => classFeature.requiredLevel <= classLevel)
      .sort((a, b) => a.requiredLevel - b.requiredLevel);
    return result;
  } else {
    const result = cls.classFeatures
      .map((feature) => {
        const f = feature.definition;
        f.className = cls.definition.name;
        f.subclassName = null;
        return f;
      })
      .filter((classFeature) => classFeature.requiredLevel <= classLevel)
      .sort((a, b) => a.requiredLevel - b.requiredLevel);
    return result;
  }
}


/**
 * Checks if a given class is the starting class of this character
 * @param {object} data character data
 * @param {string} className name of the class to check
 * @returns {boolean} true of the class is a starting class, false otherwise
 */
function isStartingClass(data, className) {
  return data.classes.find((cls) => cls.definition.name === className && cls.isStartingClass);
}

/**
 * Gets all class modifiers for a given character
 * This filters out all modifiers that do not have an entry in the class features passed in
 * For multiclassing characters, it checks if the given class is the starting class or a multiclass,
 *    then the `.availableToMulticlass` is queried if this modifier is enabled or not
 * @param {obj} cls character.classes[] entry
 * @param {*} classLevel level requirement up to which the class features should be extracted
 */
function getClassModifiers(data, classFeatures, isStartingClass = false) {
  const modifiers = data.modifiers.class.filter((classModifier) => {
    // check the class from which this modifier came
    const componentId = classModifier.componentId;
    const feature = classFeatures.find((feature) => feature.id === componentId);
    if (feature !== undefined) {
      const isFeatureAvailable = classModifier.availableToMulticlass ? true : isStartingClass;
      logger.debug(
        `${isFeatureAvailable ? "  [  AVAIL]" : "  [UNAVAIL]"} Modifier found: ${classModifier.friendlyTypeName} (${
          classModifier.friendlySubtypeName
        })`
      );
      return isFeatureAvailable;
    }
    return false;
  });

  return modifiers;
}

function getAllClassFeatures(data) {
  return data.classes
    .map((cls) => {
      return getClassFeatures(cls, cls.level);
    })
    .flat();
}

function getClassOptionModifiers(data) {
  const classFeatures = getAllClassFeatures(data);

  const modifiers = data.modifiers.class.filter((classModifier) => {
    const componentId = classModifier.componentId;
    const feature = classFeatures.find((feature) => feature.id === componentId);

    if (feature === undefined) {
      logger.debug(`Modifier found: ${classModifier.friendlyTypeName} (${classModifier.friendlySubtypeName})`);
      return true;
    }
    return false;
  });

  return modifiers;
}

/**
 * Filters the modifiers with the utility functions above
 * @param {object} data character data
 * @returns {[object[]]} an array containing an array of filtered modifiers, grouped by class
 */
function filterModifiers(data, classInfo) {
  // get the classFeatures for all classes
  data.classes.forEach((cls, index) => {
    const features = getClassFeatures(cls, cls.level);
    classInfo[index].modifiers = getClassModifiers(data, features, isStartingClass(data, cls.definition.name));
  });
  return classInfo;
}

function fixCharacterLevels(data) {
  const classInfo = getClassInfo(data.character);
  const filteredClassInfo = filterModifiers(data.character, classInfo);
  let classModifiers = getClassOptionModifiers(data.character, classInfo);

  filteredClassInfo.forEach((cls) => {
    logger.debug(`${cls.isStartingClass ? "Starting Class" : "Multiclass"}: [lvl${cls.level}] ${cls.name} `);
    logger.debug(
      extractInfo(cls.modifiers)
        .map((s) => `    ${s}`)
        .join("\n")
    );
    classModifiers = classModifiers.concat(cls.modifiers);
  });
  data.character.modifiers.class = classModifiers;
  return data;
}

;// CONCATENATED MODULE: ./src/parser/character/ac.js







/**
 * This excludes shields
 */
DDBCharacter/* default.prototype.isArmored */.Z.prototype.isArmored = function isArmored() {
  return (
    this.source.ddb.character.inventory.filter(
      (item) => item.equipped && item.definition.armorClass && item.definition.armorTypeId !== 4
    ).length >= 1
  );
};

/**
 * This excludes shields
 */
DDBCharacter/* default.prototype.isUnArmored */.Z.prototype.isUnArmored = function isUnArmored() {
  return !this.isArmored();
};

function getMinimumBaseAC(modifiers) {
  let hasBaseArmor = modifiers.filter(
    (modifier) => modifier.type === "set" && modifier.subType === "minimum-base-armor" && modifier.isGranted
  );
  let baseAC = [];
  hasBaseArmor.forEach((base) => {
    baseAC.push(base.value);
  });
  return baseAC;
}

function getBaseArmor(ac, armorType, name = "Racial") {
  return {
    definition: {
      name: `Base Armor - ${name}`,
      type: armorType,
      armorClass: ac,
      armorTypeId: dictionary/* default.equipment.armorType.find */.Z.equipment.armorType.find((id) => id.name === armorType).id,
      grantedModifiers: [],
      canAttune: false,
      filterType: "Armor",
    },
    isAttuned: false,
  };
}

function getEquippedAC(equippedGear) {
  return equippedGear.reduce((prev, item) => {
    let ac = 0;
    // regular armor
    if (item.definition.armorClass) {
      ac += item.definition.armorClass;
    }

    // magical armor
    const usingItemEffects = game.settings.get("ddb-importer", "character-update-policy-add-item-effects");

    const daeItemEffects = (usingItemEffects
      && item.equipped && item.definition.filterType !== "Armor"
    );

    if (!daeItemEffects && item.definition.grantedModifiers) {
      let isAvailable = false;
      // does an item need attuning
      if (item.definition.canAttune === true) {
        if (item.isAttuned === true) {
          isAvailable = true;
        }
      } else {
        isAvailable = true;
      }

      if (isAvailable) {
        item.definition.grantedModifiers.forEach((modifier) => {
          if (modifier.type === "bonus" && modifier.subType === "armor-class") {
            // add this to armor AC
            ac += modifier.value;
          }
        });
      }
    }
    return prev + ac;
  }, 0);
}

// returns an array of ac values from provided array of modifiers
function getUnarmoredAC(modifiers, character) {
  let unarmoredACValues = [];
  let isUnarmored = modifiers.filter(
    (modifier) => modifier.type === "set" && modifier.subType === "unarmored-armor-class" && modifier.isGranted
  );
  // if (isUnarmored.length === 0) {
  //   // Some items will have an unarmoured bonus, but won't set a base, so if we are in this
  //   // situation, we add a default base ac
  //   isUnarmored.push({
  //     statId: 2,
  //     value: 0,
  //   });
  // }

  const ignoreDex = modifiers.some((modifier) => modifier.type === "ignore" && modifier.subType === "unarmored-dex-ac-bonus");

  const maxUnamoredDexMods = modifiers.filter(
    (modifier) => modifier.type === "set" && modifier.subType === "ac-max-dex-modifier" && modifier.isGranted
  ).map((mods) => mods.value);
  const maxUnamoredDexMod = ignoreDex ? 0 : Math.min(...maxUnamoredDexMods, 20);

  // console.log(`Max Dex: ${maxUnamoredDexMod}`);
  const characterAbilities = character.flags.ddbimporter.dndbeyond.effectAbilities;

  isUnarmored.forEach((unarmored) => {
    let unarmoredACValue = 10;
    // +DEX
    // for a case of setting unarmoured ac, the dex won't detract
    unarmoredACValue += Math.max(0, Math.min(characterAbilities.dex.mod, maxUnamoredDexMod));
    // +WIS or +CON, if monk or barbarian, draconic resilience === null

    // console.log(`Unarmoured AC Value: ${unarmoredACValue}`);
    // console.log(unarmored);

    if (unarmored.statId !== null) {
      let ability = dictionary/* default.character.abilities.find */.Z.character.abilities.find((ability) => ability.id === unarmored.statId);
      unarmoredACValue += characterAbilities[ability.value].mod;
    }
    if (unarmored.value) unarmoredACValue += unarmored.value;
    unarmoredACValues.push(unarmoredACValue);
  });
  // console.warn(unarmoredACValues);
  return unarmoredACValues;
}

function getDualWieldAC(data, modifiers) {
  const dualWielding = data.character.characterValues.some((cv) => {
    const equipped = data.character.inventory.some((item) => item.equipped && item.id == cv.valueId);
    const dualWielding = cv.typeId === 18;
    return equipped && dualWielding;
  });
  let dualWieldBonus = 0;

  if (dualWielding) {
    DDBHelper/* default.filterModifiers */.Z.filterModifiers(modifiers, "bonus", "dual-wield-armor-class", ["", null], true).forEach((bonus) => {
      dualWieldBonus += bonus.value;
    });
  }

  return dualWieldBonus;
}

// To Do: Rework AC functions as class functions to help reduce complexity in calculation.
// eslint-disable-next-line complexity
function calculateACOptions(data, character, calculatedArmor) {
  const characterAbilities = character.flags.ddbimporter.dndbeyond.effectAbilities;
  let actorBase = 10 + characterAbilities.dex.mod;
  // generated AC effects
  let effects = [];
  // array to assemble possible AC values
  let armorClassValues = [];
  // max holders
  let maxType = "Unarmored";
  let maxValue = actorBase;

  // the presumption here is that you can only wear a shield and a single
  // additional 'armor' piece. in DDB it's possible to equip multiple armor
  // types and it works out the best AC for you
  // we also want to handle unarmored for monks etc.
  // we might have multiple shields "equipped" by accident, so work out
  // the best one
  for (let armor = 0; armor < calculatedArmor.armors.length; armor++) {
    // getEquippedAC fetches any magical AC boost on the items passed
    let armorAC = getEquippedAC([calculatedArmor.armors[armor]]);
    let shieldMod = 0;

    if (calculatedArmor.shields.length !== 0) {
      let maxAC = armorAC;
      for (let shield = 0; shield < calculatedArmor.shields.length; shield++) {
        const combinedAC = getEquippedAC([calculatedArmor.armors[armor], calculatedArmor.shields[shield]]);
        if (combinedAC > maxAC) {
          shieldMod = combinedAC - armorAC;
          maxAC = combinedAC;
        }
      }
      armorAC = maxAC;
    }

    // Determine final AC values based on AC Type
    // Light Armor: AC + DEX
    // Medium Armor: AC + DEX (max 2)
    // Heavy Armor: AC only
    // Unarmored Defense: Dex mod already included in calculation

    // sometimes the type field can be blank in DDB
    if (!calculatedArmor.armors[armor].definition.type || calculatedArmor.armors[armor].definition.type === "") {
      const armourTypeId = calculatedArmor.armors[armor].definition.armorTypeId;
      const acType = dictionary/* default.equipment.armorType.find */.Z.equipment.armorType.find((a) => a.id === armourTypeId);
      if (acType) calculatedArmor.armors[armor].definition.type = acType.name;
    }
    let effect = null;
    let acValue;

    switch (calculatedArmor.armors[armor].definition.type) {
      case "Natural Armor": {
        let acCalc = 0;
        // Tortles don't get to add an unarmored ac bonus for their shell
        const ignoreUnarmouredACBonus = DDBHelper/* default.filterBaseModifiers */.Z.filterBaseModifiers(data, "ignore", "unarmored-dex-ac-bonus");
        if (ignoreUnarmouredACBonus) {
          acCalc = armorAC + calculatedArmor.miscACBonus;
          // console.log(armorAC);
          // console.log(gearAC);
          // console.log(miscACBonus);
        } else {
          acCalc = armorAC + calculatedArmor.miscACBonus + calculatedArmor.unarmoredACBonus;
        }
        acValue = {
          name: calculatedArmor.armors[armor].definition.name,
          value: acCalc + calculatedArmor.gearAC,
          type: "Natural",
          acCalc,
          shieldMod,
        };
        if (acCalc > actorBase) actorBase = acCalc - shieldMod;
        effect = (0,acEffects/* generateFixedACEffect */.LY)(acValue.value, `AC ${calculatedArmor.armors[armor].definition.name} (Natural): ${acValue.value}`, true);
        break;
      }
      case "Unarmored Defense": {
        const acCalc = armorAC + calculatedArmor.miscACBonus + calculatedArmor.unarmoredACBonus;
        acValue = {
          name: calculatedArmor.armors[armor].definition.name,
          value: acCalc + calculatedArmor.gearAC,
          type: "Unarmored Defense",
          acCalc,
          shieldMod,
        };
        if (acCalc > actorBase) actorBase = acCalc - shieldMod;
        effect = (0,acEffects/* generateFixedACEffect */.LY)(acValue.value, `AC ${calculatedArmor.armors[armor].definition.name} (Unarmored Defense): ${acValue.value}`);
        break;
      }
      case "Unarmored": {
        const base = armorAC + calculatedArmor.miscACBonus + calculatedArmor.unarmoredACBonus;
        const acCalc = base + characterAbilities.dex.mod;
        acValue = {
          name: calculatedArmor.armors[armor].definition.name,
          value: acCalc + calculatedArmor.gearAC,
          type: "Unarmored",
          acCalc,
          shieldMod,
        };
        if (acCalc > actorBase) actorBase = acCalc - shieldMod;
        effect = (0,acEffects/* generateFixedACEffect */.LY)(`${acValue.value} + @abilities.dex.mod`, `AC ${calculatedArmor.armors[armor].definition.name} (Unarmored): ${acValue.value}`, true, 15);
        break;
      }
      case "Heavy Armor": {
        const acCalc = armorAC + calculatedArmor.gearAC + calculatedArmor.miscACBonus;
        acValue = {
          name: calculatedArmor.armors[armor].definition.name,
          value: acCalc,
          type: "Heavy",
          acCalc,
          shieldMod,
        };
        effect = (0,acEffects/* generateFixedACEffect */.LY)(acValue.value, `AC ${calculatedArmor.armors[armor].definition.name} (Heavy): ${acValue.value}`);
        break;
      }
      case "Medium Armor": {
        const maxDexMedium = Math.max(...DDBHelper/* default.filterBaseModifiers */.Z.filterBaseModifiers(data, "set", "ac-max-dex-armored-modifier", ["", null], true)
          .map((mod) => mod.value), 2);
        const acCalc = armorAC + calculatedArmor.gearAC + calculatedArmor.miscACBonus;
        acValue = {
          name: calculatedArmor.armors[armor].definition.name,
          value: acCalc + Math.min(maxDexMedium, characterAbilities.dex.mod),
          type: "Medium",
          acCalc,
          shieldMod,
        };
        effect = (0,acEffects/* generateFixedACEffect */.LY)(`${acCalc} + {@abilities.dex.mod, ${maxDexMedium}}kl`, `AC ${calculatedArmor.armors[armor].definition.name} (Medium): ${acValue.value}`);
        break;
      }
      case "Light Armor": {
        const acCalc = armorAC + calculatedArmor.gearAC + calculatedArmor.miscACBonus;
        acValue = {
          name: calculatedArmor.armors[armor].definition.name,
          value: acCalc + characterAbilities.dex.mod,
          type: "Light",
          acCalc,
          shieldMod,
        };
        effect = (0,acEffects/* generateFixedACEffect */.LY)(`${acCalc} + @abilities.dex.mod`, `AC ${calculatedArmor.armors[armor].definition.name} (Light): ${acValue.value}`);
        break;
      }
      default: {
        const acCalc = armorAC + calculatedArmor.gearAC + calculatedArmor.miscACBonus;
        acValue = {
          name: calculatedArmor.armors[armor].definition.name,
          value: acCalc + characterAbilities.dex.mod,
          type: "Other",
          acCalc,
          shieldMod,
        };
        effect = (0,acEffects/* generateFixedACEffect */.LY)(`${acCalc} + @abilities.dex.mod`, `AC ${calculatedArmor.armors[armor].definition.name}: ${acValue.value}`, false, 22);
        break;
      }
    }
    if (effect) {
      effect.flags.ddbimporter.itemId = calculatedArmor.armors[armor].id;
      effect.flags.ddbimporter.entityTypeId = calculatedArmor.armors[armor].entityTypeId;
      effects.push(effect);
    }
    armorClassValues.push(acValue);
    if (acValue.value >= maxValue) {
      maxType = acValue.type;
      maxValue = acValue.value;
    }
  }

  src_logger/* default.debug */.Z.debug("Final AC Choices:", armorClassValues);
  return {
    actorBase,
    armorClassValues,
    effects,
    maxType,
    maxValue,
  };
}


DDBCharacter/* default.prototype._generateOverrideArmorClass */.Z.prototype._generateOverrideArmorClass = function _generateOverrideArmorClass(overRideAC) {
  const overRideEffect = (0,acEffects/* generateFixedACEffect */.LY)(overRideAC.value, `AC Override: ${overRideAC.value}`);

  this.raw.character.system.attributes.ac = {
    flat: overRideAC.value,
    calc: "flat",
    formula: "",
  };
  this.raw.character.effects = this.raw.character.effects.concat(overRideEffect);
  this.raw.character.flags.ddbimporter.acEffects = [overRideEffect];
  this.raw.character.flags.ddbimporter.baseAC = overRideAC.value;
  this.raw.character.flags.ddbimporter.autoAC = deepClone(this.raw.character.system.attributes.ac);
  this.raw.character.flags.ddbimporter.overrideAC = {
    flat: overRideAC.value,
    calc: "flat",
    formula: "",
  };
  this.raw.character.flags.ddbimporter.fixedAC = {
    type: "Number",
    label: "Armor Class",
    value: overRideAC.value,
  };
};


DDBCharacter/* default.prototype._generateArmorClass */.Z.prototype._generateArmorClass = function _generateArmorClass() {
  const overRideAC = this.source.ddb.character.characterValues.find((val) => val.typeId === 1);

  if (overRideAC) {
    this._generateOverrideArmorClass(overRideAC);
    return;
  }

  // get a list of equipped armor
  // we make a distinction so we can loop over armor
  let equippedArmor = this.source.ddb.character.inventory.filter(
    (item) => item.equipped && item.definition.filterType === "Armor"
  );
  let baseAC = 10;
  // for things like fighters fighting style
  let miscACBonus = 0;
  let bonusEffects = [];
  // lets get equipped gear
  const equippedGear = this.source.ddb.character.inventory.filter(
    (item) => item.equipped && item.definition.filterType !== "Armor"
  );
  const unarmoredACBonus = DDBHelper/* default.filterBaseModifiers */.Z.filterBaseModifiers(this.source.ddb, "bonus", "unarmored-armor-class")
    .reduce((prev, cur) => prev + cur.value, 0);

  // lets get the AC for all our non-armored gear, we'll add this later
  const gearAC = getEquippedAC(equippedGear);

  // While not wearing armor, lets see if we have special abilities
  if (this.isUnArmored()) {
    // unarmored abilities from Class/Race?
    const unarmoredSources = [
      DDBHelper/* default.getChosenClassModifiers */.Z.getChosenClassModifiers(this.source.ddb),
      this.source.ddb.character.modifiers.race,
      this.source.ddb.character.modifiers.feat,
      DDBHelper/* default.getActiveItemModifiers */.Z.getActiveItemModifiers(this.source.ddb, true),
    ];
    unarmoredSources.forEach((modifiers) => {
      const unarmoredAC = Math.max(getUnarmoredAC(modifiers, this.raw.character));
      if (unarmoredAC) {
        // we add this as an armored type so we can get magical item bonuses
        // e.g. ring of protection
        equippedArmor.push(getBaseArmor(unarmoredAC, "Unarmored Defense", "Unarmored defense"));
      }
    });
  } else {
    // check for things like fighters fighting style defense
    const armorBonusSources = [DDBHelper/* default.getChosenClassModifiers */.Z.getChosenClassModifiers(this.source.ddb), this.source.ddb.character.modifiers.race].flat();
    const armoredBonuses = armorBonusSources.filter(
      (modifier) => modifier.subType === "armored-armor-class" && modifier.isGranted
    );
    const effect = (0,acEffects/* generateBonusACEffect */.AD)(armoredBonuses, "AC: Armored Misc Bonuses", "armored-armor-class", null);
    if (effect.changes.length > 0) bonusEffects.push(effect);
  }

  // Generic AC bonuses like Warforfed Integrated Protection
  // item modifiers are loaded by ac calcs
  const miscModifiers = [
    DDBHelper/* default.getChosenClassModifiers */.Z.getChosenClassModifiers(this.source.ddb),
    DDBHelper/* default.getModifiers */.Z.getModifiers(this.source.ddb, "race"),
    DDBHelper/* default.getModifiers */.Z.getModifiers(this.source.ddb, "background"),
    DDBHelper/* default.getModifiers */.Z.getModifiers(this.source.ddb, "feat")
  ];

  DDBHelper/* default.filterModifiers */.Z.filterModifiers(miscModifiers, "bonus", "armor-class", ["", null], true).forEach((bonus) => {
    const component = DDBHelper/* default.findComponentByComponentId */.Z.findComponentByComponentId(this.source.ddb, bonus.componentId);
    const name = component ? component.definition?.name ?? component.name : `AC: Misc (${bonus.friendlySubtypeName})`;
    const effect = (0,acEffects/* generateBonusACEffect */.AD)([bonus], name, "armor-class", null);
    if (effect.changes.length > 0) bonusEffects.push(effect);
  });

  this.source.ddb.character.characterValues.filter((value) =>
    (value.typeId === 3 || value.typeId === 2)
    && value.value !== 0
  ).forEach((custom) => {
    const name = custom.notes && custom.notes.trim() !== "" ? custom.notes : "AC: Custom Bonus";
    const effect = (0,acEffects/* generateBonusACEffect */.AD)([], name, "custom", null);
    const key = game.modules.get("dae")?.active
      ? "system.attributes.ac.value"
      : "system.attributes.ac.bonus";
    effect.changes.push({
      key,
      value: custom.value,
      mode: CONST.ACTIVE_EFFECT_MODES.ADD,
      priority: 30,
    });
    bonusEffects.push(effect);
  });

  miscACBonus += getDualWieldAC(this.source.ddb, miscModifiers);

  // Each racial armor appears to be slightly different!
  // We care about Tortles and Lizardfolk here as they can use shields, but their
  // modifier is set differently
  switch (this.source.ddb.character.race.fullName) {
    case "Lizardfolk":
      baseAC = Math.max(getUnarmoredAC(this.source.ddb.character.modifiers.race, this.raw.character));
      equippedArmor.push(getBaseArmor(baseAC, "Natural Armor", this.source.ddb.character.race.fullName));
      break;
    case "Autognome":
    case "Thri-kreen":
    case "Loxodon":
    case "Tortle":
      baseAC = Math.max(getMinimumBaseAC(this.source.ddb.character.modifiers.race, this.raw.character), getUnarmoredAC(this.source.ddb.character.modifiers.race, this.raw.character));
      equippedArmor.push(getBaseArmor(baseAC, "Natural Armor", this.source.ddb.character.race.fullName));
      break;
    default:
      equippedArmor.push(getBaseArmor(baseAC, "Unarmored"));
  }

  const shields = equippedArmor.filter((shield) => shield.definition.armorTypeId === 4);
  const armors = equippedArmor.filter((armour) => armour.definition.armorTypeId !== 4);

  src_logger/* default.debug */.Z.debug("Calculated GearAC: " + gearAC);
  src_logger/* default.debug */.Z.debug("Unarmoured AC Bonus:" + unarmoredACBonus);
  src_logger/* default.debug */.Z.debug("Calculated MiscACBonus: " + miscACBonus);
  src_logger/* default.debug */.Z.debug("Equipped AC Options: ", equippedArmor);
  src_logger/* default.debug */.Z.debug("Armors: ", armors);
  src_logger/* default.debug */.Z.debug("Shields: ", shields);

  const calculatedArmor = {
    gearAC,
    unarmoredACBonus,
    miscACBonus,
    equippedArmor,
    armors,
    shields,
  };
  const results = calculateACOptions(this.source.ddb, this.raw.character, calculatedArmor);

  src_logger/* default.debug */.Z.debug("Calculated AC Results:", results);
  // get the max AC we can use from our various computed values
  // const max = Math.max(...results.armorClassValues.map((type) => type.value));

  //
  // DND5E.armorClasses = {
  //   "default": {


  // const draconic = ddb.classes[0].classFeatures[1].definition
  const classFeatures = getAllClassFeatures(this.source.ddb.character);
  src_logger/* default.debug */.Z.debug("Class features", classFeatures);

  let calc = "default";
  let flat = null;
  if (classFeatures.some((kf) =>
    kf.className === "Sorcerer"
    && kf.subclassName === "Draconic Bloodline"
    && kf.name === "Draconic Resilience"
  )) calc = "draconic";

  if (classFeatures.some((kf) =>
    kf.className === "Monk"
    && kf.subclassName === null
    && kf.name === "Unarmored Defense"
  )) calc = "unarmoredMonk";

  if (classFeatures.some((kf) =>
    kf.className === "Barbarian"
    && kf.subclassName === null
    && kf.name === "Unarmored Defense"
  )) calc = "unarmoredBarb";

  if (results.maxType === "Natural") {
    calc = "natural";
    flat = results.actorBase;
  }

  src_logger/* default.debug */.Z.debug("AC Results:", {
    fixed: {
      type: "Number",
      label: "Armor Class",
      value: results.maxValue,
    },
    base: results.actorBase,
    effects: results.effects,
    bonusEffects: bonusEffects,
    override: {
      flat: results.maxValue,
      calc: "flat",
      formula: "",
    },
    auto: {
      flat,
      calc,
      formula: "",
    },
  });

  this.raw.character.system.attributes.ac = {
    flat,
    calc,
    formula: "",
  };
  this.raw.character.effects = this.raw.character.effects.concat(bonusEffects);

  this.raw.character.flags.ddbimporter.acEffects = results.effects;
  this.raw.character.flags.ddbimporter.baseAC = results.actorBase;
  this.raw.character.flags.ddbimporter.autoAC = deepClone(this.raw.character.system.attributes.ac);
  this.raw.character.flags.ddbimporter.overrideAC = {
    flat: results.maxValue,
    calc: "flat",
    formula: "",
  };

};

;// CONCATENATED MODULE: ./src/parser/character/specialTraits.js



DDBCharacter/* default.prototype._setSpecialTraitFlags */.Z.prototype._setSpecialTraitFlags = function _setSpecialTraitFlags() {
  this.raw.character.flags.dnd5e = {
    powerfulBuild: false,
    savageAttacks: false,
    elvenAccuracy: false,
    halflingLucky: false,
    initiativeAdv: false,
    initiativeAlert: false,
    jackOfAllTrades: false,
    weaponCriticalThreshold: 20,
    observantFeat: false,
    remarkableAthlete: false,
    reliableTalent: false,
    diamondSoul: false,
    meleeCriticalDamageDice: 0,
    wildMagic: false,
    spellSniper: false,
  };

  // powerful build/equine build
  this.raw.character.flags.dnd5e.powerfulBuild = this.source.ddb.character.race.racialTraits.some(
    (trait) => trait.definition.name === "Equine Build" || trait.definition.name === "Powerful Build"
  );

  // savage attacks
  const savageAttacks = this.source.ddb.character.race.racialTraits.some(
    (trait) => trait.definition.name === "Savage Attacks"
  );
  this.raw.character.flags.dnd5e.savageAttacks = savageAttacks;
  if (savageAttacks) this.raw.character.flags.dnd5e.meleeCriticalDamageDice += 1;

  // halfling lucky
  this.raw.character.flags.dnd5e.halflingLucky = this.source.ddb.character.race.racialTraits.some(
    (trait) => trait.definition.name === "Lucky"
  );

  // elven accuracy
  this.raw.character.flags.dnd5e.elvenAccuracy = this.source.ddb.character.feats.some(
    (feat) => feat.definition.name === "Elven Accuracy"
  );

  // alert feat
  this.raw.character.flags.dnd5e.initiativeAlert = this.source.ddb.character.feats.some(
    (feat) => feat.definition.name === "Alert"
  );

  // advantage on initiative
  this.raw.character.flags.dnd5e.initiativeAdv
    = DDBHelper/* default.filterBaseModifiers */.Z.filterBaseModifiers(this.source.ddb, "advantage", "initiative").length > 0;

  // initiative half prof
  this.raw.character.flags.dnd5e.initiativeHalfProf
    = DDBHelper/* default.filterBaseModifiers */.Z.filterBaseModifiers(this.source.ddb, "half-proficiency", "initiative").length > 0;

  // observant
  this.raw.character.flags.dnd5e.observantFeat = this.source.ddb.character.feats.some(
    (feat) => feat.definition.name === "Observant"
  );

  // weapon critical threshold
  // fighter improved crit
  // remarkable athlete
  this.source.ddb.character.classes.forEach((cls) => {
    if (cls.subclassDefinition) {
      // Improved Critical
      const improvedCritical = cls.subclassDefinition.classFeatures.some(
        (feature) => feature.name === "Improved Critical" && cls.level >= feature.requiredLevel
      );
      const superiorCritical = cls.subclassDefinition.classFeatures.some(
        (feature) => feature.name === "Superior Critical" && cls.level >= feature.requiredLevel
      );

      if (superiorCritical) {
        this.raw.character.flags.dnd5e.weaponCriticalThreshold = 18;
      } else if (improvedCritical && this.raw.character.flags.dnd5e.weaponCriticalThreshold > 19) {
        this.raw.character.flags.dnd5e.weaponCriticalThreshold = 19;
      }

      // Remarkable Athlete
      this.raw.character.flags.dnd5e.remarkableAthlete = cls.subclassDefinition.classFeatures.some(
        (feature) => feature.name === "Remarkable Athlete" && cls.level >= feature.requiredLevel
      );

      // wild magic surge for 5e Helpers
      this.raw.character.flags.dnd5e.wildMagic = cls.subclassDefinition.classFeatures.some(
        (feature) => feature.name === "Wild Magic Surge" && cls.level >= feature.requiredLevel
      );
    }

    // Brutal Critical
    this.raw.character.flags.dnd5e.meleeCriticalDamageDice += cls.definition.classFeatures.filter(
      (feature) => feature.name === "Brutal Critical" && cls.level >= feature.requiredLevel
    ).length;

    // Diamond Soul
    this.raw.character.flags.dnd5e.diamondSoul = cls.definition.classFeatures.some(
      (feature) => feature.name === "Diamond Soul" && cls.level >= feature.requiredLevel
    );

    // Jack of All Trades
    this.raw.character.flags.dnd5e.jackOfAllTrades = cls.definition.classFeatures.some(
      (feature) => feature.name === "Jack of All Trades" && cls.level >= feature.requiredLevel
    );

    // Reliable Talent
    this.raw.character.flags.dnd5e.reliableTalent = cls.definition.classFeatures.some(
      (feature) => feature.name === "Reliable Talent" && cls.level >= feature.requiredLevel
    );
  });
};

;// CONCATENATED MODULE: ./src/parser/character/proficiencies.js





DDBCharacter/* default.prototype._getCustomProficiencies */.Z.prototype._getCustomProficiencies = function _getCustomProficiencies(type) {
  const profGroup = CONFIG.DDB.proficiencyGroups.find((group) => group.label == type);
  const profCharacterValues = this.source.ddb.character.characterValues.filter(
    (value) =>
      profGroup.customAdjustments.includes(parseInt(value.typeId))
      && profGroup.entityTypeIds.includes(parseInt(value.valueTypeId))
      && value.value == 3
  );
  const customProfs = CONFIG.DDB[type.toLowerCase()]
    .filter((prof) => profCharacterValues.some((value) => value.valueId == prof.id))
    .map((prof) => prof.name);

  return customProfs;
};

DDBCharacter/* default.prototype._getCoreProficiencies */.Z.prototype._getCoreProficiencies = function _getCoreProficiencies(includeItemEffects = false) {
  return DDBHelper/* default.filterBaseModifiers */.Z.filterBaseModifiers(this.source.ddb, "proficiency", null, null, includeItemEffects)
    .map((proficiency) => {
      return { name: proficiency.friendlySubtypeName };
    });
};


DDBCharacter/* default.prototype.getArmorProficiencies */.Z.prototype.getArmorProficiencies = function getArmorProficiencies(proficiencyArray) {
  let values = [];
  let custom = [];

  // lookup the characters's proficiencies in the DICT
  let allProficiencies = dictionary/* default.character.proficiencies.filter */.Z.character.proficiencies.filter((prof) => prof.type === "Armor");
  proficiencyArray.forEach((prof) => {
    if (prof.name === "Light Armor" && !values.includes("lgt")) {
      values.push("lgt");
    }
    if (prof.name === "Medium Armor" && !values.includes("med")) {
      values.push("med");
    }
    if (prof.name === "Heavy Armor" && !values.includes("hvy")) {
      values.push("hvy");
    }
    if (prof.name === "Shields" && !values.includes("shl")) {
      values.push("shl");
    }
    if (allProficiencies.find((p) => p.name === prof.name) !== undefined && !custom.includes(prof.name)) {
      custom.push(prof.name);
    }
  });

  if (this.source?.ddb) {
    // load custom proficiencies in characterValues
    const customProfs = this._getCustomProficiencies("Armor");
    custom = custom.concat(customProfs);
  }
  return {
    value: [...new Set(values)],
    custom: [...new Set(custom)].join(";"),
  };
};

//
// DND5E.toolProficiencies = {
// "art": "Artisan's Tools",
// "disg": "Disguise Kit",
// "forg": "Forgery Kit",
// "game": "Gaming Set",
// "herb": "Herbalism Kit",
// "music": "Musical Instrument",
// "navg": "Navigator's Tools",
// "pois": "Poisoner's Kit",
// "thief": "Thieves' Tools",
// "vehicle": "Vehicle (Land or Water)"
// };
//
DDBCharacter/* default.prototype.getToolProficiencies */.Z.prototype.getToolProficiencies = function getToolProficiencies(proficiencyArray) {
  let values = [];
  let custom = [];

  // lookup the characters's proficiencies in the DICT
  let allToolProficiencies = dictionary/* default.character.proficiencies.filter */.Z.character.proficiencies.filter((prof) => prof.type === "Tool")
    .map((prof) => {
      return prof;
    });

  proficiencyArray.forEach((prof) => {
    // Some have values we can match too in foundry, others have to be custom imported
    switch (prof.name) {
      default: {
        const allProfMatch = allToolProficiencies.find((allProf) => allProf.name === prof.name);
        if (allProfMatch && allProfMatch.baseTool && allProfMatch.baseTool !== "") {
          values.push(allProfMatch.baseTool);
        } else if (allProfMatch) {
          custom.push(prof.name);
        }
      }
    }
  });

  if (this.source?.ddb) {
    // Custom proficiencies!
    this.source.ddb.character.customProficiencies.forEach((proficiency) => {
      if (proficiency.type === 2) {
        // type 2 is TOOL, 1 is SKILL, 3 is LANGUAGE
        custom.push(proficiency.name);
      }
    });

    // load custom proficiencies in characterValues
    const customProfs = this._getCustomProficiencies("Tools");
    custom = custom.concat(customProfs);
  }

  return {
    value: [...new Set(values)],
    custom: [...new Set(custom)].join(";"),
  };
};

DDBCharacter/* default.prototype.getWeaponProficiencies */.Z.prototype.getWeaponProficiencies = function getWeaponProficiencies(proficiencyArray) {
  let values = [];
  let custom = [];

  // lookup the characters's proficiencies in the DICT
  const allProficiencies = dictionary/* default.character.proficiencies.filter */.Z.character.proficiencies.filter((prof) => prof.type === "Weapon");
  proficiencyArray.forEach((prof) => {
    if (prof.name === "Simple Weapons" && !values.includes("sim")) {
      values.push("sim");
    }
    if (prof.name === "Martial Weapons" && !values.includes("mar")) {
      values.push("mar");
    }
    // new  1.5
    const systemWeaponIds = CONFIG.DND5E.weaponIds;
    const dnd5eNameArray = prof.name.toLowerCase().split(",");
    const dnd5eName = dnd5eNameArray.length === 2
      ? `${dnd5eNameArray[1].trim()}${dnd5eNameArray[0].trim()}`
      : prof.name.toLowerCase();
    if (systemWeaponIds && dnd5eName in systemWeaponIds) {
      if (!values.includes(dnd5eName)) values.push(dnd5eName);
    } else if (allProficiencies.some((p) => p.name === prof.name) && !custom.includes(prof.name)) {
      custom.push(prof.name);
    }
  });

  if (this.source?.ddb) {
    // load custom proficiencies in characterValues
    const customProfs = this._getCustomProficiencies("Weapons");
    custom = custom.concat(customProfs);
  }

  return {
    value: [...new Set(values)],
    custom: [...new Set(custom)].join("; "),
  };
};

DDBCharacter/* default.prototype.getLanguagesFromModifiers */.Z.prototype.getLanguagesFromModifiers = function getLanguagesFromModifiers(modifiers) {
  let languages = [];
  let custom = [];

  modifiers
    .filter((mod) => mod.type === "language")
    .forEach((language) => {
      let result = dictionary/* default.character.languages.find */.Z.character.languages.find((lang) => lang.name === language.friendlySubtypeName);
      if (result) {
        languages.push(result.value);
      } else {
        custom.push(language.friendlySubtypeName);
      }
    });

  if (this.source?.ddb) {
    this.source.ddb.character.customProficiencies.forEach((proficiency) => {
      if (proficiency.type === 3) {
        // type 3 is LANGUAGE, 1 is SKILL, 2 is TOOL
        custom.push(proficiency.name);
      }
    });

    // load custom proficiencies in characterValues
    const customProfs = this._getCustomProficiencies("Languages");
    custom = custom.concat(customProfs);
  }

  return {
    value: languages,
    custom: custom.map((entry) => utils/* default.capitalize */.Z.capitalize(entry)).join(";"),
  };
};

DDBCharacter/* default.prototype._generateLanguages */.Z.prototype._generateLanguages = function _generateLanguages() {
  const modifiers = DDBHelper/* default.filterBaseModifiers */.Z.filterBaseModifiers(this.source.ddb, "language");
  this.raw.character.system.traits.languages = this.getLanguagesFromModifiers(modifiers);
};

DDBCharacter/* default.prototype._generateProficiencies */.Z.prototype._generateProficiencies = function _generateProficiencies() {
  const customProficiencies = [
    ...this._getCustomProficiencies("Armor"),
    ...this._getCustomProficiencies("Tools"),
    ...this._getCustomProficiencies("Weapons"),
    ...this._getCustomProficiencies("Languages"),
  ].map((proficiency) => {
    return { name: proficiency };
  });

  this.proficiencies = this._getCoreProficiencies(false).concat(customProficiencies);
  this.proficienciesIncludingEffects = this._getCoreProficiencies(true).concat(customProficiencies);

  this.raw.character.flags.ddbimporter.dndbeyond.proficiencies = this.proficiencies;
  this.raw.character.flags.ddbimporter.dndbeyond.proficienciesIncludingEffects = this.proficienciesIncludingEffects;

  this.raw.character.system.traits.weaponProf = this.getWeaponProficiencies(this.proficiencies);
  this.raw.character.system.traits.armorProf = this.getArmorProficiencies(this.proficiencies);
  this.raw.character.system.traits.toolProf = this.getToolProficiencies(this.proficiencies);
  this._generateLanguages();
};

// EXTERNAL MODULE: ./src/effects/effects.js + 1 modules
var effects_effects = __webpack_require__(5751);
;// CONCATENATED MODULE: ./src/parser/character/skills.js







DDBCharacter/* default.prototype._isHalfProficiencyRoundedUp */.Z.prototype._isHalfProficiencyRoundedUp = function _isHalfProficiencyRoundedUp (skill, modifiers = null) {
  const longAbility = dictionary/* default.character.abilities.filter */.Z.character.abilities.filter((ability) => skill.ability === ability.value)
    .map((ability) => ability.long)[0];

  const roundUp = (modifiers)
    ? DDBHelper/* default.filterModifiers */.Z.filterModifiers(modifiers, "half-proficiency-round-up", `${longAbility}-ability-checks`)
    : DDBHelper/* default.filterBaseModifiers */.Z.filterBaseModifiers(this.source?.ddb, "half-proficiency-round-up", `${longAbility}-ability-checks`, ["", null], true);
  return Array.isArray(roundUp) && roundUp.length;
};

DDBCharacter/* default.prototype.getSkillProficiency */.Z.prototype.getSkillProficiency = function getSkillProficiency (skill, modifiers = null) {
  if (!modifiers) {
    modifiers = [
      DDBHelper/* default.getChosenClassModifiers */.Z.getChosenClassModifiers(this.source.ddb, true),
      DDBHelper/* default.getModifiers */.Z.getModifiers(this.source.ddb, "race", true),
      DDBHelper/* default.getModifiers */.Z.getModifiers(this.source.ddb, "background", true),
      DDBHelper/* default.getModifiers */.Z.getModifiers(this.source.ddb, "feat", true),
      DDBHelper/* default.getActiveItemModifiers */.Z.getActiveItemModifiers(this.source.ddb, true),
    ].flat();
  }

  const skillMatches = modifiers
    .filter((modifier) => modifier.friendlySubtypeName === skill.label)
    .map((mod) => mod.type);

  const halfProficiency = modifiers.find(
    (modifier) =>
    // Jack of All trades/half-rounded down
      (modifier.type === "half-proficiency" && modifier.subType === "ability-checks")
        // e.g. champion for specific ability checks
        || this._isHalfProficiencyRoundedUp(skill, modifiers)
  ) !== undefined
    ? 0.5
    : 0;

  const proficient = skillMatches.includes("expertise") ? 2 : skillMatches.includes("proficiency") ? 1 : halfProficiency;

  return proficient;
};

DDBCharacter/* default.prototype.getCustomSkillProficiency */.Z.prototype.getCustomSkillProficiency = function getCustomSkillProficiency(skill) {
  // Overwrite the proficient value with any custom set over rides
  if (this.source.ddb.character.characterValues) {
    const customProficiency = this.source.ddb.character.characterValues.find(
      (value) => value.typeId === 26 && value.valueId == skill.valueId && value.value
    );
    if (customProficiency) {
      return dictionary/* default.character.customSkillProficiencies.find */.Z.character.customSkillProficiencies.find((prof) => prof.value === customProficiency.value)
        .proficient;
    }
  }
  return undefined;
};

DDBCharacter/* default.prototype.getCustomSkillAbility */.Z.prototype.getCustomSkillAbility = function getCustomSkillAbility(skill) {
  // Overwrite the proficient value with any custom set over rides
  let mod;
  if (this.source.ddb.character.characterValues) {
    const customAbility = this.source.ddb.character.characterValues.find(
      (value) => value.typeId === 27 && value.valueId == skill.valueId
    );
    if (customAbility) {
      const ability = dictionary/* default.character.abilities.find */.Z.character.abilities.find((ability) => ability.id == customAbility.value);
      if (ability)
        mod = ability.value;
    }
  }
  return mod;
};

DDBCharacter/* default.prototype.getCustomSkillBonus */.Z.prototype.getCustomSkillBonus = function getCustomSkillBonus(skill) {
  // Get any custom skill bonuses
  if (this.source.ddb.character.characterValues) {
    const customBonus = this.source.ddb.character.characterValues.filter(
      (value) => (value.typeId == 24 || value.typeId == 25) && value.valueId == skill.valueId
    ).reduce((total, bonus) => {
      return total + bonus.value;
    }, 0);

    if (customBonus) {
      return customBonus;
    }
  }
  return 0;
};

DDBCharacter/* default.prototype._setSpecialSkills */.Z.prototype._setSpecialSkills = function _setSpecialSkills() {
  this.source.ddb.character.classes.forEach((klass) => {
    if (klass.subclassDefinition) {
      const silverTongue = klass.subclassDefinition.classFeatures.some(
        (feature) => feature.name === "Silver Tongue" && klass.level >= feature.requiredLevel
      );
      if (silverTongue) {
        this.raw.character.system.skills["per"].bonuses.minimum = 10;
        this.raw.character.system.skills["dec"].bonuses.minimum = 10;
      }
    }
  });
};

DDBCharacter/* default.prototype._generateCustomSkills */.Z.prototype._generateCustomSkills = async function _generateCustomSkills() {
  if (!game.modules.get("dnd5e-custom-skills")?.active) return;
  const version = game.modules.get("dnd5e-custom-skills")?.version;
  const newEnough = foundry.utils.isNewerVersion(version, "1.1.2");
  if (!newEnough) return;

  const customSkillData = this.source.ddb.character.customProficiencies
    .filter((prof) => prof.type === 1 && Number.isInteger(prof.statId))
    .map((prof) => {
      const ability = dictionary/* default.character.abilities.find */.Z.character.abilities.find((ability) => ability.id == prof.statId);
      return {
        ability: ability.value,
        label: prof.name,
        proficiencyLevel: prof.proficiencyLevel,
        miscBonus: prof.miscBonus,
        magicBonus: prof.magicBonus,
        override: prof.override,
      };
    });

  const skillData = {};

  for (let i = 0; i < customSkillData.length; i++) {
    skillData[i] = customSkillData[i];
  }

  const customSkills = await window.dnd5eCustomSkills("add", { skills: skillData });

  for (const [key, value] of Object.entries(customSkills.skills.list)) {
    if (value.applied || value.applied === 1) {
      const customSkillMatch = customSkillData.find((customSkill) => customSkill.label === value.label);
      if (customSkillMatch) {
        src_logger/* default.debug */.Z.debug(`Adding custom skill ${value.label}`, { key, value, customSkillMatch });
        const prof = dictionary/* default.character.customSkillProficiencies.find */.Z.character.customSkillProficiencies.find((proficiency) =>
          proficiency.value === customSkillMatch.proficiencyLevel
        ).proficient;
        const miscBonus = customSkillMatch.miscBonus && customSkillMatch.miscBonus !== "" && customSkillMatch.miscBonus !== 0
          ? `+ ${customSkillMatch.miscBonus}`
          : "";
        const magicBonus = customSkillMatch.magicBonus && customSkillMatch.magicBonus !== "" && customSkillMatch.magicBonus !== 0
          ? ` + ${customSkillMatch.magicBonus}`
          : "";
        if (customSkillMatch) {
          this.raw.character.system.skills[key] = {
            type: "Number",
            label: value.label,
            ability: value.ability,
            value: prof,
            mod: utils/* default.calculateModifier */.Z.calculateModifier(value),
            bonus: 0,
            bonuses: {
              "check": `${(miscBonus + magicBonus).trim()}`,
              "passive": "",
              "minimum": null,
            },
          };
        }
      }
    }
  }
};

DDBCharacter/* default.prototype._generateSkills */.Z.prototype._generateSkills = async function _generateSkills() {
  const addEffects = game.modules.get("dae")?.active;

  if (!addEffects) this.raw.character.flags['skill-customization-5e'] = {};
  dictionary/* default.character.skills.forEach */.Z.character.skills.forEach((skill) => {
    const customProficient = this.getCustomSkillProficiency(skill);
    // we use !== undefined because the return value could be 0, which is falsey
    const proficient = customProficient !== undefined ? customProficient : this.getSkillProficiency(skill);

    // some abilities round half prof up, some down
    const proficiencyBonus = this._isHalfProficiencyRoundedUp(skill)
      ? Math.ceil(2 * this.raw.character.system.attributes.prof * proficient)
      : Math.floor(2 * this.raw.character.system.attributes.prof * proficient);

    // Skill bonuses
    const skillModifierBonus = DDBHelper/* default.filterBaseModifiers */.Z.filterBaseModifiers(this.source.ddb, "bonus", skill.subType)
      .map((skl) => skl.value)
      .reduce((a, b) => a + b, 0) ?? 0;
    const customSkillBonus = this.getCustomSkillBonus(skill);
    const skillBonus = skillModifierBonus + customSkillBonus;
    const value = this.raw.character.system.abilities[skill.ability].value + proficiencyBonus + skillBonus;
    const customAbility = this.getCustomSkillAbility(skill);
    const ability = customAbility !== undefined ? customAbility : skill.ability;

    // custom skill ability over ride effects
    if (customAbility) {
      const label = "Skill Ability Changes";
      const change = {
        key: `data.skills.${skill.name}.ability`,
        mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
        value: `${customAbility}`,
        priority: "20"
      };

      const changeIndex = this.raw.character.effects.findIndex((effect) => effect.label === label);
      if (changeIndex >= 0) {
        this.raw.character.effects[changeIndex].changes.push(change);
      } else {
        let skillEffect = (0,effects_effects/* generateBaseSkillEffect */.Tb)(this.source.ddb.character.id, label);
        skillEffect.changes.push(change);
        this.raw.character.effects.push(skillEffect);
      }
    }

    this.raw.character.system.skills[skill.name] = {
      type: "Number",
      label: skill.label,
      ability: ability,
      value: proficient,
      mod: utils/* default.calculateModifier */.Z.calculateModifier(value),
      bonus: 0,
      bonuses: {
        check: `${skillBonus}`,
        passive: "",
        minimum: null,
      },
    };
  });

  await this._generateCustomSkills();
  this._setSpecialSkills();

};

;// CONCATENATED MODULE: ./src/parser/character/abilities.js

// import logger from "../../logger.js";




DDBCharacter/* default.prototype._generateAbilitiesOverrides */.Z.prototype._generateAbilitiesOverrides = function _generateAbilitiesOverrides() {
  dictionary/* default.character.abilities.forEach */.Z.character.abilities.forEach((ability) => {
    this.abilities.overrides[ability.value]
      = this.source.ddb.character.overrideStats.find((stat) => stat.id === ability.id).value || 0;
  });
  this.raw.character.flags.ddbimporter.dndbeyond.abilityOverrides = this.abilities.overrides;
};

DDBCharacter/* default.prototype._getCustomSaveProficiency */.Z.prototype._getCustomSaveProficiency = function _getCustomSaveProficiency(ability) {
  // Overwrite the proficient value with any custom set over rides
  if (this.source.ddb.character.characterValues) {
    const customProficiency = this.source.ddb.character.characterValues.find(
      (value) => value.typeId === 41 && value.valueId == ability.id && value.value
    );
    if (customProficiency) {
      if (customProficiency.value === 1) {
        return 0;
      }
      // Foundry does not support half proficiencies or expertise here
      return 1;
    }
  }
  return undefined;
};

DDBCharacter/* default.prototype._getCustomSaveBonus */.Z.prototype._getCustomSaveBonus = function _getCustomSaveBonus(ability) {
  // Get any custom skill bonuses
  if (this.source.ddb.character.characterValues) {
    const customBonus = this.source.ddb.character.characterValues
      .filter((value) => (value.typeId == 40 || value.typeId == 39) && value.valueId == ability.id)
      .reduce((total, bonus) => {
        return total + bonus.value;
      }, 0);

    if (customBonus) {
      return customBonus;
    }
  }
  return 0;
};

/**
 * Retrieves character abilities, including proficiency on saving throws
 * @param {obj} includeExcludedEffects Include effects from dae added items?
 */
DDBCharacter/* default.prototype._getAbilities */.Z.prototype._getAbilities = function _getAbilities(includeExcludedEffects = false) {
  let result = {};
  dictionary/* default.character.abilities.forEach */.Z.character.abilities.forEach((ability) => {
    result[ability.value] = {
      value: 0,
      min: 3,
      max: 20,
      proficient: 0,
    };

    const stat = this.source.ddb.character.stats.find((stat) => stat.id === ability.id).value || 0;
    const abilityScoreMaxBonus = DDBHelper/* default.filterBaseModifiers */.Z.filterBaseModifiers(this.source.ddb, "bonus", "ability-score-maximum", [null, ""], includeExcludedEffects)
      .filter((mod) => mod.statId === ability.id)
      .reduce((prev, cur) => prev + cur.value, 0);
    const bonusStatRestrictions = [
      null,
      "",
      "+2 to score maximum",
      "+4 to score maximum",
      "+2 to maximum score",
      "+4 to maximum score",
      "Can't be an Ability Score you already increased with this trait.",
    ];
    const bonus = DDBHelper/* default.filterBaseModifiers */.Z.filterBaseModifiers(this.source.ddb, "bonus", `${ability.long}-score`, bonusStatRestrictions, includeExcludedEffects)
      .filter((mod) => mod.entityId === ability.id)
      .reduce((prev, cur) => prev + cur.value, 0);
    const setAbilities = DDBHelper/* default.filterBaseModifiers */.Z.filterBaseModifiers(this.source.ddb, "set", `${ability.long}-score`, [null, "", "if not already higher"], includeExcludedEffects)
      .map((mod) => mod.value);
    const modRestrictions = ["Your maximum is now ", "Maximum of "];
    const cappedBonusExp = new RegExp(`(?:${modRestrictions.join("|")})(\\d*)`);
    const cappedBonus = DDBHelper/* default.filterBaseModifiers */.Z.filterBaseModifiers(this.source.ddb, "bonus", `${ability.long}-score`, false, includeExcludedEffects)
      .filter(
        (mod) =>
          mod.entityId === ability.id
          && mod.restriction
          && modRestrictions.some((m) => mod.restriction.startsWith(m))
      )
      .reduce(
        (prev, cur) => {
          const restricted = cur.restriction ? cappedBonusExp.exec(cur.restriction) : undefined;
          const max = restricted ? restricted[1] : 20;
          return {
            value: prev.value + cur.value,
            cap: Math.max(prev.cap, max),
          };
        },
        { value: 0, cap: 20 + abilityScoreMaxBonus }
      );
    // applied regardless of cap
    const bonusStat = this.source.ddb.character.bonusStats.find((stat) => stat.id === ability.id).value || 0;
    // over rides all other calculations if present
    const overrideStat = this.source.ddb.character.overrideStats.find((stat) => stat.id === ability.id).value || 0;

    const setAbility = Math.max(...[0, ...setAbilities]);
    const calculatedStat = stat + bonus + cappedBonus.value;
    // bonus gets added regardlesss of normal caps
    const maxAdjustedStat = Math.min(cappedBonus.cap, calculatedStat) + bonusStat;
    // some items will set the ability score if lower
    const setAbilityState = maxAdjustedStat > setAbility ? maxAdjustedStat : setAbility;
    // Is there a hard over ride?
    const overRiddenStat = overrideStat === 0 ? setAbilityState : overrideStat;
    const customProficiency = this._getCustomSaveProficiency(ability);

    const proficient = customProficiency
      ? customProficiency
      : DDBHelper/* default.filterBaseModifiers */.Z.filterBaseModifiers(this.source.ddb, "proficiency", `${ability.long}-saving-throws`, [null, ""], includeExcludedEffects).length > 0
        ? 1
        : 0;

    // update value, mod and proficiency
    result[ability.value].value = overRiddenStat;
    result[ability.value].mod = utils/* default.calculateModifier */.Z.calculateModifier(result[ability.value].value);
    result[ability.value].proficient = proficient;
    result[ability.value].max = Math.max(cappedBonus.cap, overRiddenStat);
  });

  return result;
};

DDBCharacter/* default.prototype._getAbilitiesBonuses */.Z.prototype._getAbilitiesBonuses = function (includeExcludedEffects = false) {

  let result = {};
  dictionary/* default.character.abilities.forEach */.Z.character.abilities.forEach((ability) => {
    result[ability.value] = {
      bonuses: {
        check: "",
        save: "",
        checkMinimum: null,
        saveMinimum: null,
      },
    };

    const checkBonusModifiers = DDBHelper/* default.filterBaseModifiers */.Z.filterBaseModifiers(this.source.ddb, "bonus", `${ability.long}-ability-checks`, [null, ""], includeExcludedEffects);
    const checkBonus = DDBHelper/* default.getModifierSum */.Z.getModifierSum(checkBonusModifiers, this.raw.character);
    if (checkBonus && checkBonus !== "") {
      result[ability.value].bonuses.check = `+ ${checkBonus}`;
    }

    const saveBonusModifiers = DDBHelper/* default.filterBaseModifiers */.Z.filterBaseModifiers(this.source.ddb, "bonus", `${ability.long}-saving-throws`, [null, ""], includeExcludedEffects);
    const modifiersSaveBonus = DDBHelper/* default.getModifierSum */.Z.getModifierSum(saveBonusModifiers, this.raw.character);
    const customSaveBonus = this._getCustomSaveBonus(ability);

    if (modifiersSaveBonus && modifiersSaveBonus !== "" && parseInt(modifiersSaveBonus)) {
      if (customSaveBonus) {
        const totalSave = parseInt(customSaveBonus) + parseInt(modifiersSaveBonus);
        // console.warn("totalSave", totalSave);
        result[ability.value].bonuses.save = `+ ${totalSave}`;
      } else {
        result[ability.value].bonuses.save = `+ ${modifiersSaveBonus}`;
      }
    } else if (modifiersSaveBonus && modifiersSaveBonus !== "") {
      if (customSaveBonus) {
        result[ability.value].bonuses.save = `+ ${modifiersSaveBonus} + ${customSaveBonus}`;
      } else {
        result[ability.value].bonuses.save = `+ ${modifiersSaveBonus}`;
      }
    } else if (customSaveBonus) {
      result[ability.value].bonuses.save = `+ ${customSaveBonus}`;
    }
  });

  return result;
};

/**
 * Retrieves character abilities, including proficiency on saving throws
 * @param {obj} includeExcludedEffects Include effects from dae added items?
 */
DDBCharacter/* default.prototype._generateBaseAbilities */.Z.prototype._generateBaseAbilities = function (includeExcludedEffects = false) {
  this.raw.character.system.abilities = this._getAbilities(includeExcludedEffects);
};


/**
 * Generates character abilities, including proficiency on saving throws
 */
DDBCharacter/* default.prototype._generateAbilities */.Z.prototype._generateAbilities = function _generateAbilities() {
  // go through every ability

  // we need to populate some base abilities to work out bonuses
  this._generateBaseAbilities(false);

  this.abilities.core = mergeObject(this._getAbilities(false), this._getAbilitiesBonuses(false));
  this.abilities.withEffects = mergeObject(this._getAbilities(true), this._getAbilitiesBonuses(true));
  this.raw.character.system.abilities = this.abilities.core;
  this.raw.character.flags.ddbimporter.dndbeyond.effectAbilities = this.abilities.withEffects;

  this._generateAbilitiesOverrides();

};

;// CONCATENATED MODULE: ./src/parser/character/hp.js



DDBCharacter/* default.prototype._generateHitPoints */.Z.prototype._generateHitPoints = function _generateHitPoints() {
  const constitutionHP = this.raw.character.flags.ddbimporter.dndbeyond.effectAbilities.con.mod * this.raw.character.flags.ddbimporter.dndbeyond.totalLevels;
  const baseHitPoints = this.source.ddb.character.baseHitPoints || 0;
  const bonusHitPoints = this.source.ddb.character.bonusHitPoints || 0;
  const overrideHitPoints = this.source.ddb.character.overrideHitPoints || 0;
  const removedHitPoints = this.source.ddb.character.removedHitPoints || 0;
  const temporaryHitPoints = this.source.ddb.character.temporaryHitPoints || 0;

  // get all hit points features
  const bonusHitPointFeatures = DDBHelper/* default.filterBaseModifiers */.Z.filterBaseModifiers(this.source.ddb, "bonus", "hit-points-per-level");
  const bonusHitPointFeaturesWithEffects = DDBHelper/* default.filterBaseModifiers */.Z.filterBaseModifiers(this.source.ddb, "bonus", "hit-points-per-level", ["", null], true);

  // get their values
  const bonusHitPointValues = bonusHitPointFeatures.map((bonus) => {
    const cls = DDBHelper/* default.findClassByFeatureId */.Z.findClassByFeatureId(this.source.ddb, bonus.componentId);
    if (cls) {
      return cls.level * bonus.value;
    } else {
      return this.raw.character.flags.ddbimporter.dndbeyond.totalLevels * bonus.value;
    }
  });

  const bonusHitPointValuesWithEffects = bonusHitPointFeaturesWithEffects.map((bonus) => {
    const cls = DDBHelper/* default.findClassByFeatureId */.Z.findClassByFeatureId(this.source.ddb, bonus.componentId);
    if (cls) {
      return cls.level * bonus.value;
    } else {
      return this.raw.character.flags.ddbimporter.dndbeyond.totalLevels * bonus.value;
    }
  });

  // sum up the bonus HP per class level
  const totalBonusHitPoints = bonusHitPointValues.reduce((prev, cur) => prev + cur, 0);
  const totalBonusHPWithEffects = bonusHitPointValuesWithEffects.reduce((prev, cur) => prev + cur, 0);
  const bonusHPEffectDiff = totalBonusHPWithEffects - totalBonusHitPoints;

  // add the result to the base hitpoints
  // baseHitPoints += totalBonusHitPoints;

  const totalHitPoints = overrideHitPoints === 0
    ? constitutionHP + baseHitPoints + bonusHitPoints + totalBonusHitPoints
    : overrideHitPoints;

  this.raw.character.system.attributes.hp = {
    value: totalHitPoints - removedHitPoints + bonusHPEffectDiff,
    min: 0,
    max: totalHitPoints,
    temp: temporaryHitPoints,
    tempmax: bonusHitPoints,
  };
};

DDBCharacter/* default.prototype._generateHitDice */.Z.prototype._generateHitDice = function _generateHitDice() {
  const used = this.source.ddb.character.classes.reduce((prev, cls) => prev + cls.hitDiceUsed, 0);
  const total = this.source.ddb.character.classes.reduce((prev, cls) => prev + cls.level, 0);
  this.raw.character.system.attributes.hd = total - used;
};

;// CONCATENATED MODULE: ./src/parser/character/initiative.js



DDBCharacter/* default.prototype._generateInitiative */.Z.prototype._generateInitiative = function _generateInitiative() {
  const initMods = DDBHelper/* default.filterBaseModifiers */.Z.filterBaseModifiers(this.source.ddb, "bonus", "initiative");
  const initiativeBonus = DDBHelper/* default.getModifierSum */.Z.getModifierSum(initMods, this.raw.character);

  // If we have the alert Feat set, lets sub 5 so it's correct
  this.raw.character.system.attributes.init = this.raw.character.flags.dnd5e.initiativeAlert
    ? {
      ability: "dex",
      bonus: Number.isInteger(Number.parseInt(initiativeBonus)) ? Number.parseInt(initiativeBonus) - 5 : `${initiativeBonus} - 5`,
    }
    : {
      ability: "dex",
      bonus: Number.isInteger(Number.parseInt(initiativeBonus)) ? Number.parseInt(initiativeBonus) : initiativeBonus,
    };

};

;// CONCATENATED MODULE: ./src/parser/character/effects.js




DDBCharacter/* default.prototype._generateDeathSaves */.Z.prototype._generateDeathSaves = function _generateDeathSaves () {
  this.raw.character.system.attributes.death = {
    success: this.source.ddb.character.deathSaves.successCount || 0,
    failure: this.source.ddb.character.deathSaves.failCount || 0,
  };
};

DDBCharacter/* default.prototype._generateExhaustion */.Z.prototype._generateExhaustion = function _generateExhaustion() {
  const condition = this.source.ddb.character.conditions.find((condition) => parseInt(condition.id) === 4);
  this.raw.character.system.attributes.exhaustion = condition
    ? parseInt(condition.level)
    : 0;
};

DDBCharacter/* default.prototype.getGenericConditionAffect */.Z.prototype.getGenericConditionAffect = function getGenericConditionAffect(condition, typeId) {
  const damageTypes = dictionary/* default.character.damageAdjustments.filter */.Z.character.damageAdjustments.filter((type) => type.kind === condition && type.type === typeId)
    .map((type) => type.value);

  let result = DDBHelper/* default.filterBaseModifiers */.Z.filterBaseModifiers(this.source.ddb, condition)
    .filter((modifier) => modifier.isGranted && damageTypes.includes(modifier.subType)
      && (modifier.restriction === "" || !modifier.restriction))
    .map((modifier) => {
      const entry = dictionary/* default.character.damageAdjustments.find */.Z.character.damageAdjustments.find(
        (type) => type.type === typeId && type.kind === modifier.type && type.value === modifier.subType
      );
      return entry ? entry.foundryValue || entry.value : undefined;
    });

  result = result.concat(
    this.source.ddb.character.customDefenseAdjustments
      .filter((adjustment) => adjustment.type === typeId)
      .map((adjustment) => {
        const entry = dictionary/* default.character.damageAdjustments.find */.Z.character.damageAdjustments.find(
          (type) =>
            (type.id === adjustment.id || type.id === adjustment.adjustmentId)
            && type.type === adjustment.type
            && type.kind === condition
        );
        return entry ? entry.foundryValue || entry.value : undefined;
      })
      .filter((adjustment) => adjustment !== undefined)
  );

  return result;
};

DDBCharacter/* default.prototype._generateConditions */.Z.prototype._generateConditions = function _generateConditions() {
  this.raw.character.system.traits.di = {
    custom: "",
    value: this.getGenericConditionAffect("immunity", 2),
  };
  this.raw.character.system.traits.dr = {
    custom: "",
    value: this.getGenericConditionAffect("resistance", 2),
  };
  this.raw.character.system.traits.dv = {
    custom: "",
    value: this.getGenericConditionAffect("vulnerability", 2),
  };
  this.raw.character.system.traits.ci = {
    custom: "",
    value: this.getGenericConditionAffect("immunity", 1),
  };
};

;// CONCATENATED MODULE: ./src/parser/character/currency.js


DDBCharacter/* default.prototype._generateCurrency */.Z.prototype._generateCurrency = function _generateCurrency() {
  this.raw.character.system.currency = {
    pp: this.source.ddb.character.currencies.pp,
    gp: this.source.ddb.character.currencies.gp,
    ep: this.source.ddb.character.currencies.ep,
    sp: this.source.ddb.character.currencies.sp,
    cp: this.source.ddb.character.currencies.cp,
  };
};

;// CONCATENATED MODULE: ./src/parser/character/senses.js




DDBCharacter/* default.prototype.getSenses */.Z.prototype.getSenses = function getSenses() {
  let senses = {
    darkvision: 0,
    blindsight: 0,
    tremorsense: 0,
    truesight: 0,
    units: "ft",
    special: ""
  };

  // custom senses
  if (this.source.ddb.character.customSenses) {
    this.source.ddb.character.customSenses
      .filter((sense) => sense.distance)
      .forEach((sense) => {
        const s = dictionary/* default.character.senses.find */.Z.character.senses.find((s) => s.id === sense.senseId);
        if (s && sense.distance && Number.isInteger(sense.distance)) {
          senses[s.name.toLowerCase()] = parseInt(sense.distance);
        } else {
          senses.special += `${sense.distance}; `;
        }
      });
  }

  // Base senses
  for (const senseName in senses) {
    DDBHelper/* default.filterBaseModifiers */.Z.filterBaseModifiers(this.source.ddb, "set-base", senseName).forEach((sense) => {
      if (Number.isInteger(sense.value) && sense.value > senses[senseName]) {
        senses[senseName] = parseInt(sense.value);
      }
    });
  }

  // Devils Sight gives bright light to 120 foot instead of normal darkvision
  DDBHelper/* default.filterBaseModifiers */.Z.filterBaseModifiers(this.source.ddb, "set-base", "darkvision", [
      "You can see normally in darkness, both magical and nonmagical",
    ])
    .forEach((sense) => {
      if (Number.isInteger(sense.value) && sense.value > senses['darkvision']) {
        senses['darkvision'] = parseInt(sense.value);
        senses.special += "You can see normally in darkness, both magical and nonmagical.";
      }
    });

  // Magical bonuses and additional, e.g. Gloom Stalker
  DDBHelper/* default.filterBaseModifiers */.Z.filterBaseModifiers(this.source.ddb, "sense", "darkvision", ["", null, "plus 60 feet if wearer already has Darkvision"])
    .forEach((mod) => {
      const hasSense = mod.subType in senses;
      if (hasSense && mod.value && Number.isInteger(mod.value)) {
        senses[mod.subType] += parseInt(mod.value);
      } else {
        senses.special += ` ${mod.value},`;
      }
    });

  return senses;

};

DDBCharacter/* default.prototype._generateSenses */.Z.prototype._generateSenses = function _generateSenses() {
  this.raw.character.system.attributes.senses = this.getSenses();
};

;// CONCATENATED MODULE: ./src/parser/character/speed.js




DDBCharacter/* default.prototype._generateSpeed */.Z.prototype._generateSpeed = function _generateSpeed() {

  // For all processing, we take into account the regular movement types of this character
  let movementTypes = {};
  let setToWalking = {};
  for (const type in this.source.ddb.character.race.weightSpeeds.normal) {
    // if (data.character.race.weightSpeeds.normal[type] !== 0) {
    movementTypes[type] = this.source.ddb.character.race.weightSpeeds.normal[type];
    setToWalking[type] = false;
    // }
  }


  // get bonus speed mods
  let restriction = ["", null, "unless your speed is already higher"];
  // Check for equipped Heavy Armor
  const wearingHeavy = this.source.ddb.character.inventory.some((item) => item.equipped && item.definition.type === "Heavy Armor");
  // Accounts for Barbarian Class Feature - Fast Movement
  if (!wearingHeavy) restriction.push("while you arenâ€™t wearing heavy armor");

  // build base speeds
  for (let type in movementTypes) {
    // is there a 'inntate-speed-[type]ing' race/class modifier?
    const innateType = dictionary/* default.character.speeds.find */.Z.character.speeds.find((s) => s.type === type).innate;
    let innateSpeeds = this.source.ddb.character.modifiers.race.filter(
      (modifier) => modifier.type === "set" && modifier.subType === `innate-speed-${innateType}`
    );
    let base = movementTypes[type];

    innateSpeeds.forEach((speed) => {
      // take the highest value
      if (speed.value === null && speed.modifierSubTypeId == 182 && speed.modifierTypeId == 9) {
        setToWalking[type] = true;
      } else if (speed.value > base) {
        base = speed.value;
      }
    });

    // overwrite the (perhaps) changed value
    movementTypes[type] = base;
  }

  const bonusSpeed = DDBHelper/* default.filterBaseModifiers */.Z.filterBaseModifiers(this.source.ddb, "bonus", "speed", restriction)
    .reduce((speed, feat) => speed + feat.value, 0);

  // speed bonuses
  for (let type in movementTypes) {
    let innateBonus = DDBHelper/* default.filterBaseModifiers */.Z.filterBaseModifiers(this.source.ddb, "bonus", `speed-${type}ing`, restriction)
      .reduce((speed, feat) => speed + feat.value, 0);

    // overwrite the (perhaps) changed value
    if (movementTypes[type] !== 0) movementTypes[type] += bonusSpeed + innateBonus;
  }

  // unarmored movement for barbarians and monks
  if (this.isUnArmored()) {
    DDBHelper/* default.getChosenClassModifiers */.Z.getChosenClassModifiers(this.source.ddb)
      .filter((modifier) => modifier.type === "bonus" && modifier.subType === "unarmored-movement")
      .forEach((bonusSpeed) => {
        for (let type in movementTypes) {
          if (movementTypes[type] !== 0) movementTypes[type] += bonusSpeed.value;
        }
      });
  }

  // new ranger deft explorer sets speeds, leaves value null, use walking
  for (let type in movementTypes) {
    const innateType = dictionary/* default.character.speeds.find */.Z.character.speeds.find((s) => s.type === type).innate;
    // is there a 'inntate-speed-[type]ing' race/class modifier?
    let innateSpeeds = DDBHelper/* default.filterBaseModifiers */.Z.filterBaseModifiers(this.source.ddb, "set", `innate-speed-${innateType}`, restriction);
    let base = movementTypes[type];

    innateSpeeds.forEach((speed) => {
      // take the highest value
      if (speed.value > base) {
        base = speed.value;
      } else if (!speed.value && movementTypes['walk']) {
        base = movementTypes['walk'];
      }
    });

    // overwrite the (perhaps) changed value
    movementTypes[type] = base;
  }


  // is there a custom seed over-ride?
  if (this.source.ddb.character.customSpeeds) {
    this.source.ddb.character.customSpeeds.forEach((speed) => {
      const type = dictionary/* default.character.speeds.find */.Z.character.speeds.find((s) => s.id === speed.movementId).type;
      if (speed.distance) {
        movementTypes[type] = speed.distance;
      }
    });
  }

  for (let type in setToWalking) {
    if (setToWalking[type] && movementTypes["walk"] > movementTypes[type]) {
      movementTypes[type] = movementTypes["walk"];
    }
  }

  this.raw.character.system.attributes.movement = {
    burrow: movementTypes['burrow'] || 0,
    climb: movementTypes['climb'] || 0,
    fly: movementTypes['fly'] || 0,
    swim: movementTypes['swim'] || 0,
    walk: movementTypes['walk'] || 0,
    units: "ft",
    hover: false,
  };

};

// EXTERNAL MODULE: ./src/parser/character/bio.js
var bio = __webpack_require__(2331);
;// CONCATENATED MODULE: ./src/parser/character/size.js



DDBCharacter/* default.prototype._generateSize */.Z.prototype._generateSize = function _generateSize() {
  const size = dictionary/* default.character.actorSizes.find */.Z.character.actorSizes.find(
    (size) => size.name === this.source.ddb.character.race.size || size.id === this.source.ddb.character.race.sizeId
  );
  this.raw.character.system.traits.size = size ? size.value : "med";
};

;// CONCATENATED MODULE: ./src/parser/character/spellCasting.js




// is there a spell casting ability?
function hasSpellCastingAbility (spellCastingAbilityId) {
  return dictionary/* default.character.abilities.some */.Z.character.abilities.some((ability) => ability.id === spellCastingAbilityId);
};

// convert spellcasting ability id to string used by foundry
function convertSpellCastingAbilityId(spellCastingAbilityId) {
  return dictionary/* default.character.abilities.find */.Z.character.abilities.find((ability) => ability.id === spellCastingAbilityId).value;
};

function getSpellCastingAbility(klass) {
  let spellCastingAbility = undefined;
  if (hasSpellCastingAbility(klass.definition.spellCastingAbilityId)) {
    // check to see if class has a spell casting ability
    spellCastingAbility = convertSpellCastingAbilityId(klass.definition.spellCastingAbilityId);
  } else if (
    klass.subclassDefinition
    && hasSpellCastingAbility(klass.subclassDefinition.spellCastingAbilityId)
  ) {
    // some subclasses attach a spellcasting ability, e.g. Arcane Trickster
    spellCastingAbility = convertSpellCastingAbilityId(klass.subclassDefinition.spellCastingAbilityId);
  }
  return spellCastingAbility;
}

DDBCharacter/* default.prototype._generateSpellCasting */.Z.prototype._generateSpellCasting = function _generateSpellCasting() {
  let result = [];
  this.source.ddb.character.classSpells.forEach((playerClass) => {
    let classInfo = this.source.ddb.character.classes.find((cls) => cls.id === playerClass.characterClassId);
    const spellCastingAbility = getSpellCastingAbility(classInfo);
    if (spellCastingAbility !== undefined) {
      const characterAbilities = this.raw.character.flags.ddbimporter.dndbeyond.effectAbilities;
      let abilityModifier = utils/* default.calculateModifier */.Z.calculateModifier(characterAbilities[spellCastingAbility].value);
      result.push({ label: spellCastingAbility, value: abilityModifier });
    }
  });
  // we need to decide on one spellcasting ability, so we take the one with the highest modifier
  if (result.length === 0) {
    this.raw.character.system.attributes.spellcasting = "";
  } else {
    this.raw.character.system.attributes.spellcasting = result
      .sort((a, b) => {
        if (a.value > b.value) return -1;
        if (a.value < b.value) return 1;
        return 0;
      })
      .map((entry) => entry.label)[0];
  }
};

DDBCharacter/* default.prototype._generateSpellDC */.Z.prototype._generateSpellDC = function _generateSpellDC() {
  if (this.raw.character.system.attributes.spellcasting === "") {
    this.raw.character.system.attributes.spelldc = 10;
  } else {
    const characterAbilities = this.raw.character.flags.ddbimporter.dndbeyond.effectAbilities;
    const dc = 8 + characterAbilities[this.raw.character.system.attributes.spellcasting].mod + this.raw.character.system.attributes.prof;
    this.raw.character.system.attributes.spelldc = dc;
  }
};

DDBCharacter/* default.prototype.getCasterInfo */.Z.prototype.getCasterInfo = function getCasterInfo() {
  return this.source.ddb.character.classes
    .filter((cls) => {
      return cls.definition.canCastSpells || (cls.subclassDefinition && cls.subclassDefinition.canCastSpells);
    })
    .map((cls) => {
      // the class total level
      let casterLevel = cls.level;
      // class name
      const name = cls.definition.name;

      // get the casting level if the character is a multiclassed spellcaster
      if (cls.definition.spellRules && cls.definition.spellRules.multiClassSpellSlotDivisor) {
        casterLevel = Math.floor(casterLevel / cls.definition.spellRules.multiClassSpellSlotDivisor);
      } else {
        casterLevel = 0;
      }
      // Blood hunters are weird
      if (["Blood Hunter"].includes(name)) {
        casterLevel = cls.level;
      }

      const cantrips
        = cls.definition.spellRules
        && cls.definition.spellRules.levelCantripsKnownMaxes
        && Array.isArray(cls.definition.spellRules.levelCantripsKnownMaxes)
          ? cls.definition.spellRules.levelCantripsKnownMaxes[casterLevel + 1]
          : 0;

      if (["Warlock", "Blood Hunter"].includes(name)) {
        // pact casting doesn't count towards multiclass spells casting
        // we still add an entry to get cantrip info
        const levelSpellSlots = cls.definition.spellRules.levelSpellSlots[casterLevel];
        const maxLevel = levelSpellSlots.indexOf(Math.max(...levelSpellSlots)) + 1;
        const maxSlots = Math.max(...levelSpellSlots);
        const currentSlots = this.source.ddb.character.pactMagic.find((pact) => pact.level === maxLevel).used;
        if (["Blood Hunter"].includes(name)) {
          this.spellSlots.pact = { value: maxSlots - currentSlots, max: maxSlots, override: maxSlots };
        } else {
          this.spellSlots.pact = { value: maxSlots - currentSlots, max: maxSlots };
        }
        return {
          name,
          casterLevel: 0,
          slots: cls.definition.spellRules.levelSpellSlots[0],
          cantrips,
        };
      } else {
        return {
          name,
          casterLevel,
          slots: cls.definition.spellRules.levelSpellSlots[cls.level],
          cantrips,
        };
      }
    });
};

DDBCharacter/* default.prototype._generateSpellSlots */.Z.prototype._generateSpellSlots = function _generateSpellSlots() {
  // get the caster information from all classes and subclasses
  const casterInfo = this.getCasterInfo();

  let result = null;
  if (casterInfo.length !== 1) {
    const multiClassSpellSlots = [
      [0, 0, 0, 0, 0, 0, 0, 0, 0], // 0
      [2, 0, 0, 0, 0, 0, 0, 0, 0], // 1
      [3, 0, 0, 0, 0, 0, 0, 0, 0], // 2
      [4, 2, 0, 0, 0, 0, 0, 0, 0], // 3
      [4, 3, 0, 0, 0, 0, 0, 0, 0], // 4
      [4, 3, 2, 0, 0, 0, 0, 0, 0], // 5
      [4, 3, 3, 0, 0, 0, 0, 0, 0], // 6
      [4, 3, 3, 1, 0, 0, 0, 0, 0], // 7
      [4, 3, 3, 2, 0, 0, 0, 0, 0], // 8
      [4, 3, 3, 3, 1, 0, 0, 0, 0], // 9
      [4, 3, 3, 3, 2, 0, 0, 0, 0], // 10
      [4, 3, 3, 3, 2, 1, 0, 0, 0], // 11
      [4, 3, 3, 3, 2, 1, 0, 0, 0], // 12
      [4, 3, 3, 3, 2, 1, 1, 0, 0], // 13
      [4, 3, 3, 3, 2, 1, 1, 0, 0], // 14
      [4, 3, 3, 3, 2, 1, 1, 1, 0], // 15
      [4, 3, 3, 3, 2, 1, 1, 1, 0], // 16
      [4, 3, 3, 3, 2, 1, 1, 1, 1], // 17
      [4, 3, 3, 3, 3, 1, 1, 1, 1], // 18
      [4, 3, 3, 3, 3, 2, 1, 1, 1], // 19
      [4, 3, 3, 3, 3, 2, 2, 1, 1], // 20
    ];
    const casterLevelTotal = casterInfo.reduce((prev, cur) => prev + cur.casterLevel, 0);
    const cantripsTotal = casterInfo.reduce((prev, cur) => prev + cur.cantrips, 0);
    result = [cantripsTotal, ...multiClassSpellSlots[casterLevelTotal]];
  } else {
    result = [casterInfo[0].cantrips, ...casterInfo[0].slots];
  }

  for (let i = 0; i < result.length; i++) {
    const currentSlots = this.source.ddb.character.spellSlots.filter((slot) => slot.level === i).map((slot) => slot.used) || 0;
    this.spellSlots["spell" + i] = {
      value: result[i] - currentSlots,
      max: result[i],
    };
  }
  this.raw.character.system.spells = this.spellSlots;
};

DDBCharacter/* default.prototype._generateMaxPreparedSpells */.Z.prototype._generateMaxPreparedSpells = function _generateMaxPreparedSpells() {
  let max = 0;

  this.source.ddb.character.classes
    .filter((klass) => {
      return (klass.definition.canCastSpells || (klass.subclassDefinition?.canCastSpells));
    })
    .forEach((klass) => {
      const spellCastingAbility = getSpellCastingAbility(klass);
      if (spellCastingAbility !== undefined) {
        const characterAbilities = this.raw.character.flags.ddbimporter.dndbeyond.effectAbilities;
        const abilityModifier = utils/* default.calculateModifier */.Z.calculateModifier(characterAbilities[spellCastingAbility].value);
        if (klass.definition.spellPrepareType === 1 || klass.subclassDefinition?.spellPrepareType === 1) {
          max += abilityModifier + klass.level;
        } else if (klass.definition.spellPrepareType === 2 || klass.subclassDefinition?.spellPrepareType === 2) {
          max += abilityModifier + Math.floor(klass.level / 2);
        }

      }
    });

  this.raw.character.system.details.maxPreparedSpells = max;
};

// EXTERNAL MODULE: ./src/parser/race/DDBRace.js
var DDBRace = __webpack_require__(1434);
;// CONCATENATED MODULE: ./src/parser/character/race.js



DDBCharacter/* default.prototype._generateRace */.Z.prototype._generateRace = async function _generateRace() {
  const traits = this.source.ddb.character.race.racialTraits.map((r) => r.definition);
  const compendiumRacialTraits = await DDBRace/* default.getRacialTraitsLookup */.Z.getRacialTraitsLookup(traits, false);
  const race = new DDBRace/* default */.Z(this.source.ddb.character.race, compendiumRacialTraits);
  const builtRace = await race.buildRace();
  delete builtRace.sort;
  this.raw.race = builtRace;
};

;// CONCATENATED MODULE: ./src/parser/character/resources.js




DDBCharacter/* default.prototype.resourceList */.Z.prototype.resourceList = function resourceList() {
  const resources = [this.source.ddb.character.actions.race, this.source.ddb.character.actions.class, this.source.ddb.character.actions.feat]
    .flat()
    .filter((action) =>
      action.limitedUse
        && (action.limitedUse.maxUses || action.limitedUse.statModifierUsesId || action.limitedUse.useProficiencyBonus));

  return resources;
};

DDBCharacter/* default.prototype.getSortedByUsedResourceList */.Z.prototype.getSortedByUsedResourceList = function getSortedByUsedResourceList() {
  // get all resources
  const allResources = this.resourceList();
  const resources = allResources
    .map((action) => {
      let maxUses = (action.limitedUse.maxUses && action.limitedUse.maxUses !== -1) ? action.limitedUse.maxUses : 0;

      if (action.limitedUse.statModifierUsesId) {
        const ability = dictionary/* default.character.abilities.find */.Z.character.abilities.find(
          (ability) => ability.id === action.limitedUse.statModifierUsesId
        ).value;

        switch (action.limitedUse.operator) {
          case 2: {
            maxUses *= this.raw.character.flags.ddbimporter.dndbeyond.effectAbilities[ability].mod;
            break;
          }
          case 1:
          default:
            maxUses += this.raw.character.flags.ddbimporter.dndbeyond.effectAbilities[ability].mod;
        }
      }

      if (action.limitedUse.useProficiencyBonus) {
        switch (action.limitedUse.proficiencyBonusOperator) {
          case 2: {
            maxUses *= this.raw.character.system.attributes.prof;
            break;
          }
          case 1:
          default:
            maxUses += this.raw.character.system.attributes.prof;
        }
      }

      return {
        label: action.name,
        value: maxUses - action.limitedUse.numberUsed,
        max: maxUses,
        sr: action.limitedUse.resetType === 1,
        lr: action.limitedUse.resetType === 1 || action.limitedUse.resetType === 2 || action.limitedUse.resetType === 3,
      };
    })
    // sort by maxUses, I guess one wants to track the most uses first, because it's used more often
    .sort((a, b) => {
      if (a.max > b.max) return -1;
      if (a.max < b.max) return 1;
      return 0;
    });
  return resources;
};

const sheetResources = [
  "primary",
  "secondary",
  "tertiary",
  "fourth",
  "fifth",
  "sixth",
  "seventh",
  "eighth",
  "ninth",
  "tenth",
  "eleventh",
  "twelfth",
  "thirteenth",
  "fourteenth",
  "fifteenth",
  "sixteenth",
  "seventeenth",
  "eighteenth",
  "nineteenth",
  "twentieth",
];

DDBCharacter/* default.prototype._generateResources */.Z.prototype._generateResources = function _generateResources(numberOfResources = 3) {
  // get all resources
  const allResources = this.getSortedByUsedResourceList();

  let result = {};

  const resourceSelectionType = hasProperty(this.raw.character, "flags.ddbimporter.resources")
    ? getProperty(this.raw.character, "flags.ddbimporter.resources")
    : { type: "default" };

  switch (resourceSelectionType.type) {
    case "custom": {
      const customResourceSelection = getProperty(this.raw.character, "flags.ddbimporter.resources");
      for (let i = 0; i < sheetResources.length && i < numberOfResources; i++) {
        const resourceLookupName = customResourceSelection[sheetResources[i]];

        const resource = resourceLookupName && resourceLookupName !== ""
          ? allResources.find((r) => r.label === resourceLookupName)
          : { value: 0, max: 0, sr: false, lr: false, label: "" };
        result[sheetResources[i]] = resource || { value: 0, max: 0, sr: false, lr: false, label: "" };
      };
      break;
    }
    case "disable": {
      for (let i = 0; i < sheetResources.length && i < numberOfResources; i++) {
        result[sheetResources[i]] = { value: 0, max: 0, sr: false, lr: false, label: "" };
      };
      break;
    }
    default: {
      const usedResources = allResources.slice(0, numberOfResources);
      for (let i = 0; i < sheetResources.length && i < numberOfResources; i++) {
        const resource = usedResources.length > i ? usedResources[i] : { value: 0, max: 0, sr: false, lr: false, label: "" };
        result[sheetResources[i]] = resource;
      };
      break;
    }
  }

  this.raw.character.system.resources = result;
};

DDBCharacter/* default.prototype.getResourceList */.Z.prototype.getResourceList = function getResourceList() {
  return this.getSortedByUsedResourceList();
};

function generateResourceSelectionFromForm(formData, type) {
  const primary = formData.find((r) => r.name === "primary-select" && r.value !== "");
  const secondary = formData.find((r) => r.name === "secondary-select" && r.value !== "");
  const tertiary = formData.find((r) => r.name === "tertiary-select" && r.value !== "");
  const ask = formData.find((r) => r.name === "ask-resources")?.value === "on";

  const resourceSelection = {
    type: type,
    primary: type === "custom" && primary ? primary.value : "",
    secondary: type === "custom" && secondary ? secondary.value : "",
    tertiary: type === "custom" && tertiary ? tertiary.value : "",
    ask,
  };
  return resourceSelection;
}

DDBCharacter/* default.prototype.setResourceType */.Z.prototype.setResourceType = function setResourceType(resourceSelection) {
  setProperty(this.raw.character, "flags.ddbimporter.resources", resourceSelection);
  this._generateResources();
};

function setDefaultResources(sortedResources, resourceSelection) {
  if (sortedResources.length >= 1) {
    resourceSelection.primary = sortedResources[0].label;
  }
  if (sortedResources.length >= 2) {
    resourceSelection.secondary = sortedResources[1].label;
  }
  if (sortedResources.length >= 3) {
    resourceSelection.tertiary = sortedResources[2].label;
  }
  return resourceSelection;
}

// this.source.ddb, this.raw.character
DDBCharacter/* default.prototype.resourceSelectionDialog */.Z.prototype.resourceSelectionDialog = async function resourceSelectionDialog() {
  const currentActor = game.actors.get(this.currentActorId);
  return new Promise((resolve) => {
    let currentResourceSelection = hasProperty(currentActor, "flags.ddbimporter.resources.type")
      ? getProperty(currentActor, "flags.ddbimporter.resources")
      : {
        ask: true,
        type: "default",
        primary: "",
        secondary: "",
        tertiary: "",
      };

    const sortedResources = this.getSortedByUsedResourceList();

    if (currentResourceSelection.type === "default") {
      currentResourceSelection = setDefaultResources(sortedResources, currentResourceSelection);
    }

    if (currentResourceSelection.ask || !hasProperty(currentResourceSelection, "ask")) {
      const resources = sortedResources.map((resource) => {
        let resourceArray = [];
        if (resource.sr) resourceArray.push("SR");
        if (resource.lr) resourceArray.push("LR");
        if (!resource.sr && !resource.lr) resourceArray.push("Other");
        resource.resetString = resourceArray.join(", ");
        switch (resource.label) {
          case currentResourceSelection.primary:
            resource.primary = true;
            break;
          case currentResourceSelection.secondary:
            resource.secondary = true;
            break;
          case currentResourceSelection.tertiary:
            resource.tertiary = true;
            break;
          // no default
        }
        return resource;
      });

      const dialog = new Dialog({
        title: `Choose Resources for ${this.raw.character.name}`,
        content: {
          "resources": resources,
          "character": this.raw.character.name,
          "img": this.source.ddb.character.decorations?.avatarUrl
            ? this.source.ddb.character.decorations.avatarUrl
            : CONST.DEFAULT_TOKEN,
          "cssClass": "character-resource-selection sheet"
        },
        buttons: {
          default: {
            icon: '<i class="fas fa-list-ol"></i>',
            label: "Default",
            callback: async () => {
              const formData = $('.character-resource-selection').serializeArray();
              let resourceSelection = generateResourceSelectionFromForm(formData, "default");
              resourceSelection = setDefaultResources(resources, resourceSelection);
              this.setResourceType(resourceSelection);
              resolve(this.raw.character);
            }
          },
          custom: {
            icon: '<i class="fas fa-sort"></i>',
            label: "Use selected",
            callback: async () => {
              const formData = $('.character-resource-selection').serializeArray();
              const resourceSelection = generateResourceSelectionFromForm(formData, "custom");
              this.setResourceType(resourceSelection);
              resolve(this.raw.character);
            }
          },
          disable: {
            icon: '<i class="fas fa-times"></i>',
            label: "None",
            callback: async () => {
              const formData = $('.character-resource-selection').serializeArray();
              const resourceSelection = generateResourceSelectionFromForm(formData, "disable");
              this.setResourceType(resourceSelection);
              resolve(this.raw.character);
            }
          }
        },
        default: "default",
        close: () => resolve(this.raw.character),
      },
      {
        width: 400,
        classes: ["dialog", "character-resource-selection"],
        template: "modules/ddb-importer/handlebars/resources.hbs",
      });
      dialog.render(true);
    } else {
      this.setResourceType(currentResourceSelection);
      resolve(this.raw.character);
    }
  });
};

const resourceFeatureLinkMap = {
  "Channel Divinity": ["Channel Divinity:"],
  "Superiority Dice": ["Manoeuvres:", "Maneuvers:"],
  "Sorcery Points": ["Metamagic - ", "Metamagic:"],
  "Bardic Inspiration": [
    "Mote of Potential", "Unsettling Words", "Mantle of Inspiration",
    "Cutting Words", "Peerless Skill", "Tales from Beyond", "Blade Flourish",
    "Defensive Flourish", "Slashing Flourish", "Mobile Flourish",
    "Psychic Blades",
  ],
  "Wild Shape": ["Symbiotic Entity", "Starry Form", "Wild Companion", "Summon Wildfire Spirit"],
  "Grit Points": [
    "Trick Shots:", "Bullying Shot", "Dazing Shot", "Deadeye Shot", "Disarming Shot",
    "Forceful Shot", "Piercing Shot", "Violent Shot", "Winging Shot",
  ],
  "Psionic Power: Psionic Energy": [
    "Psionic Power: Psionic Strike", "Psionic Power: Protective Field", "Guarded Mind",
    "Psionic Power: Psi-Bolstered Knack", "Soul Blades: Homing Strikes", "Soul Blades: Psychic Teleportation",
    "Psionic Power: Recovery",
  ],
  "Ki Points": [
    "Ki-Fueled Attack", "Flurry of Blows", "Patient Defense", "Step of the Wind",
    "Deflect Missiles Attack", "Arms of the Astral Self: Summon", "Stunning Strike",
    "Empty Body", "Diamond Soul", "Visage of the Astral Self", "Quickened Healing",
    "Focused Aim", "Sharpen the Blade", "Deft Strike", "Shadow Arts",
    "Extort Truth", "Mind of Mercury", "Debilitating Barrage", "Tipsy Sway",
    "Drunkardâ€™s Luck", "Drunkard's Luck", "Touch of the Long Death",
    "Quivering Palm", "Radiant Sun Bolt", "Searing Arc Strike",
    "Breath of Winter", "Clench of the North Wind", "Eternal Mountain Defense",
    "Fangs of the Fire Snake", "Fist of Four Thunders", "Fist of Unbroken Air",
    "Flames of the Phoenix", "Gong of the Summit", "Mist Stance",
    "Ride the Wind", "River of Hungry Flame", "Rush of the Gale Spirits",
    "Shape the Flowing River", "Sweeping Cinder Strike", "Water Whip",
    "Wave of Rolling Earth", "Hand of Healing", "Hand of Harm", "Hand of Ultimate Mercy",
  ],
};

const resourceSpellLinkMap = {
  "Ki Points": [
    { name: "Astral Projection", cost: 8, lookupName: "Empty Body" },
    { name: "Darkness", cost: 2, lookupName: "Shadow Arts" },
    { name: "Darkvision", cost: 2, lookupName: "Shadow Arts" },
    { name: "Pass Without Trace", cost: 2, lookupName: "Shadow Arts" },
    { name: "Silence", cost: 2, lookupName: "Shadow Arts" },
    { name: "Burning Hands", cost: 2, lookupName: "Searing Arc Strike" },
    { name: "Cone of Cold", cost: 6, lookupName: "Breath of Winter" },
    { name: "Hold Person", cost: 3, lookupName: "Clench of the North Wind" },
    { name: "Stoneskin", cost: 5, lookupName: "Eternal Mountain Defense" },
    { name: "Thunderwave", cost: 2, lookupName: "Fist of Four Thunders" },
    { name: "Fireball", cost: 4, lookupName: "Flames of the Phoenix" },
    { name: "Shatter", cost: 3, lookupName: "Gong of the Summit" },
    { name: "Gaseous Form", cost: 4, lookupName: "Mist Stance" },
    { name: "Fly", cost: 4, lookupName: "Ride the Wind" },
    { name: "Wall of Fire", cost: 5, lookupName: "River of Hungry Flame" },
    { name: "Gust of Wind", cost: 2, lookupName: "Rush of the Gale Spirits" },
    { name: "Burning Hands", cost: 2, lookupName: "Sweeping Cinder Strike" },
    { name: "Wall of Stone", cost: 6, lookupName: "Wave of Rolling Earth" },
  ],
};

DDBCharacter/* default.prototype.autoLinkResources */.Z.prototype.autoLinkResources = async function autoLinkResources() {
  // loop over resourceFeatureLinkMap
  const possibleItems = this.currentActor.items.toObject();
  let toUpdate = [];

  for (const [key, values] of Object.entries(resourceFeatureLinkMap)) {
    src_logger/* default.debug */.Z.debug(`Checking ${key}`, values);
    const parent = possibleItems.find((doc) => {
      const name = doc.flags.ddbimporter?.originalName || doc.name;
      return name === key;
    });

    if (parent) {
      src_logger/* default.debug */.Z.debug("parent", parent);
      values.forEach((value) => {
        src_logger/* default.debug */.Z.debug(`Checking ${value}`);
        const children = possibleItems.filter((doc) => {
          const name = doc.flags.ddbimporter?.originalName || doc.name;
          return name.startsWith(value);
        });

        if (children) {
          src_logger/* default.debug */.Z.debug(`Found children`, children);
          children.forEach((child) => {
            if (getProperty(child, "flags.ddbimporter.retainResourceConsumption")) return;
            src_logger/* default.debug */.Z.debug("child", child);
            const update = {
              _id: child._id
            };
            const charge = getProperty(child, "system.consume.amount") ?? 1;
            setProperty(update, "system.consume", {
              type: "charges",
              target: parent._id,
              amount: charge,
            });
            toUpdate.push(update);
          });
        }
      });
    }
  }

  for (const [key, values] of Object.entries(resourceSpellLinkMap)) {
    src_logger/* default.debug */.Z.debug(`Checking ${key}`, values);
    const parent = possibleItems.find((doc) => {
      const name = doc.flags.ddbimporter?.originalName || doc.name;
      return name === key;
    });
    if (parent) {
      src_logger/* default.debug */.Z.debug("parent", parent);
      values.forEach((value) => {
        src_logger/* default.debug */.Z.debug(`Checking ${value.name}`, value);
        const child = possibleItems.find((doc) => {
          const name = doc.flags.ddbimporter?.originalName || doc.name;
          const lookupName = doc.flags.ddbimporter?.dndbeyond?.lookupName || "NO_LOOKUP_NAME";
          return name === value.name && value.lookupName === lookupName;
        });

        if (child) {
          if (getProperty(child, "flags.ddbimporter.retainResourceConsumption")) return;
          src_logger/* default.debug */.Z.debug("child", child);
          const update = {
            _id: child._id
          };
          setProperty(update, "system.consume", {
            type: "charges",
            target: parent._id,
            amount: value.cost,
          });
          toUpdate.push(update);
        }
      });
    }
  }

  src_logger/* default.debug */.Z.debug("toUpdate", toUpdate);

  const results = await this.currentActor.updateEmbeddedDocuments("Item", toUpdate);
  src_logger/* default.debug */.Z.debug("resource Update results", results);
};

// EXTERNAL MODULE: ./src/parser/spells/metadata.js
var metadata = __webpack_require__(6721);
// EXTERNAL MODULE: ./src/parser/spells/special.js
var special = __webpack_require__(1838);
// EXTERNAL MODULE: ./src/parser/spells/parseSpell.js + 12 modules
var parseSpell = __webpack_require__(1702);
// EXTERNAL MODULE: ./src/parser/spells/ability.js
var ability = __webpack_require__(2352);
;// CONCATENATED MODULE: ./src/parser/spells/getItemSpells.js
/* eslint-disable no-continue */


// Import parsing functions






async function getItemSpells(ddb, character) {
  let items = [];
  const proficiencyModifier = character.system.attributes.prof;
  const lookups = (0,metadata/* getLookups */.t)(ddb.character);

  // feat spells are handled slightly differently
  for (const spell of ddb.character.spells.item) {
    if (!spell.definition) continue;

    const itemInfo = lookups.item.find((it) => it.id === spell.componentId);
    if (!itemInfo) continue;

    const active
      = (!itemInfo.canEquip && !itemInfo.canAttune) // if item just gives a thing
      || itemInfo.isAttuned // if it is attuned (assume equipped)
      || (!itemInfo.canAttune && itemInfo.equipped); // can't attune but is equipped
    // for item spells the spell dc is often on the item spell
    let spellDC = 8;
    if (spell.overrideSaveDc) {
      spellDC = spell.overrideSaveDc;
    } else if (spell.spellCastingAbilityId) {
      // If the spell has an ability attached, use that
      // if there is no ability on spell, we default to wis
      let spellCastingAbility = "wis";
      if ((0,ability/* hasSpellCastingAbility */.eO)(spell.spellCastingAbilityId)) {
        spellCastingAbility = (0,ability/* convertSpellCastingAbilityId */.f5)(spell.spellCastingAbilityId);
      }

      const abilityModifier = utils/* default.calculateModifier */.Z.calculateModifier(character.flags.ddbimporter.dndbeyond.effectAbilities[spellCastingAbility].value);
      spellDC = 8 + proficiencyModifier + abilityModifier;
    } else {
      spellDC = null;
    }

    // add some data for the parsing of the spells into the data structure
    spell.flags = {
      ddbimporter: {
        dndbeyond: {
          lookup: "item",
          lookupName: itemInfo.name,
          lookupId: itemInfo.id,
          level: spell.castAtLevel,
          dc: spellDC,
          limitedUse: itemInfo.limitedUse,
          nameOverride: `${spell.definition.name} (${itemInfo.name})`,
          overrideDC: !!spell.overrideSaveDc,
          spellLimitedUse: spell.limitedUse,
          castAtLevel: spell.castAtLevel,
          active: active,
        },
      },
    };

    // eslint-disable-next-line no-await-in-loop
    items.push(await (0,parseSpell/* parseSpell */.T)(spell, character));
  }

  if (items) (0,special/* fixSpells */.F)(ddb, items);

  return items;
}

;// CONCATENATED MODULE: ./src/parser/character/inventory.js




DDBCharacter/* default.prototype._generateInventory */.Z.prototype._generateInventory = async function _generateInventory() {
  this.raw.itemSpells = await getItemSpells(this.source.ddb, this.raw.character);
  src_logger/* default.debug */.Z.debug("Item Spells parse complete");
  this.raw.inventory = await this.getInventory();
  src_logger/* default.debug */.Z.debug("Inventory parse complete");
};

;// CONCATENATED MODULE: ./src/parser/character/globalBonuses.js



/**
 * Gets global bonuses to attacks and damage
 * Supply a list of maps that have the fvtt tyoe and ddb sub type, e,g,
 * { fvttType: "attack", ddbSubType: "magic" }
  {
    "attack": "",
    "damage": "",
  },
 * @param {*} lookupTable
 */
DDBCharacter/* default.prototype.getGlobalBonusAttackModifiers */.Z.prototype.getGlobalBonusAttackModifiers = function(lookupTable) {
  let result = {
    attack: "",
    damage: "",
  };
  const diceFormula = /\d*d\d*/;

  let lookupResults = {
    attack: {
      sum: 0,
      diceString: "",
    },
    damage: {
      sum: 0,
      diceString: "",
    },
  };

  lookupTable.forEach((b) => {
    const lookupResult = DDBHelper/* default.getModifierSum */.Z.getModifierSum(DDBHelper/* default.filterBaseModifiers */.Z.filterBaseModifiers(this.source.ddb, "bonus", b.ddbSubType), this.raw.character);
    const lookupMatch = diceFormula.test(lookupResult);

    // if a match then a dice string
    if (lookupMatch || !Number.isInteger(parseInt(lookupResult))) {
      lookupResults[b.fvttType].diceString += lookupResult === "" ? lookupResult : " + " + lookupResult;
    } else {
      lookupResults[b.fvttType].sum += parseInt(lookupResult);
    }
  });

  // loop through outputs from lookups and build a response
  ["attack", "damage"].forEach((fvttType) => {
    if (lookupResults[fvttType].diceString === "") {
      if (lookupResults[fvttType].sum !== 0) {
        result[fvttType] = `${lookupResults[fvttType].sum}`;
      }
    } else {
      result[fvttType] = lookupResults[fvttType].diceString;
      if (lookupResults[fvttType].sum !== 0) {
        result[fvttType] += " + " + lookupResults[fvttType].sum;
      }
    }
  });

  return result;
};

/**
 * Gets global bonuses to spell attacks and damage
 * Most likely from items such as wand of the warmage
 * supply type as 'ranged' or 'melee'
  {
    "attack": "",
    "damage": "",
  },
 * @param {*} type
 */
DDBCharacter/* default.prototype.getBonusSpellAttacks */.Z.prototype.getBonusSpellAttacks = function(type) {
  // I haven't found any matching global spell damage boosting mods in ddb
  const bonusLookups = [
    { fvttType: "attack", ddbSubType: "spell-attacks" },
    { fvttType: "attack", ddbSubType: `${type}-spell-attacks` },
    { fvttType: "attack", ddbSubType: "warlock-spell-attacks" },
  ];

  return this.getGlobalBonusAttackModifiers(bonusLookups);
};

DDBCharacter/* default.prototype._generateBonusSpellAttacks */.Z.prototype._generateBonusSpellAttacks = function() {
  this.raw.character.system.bonuses.rsak = this.getBonusSpellAttacks("ranged");
  this.raw.character.system.bonuses.msak = this.getBonusSpellAttacks("melee");
};


/**
 * Gets global bonuses to weapon attacks and damage
 * Most likely from items such as wand of the warmage
 * supply type as 'ranged' or 'melee'
  {
    "attack": "",
    "damage": "",
  },
 * @param {*} type
 */
DDBCharacter/* default.prototype.getBonusWeaponAttacks */.Z.prototype.getBonusWeaponAttacks = function(type) {
  // global melee damage is not a ddb type, in that it's likely to be
  // type specific. The only class one I know of is the Paladin Improved Smite
  // which will be handled in the weapon import later.
  const bonusLookups = [
    { fvttType: "attack", ddbSubType: `${type}-attacks` },
    { fvttType: "attack", ddbSubType: "weapon-attacks" },
    { fvttType: "attack", ddbSubType: `${type}-weapon-attacks` },
  ];

  return this.getGlobalBonusAttackModifiers(bonusLookups);
};

DDBCharacter/* default.prototype._generateBonusWeaponAttacks */.Z.prototype._generateBonusWeaponAttacks = function() {
  this.raw.character.system.bonuses.mwak = this.getBonusWeaponAttacks("melee");
  this.raw.character.system.bonuses.rwak = this.getBonusWeaponAttacks("ranged");
};

/**
 * Gets global bonuses to ability checks, saves and skills
 * These can come from Paladin auras or items etc
  "abilities": {
    "check": "",
    "save": "",
    "skill": ""
  },
 * @param {*} this.raw.character
 */
DDBCharacter/* default.prototype._generateBonusAbilities */.Z.prototype._generateBonusAbilities = function() {
  let result = {
    "check": "",
    "save": "",
    "skill": "",
  };
  const bonusLookup = [
    { fvttType: "check", ddbSubType: "ability-checks" },
    { fvttType: "save", ddbSubType: "saving-throws" },
    { fvttType: "skill", ddbSubType: "skill-checks" },
  ];

  bonusLookup.forEach((b) => {
    const mods = DDBHelper/* default.filterBaseModifiers */.Z.filterBaseModifiers(this.source.ddb, "bonus", b.ddbSubType);
    const bonus = DDBHelper/* default.getModifierSum */.Z.getModifierSum(mods, this.raw.character);
    if (bonus !== 0 && bonus !== "") result[b.fvttType] = `+ ${bonus}`.trim().replace(/\+\s*\+/, "+");
  });
  this.raw.character.system.bonuses.abilities = result;
};

DDBCharacter/* default.prototype._generateBonusSpellDC */.Z.prototype._generateBonusSpellDC = function() {
  let result = {
    "dc": "",
  };
  const bonusLookup = [
    { fvttType: "dc", ddbSubType: "spell-save-dc" },
    { fvttType: "dc", ddbSubType: "warlock-spell-save-dc" },
  ];

  const bonus = bonusLookup.map((b) => {
    return DDBHelper/* default.getModifierSum */.Z.getModifierSum(DDBHelper/* default.filterBaseModifiers */.Z.filterBaseModifiers(this.source.ddb, "bonus", b.ddbSubType), this.raw.character);
  })
    .filter((b) => b && b !== 0 && String(b).trim() !== "")
    .reduce((previous, current) => {
      return previous !== "" ? [previous, current].join(" + ") : current;
    }, "");

  if (bonus && String(bonus).trim() !== "") {
    result["dc"] = bonus;
  }

  this.raw.character.system.bonuses.spell = result;
};

;// CONCATENATED MODULE: ./src/parser/special/additions/divineSmite.js
// import DICTIONARY from '../dictionary.js';



function getDivineSmiteSpell(feature) {
  const restriction = "Against undead or fiends";

  const damageTagInfo = DDBHelper/* default.getDamageTag */.Z.getDamageTag({ subType: "radiant", restriction: "" });
  const regularDamage = utils/* default.parseDiceString */.Z.parseDiceString("2d8", "", damageTagInfo.damageTag).diceString;
  const extraDamageTagInfo = DDBHelper/* default.getDamageTag */.Z.getDamageTag({ subType: "radiant", restriction });
  const extraDamage = utils/* default.parseDiceString */.Z.parseDiceString("1d8", "", extraDamageTagInfo.damageTag).diceString;

  let result = {
    flags: {},
    name: "Divine Smite",
    type: "spell",
    img: "icons/skills/melee/weapons-crossed-swords-yellow-teal.webp",
    system: {
      description: {
        value: feature.system.description.value,
        chat: "",
        unidentified: ""
      },
      source: "PHB PG. 85",
      activation: {
        type: "special",
        cost: null,
        condition: "",
      },
      duration: {
        value: null,
        units: "",
      },
      target: {
        value: 1,
        units: "",
        type: "enemy",
      },
      range: {
        value: null,
        long: null,
        units: "",
      },
      uses: {
        value: 0,
        max: 0,
        per: "",
      },
      consume: {
        type: "",
        target: "",
        amount: null,
      },
      ability: "",
      actionType: "other",
      attackBonus: 0,
      chatFlavor: "",
      critical: null,
      damage: {
        parts: [
          [`${regularDamage}`, "radiant"],
        ],
        versatile: "",
      },
      formula: "",
      save: {
        ability: "",
        dc: null,
        scaling: "spell",
      },
      level: 1,
      school: "",
      components: {
        value: "",
        vocal: false,
        somatic: false,
        material: false,
        ritual: false,
        concentration: false,
      },
      materials: {
        value: "",
        consumed: false,
        cost: 0,
        supply: 0,
      },
      preparation: {
        mode: "always",
        prepared: true,
      },
      scaling: {
        mode: "level",
        formula: "1d8",
      },
    },
  };

  result.system.formula = `${regularDamage} + ${extraDamage}`;
  result.system.chatFlavor = `Use Other damage ${restriction.toLowerCase()}`;
  if (game.modules.get("midi-qol")?.active) {
    result.system.activation.condition = `["undead", "fiend"].includes("@raceOrType")`;
  }

  return result;
}


;// CONCATENATED MODULE: ./src/parser/special/character.js



DDBCharacter/* default.prototype._addSpecialAdditions */.Z.prototype._addSpecialAdditions = function _addSpecialAdditions() {
  const checkList = this.data.features.concat(this.data.actions);
  const divineSmite = checkList.find((f) => f.name === "Divine Smite" && f.type === "feat");
  if (divineSmite) {
    this.data.spells.push(getDivineSmiteSpell(divineSmite));
  }
};

// EXTERNAL MODULE: ./src/lib/FileHelper.js
var FileHelper = __webpack_require__(2397);
;// CONCATENATED MODULE: ./src/parser/item/magicify.js
//
// Attempts to parse information from ddb about items to build a magicitems
// compatible set of metadata.
//
// https://gitlab.com/riccisi/foundryvtt-magic-items/
//
// Wand of Entangle Target example
//
// flags": {
// "magicitems": {
//       "enabled": true,
//       "charges": "7",
//       "chargeType": "c1",
//       "destroy": true,
//       "destroyCheck": "d1",
//       "rechargeable": true,
//       "recharge": "1d6+1",
//       "rechargeType": "t2",
//       "rechargeUnit": "r2",
//       "spells": {
//           "0": {
//               "id": "af8QUpphSZMoi2yb",
//               "name": "Entangle",
//               "pack": "world.spellsdndbeyond",
//               "img": "iconizer/Spell_Nature_StrangleVines.png",
//               "baseLevel": "1",
//               "level": "1",
//               "consumption": "1",
//               "upcast": "1",
//               "upcastCost": "1"
//           }
//       }
// "feats": {},
// "tables": {},
// "equipped": true,
// "attuned": true,
// "destroyFlavorText": "reaches 0 charges: it crumbles into ashes and is destroyed.",
// "sorting": "l"

// }
//
//
//



const MAGICITEMS = {
  DAILY: "r1",
  SHORT_REST: "r4",
  LONG_REST: "r5",
  CHARGE_TYPE_WHOLE_ITEM: "c1",
  CHARGE_TYPE_PER_SPELL: "c2",
  NUMERIC_RECHARGE: "t1",
  FORMULA_RECHARGE: "t2",
  DestroyCheckAlways: "d1",
  DestroyCheck1D20: "d2",
};


function getRechargeFormula(description, maxCharges) {
  if (description === "") {
    return `${maxCharges}`;
  }

  let chargeMatchFormula = /regains (\dd\d* \+ \d) expended charges/i;
  let chargeMatchFixed = /regains (\d*) /i;
  let chargeMatchLastDitch = /(\dd\d* \+ \d)/i;
  let chargeNextDawn = /can't be used this way again until the next/i;

  let matchFormula = chargeMatchFormula.exec(description);
  let matchFixed = chargeMatchFixed.exec(description);
  let matchLastDitch = chargeMatchLastDitch.exec(description);

  let match = maxCharges;
  if (matchFormula && matchFormula[1]) {
    match = matchFormula[1];
  } else if (matchFixed && matchFixed[1]) {
    match = matchFixed[1];
  } else if (matchLastDitch && matchLastDitch[1]) {
    match = matchLastDitch[1];
  } else if (description.search(chargeNextDawn) !== -1) {
    match = maxCharges;
  }

  return `${match}`;
}

function getPerSpell(useDescription, itemDescription) {
  if (useDescription === "") {
    // some times 1 use per day items, like circlet of blasting have nothing in
    // the limited use description, fall back to this
    let limitedUse = /can't be used this way again until the next/i;
    if (itemDescription.search(limitedUse) !== -1) {
      return 1;
    }
    return false;
  }

  let perSpell = /each ([A-z]*|\n*) per/i;
  let match = perSpell.exec(useDescription);
  if (match) {
    match = dictionary/* default.magicitems.nums.find */.Z.magicitems.nums.find((num) => num.id == match[1]).value;
  } else {
    match = false;
  }
  return match;
}

function checkDestroy(description) {
  let destroy = /expend the .* last charge/i;
  if (description.search(destroy) !== -1) {
    return true;
  } else {
    return false;
  }
}

function checkD20Destroy(description) {
  let destroy = /roll a d20.*destroyed/i;
  if (description.search(destroy) !== -1) {
    return MAGICITEMS.DestroyCheck1D20;
  } else {
    return MAGICITEMS.DestroyCheckAlways;
  }
}

// returns the default magicitem flags
function buildMagicItemSpell(chargeType, itemSpell) {
  let consumption = chargeType == MAGICITEMS.CHARGE_TYPE_PER_SPELL ? 1 : itemSpell.system.level;
  let castLevel = itemSpell.system.level;
  let upcast = itemSpell.system.level;

  // Do we have charge use data on spell?
  if (itemSpell.flags.ddbimporter.dndbeyond.spellLimitedUse) {
    const limitedUse = itemSpell.flags.ddbimporter.dndbeyond.spellLimitedUse;

    if (
      chargeType == MAGICITEMS.CHARGE_TYPE_WHOLE_ITEM
      && !!limitedUse.minNumberConsumed
      && itemSpell.system.level !== 0
    ) {
      consumption = limitedUse.minNumberConsumed;
      if (limitedUse.maxNumberConsumed) {
        upcast = itemSpell.system.level - limitedUse.minNumberConsumed + limitedUse.maxNumberConsumed;
      }
    }

    if (itemSpell.flags.ddbimporter.dndbeyond.castAtLevel) {
      castLevel = itemSpell.flags.ddbimporter.dndbeyond.castAtLevel;
    }
  }
  const spellName = hasProperty(itemSpell, "flags.ddbimporter.originalName")
    ? itemSpell.flags.ddbimporter.originalName
    : itemSpell.name;

  return {
    id: "",
    name: spellName,
    img: "",
    pack: "",
    baseLevel: itemSpell.system.level,
    level: castLevel,
    consumption,
    upcast,
    upcastCost: 1,
  };
}

function getMagicItemSpells(itemId, chargeType, itemSpells) {
  let spells = {};

  for (let spellIndex = 0, i = 0; i < itemSpells.length; i++) {
    if (itemSpells[i].flags.ddbimporter.dndbeyond.lookupId === itemId) {
      spells[spellIndex] = buildMagicItemSpell(chargeType, itemSpells[i]);
      spellIndex++;
    }
  }

  return spells;
}

function createDefaultMagicItemFlags() {
  return {
    enabled: true,
    charges: 0,
    chargeType: MAGICITEMS.CHARGE_TYPE_WHOLE_ITEM, // c1 charge whole item, c2 charge per spells
    rechargeable: false,
    recharge: "0", // recharge amount/formula
    rechargeType: MAGICITEMS.FORMULA_RECHARGE, // t1 fixed amount, t2 formula
    rechargeUnit: "", // r1 daily, r2 dawn, r3 sunset, r4vshort rest, r5 long rest
    destroy: false, // destroy on depleted?
    destroyCheck: MAGICITEMS.DestroyCheckAlways, // d1 always, 1d20
    spells: {},
    feats: {},
    tables: {},
    equipped: true,
    attuned: false,
    destroyFlavorText: game.modules.get("magicitems")?.active
      ? game.i18n.localize("MAGICITEMS.MagicItemDestroy")
      : "reaches 0 charges: it crumbles into ashes and is destroyed.",
    sorting: "l"
  };
}

function capitalize(word) {
  return word.charAt(0).toUpperCase() + word.slice(1);
}

function getMagicItemResetType(description) {
  let resetType = null;

  const chargeMatchFormula = /expended charges (?:\w) at (\w)/i;
  const usedAgainFormula = /(?:until|when) you (?:take|finish) a (short|long|short or long) rest/i;
  const chargeNextDawnFormula = /can't be used this way again until the next (dawn|dusk)/i;

  const chargeMatch = chargeMatchFormula.exec(description);
  const untilMatch = usedAgainFormula.exec(description);
  const dawnMatch = chargeNextDawnFormula.exec(description);

  if (chargeMatch && chargeMatch[1]) {
    resetType = capitalize(`${chargeMatch[1]}Rest`);
  } else if (untilMatch && untilMatch[1]) {
    switch (untilMatch[1]) {
      case "short or long":
        resetType = "ShortRest";
        break;
      default:
        resetType = capitalize(`${untilMatch[1]}Rest`);
    }
  } else if (dawnMatch && dawnMatch[1]) {
    resetType = capitalize(`${dawnMatch[1]}Rest`);
  }

  return resetType;
}


function parseMagicItemsModule(data, itemSpells, characterItem) {
  // this builds metadata for the magicitems module to use
  // https://gitlab.com/riccisi/foundryvtt-magic-items/

  if (data.definition.magic) {
    // default magicitem data
    let magicItem = createDefaultMagicItemFlags();
    magicItem.equipped = data.definition.canEquip;

    if (!characterItem) {
      const maxUses = "has (\\d*) charges";
      const maxUsesMatches = maxUses.exec(data.definition.description);
      const limitedUse = {
        maxUses: (maxUsesMatches && maxUsesMatches[1]) ? maxUsesMatches[1] : null,
        numberUsed: 0,
        resetType: getMagicItemResetType(data.definition.description),
        resetTypeDescription: data.definition.description,
      };

      if (limitedUse.maxUses || limitedUse.resetType) data.limitedUse = limitedUse;
    }

    if (data.limitedUse) {
      // if the item is x per spell
      const perSpell = getPerSpell(data.limitedUse.resetTypeDescription, data.definition.description);
      if (perSpell) {
        magicItem.charges = perSpell;
        magicItem.recharge = `${perSpell}`;
        magicItem.rechargeUnit = MAGICITEMS.DAILY;
        magicItem.rechargeable = true;
        magicItem.rechargeType = MAGICITEMS.NUMERIC_RECHARGE;
        magicItem.chargeType = MAGICITEMS.CHARGE_TYPE_PER_SPELL;
      } else {
        magicItem.charges = data.limitedUse.maxUses;
        magicItem.recharge = getRechargeFormula(data.limitedUse.resetTypeDescription, magicItem.charges);

        if (data.limitedUse.resetType) {
          magicItem.rechargeUnit = dictionary/* default.magicitems.rechargeUnits.find */.Z.magicitems.rechargeUnits.find(
            (reset) => reset.id == data.limitedUse.resetType
          ).value;
        }
        magicItem.rechargeable = true;
      }

      magicItem.destroy = checkDestroy(data.limitedUse.resetTypeDescription);
      magicItem.destroyCheck = checkD20Destroy(data.limitedUse.resetTypeDescription);
    }

    magicItem.spells = getMagicItemSpells(data.definition.id, magicItem.chargeType, itemSpells);

    return magicItem;
  } else {
    return {
      enabled: false,
    };
  }
}

function parseItemsWithSpellsModule(item, data, itemSpells, characterItem) {

  if (!characterItem) {
    src_logger/* default.debug */.Z.debug("Non character item magic item additions are not supported");
  }

  const thisItemSpells = itemSpells.filter((spell) =>
    spell.flags.ddbimporter.dndbeyond.lookup === "item"
    && spell.flags.ddbimporter.dndbeyond.lookupId === item.flags.ddbimporter.definitionId
  );

  if (thisItemSpells.length === 0) return item;

  const perSpell = getPerSpell(data.limitedUse?.resetTypeDescription ?? "", data.definition.description);

  const iSpells = thisItemSpells.map((itemSpell) => {
    const isPerSpell = Number.isInteger(perSpell);
    const chargeType = isPerSpell
      ? MAGICITEMS.CHARGE_TYPE_PER_SPELL
      : MAGICITEMS.CHARGE_TYPE_WHOLE_ITEM;

    // c1 charge whole item, c2 charge per spells
    const spellData = buildMagicItemSpell(chargeType, itemSpell);

    const resetType = data.limitedUse?.resetType
      ? dictionary/* default.magicitems.rechargeUnits.find */.Z.magicitems.rechargeUnits.find((reset) => reset.id == data.limitedUse.resetType).value
      : undefined;

    const uses = isPerSpell
      ? { max: spellData.charges, per: resetType ?? "" }
      : { max: "", per: "" };
    const consume = isPerSpell
      ? { amount: null }
      : { amount: spellData.consumption };

    const save = getProperty(itemSpell, "flags.ddbimporter.dndbeyond.overrideDC")
      ? { scaling: "flat", dc: itemSpell.flags.ddbimporter.dndbeyond?.dc }
      : { scaling: "spell" };
    const preparation = isPerSpell
      ? { mode: "atwill" }
      : undefined;

    return {
      uuid: "",
      changes: {
        system: {
          level: Number.parseInt(spellData.level),
          uses,
          consume,
          save,
          preparation,
        },
      },
      flags: {
        ddbimporter: {
          spellName: spellData.name,
        },
        // "items-with-spells-5e": {
        //   "parent-item": "",
        // },
      },
    };
  });

  item.flags["items-with-spells-5e"] = {
    "item-spells": iSpells,
  };
  return item;
}

function parseMagicItem(item, data, itemSpells, characterItem = true) {
  if (game.modules.get("magicitems")?.active) {
    item.flags.magicitems = parseMagicItemsModule(data, itemSpells, characterItem);
  } else if (game.modules.get("items-with-spells-5e")?.active) {
    item = parseItemsWithSpellsModule(item, data, itemSpells, characterItem);
  }
  return item;
}


;// CONCATENATED MODULE: ./src/parser/item/special.js
// import DICTIONARY from "../../dictionary.js";
// import logger from "../../logger.js";

function prepItem(item) {
  if (item.name.startsWith("Potion of")) {
    if (!item.system.duration) item.system.duration = { units: "", value: null };
    if (!item.system.target) item.system.target = { value: null, width: null, units: "", type: "creature" };
    if (!item.system.range) item.system.range = { value: null, long: null, units: "", type: "touch" };
  } else if (item.name.startsWith("Vicious")) {
    setProperty(item, "data.critical", { damage: "+ 7", threshold: null });
  }
}

/**
 * Some items we need to fix up or massage because they are modified
 * in interesting ways
 * @param {*} ddb
 * @param {*} items
 */
function fixItems(items) {
  items.forEach((item) => {
    prepItem(item);
    const name = item.flags.ddbimporter.originalName || item.name;
    switch (name) {
      case "Potion of Healing":
        item.system.damage = { parts: [["2d4 + 2", "healing"]], versatile: "", value: "" };
        item.system.uses = { value: 1, max: 1, per: "charges", autoDestroy: true, autoUse: true };
        item.system["duration"]["value"] = 0;
        item.system.actionType = "heal";
        item.system["target"]["type"] = "creature";
        item.system["range"]["type"] = "touch";
        break;
      case "Potion of Healing (Greater)":
      case "Potion of Greater Healing":
        item.system.damage = { parts: [["4d4 + 4", "healing"]], versatile: "", value: "" };
        item.system.uses = { value: 1, max: 1, per: "charges", autoDestroy: true, autoUse: true };
        item.system["duration"]["value"] = 0;
        item.system.actionType = "heal";
        item.system["target"]["type"] = "creature";
        item.system["range"]["type"] = "touch";
        item.flags["ddbimporter"]["dndbeyond"]["alternativeNames"] = ["Potion of Greater Healing"];
        break;
      case "Potion of Healing (Superior)":
      case "Potion of Superior Healing":
        item.system.damage = { parts: [["8d4 + 8", "healing"]], versatile: "", value: "" };
        item.system.uses = { value: 1, max: 1, per: "charges", autoDestroy: true, autoUse: true };
        item.system["duration"]["value"] = 0;
        item.system.actionType = "heal";
        item.system["target"]["type"] = "creature";
        item.system["range"]["type"] = "touch";
        item.flags["ddbimporter"]["dndbeyond"]["alternativeNames"] = [
          "Potion of Superior Healing",
          "potion of superior healing",
        ];
        break;
      case "Potion of Healing (Supreme)":
      case "Potion of Supreme Healing":
        item.system.damage = { parts: [["10d4 + 20", "healing"]], versatile: "", value: "" };
        item.system.uses = { value: 1, max: 1, per: "charges", autoDestroy: true, autoUse: true };
        item.system["duration"]["value"] = 0;
        item.system.actionType = "heal";
        item.system["target"]["type"] = "creature";
        item.system["range"]["type"] = "touch";
        item.flags["ddbimporter"]["dndbeyond"]["alternativeNames"] = ["Potion of Supreme Healing"];
        break;
      case "Iron Bands of Binding":
        item.system.activation = { type: "action", cost: 1, condition: "" };
        item.system.uses = { value: 1, max: "1", per: "day" };
        item.system.range = { value: 60, long: null, units: "ft" };
        item.system.ability = "dex";
        item.system.actionType = "rwak";
        item.system.save = { ability: "str", dc: 20, scaling: "flat" };
        item.system.target = { value: 1, width: null, units: "any", type: "creature" };
        break;
      case "Far Realm Shard": {
        item.system.activation.type = "special";
        item.system.actionType = "save";
        item.system.damage = { parts: [["3d6[psychic]", "psychic"]], versatile: "", value: "" };
        item.system.save = {
          ability: "cha",
          dc: null,
          scaling: "spell",
        };
        break;
      }
      case "Acid (vial)": {
        item.system.activation = { type: "action", cost: 1, condition: "" };
        item.system.target = { value: 1, width: null, units: "any", type: "creature" };
        item.system.range = { value: 20, long: null, units: "ft" };
        item.system.ability = "dex";
        item.system.actionType = "rwak";
        item.system.chatFlavor = "improvised weapon";
        item.system.damage = { parts: [["2d6[acid]", "acid"]], versatile: "", value: "" };
        break;
      }
      case "Bead of Force": {
        item.system.activation = { type: "action", cost: 1, condition: "" };
        item.system.target = { value: 10, width: null, units: "ft", type: "radius" };
        item.system.range = { value: 60, long: null, units: "ft" };
        item.system.ability = "dex";
        item.system.duration = { units: "minute", value: 1 };
        item.system.uses = { value: 1, max: "1", per: "" };
        item.system.actionType = "rwak";
        item.system.chatFlavor = "improvised weapon";
        item.system.damage = { parts: [["5d4[force]", "force"]], versatile: "", value: "" };
        item.system.save = {
          ability: "dex",
          dc: 15,
          scaling: "flat",
        };
        break;
      }
      case "Alchemist's Fire (flask)":
      case "Alchemist's Fire": {
        item.system.activation = { type: "action", cost: 1, condition: "" };
        item.system.target = { value: 1, width: null, units: "any", type: "creature" };
        item.system.range = { value: 20, long: null, units: "ft" };
        item.system.ability = "dex";
        item.system.actionType = "rwak";
        item.system.chatFlavor = "improvised weapon";
        item.system.damage = { parts: [["1d4[fire]", "fire"]], versatile: "", value: "" };
        item.system.save = {
          ability: "dex",
          dc: 10,
          scaling: "flat",
        };
        break;
      }
      case "Bomb": {
        item.type = "consumable";
        item.system.activation = { type: "action", cost: 1, condition: "" };
        item.system.target = { value: 5, width: null, units: "ft", type: "radius" };
        item.system.range = { value: 60, long: null, units: "ft" };
        item.system.ability = "dex";
        item.system.actionType = "rwak";
        item.system.chatFlavor = "improvised weapon";
        item.system.damage = { parts: [["3d6[fire]", "fire"]], versatile: "", value: "" };
        item.system.save = {
          ability: "dex",
          dc: 12,
          scaling: "flat",
        };
        break;
      }
      case "Grenade, Fragmentation": {
        item.type = "consumable";
        item.system.activation = { type: "action", cost: 1, condition: "" };
        item.system.target = { value: 20, width: null, units: "ft", type: "radius" };
        item.system.range = { value: 60, long: null, units: "ft" };
        item.system.ability = "dex";
        item.system.actionType = "rwak";
        item.system.chatFlavor = "improvised weapon";
        item.system.damage = { parts: [["5d6[piercing]", "piercing"]], versatile: "", value: "" };
        item.system.save = {
          ability: "dex",
          dc: 15,
          scaling: "flat",
        };
        break;
      }
      // no default
    }
  });
}

// EXTERNAL MODULE: ./src/parser/item/infusions.js
var infusions = __webpack_require__(7336);
// EXTERNAL MODULE: ./src/effects/macros.js
var macros = __webpack_require__(3752);
;// CONCATENATED MODULE: ./src/effects/restrictions.js




async function woundingWeaponEffect(document) {
  let effect = (0,effects_effects/* baseItemEffect */.uT)(document, document.name);

  effect.transfer = false;
  effect.flags.dae.macroRepeat = "startEveryTurn";
  effect.flags.dae.stackable = "count";
  effect.flags.dae.transfer = false;
  effect.duration = {
    startTime: null,
    seconds: null,
    rounds: 400,
    turns: null,
    startRound: null,
    startTurn: null,
  };

  const itemMacroText = await (0,macros/* loadMacroFile */.dp)("item", "wounding.js");
  document.flags["itemacro"] = (0,macros/* generateItemMacroFlag */.gL)(document, itemMacroText);
  effect.changes.push((0,macros/* generateMacroChange */.n4)());
  document.effects.push(effect);

  return document;
}

async function lifeStealingEffect(document) {
  let effect = (0,effects_effects/* baseItemEffect */.uT)(document, document.name);
  const itemMacroText = await (0,macros/* loadMacroFile */.dp)("item", "lifeStealing.js");
  document.flags["itemacro"] = (0,macros/* generateItemMacroFlag */.gL)(document, itemMacroText);
  setProperty(document, "flags.midi-qol.onUseMacroName", "[postActiveEffects]ItemMacro");
  document.effects.push(effect);
  return document;
}

const RESTRICTION_MAPPINGS = [
  {
    // name: "Extra Critical",
    ddb: ["20 on the Attack Roll"],
    restriction: `@workflow.diceRoll === 20`,
  },
  {
    name: "of Life Stealing",
    ddb: ["20 on the Attack Roll, Not Construct or Undead"],
    restriction: `@workflow.diceRoll === 20 && !(["construct", "undead"].includes("@raceOrType"))`,
    effect: true,
    effectFunction: lifeStealingEffect,
  },
  {
    name: "Bloodaxe",
    ddb: ["to creatures that arenâ€™t constructs or undead"],
    restriction: `!(["construct", "undead"].includes("@raceOrType"))`,
  },
  {
    // name: "Plants",
    ddb: ["against a plant (an ordinary plant or a creature with the Plant type) or a wooden object that isnâ€™t being worn or carried"],
    restriction: `["plant"].includes("@raceOrType")`
  },
  //  "Javelin of Lightning"
  {
    name: "Javelin of Lightning",
    ddb: ["On Hit or DC 13 Dexterity Save for Half Damage"],
    restriction: ``,
    save: true,
    macro: true,
  },
  {
    name: "Zariel",
    ddb: ["3d10 radiant if youâ€™re wielding the weapon with two hands"],
    restriction: ``,
  },
  {
    // name: "Undead",
    ddb: [
      "Against Undead Targets",
      "Against undead targets.",
      "(Against undead)",
      "An undead creature hit by the weapon takes an extra 1d8 radiant damage."
    ],
    restriction: `["undead"].includes("@raceOrType")`,
  },
  {
    // name: "Dragon",
    ddb: ["When you hit a dragon with this weapon"],
    restriction: `["dragon"].includes("@raceOrType")`,
  },
  {
    name: "of Wounding",
    ddb: ["Per Wound, DC 15 Constitution Save Ends Effect"],
    restriction: "",
    effect: true,
    effectFunction: woundingWeaponEffect,
  },
  {
    name: "Markovia",
    ddb: ["Against Fiends or Undead", "Against a fiend or an undead"],
    restriction: `["fiend", "undead"].includes("@raceOrType")`,
  },
  {
    name: "Riteknife",
    ddb: ["For each soul imprisoned in the dagger"],
    restriction: `false`,
  },
  {
    name: "Oathbow",
    ddb: ["Against Sworn Enemy"],
    restriction: `false`,
  },
  {
    name: "Matalotok",
    ddb: ["30-foot-radius sphere"],
    restriction: `false`,
  },
  {
    name: "Mastix",
    ddb: ["regain hit points equal to half the amount of necrotic damage dealt"],
    restriction: "",
    macro: true,
  },
  {
    name: "Mace of Disruption",
    ddb: ["Special"],
    nameMatch: "Mace of Disruption",
    restriction: `["fiend", "undead"].includes("@raceOrType")`,
  },
  {
    name: "Gurt",
    ddb: ["plus an extra 2d12 slashing damage if the target is human"],
    restriction: `["human"].includes("@raceOrType")`,
  },
  {
    name: "Grovelthrash",
    ddb: ["If you do, you take 1d6 psychic damage"],
    restriction: `false`,
  },
  {
    // name: "Giants",
    ddb: ["Against Giants"],
    restriction: `["giant"].includes("@raceOrType")`,
  },
  {
    name: "Flame Tongue",
    ddb: ["While Flaming"],
    restriction: "",
  },
  {
    name: "Dwarven Thrower",
    ddb: ["On hit with a ranged attack against Giants", "When Thrown (+2d8 against Giants)"],
    restriction: `["giant"].includes("@raceOrType")`,
  },
  {
    name: "Dragon's Wrath",
    ddb: [
      "On a hit, the weapon deals an extra damage of the type dealt by the dragonâ€™s breath weapon. (Wakened)",
      "On a hit, the weapon deals an extra damage of the type dealt by the dragonâ€™s breath weapon. (Stirring)",
      "On a hit, the weapon deals an extra damage of the type dealt by the dragonâ€™s breath weapon. (Ascendant)",

    ],
    restriction: ``,
  },
  {
    name: "Dagger of Venom",
    ddb: ["DC 15 Constitution Save Negates"],
    restriction: `false`,
  },
  {
    name: "Yagas Pestle",
    ddb: ["Per Charge (Max 3)"],
    restriction: `false`,
  },
];

async function addRestrictionFlags(document) {

  if (!game.modules.get("midi-qol")?.active) return document;
  const restrictions = getProperty(document, "flags.ddbimporter.dndbeyond.restrictions");
  if (!restrictions || restrictions.length == 0) return document;
  const name = document.flags.ddbimporter.originalName || document.name;

  const nameMatch = RESTRICTION_MAPPINGS.find((r) => {
    return r.name && name.toLowerCase()[0].includes(r.name.toLowerCase());
  });
  const restriction = nameMatch
    ? nameMatch
    : RESTRICTION_MAPPINGS.find((r) => {
      return r.ddb.map((m) => m.toLowerCase())[0].includes(restrictions[0].toLowerCase());
    });

  if (restriction) {
    let restrictionText = restriction.restriction;

    if (document.system.attunement > 0 && !["", "false"].includes(restriction.restriction)) {
      restrictionText += ` && @item.attunement !== 1`;
    }
    setProperty(document, "system.activation.condition", restrictionText);
    if (restriction.effectRestrictionACtivation) {
      setProperty(document, "flags.midi-qol.effectActivation", true);
    }

    if (restriction.effect) {
      document = await restriction.effectFunction(document);
    }
  }

  // effects needed for:
  // mace of disruption
  // oathbow
  // sharpness - needs light effect
  // sunswords
  // "Javelin of Lightning"
  // dwarven thrower
  // axe of dwarfish lords

  return document;
}

// EXTERNAL MODULE: ./src/effects/specialEquipment.js + 5 modules
var specialEquipment = __webpack_require__(2340);
// EXTERNAL MODULE: ./src/muncher/table.js + 2 modules
var table = __webpack_require__(7967);
;// CONCATENATED MODULE: ./src/parser/item/itemCollections.js
// this function enriches a bunch of items for the item collection module
// the actual moving of items to containers is done after the actor is imported
// this just adds some needed flags to the items
function fixForItemCollections(ddb, items) {
  const isItemCollectionsInstalled = game.modules.get("itemcollection")?.active;

  if (!isItemCollectionsInstalled) return items;

  items.forEach((item) => {
    if (getProperty(item, "flags.ddbimporter.dndbeyond.isContainer") === true) {
      item.type = "backpack";
    }
    if (item.type === "backpack") {
      setProperty(item, "flags.itemcollection.bagWeight", item.system.weight);
      setProperty(item, "flags.itemcollection.bagPrice", item.system.cost);
      setProperty(item, "flags.core.sheetClass", "dnd5e.ItemSheet5eWithBags");
    }
    if (hasProperty(item, "flags.ddbimporter.id")
      && hasProperty(item, "flags.ddbimporter.containerEntityId")
      && item.flags.ddbimporter.containerEntityId === ddb.character.id
    ) {
      setProperty(item, "flags.itemcollection.contentsData", []);
    }
  });

  return items;
}


// EXTERNAL MODULE: ./src/lib/DDBTemplateStrings.js
var DDBTemplateStrings = __webpack_require__(258);
;// CONCATENATED MODULE: ./src/parser/item/common.js



function getDescription(data) {
  const chatSnippet = data.definition.snippet ? data.definition.snippet : "";
  const chatAdd = game.settings.get("ddb-importer", "add-description-to-chat");

  const attunementText = data.definition.canAttune && data.definition.attunementDescription && data.definition.attunementDescription !== ""
    ? `<div class="item-attunement"><i>Requires attunement by a ${data.definition.attunementDescription}</i></div>`
    : "";

  return {
    value: (0,DDBTemplateStrings/* parseTags */.RN)(data.definition.description + attunementText),
    chat: chatAdd ? (0,DDBTemplateStrings/* parseTags */.RN)(chatSnippet) : "",
    unidentified: data.definition.type,
  };
}

function getItemRarity(data) {
  const tmpRarity = data.definition.rarity;
  const isMundaneItem = data.definition?.rarity === "Common" && !data.definition.magic;
  const rarity = data.definition.rarity && !isMundaneItem
    ? tmpRarity.charAt(0).toLowerCase() + tmpRarity.slice(1).replace(/\s/g, "")
    : "";
  return rarity;
}

/**
 * Checks if the character can attune to an item and if yes, if he is attuned to it.
 */
function getAttuned(data) {
  if (data.definition.canAttune !== undefined && data.definition.canAttune === true) {
    return data.isAttuned;
  } else {
    return false;
  }
}

/**
 * Checks if the character can equip an item and if yes, if he is has it currently equipped.
 */
function getEquipped(data) {
  if (data.definition.canEquip !== undefined && data.definition.canEquip === true) {
    return data.equipped;
  } else {
    return false;
  }
}

/**
 * Gets Limited uses information, if any
 * uses: { value: 0, max: 0, per: null }
 */
function getUses(data) {
  if (data.limitedUse !== undefined && data.limitedUse !== null) {
    let resetType = dictionary/* default.resets.find */.Z.resets.find((reset) => reset.id == data.limitedUse.resetType);
    return {
      max: data.limitedUse.maxUses,
      value: data.limitedUse.numberUsed
        ? data.limitedUse.maxUses - data.limitedUse.numberUsed
        : data.limitedUse.maxUses,
      per: resetType ? resetType.value : "",
      description: data.limitedUse.resetTypeDescription,
    };
  } else {
    return { value: 0, max: 0, per: null };
  }
}

function getConsumableUses(data) {
  if (data.limitedUse) {
    let uses = getUses(data);
    if (uses.per === "") uses.per = "charges";
    uses.autoUse = false;
    uses.autoDestroy = true;
    return uses;
  } else {
    // default
    return { value: 1, max: 1, per: "charges", autoUse: false, autoDestroy: true };
  }
}

/**
 * Checks the proficiency of the character with this specific weapon
 * @param {obj} data Item data
 * @param {string} weaponType The DND5E weaponType
 * @param {array} proficiencies The character's proficiencies as an array of `{ name: 'PROFICIENCYNAME' }` objects
 */
function getWeaponProficient(data, weaponType, proficiencies) {
  // if it's a simple weapon and the character is proficient in simple weapons:
  if (
    proficiencies.find((proficiency) => proficiency.name === "Simple Weapons")
    && weaponType.indexOf("simple") !== -1
  ) {
    return true;
  } else if (
    proficiencies.find((proficiency) => proficiency.name === "Martial Weapons")
    && weaponType.indexOf("martial") !== -1
  ) {
    return true;
  } else {
    const proficient = proficiencies.some((proficiency) => proficiency.name.toLowerCase() === data.definition.type.toLowerCase());
    return proficient;
  }
};

/**
 * Searches for a magical attack bonus granted by this weapon
 * @param {obj} data item data
 */
function getMagicalBonus(data) {
  let boni = data.definition.grantedModifiers.filter(
    (mod) => mod.type === "bonus" && mod.subType === "magic" && mod.value && mod.value !== 0
  );
  let bonus = boni.reduce((prev, cur) => prev + cur.value, 0);
  return bonus;
}

function getAttunement(item) {
  if (item.isAttuned) {
    return 2;
  } else if (item.definition.canAttune) {
    return 1;
  } else {
    return 0;
  }
}

function getBaseItem(data) {
  let baseItem = "";
  let toolType = "";

  if (data.definition.filterType === "Weapon") {
    baseItem = data.definition.type.toLowerCase().split(",").reverse().join("").replace(/\s/g, "");
  } else if (data.definition.filterType === "Armor" && data.definition.baseArmorName) {
    baseItem = data.definition.baseArmorName.toLowerCase().split(",").reverse().join("").replace(/\s/g, "");
  } else if (data.definition.filterType === "Other Gear"
    && ((data.definition.gearTypeId === 1 && data.definition.subType === "Tool")
      || (data.definition.gearTypeId === 11))) {
    const toolProficiencies = dictionary/* default.character.proficiencies.filter */.Z.character.proficiencies.filter((prof) => prof.type === "Tool")
      .map((prof) => {
        return prof;
      });

    const baseTool = toolProficiencies.find((allProf) => allProf.name.toLowerCase() === data.definition.name.toLowerCase());
    if (baseTool && baseTool.baseTool && baseTool.baseTool !== "") {
      baseItem = baseTool.baseTool;
      toolType = baseTool.toolType;
    }
  } else if (data.definition.filterType === "Staff") {
    baseItem = "quarterstaff";
  }


  return { baseItem, toolType };
}

function getQuantity(data) {
  return data.definition.quantity
    ? data.definition.quantity
    : data.quantity
      ? data.quantity
      : 1;
}

function getSingleItemWeight(data) {
  const bundleSize = data.definition?.bundleSize ? data.definition.bundleSize : 1;
  const totalWeight = data.definition?.weight ? data.definition.weight : 0;
  const weight = totalWeight / bundleSize;
  return weight;
}

function getCapacity(data) {

  const capacity = (data.definition.capacityWeight !== null)
    ? {
      "type": "weight",
      "value": data.definition.capacityWeight,
      "weightless": data.definition.weightMultiplier === 0,
    }
    : {};

  return capacity;
}

;// CONCATENATED MODULE: ./src/parser/item/weapon.js





/**
 * Gets the DND5E weapontype (simpleM, martialR etc.) as string
 * Supported Types only: Simple/Martial Melee/Ranged and Ammunition (Firearms in D&DBeyond)
 * @param {obj} data item data
 */
function getWeaponType(data) {
  const type = dictionary/* default.weapon.weaponType.find */.Z.weapon.weaponType.find(
    (type) => type.categoryId === data.definition.categoryId
  );
  const range = dictionary/* default.weapon.weaponRange.find */.Z.weapon.weaponRange.find(
    (type) => type.attackType === data.definition.attackType
  );

  if (type && range) {
    return `${type.value}${range.value}`;
  } else {
    return "simpleM";
  }
}

/**
 * Gets the weapons's properties (Finesse, Reach, Heavy etc.)
 * @param {obj} data Item data
 */
function getProperties(data) {
  let result = {};
  dictionary/* default.weapon.properties.forEach */.Z.weapon.properties.forEach((property) => {
    if (data.definition.properties && Array.isArray(data.definition.properties)) {
      result[property.value] = data.definition.properties.some((prop) => prop.name === property.name);
    }
    if (
      !result[property.value]
      && data.definition.grantedModifiers
      && Array.isArray(data.definition.grantedModifiers)
    ) {
      result[property.value] = data.definition.grantedModifiers.some(
        (prop) => prop.type === "weapon-property" && prop.friendlySubtypeName === property.name
      );
    }
  });
  return result;
}

/**
 * Gets the range(s) of a given weapon
 */
function getRange(data, weaponProperties) {
  // range: { value: null, long: null, units: '' },
  // sometimes reach weapons have their range set as 5. it's not clear why.
  const shortRange = data.definition.range ? data.definition.range : 5;
  const reach = weaponProperties.rch && data.definition.range == 5 ? 5 : 0;
  return {
    value: shortRange + reach,
    long: (data.definition.longRange && data.definition.longRange != data.definition.range)
      ? data.definition.longRange + reach
      : "",
    units: "ft",
  };
};

/**
 * Gets the ability which the to hit modifier is baed on
 * Melee: STR
 * Ranged: DEX
 * Finesse: STR || DEX
 * Thrown: STR, unless Finesse, then STR || DEX
 * @param {obj} data item data
 * @param {obj} weaponProperties weapon properties
 * @param {obj} weaponRange weapon range information
 * @param {obj} abilities character abilities (scores)
 */
function getAbility(weaponProperties, weaponRange) {
  // finesse weapons can choose freely, so we choose the higher one
  if (weaponProperties.fin) {
    return null;
  }

  // thrown, but not finesse weapon: STR
  if (weaponProperties.thr) {
    return "str";
  }

  // if it's a ranged weapon, and not a reach weapon (long = 10 (?))
  if (weaponRange.long > 5 && !weaponProperties.rch) {
    return "dex";
  }
  // the default is STR
  return null;
}

/**
 * Searches for a magical attack bonus granted by this weapon
 * @param {obj} data item data
 * @param {obj} flags
 */
function getWeaponMagicalBonus(data, flags) {
  const bonus = getMagicalBonus(data);
  if (flags.classFeatures.includes("Improved Pact Weapon") && bonus === 0) {
    return 1;
  } else {
    return bonus;
  }
};

/**
 *
 * @param {obj} data item data
 * @param {obj} flags
 * /* damage: { parts: [], versatile: '' }, * /
 */
function getDamage(data, flags) {
  const magicalDamageBonus = getWeaponMagicalBonus(data, flags);
  // we can safely make these assumptions about GWF and Dueling because the
  // flags are only added for melee attacks
  const greatWeaponFighting = flags.classFeatures.includes("greatWeaponFighting") ? "r<=2" : "";
  const offHand = flags.classFeatures.includes("OffHand");
  const twoWeapon = flags.classFeatures.includes("Two-Weapon Fighting");
  const twoHanded = data.definition.properties.find((property) => property.name === "Two-Handed");
  const melee = data.definition.attackType === 1;
  const dueling = flags.classFeatures.includes("Dueling") && !twoHanded && melee ? " + 2" : "";
  const mod = (offHand && !twoWeapon) ? "" : " + @mod";

  const baseDamageTagData = DDBHelper/* default.getDamageTagForItem */.Z.getDamageTagForItem(data);
  const damageTag = baseDamageTagData.damageTag;
  const damageType = baseDamageTagData.damageType;

  const versatile = data.definition.properties
    .filter((property) => property.name === "Versatile")
    .map((versatile) => {
      if (versatile && versatile.notes) {
        return (
          utils/* default.parseDiceString */.Z.parseDiceString(versatile.notes + ` + ${magicalDamageBonus}`, null, damageTag, greatWeaponFighting).diceString + mod
        );
      } else {
        return "";
      }
    })[0];

  let parts = [];

  // if we have greatweapon fighting style and this is two handed, add the roll tweak
  // else if we have duelling we add the bonus here (assumption- if you have dueling
  // you're going to use it! (DDB also makes this assumption))
  const fightingStyleDiceMod = twoHanded ? greatWeaponFighting : "";

  // if we are a martial artist and the weapon is eligable we may need to use a bigger dice type.
  // this martial arts die info is addedd to the weapon flags before parse weapon is called
  const martialArtsDie = flags.martialArtsDie;

  if (Number.isInteger(data.definition.fixedDamage)) {
    parts.push([
      utils/* default.parseDiceString */.Z.parseDiceString(data.definition.fixedDamage + ` + ${magicalDamageBonus}`, `${mod}${dueling}`, damageTag, fightingStyleDiceMod)
        .diceString,
      damageType,
    ]);
  } else if (data.definition.damage && data.definition.damage.diceString && damageType) {
    let diceString = data.definition.damage.diceString;
    if (martialArtsDie.diceValue && data.definition.damage.diceValue && martialArtsDie.diceValue > data.definition.damage.diceValue) {
      diceString = martialArtsDie.diceString;
    }

    // if there is a magical damage bonus, it probably should only be included into the first damage part.
    parts.push([
      utils/* default.parseDiceString */.Z.parseDiceString(diceString + ` + ${magicalDamageBonus}`, `${mod}${dueling}`, damageTag, fightingStyleDiceMod)
        .diceString,
      damageType,
    ]);
  }

  // additional damage parts with no restrictions
  data.definition.grantedModifiers
    .filter((mod) => mod.type === "damage" && (!mod.restriction || mod.restriction === ""))
    .forEach((mod) => {
      const die = mod.dice ? mod.dice : mod.die ? mod.die : undefined;
      const damagePart = die ? die.diceString : mod.value;
      if (damagePart) {
        const subDamageTagData = DDBHelper/* default.getDamageTagForMod */.Z.getDamageTagForMod(mod);
        const damageParsed = utils/* default.parseDiceString */.Z.parseDiceString(damagePart, "", subDamageTagData.damageTag).diceString;
        parts.push([`${damageParsed}`, subDamageTagData.damageType]);
      }
    });


  let chatFlavors = [];
  let otherFormulas = [];
  let restrictions = [];
  // loop over restricted damage types
  // we do this so we can either break this out for midi users
  data.definition.grantedModifiers
    .filter((mod) => mod.type === "damage" && mod.restriction && mod.restriction !== "")
    .forEach((mod) => {
      const die = mod.dice ? mod.dice : mod.die ? mod.die : undefined;
      const damagePart = die ? die.diceString : `${mod.value}`;
      if (damagePart) {
        const subDamageTagData = DDBHelper/* default.getDamageTagForMod */.Z.getDamageTagForMod(mod);
        const damageParsed = utils/* default.parseDiceString */.Z.parseDiceString(damagePart, "", subDamageTagData.damageTag).diceString;
        restrictions.push(mod.restriction);
        otherFormulas.push(damageParsed);
        chatFlavors.push(`[${damagePart}] ${mod.restriction}`);
      }
    });

  const otherFormula = otherFormulas.join(" + ");
  const chatFlavor = chatFlavors.length === 0 ? "" : `Roll Other damage: ${chatFlavors.join(", ")}`;

  // add damage modifiers from other sources like improved divine smite
  if (flags.damage.parts) {
    flags.damage.parts.forEach((part) => {
      parts.push(part);
    });
  }

  const result = {
    parts,
    versatile,
  };

  return [result, otherFormula, chatFlavor, restrictions];
}

function getActionType(data) {
  if (data.definition.attackType === 1) {
    return "mwak";
  } else {
    return "rwak";
  }
}

function parseWeapon(data, character, flags) {
  let weapon = {
    name: data.definition.name,
    type: "weapon",
    system: JSON.parse(utils/* default.getTemplate */.Z.getTemplate("weapon")),
    flags: {
      ddbimporter: {
        dndbeyond: {
          type: data.definition.type,
          damage: flags.damage,
          classFeatures: flags.classFeatures,
        },
      },
    },
  };

  const characterAbilities = character.flags.ddbimporter.dndbeyond.effectAbilities;
  const characterProficiencies = character.flags.ddbimporter.dndbeyond.proficienciesIncludingEffects;

  weapon.system.weaponType = getWeaponType(data);
  weapon.system.properties = getProperties(data);

  const proficientFeatures = ["pactWeapon", "kensaiWeapon"];
  if (flags.classFeatures.some((feat) => proficientFeatures.includes(feat))) {
    weapon.system.proficient = true;
  } else {
    weapon.system.proficient = getWeaponProficient(data, weapon.system.weaponType, characterProficiencies);
  }

  weapon.system.description = getDescription(data);
  weapon.system.source = DDBHelper/* default.parseSource */.Z.parseSource(data.definition);
  weapon.system.quantity = getQuantity(data);
  weapon.system.weight = getSingleItemWeight(data);
  weapon.system.equipped = getEquipped(data);
  weapon.system.rarity = getItemRarity(data);
  weapon.system.identified = true;
  weapon.system.activation = { type: "action", cost: 1, condition: "" };
  if (flags.classFeatures.includes("OffHand")) weapon.system.activation.type = "bonus";

  weapon.system.range = getRange(data, weapon.system.properties);
  weapon.system.uses = getUses(data);
  weapon.system.ability = getAbility(weapon.system.properties, weapon.system.range);
  const mockAbility = weapon.system.ability === null
    ? weapon.system.properties.fin ? "dex" : "str"
    : weapon.system.ability;

  // warlocks can use cha for their Hex weapon
  if (flags.classFeatures.includes("hexWarrior")) {
    if (characterAbilities.cha.value >= characterAbilities[mockAbility].value) {
      weapon.system.ability = "cha";
    }
  }
  // kensai monks
  if (flags.classFeatures.includes("kensaiWeapon") || flags.classFeatures.includes("monkWeapon")) {
    if (characterAbilities.dex.value >= characterAbilities[mockAbility].value) {
      weapon.system.ability = "dex";
    }
  }
  if (flags.magicItemAttackInt && (data.definition.magic || weapon.system.properties.mgc)) {
    if (characterAbilities.int.value > characterAbilities[mockAbility].value) {
      weapon.system.ability = "int";
    }
  }

  weapon.system.actionType = getActionType(data);
  weapon.system.attackBonus = getWeaponMagicalBonus(data, flags);

  [
    weapon.system.damage,
    weapon.system.formula,
    weapon.system.chatFlavor,
    weapon.flags.ddbimporter.dndbeyond.restrictions,
  ] = getDamage(data, flags);


  return weapon;
}

;// CONCATENATED MODULE: ./src/parser/item/ammunition.js




/**
 * Gets the range(s) of a given weapon
 */
function ammunition_getRange(data) {
  // range: { value: null, long: null, units: '' },
  return {
    value: data.definition.range ? data.definition.range : null,
    long: data.definition.longRange ? data.definition.longRange : null,
    units: (data.definition.range || data.definition.range) ? "ft." : "",
  };
}

/**
 *
 * @param {obj} data item data
 * @param {obj} weaponProperties weapon properties
 * /* damage: { parts: [], versatile: '' }, * /
 */
let ammunition_getDamage = (data, magicalDamageBonus) => {
  let parts = [];

  // first damage part
  // blowguns and other weapons rely on ammunition that provides the damage parts
  if (data.definition.damage && data.definition.damage.diceString && data.definition.damageType) {
    // if there is a magical damage bonus, it probably should only be included into the first damage part.
    parts.push([
      utils/* default.parseDiceString */.Z.parseDiceString(data.definition.damage.diceString + `+${magicalDamageBonus}`).diceString,
      data.definition.damageType.toLowerCase(),
    ]);
  }

  // additional damage parts
  // Note: For the time being, restricted additional bonus parts are not included in the damage
  //       The Saving Throw Freature within Foundry is not fully implemented yet, to this will/might change
  data.definition.grantedModifiers
    .filter((mod) => mod.type === "damage" && mod.restriction && mod.restriction.length === 0)
    .forEach((mod) => {
      const die = mod.dice ? mod.dice : mod.die ? mod.die : undefined;
      if (die) {
        parts.push([die.diceString, mod.subType]);
      } else if (mod.value) {
        parts.push([mod.value, mod.subType]);
      }
    });

  let result = {
    // label: utils.parseDiceString(parts.map(part => part[0]).join(' + ')).diceString,
    parts: parts,
    versatile: "",
  };

  return result;
};

function parseAmmunition(data, itemType) {
  /**
   * MAIN parseWeapon
   */
  let template = JSON.parse(utils/* default.getTemplate */.Z.getTemplate("consumable"));
  let ammunition = {
    name: data.definition.name,
    type: "consumable",
    system: template,
    flags: {
      ddbimporter: {
        dndbeyond: {
          type: itemType,
        },
      },
    },
  };

  ammunition.system.description = getDescription(data);
  ammunition.system.source = DDBHelper/* default.parseSource */.Z.parseSource(data.definition);
  ammunition.system.properties = {};
  ammunition.system.quantity = getQuantity(data);
  ammunition.system.weight = getSingleItemWeight(data);
  ammunition.system.equipped = getEquipped(data);
  ammunition.system.rarity = getItemRarity(data);
  ammunition.system.identified = true;
  ammunition.system.activation = { type: "action", cost: 1, condition: "" };
  ammunition.system.range = ammunition_getRange(data);
  ammunition.system.ability = "";
  ammunition.system.actionType = "rwak";
  ammunition.system.attackBonus = getMagicalBonus(data);
  ammunition.system.damage = ammunition_getDamage(data, getMagicalBonus(data));
  ammunition.system.consumableType = "ammo";

  return ammunition;
}

;// CONCATENATED MODULE: ./src/parser/item/staves.js





/**
 * Gets the DND5E weapontype (simpleM, martialR etc.) as string
 * Supported Types only: Simple/Martial Melee/Ranged and Ammunition (Firearms in D&DBeyond)
 * @param {obj} data item data
 */
function staves_getWeaponType(data) {
  const weaponBehavior = data.definition.weaponBehaviors[0];
  const type = dictionary/* default.weapon.weaponType.find */.Z.weapon.weaponType.find((type) => type.categoryId === weaponBehavior.categoryId);
  const range = dictionary/* default.weapon.weaponRange.find */.Z.weapon.weaponRange.find((type) => type.attackType === weaponBehavior.attackType);

  if (type && range) {
    return `${type.value}${range.value}`;
  } else {
    return "simpleM";
  }
}

/**
 * Gets the weapons's properties (Finesse, Reach, Heavy etc.)
 * @param {obj} data Item data
 */
function staves_getProperties(data) {
  let weaponBehavior = data.definition.weaponBehaviors[0];
  let result = {};
  dictionary/* default.weapon.properties.forEach */.Z.weapon.properties.forEach((property) => {
    if (weaponBehavior.properties && Array.isArray(weaponBehavior.properties)) {
      result[property.value] = weaponBehavior.properties.find((prop) => prop.name === property.name) !== undefined;
    }
  });
  return result;
}


/**
 * Gets the range(s) of a given weapon
 */
function staves_getRange(data) {
  // range: { value: null, long: null, units: '' },
  let weaponBehavior = data.definition.weaponBehaviors[0];
  return {
    value: weaponBehavior.range ? weaponBehavior.range : 5,
    long: weaponBehavior.longRange ? weaponBehavior.longRange : 5,
    units: "ft.",
  };
}

/**
 * Gets the ability which the to hit modifier is baed on
 * Melee: STR
 * Ranged: DEX
 * Finesse: STR || DEX
 * Thrown: STR, unless Finesse, then STR || DEX
 * @param {obj} weaponProperties weapon properties
 * @param {obj} weaponRange weapon range information
 * @param {obj} abilities character abilities (scores)
 */
function staves_getAbility(weaponProperties, weaponRange, abilities) {
  // finesse weapons can choose freely, so we choose the higher one
  if (weaponProperties.fin) {
    return abilities.str.value > abilities.dex.value ? "str" : "dex";
  }

  // thrown, but not finesse weapon: STR
  if (weaponProperties.thr) {
    return "str";
  }

  // if it's a ranged weapon, and hot a reach weapon (long = 10 (?))
  if (weaponRange.long !== 5 && !weaponProperties.rch) {
    return "dex";
  }

  // the default is STR
  return "str";
}

/**
 *
 * @param {obj} data item data
 * @param {obj} weaponProperties weapon properties
 * /* damage: { parts: [], versatile: '' }, * /
 */
function staves_getDamage(data, magicalDamageBonus) {
  let weaponBehavior = data.definition.weaponBehaviors[0];
  let versatile = weaponBehavior.properties.find((property) => property.name === "Versatile");
  if (versatile && versatile.notes) {
    versatile = utils/* default.parseDiceString */.Z.parseDiceString(versatile.notes + `+${magicalDamageBonus}`).diceString;
  } else {
    versatile = "";
  }

  let parts = [];

  // first damage part
  // blowguns and other weapons rely on ammunition that provides the damage parts
  if (weaponBehavior.damage && weaponBehavior.damage.diceString && weaponBehavior.damageType) {
    parts.push([
      utils/* default.parseDiceString */.Z.parseDiceString(weaponBehavior.damage.diceString + `+${magicalDamageBonus}`).diceString,
      weaponBehavior.damageType.toLowerCase(),
    ]);
  }

  // additional damage parts
  data.definition.grantedModifiers
    .filter((mod) => mod.type === "damage")
    .forEach((mod) => {
      const die = mod.dice ? mod.dice : mod.die ? mod.die : undefined;
      if (die?.diceString) {
        parts.push([die.diceString, mod.subType]);
      } else if (mod.value) {
        parts.push([`${mod.value}`, mod.subType]);
      }
    });

  let result = {
    // label: utils.parseDiceString(parts.map(part => part[0]).join(' + ')).diceString,
    parts: parts,
    versatile: versatile,
  };

  return result;
}

function parseStaff(data, character) {
  let template = JSON.parse(utils/* default.getTemplate */.Z.getTemplate("weapon"));
  let staff = {
    name: data.definition.name,
    type: "weapon",
    system: template,
    flags: {
      ddbimporter: {
        dndbeyond: {
          type: data.definition.type,
        },
      },
    },
  };

  staff.system.weaponType = staves_getWeaponType(data);
  staff.system.properties = staves_getProperties(data);
  staff.system.proficient = getWeaponProficient(data, staff.system.weaponType, character.flags.ddbimporter.dndbeyond.proficienciesIncludingEffects);
  staff.system.description = getDescription(data);
  staff.system.source = DDBHelper/* default.parseSource */.Z.parseSource(data.definition);
  staff.system.quantity = getQuantity(data);
  staff.system.weight = getSingleItemWeight(data);
  staff.system.equipped = getEquipped(data);
  staff.system.rarity = getItemRarity(data);
  staff.system.identified = true;
  staff.system.activation = { type: "action", cost: 1, condition: "" };
  staff.system.range = staves_getRange(data);
  staff.system.ability = staves_getAbility(staff.system.properties, staff.system.range, character.flags.ddbimporter.dndbeyond.effectAbilities);
  staff.system.actionType = staff.system.range.long === 5 ? "mwak" : "rwak";
  staff.system.attackBonus = getMagicalBonus(data);
  staff.system.damage = staves_getDamage(data, getMagicalBonus(data));

  return staff;
}

;// CONCATENATED MODULE: ./src/parser/item/armor.js





/**
 * Gets the DND5E weapontype (simpleM, martialR etc.) as string
 * Supported Types only: Simple/Martial Melee/Ranged and Ammunition (Firearms in D&DBeyond)
 * @param {obj} data item data
 */
function getArmorType(data, character, flags) {
  // get the generic armor type
  const nameEntry = dictionary/* default.equipment.armorType.find */.Z.equipment.armorType.find((type) => type.name === data.definition.type);
  const idEntry = dictionary/* default.equipment.armorType.find */.Z.equipment.armorType.find((type) => type.id === data.definition.armorTypeId);

  // get the armor class
  const baseArmorClass = data.definition.armorClass;
  const bonusArmorClass = data.definition.grantedModifiers.reduce((prev, cur) => {
    if (cur.type === "bonus" && cur.subType === "armor-class" && Number.isInteger(cur.value)) {
      return prev + cur.value;
    } else {
      return prev;
    }
  }, 0);

  // console.warn("datadefinition",data.definition)
  // console.warn("baseArmorClass",baseArmorClass)
  // console.warn("bonusArmorClass",bonusArmorClass)

  // get the max dex modifier (Medium Armor: 2, Heavy: 0)
  let maxDexModifier;
  const armorType = nameEntry !== undefined ? nameEntry.value : idEntry !== undefined ? idEntry.value : "medium";

  switch (armorType) {
    case "heavy":
      maxDexModifier = 0;
      break;
    case "medium":
      maxDexModifier = flags.maxMediumArmorDex || 2;
      break;
    default:
      maxDexModifier = null;
      break;
  }

  const itemDexMaxAdjustment = DDBHelper/* default.getModifierSum */.Z.getModifierSum(DDBHelper/* default.filterModifiers */.Z.filterModifiers(data.definition.grantedModifiers, "set", "ac-max-dex-modifier"), character);
  if (maxDexModifier !== null && Number.isInteger(itemDexMaxAdjustment) && itemDexMaxAdjustment > maxDexModifier) {
    maxDexModifier = itemDexMaxAdjustment;
  }

  return {
    type: armorType,
    value: baseArmorClass + bonusArmorClass,
    dex: maxDexModifier,
  };
}

/**
 * Gets the strength requirement to wear this armor, if any
 * @param {obj} data Item data
 */
function getStrength(data) {
  return data.definition.strengthRequirement ?? 0; // in future null might be permitted again
}

/**
 * Wearing this armor can give a disadvantage on stealth checks
 */
function getStealthPenalty(data) {
  return data.definition.stealthCheck === 2;
}

/**
 * Checks the proficiency of the character with this specific weapon
 * @param {obj} data Item data
 * @param {array} proficiencies The character's proficiencies as an array of `{ name: 'PROFICIENCYNAME' }` objects
 */
function getProficient(data, proficiencies) {
  // Proficiency in armor category (Light Armor, Shield)
  if (proficiencies.find((proficiency) => proficiency.name === data.definition.type) !== -1) return true;
  // Specific proficiency
  if (proficiencies.find((proficiency) => proficiency.name === data.definition.baseArmorName) !== -1) return true;
  return false;
}

function parseArmor(data, character, flags) {
  let armor = {
    name: data.definition.name,
    type: "equipment",
    system: JSON.parse(utils/* default.getTemplate */.Z.getTemplate("equipment")),
    flags: {
      ddbimporter: {
        dndbeyond: {
          type: data.definition.type,
        },
      },
    },
  };

  armor.system.armor = getArmorType(data, character, flags);
  armor.system.strength = getStrength(data);
  armor.system.stealth = getStealthPenalty(data);
  armor.system.proficient = getProficient(data, character.flags.ddbimporter.dndbeyond.proficienciesIncludingEffects);
  armor.system.description = getDescription(data);
  armor.system.source = DDBHelper/* default.parseSource */.Z.parseSource(data.definition);
  armor.system.quantity = getQuantity(data);
  armor.system.weight = getSingleItemWeight(data);
  armor.system.equipped = getEquipped(data);
  armor.system.rarity = getItemRarity(data);
  armor.system.identified = true;
  armor.system.uses = getUses(data);

  return armor;
}

;// CONCATENATED MODULE: ./src/parser/item/wonderous.js




function parseWonderous(data) {
  /**
   * MAIN parseEquipment
   */
  let item = {
    name: data.definition.name,
    type: "equipment",
    system: JSON.parse(utils/* default.getTemplate */.Z.getTemplate("equipment")),
    flags: {
      ddbimporter: {
        dndbeyond: {
          type: data.definition.type,
        },
      },
    },
  };

  //
  // "armor": {
  // "type": "trinket",
  // "value": 10,
  // "dex": null
  // }
  item.system.armor = {
    type: "trinket",
    value: 10,
    dex: null,
  };

  /* "strength": 0 */
  item.system.strength = 0;

  /* "stealth": false,*/
  item.system.stealth = false;
  item.system.proficient = true;
  item.system.description = getDescription(data);
  item.system.source = DDBHelper/* default.parseSource */.Z.parseSource(data.definition);
  item.system.quantity = getQuantity(data);
  item.system.weight = getSingleItemWeight(data);
  item.system.equipped = getEquipped(data);
  item.system.rarity = getItemRarity(data);
  item.system.identified = true;
  item.system.uses = getUses(data);
  item.system.capacity = getCapacity(data);

  return item;
}

;// CONCATENATED MODULE: ./src/parser/item/potion.js





function potion_getActionType(data) {
  if (data.definition.tags.includes("Healing")) {
    return "heal";
  } else if (data.definition.tags.includes("Damage")) {
    // ranged spell attack. This is a good guess
    return "rsak";
  } else {
    return "other";
  }
}

function potion_getDamage(data, actionType) {
  let damage = { parts: [], versatile: "" };
  // is this a damage potion
  switch (actionType) {
    case "heal": {
      // healing potion
      // we only get the first matching modifier
      const healingModifier = data.definition.grantedModifiers.find(
        (mod) => mod.type === "bonus" && mod.subType === "hit-points"
      );
      if (healingModifier) {
        const healingDie = healingModifier.dice ? healingModifier.dice : healingModifier.die ? healingModifier.die : undefined;
        if (healingDie?.diceString) {
          damage.parts = [[healingDie.diceString + "[healing] ", "healing"]];
        } else if (healingModifier.fixedValue) {
          damage.parts = [[healingModifier.fixedValue + "[healing] ", "healing"]];
        }
      }
      break;
    }
    case "rsak": {
      // damage potion
      const damageModifier = data.definition.grantedModifiers.find((mod) => mod.type === "damage" && (mod.dice || mod.die));
      if (damageModifier) {
        const damageDie = damageModifier.dice ? damageModifier.dice : damageModifier.die ? damageModifier.die : undefined;
        if (damageDie?.diceString) {
          damage.parts = [[damageDie.diceString + `[${damageModifier.subType}] `, damageModifier.subType]];
        } else if (damageModifier.fixedValue) {
          damage.parts = [[damageModifier.fixedValue + `[${damageModifier.subType}] `, damageModifier.subType]];
        }
      }
      break;
    }
    // no default
  }
  return damage;
}

function getDuration(data) {
  let duration = {
    value: null,
    units: "",
  };

  if (data.definition.duration) {
    if (data.definition.duration.durationUnit !== null) {
      duration.units = data.definition.duration.durationUnit.toLowerCase();
    } else {
      duration.units = data.definition.duration.durationType.toLowerCase().substring(0, 4);
    }
    if (data.definition.duration.durationInterval) duration.value = data.definition.duration.durationInterval;
  } else {
    const durationArray = [
      { foundryUnit: "day", descriptionMatches: ["day", "days"] },
      { foundryUnit: "hour", descriptionMatches: ["hour", "hours"] },
      { foundryUnit: "inst", descriptionMatches: ["instant", "instantaneous"] },
      { foundryUnit: "minute", descriptionMatches: ["minute", "minutes"] },
      { foundryUnit: "month", descriptionMatches: ["month", "months"] },
      { foundryUnit: "perm", descriptionMatches: ["permanent"] },
      { foundryUnit: "round", descriptionMatches: ["round", "rounds"] },
      // { foundryUnit: "spec", descriptionMatches: [null] },
      { foundryUnit: "turn", descriptionMatches: ["turn", "turns"] },
      { foundryUnit: "year", descriptionMatches: ["year", "years"] },
    ];
    // attempt to parse duration
    const descriptionUnits = durationArray.map((unit) => unit.descriptionMatches).flat().join("|");
    const durationExpression = new RegExp(`(\\d*)(?:\\s)(${descriptionUnits})`);
    const durationMatch = data.definition.description.match(durationExpression);

    if (durationMatch) {
      duration.units = durationArray.find((duration) => duration.descriptionMatches.includes(durationMatch[2])).foundryUnit;
      duration.value = durationMatch[1];
    }
  }
  return duration;
}


function parsePotion(data, itemType) {
  let potion = {
    name: data.definition.name,
    type: "consumable",
    system: JSON.parse(utils/* default.getTemplate */.Z.getTemplate("consumable")),
    flags: {
      ddbimporter: {
        dndbeyond: {
          type: itemType,
        },
      },
    },
  };

  potion.system.consumableType = "potion";
  potion.system.uses = getConsumableUses(data);
  potion.system.description = getDescription(data);
  potion.system.source = DDBHelper/* default.parseSource */.Z.parseSource(data.definition);
  potion.system.quantity = getQuantity(data);
  potion.system.weight = getSingleItemWeight(data);
  potion.system.equipped = getEquipped(data);
  potion.system.rarity = getItemRarity(data);
  potion.system.identified = true;
  potion.system.activation = { type: "action", cost: 1, condition: "" };
  potion.system.duration = getDuration(data);
  potion.system.actionType = potion_getActionType(data);
  potion.system.damage = potion_getDamage(data, potion_getActionType(data));

  return potion;
}

;// CONCATENATED MODULE: ./src/parser/item/scroll.js





function parseScroll(data) {
  let scroll = {
    name: data.definition.name,
    type: "consumable",
    system: JSON.parse(utils/* default.getTemplate */.Z.getTemplate("consumable")),
    flags: {
      ddbimporter: {
        dndbeyond: {
          type: data.definition.type,
        },
      },
    },
  };

  scroll.system.consumableType = "scroll";
  scroll.system.uses = getConsumableUses(data);
  scroll.system.description = getDescription(data);
  scroll.system.source = DDBHelper/* default.parseSource */.Z.parseSource(data.definition);
  scroll.system.quantity = getQuantity(data);
  scroll.system.weight = getSingleItemWeight(data);
  scroll.system.equipped = getEquipped(data);
  scroll.system.rarity = getItemRarity(data);
  scroll.system.identified = true;
  scroll.system.activation = { type: "action", cost: 1, condition: "" };
  scroll.system.actionType = "other";

  return scroll;
}

;// CONCATENATED MODULE: ./src/parser/item/tool.js





function isHalfProficiencyRoundedUp(data, ab) {
  const longAbility = dictionary/* default.character.abilities.filter */.Z.character.abilities.filter((ability) => ab === ability.value)
    .map((ability) => ability.long)[0];
  const roundUp = DDBHelper/* default.filterBaseModifiers */.Z.filterBaseModifiers(data, "half-proficiency-round-up", `${longAbility}-ability-checks`);
  return Array.isArray(roundUp) && roundUp.length;
}

function getProficiency(data, toolName, ability) {
  const modifiers = [
    DDBHelper/* default.getChosenClassModifiers */.Z.getChosenClassModifiers(data, true),
    DDBHelper/* default.getModifiers */.Z.getModifiers(data, "race", true),
    DDBHelper/* default.getModifiers */.Z.getModifiers(data, "background", true),
    DDBHelper/* default.getModifiers */.Z.getModifiers(data, "feat", true),
    DDBHelper/* default.getActiveItemModifiers */.Z.getActiveItemModifiers(data, true),
  ]
    .flat()
    .filter((modifier) => modifier.friendlySubtypeName === toolName)
    .map((mod) => mod.type);

  const halfProficiency
    = DDBHelper/* default.getChosenClassModifiers */.Z.getChosenClassModifiers(data).find(
      (modifier) =>
        // Jack of All trades/half-rounded down
        (modifier.type === "half-proficiency" && modifier.subType === "ability-checks")
        // e.g. champion for specific ability checks
        || isHalfProficiencyRoundedUp(data, ability)
    ) !== undefined
      ? 0.5
      : 0;

  const proficient = modifiers.includes("expertise") ? 2 : modifiers.includes("proficiency") ? 1 : halfProficiency;

  return proficient;
}

function parseTool(ddb, data, itemType) {
  /**
   * MAIN parseTool
   */
  let tool = {
    name: data.definition.name,
    type: "tool",
    system: JSON.parse(utils/* default.getTemplate */.Z.getTemplate("tool")),
    flags: {
      ddbimporter: {
        dndbeyond: {
          type: itemType,
        },
      },
    },
  };

  const defaultAbility = dictionary/* default.character.proficiencies.find */.Z.character.proficiencies.find((prof) => prof.name === tool.name);

  tool.system.ability = defaultAbility?.ability ?? "dex";
  tool.system.description = getDescription(data);
  tool.system.proficient = (ddb) ? getProficiency(ddb, tool.name, tool.system.ability) : 0;
  tool.system.source = DDBHelper/* default.parseSource */.Z.parseSource(data.definition);
  tool.system.quantity = getQuantity(data);
  tool.system.weight = getSingleItemWeight(data);
  tool.system.equipped = getEquipped(data);
  tool.system.rarity = getItemRarity(data);
  tool.system.identified = true;
  tool.system.uses = getUses(data);

  return tool;
}

;// CONCATENATED MODULE: ./src/parser/item/loot.js





function getItemType(data) {
  let result = {
    type: "loot"
  };

  if (data.definition.isContainer) {
    return {
      type: "backpack",
    };
  } else if (data.definition.name.startsWith("Lantern,")
    || ["Lamp", "Healer's Kit"].includes(data.definition.name)
  ) {
    return {
      type: "consumable",
      consumableType: "trinket",
    };
  }

  const itemTypes = data.definition.tags && Array.isArray(data.definition.tags)
    ? [data.definition.type.toLowerCase(), ...data.definition.tags.map((t) => t.toLowerCase())]
    : [data.definition.type.toLowerCase()];

  let itemType = itemTypes
    .map((itemType) => {
      if (itemType === "container") return "backpack";
      if (itemType === "consumable") return "consumable";
      return dictionary/* default.types.full.find */.Z.types.full.find((t) => t.indexOf(itemType) !== -1 || itemType.indexOf(t) !== -1);
    })
    .reduce(
      (itemType, currentType) => (currentType !== undefined && itemType === undefined ? currentType : itemType),
      undefined
    );

  if (!itemType) {
    const isConsumable
      = data.definition.type === "Gear"
      && data.definition.subType === "Adventuring Gear"
      && data.definition.tags.includes('Utility')
      && ((data.definition.tags.includes('Damage')
      && data.definition.tags.includes('Combat'))
      || data.definition.tags.includes('Healing'));
    if (isConsumable) itemType = "consumable";
  }

  if (itemType) {
    result.type = itemType;
    if (itemType === "consumable") {
      if (data.definition.name.includes('vial') || data.definition.name.includes('flask')) {
        result.consumableType = "potion";
      } else if (data.definition.name.startsWith("Ration")) {
        result.consumableType = "food";
      } else {
        result.consumableType = "trinket";
      }
    }
  }

  return result;
}

function parseLoot(data, itemType) {
  const type = getItemType(data);

  let loot = {
    name: data.definition.name,
    type: type.type,
    system: JSON.parse(utils/* default.getTemplate */.Z.getTemplate("loot")), // was: tool
    flags: {
      ddbimporter: {
        dndbeyond: {
          type: itemType,
        },
      },
    },
  };

  if (type.consumableType) {
    loot.system.consumableType = type.consumableType;
    loot.system.uses = getConsumableUses(data);
  }
  loot.system.description = getDescription(data);
  loot.system.source = DDBHelper/* default.parseSource */.Z.parseSource(data.definition);
  loot.system.quantity = getQuantity(data);
  loot.system.weight = getSingleItemWeight(data);
  loot.system.equipped = getEquipped(data);
  loot.system.rarity = getItemRarity(data);
  loot.system.identified = true;
  loot.system.cost = data.definition.cost;

  if (type.type === "backpack") {
    loot.system.capacity = getCapacity(data);
  }
  return loot;
}

;// CONCATENATED MODULE: ./src/parser/item/custom.js



function parseCustomItem(data) {
  let customItem = {
    name: data.definition.name,
    type: "loot",
    system: JSON.parse(utils/* default.getTemplate */.Z.getTemplate("loot")),
    flags: {
      ddbimporter: {
        id: data.id,
        custom: true,
        dndbeyond: {
          type: "Custom Item",
        },
      },
    },
  };

  let description = data.definition.description && data.definition.description !== "null"
    ? data.definition.description
    : "";
  description = data.definition.notes
    ? description + `<p><blockquote>${data.definition.notes}</blockquote></p>`
    : description;

  const chatAdd = game.settings.get("ddb-importer", "add-description-to-chat");
  customItem.system.description = {
    value: description,
    chat: chatAdd ? description : "",
    unidentified: description,
  };

  customItem.system.source = "Custom item";
  customItem.system.quantity = getQuantity(data);
  customItem.system.weight = getSingleItemWeight(data);
  customItem.system.price = data.definition.cost ? data.definition.cost : 0;
  customItem.system.equipped = getEquipped(data);
  customItem.system.identified = true;
  customItem.system.rarity = getItemRarity(data);

  return customItem;
}

;// CONCATENATED MODULE: ./src/parser/item/index.js






// magicitems support




// effects support






// tables


// item collections


// type: weapon




// type: armor


// tyoe: wonderous item


// type: consumables



// type: tool


// other loot






function getItemFromGearTypeIdOne(ddb, data) {
  let item = {};

  switch (data.definition.subType) {
    case "Potion":
      item = parsePotion(data, data.definition.subType);
      break;
    case "Tool":
      item = parseTool(ddb, data, data.definition.subType);
      break;
    case "Ammunition":
      item = parseAmmunition(data, data.definition.subType);
      break;
    default:
      item = parseLoot(data, data.definition.subType);
  }
  return item;
}

function otherGear(ddb, data) {
  let item = {};

  switch (data.definition.gearTypeId) {
    case 1:
      item = getItemFromGearTypeIdOne(ddb, data);
      break;
    case 4:
      item = parseLoot(data, "Mount");
      break;
    case 5:
      item = parsePotion(data, "Poison");
      break;
    case 6:
      item = parsePotion(data, "Potion");
      break;
    case 11:
      item = parseTool(ddb, data, "Tool");
      break;
    case 12:
    case 17:
    case 19:
      item = parseLoot(data, "Vehicle");
      break;
    case 16:
      item = parseLoot(data, "Equipment Pack");
      break;
    case 18:
      // Change to parseGemstone (consummable) ?
      item = parseLoot(data, "Gemstone");
      break;
    default:
      src_logger/* default.warn */.Z.warn("Other Gear type missing from " + data.definition.name, data);
  }
  return item;
}

function addExtraDDBFlags(data, item) {
  item.flags.ddbimporter['id'] = data.id;
  item.flags.ddbimporter['entityTypeId'] = data.entityTypeId;

  if (data.definition.avatarUrl) item.flags.ddbimporter.dndbeyond['avatarUrl'] = data.definition.avatarUrl.split('?')[0];
  if (data.definition.largeAvatarUrl) item.flags.ddbimporter.dndbeyond['largeAvatarUrl'] = data.definition.largeAvatarUrl.split('?')[0];
  if (data.definition.filterType) {
    const filter = dictionary/* default.items.find */.Z.items.find((i) => i.filterType === data.definition.filterType);
    if (filter) item.flags.ddbimporter.dndbeyond['filterType'] = filter.filterType;
  }

  // container info
  if (data.containerEntityId) setProperty(item, "flags.ddbimporter.containerEntityId", data.containerEntityId);
  if (data.containerEntityTypeId) setProperty(item, "flags.ddbimporter.containerEntityTypeId", data.containerEntityTypeId);

  setProperty(item, "flags.ddbimporter.dndbeyond.isConsumable", data.definition.isConsumable);
  setProperty(item, "flags.ddbimporter.dndbeyond.isContainer", data.definition.isContainer);
  setProperty(item, "flags.ddbimporter.dndbeyond.isCustomItem", data.definition.isCustomItem);
  setProperty(item, "flags.ddbimporter.dndbeyond.isHomebrew", data.definition.isHomebrew);
  setProperty(item, "flags.ddbimporter.dndbeyond.isMonkWeapon", data.definition.isMonkWeapon);
  setProperty(item, "flags.ddbimporter.dndbeyond.isPack", data.definition.isPack);
  setProperty(item, "flags.ddbimporter.dndbeyond.levelInfusionGranted", data.definition.levelInfusionGranted);

  return item;
}

function enrichFlags(data, item) {
  if (data.definition.magic) {
    setProperty(item, "system.properties.mgc", true);
  }
  if (data.definition?.entityTypeId) item.flags.ddbimporter['definitionEntityTypeId'] = data.definition.entityTypeId;
  if (data.definition?.id) item.flags.ddbimporter['definitionId'] = data.definition.id;
  if (data.entityTypeId) item.flags.ddbimporter['entityTypeId'] = data.entityTypeId;
  if (data.id) item.flags.ddbimporter['id'] = data.id;
  if (data.definition?.tags) item.flags.ddbimporter.dndbeyond['tags'] = data.definition.tags;
  if (data.definition?.sources) item.flags.ddbimporter.dndbeyond['sources'] = data.definition.sources;
  if (data.definition?.stackable) item.flags.ddbimporter.dndbeyond['stackable'] = data.definition.stackable;
}

// the filter type "Other Gear" represents the equipment while the other filters represents the magic items in ddb
function parseItem(ddb, ddbItem, character, flags) {
  try {
    // is it a weapon?
    let item = {};
    if (ddbItem.definition.filterType) {
      switch (ddbItem.definition.filterType) {
        case "Weapon": {
          if (ddbItem.definition.type === "Ammunition" || ddbItem.definition.subType === "Ammunition") {
            item = parseAmmunition(ddbItem, "Ammunition");
          } else {
            item = parseWeapon(ddbItem, character, flags);
          }
          break;
        }
        case "Armor":
          item = parseArmor(ddbItem, character, flags);
          break;
        case "Wondrous item":
        case "Ring":
        case "Wand":
        case "Rod":
          item = parseWonderous(ddbItem);
          break;
        case "Staff":
          item = parseStaff(ddbItem, character);
          break;
        case "Potion":
          item = parsePotion(ddbItem, ddbItem.definition.type);
          break;
        case "Scroll":
          item = parseScroll(ddbItem);
          break;
        case "Other Gear":
          item = otherGear(ddb, ddbItem);
          break;
        default:
          src_logger/* default.warn */.Z.warn("Item filterType not implemented for " + ddbItem.definition.name, ddbItem);
          break;
      }
    } else {
      // try parsing it as a custom item
      item = parseCustomItem(ddbItem);
    }
    const baseItem = getBaseItem(ddbItem);
    setProperty(item, "system.baseItem", baseItem.baseItem);
    setProperty(item, "system.toolType", baseItem.toolType);
    item.system.attunement = getAttunement(ddbItem);
    if (ddbItem.definition.cost) item.system.price = ddbItem.definition.cost;

    item = addExtraDDBFlags(ddbItem, item);
    item = DDBHelper/* default.addCustomValues */.Z.addCustomValues(ddb, item);
    enrichFlags(ddbItem, item);

    return item;
  } catch (err) {
    src_logger/* default.warn */.Z.warn(
      `Unable to parse item: ${ddbItem.definition.name}, ${ddbItem.definition.type}/${ddbItem.definition.filterType}. ${err.message}`,
      ddbItem
    );
    src_logger/* default.error */.Z.error(err.stack);
    return { // return empty strut
      name: ddbItem.definition.name,
      flags: {
        ddbimporter: {
          dndbeyond: {
          },
        },
      },
    };
  }
}


/**
 * We get extra damage to a weapon attack here, for example Improved
 * Divine Smite
 * @param {*} data
 * @param {*} restrictions (array)
 */
function getExtraDamage(ddb, restrictions) {
  return DDBHelper/* default.filterBaseModifiers */.Z.filterBaseModifiers(ddb, "damage", null, restrictions).map((mod) => {
    const die = mod.dice ? mod.dice : mod.die ? mod.die : undefined;
    if (die) {
      return [die.diceString, mod.subType];
    } else if (mod.value) {
      return [mod.value, mod.subType];
    } else {
      return [null, null];
    }
  });
}

function isMartialArtists(classes) {
  return classes.some((cls) => cls.classFeatures.some((feature) => feature.definition.name === "Martial Arts"));
}

function getWarlockFeatures(ddb, weapon) {
  // Some features, notably hexblade abilities we scrape out here
  const warlockFeatures = ddb.character.characterValues
    .filter(
      (characterValue) =>
        characterValue.value
        && characterValue.valueId == weapon.id
        && dictionary/* default.character.characterValuesLookup.some */.Z.character.characterValuesLookup.some(
          (entry) => entry.typeId == characterValue.typeId
        )
    )
    .map(
      (characterValue) =>
        dictionary/* default.character.characterValuesLookup.find */.Z.character.characterValuesLookup.find(
          (entry) => entry.typeId == characterValue.typeId
        ).name
    );

  // Any Pact Weapon Features
  const pactFeatures = ddb.character.options.class
    .filter(
      (option) =>
        warlockFeatures.includes("pactWeapon")
        && option.definition.name
        && dictionary/* default.character.pactFeatures.includes */.Z.character.pactFeatures.includes(option.definition.name)
    )
    .map((option) => option.definition.name);

  const features = warlockFeatures.concat(pactFeatures);
  return features;
}

function getMonkFeatures(ddb, weapon) {
  const kenseiWeapon = DDBHelper/* default.getChosenClassModifiers */.Z.getChosenClassModifiers(ddb).some((mod) =>
    mod.friendlySubtypeName === weapon.definition.type
    && mod.type === "kensei"
  );

  const monkWeapon = DDBHelper/* default.getChosenClassModifiers */.Z.getChosenClassModifiers(ddb).some((mod) =>
    mod.friendlySubtypeName === weapon.definition.type
    && mod.type == "monk-weapon"
  ) || (weapon.definition.isMonkWeapon && isMartialArtists(ddb.character.classes));

  let features = [];

  if (kenseiWeapon) features.push("kenseiWeapon");
  if (monkWeapon) features.push("monkWeapon");

  return features;
}


function getMartialArtsDie(ddb) {
  let result = {
    diceCount: null,
    diceMultiplier: null,
    diceString: null,
    diceValue: null,
    fixedValue: null,
  };

  const die = ddb.character.classes
    // is a martial artist
    .filter((cls) => cls.classFeatures.some((feature) => feature.definition.name === "Martial Arts"))
    // get class features
    .map((cls) => cls.classFeatures)
    .flat()
    // filter relevant features, those that are martial arts and have a levelscaling hd
    .filter((feature) => feature.definition.name === "Martial Arts" && feature.levelScale && feature.levelScale.dice)
    // get this dice object
    .map((feature) => feature.levelScale.dice);

  if (die && die.length > 0) {
    result = die[0];
  }

  return result;

}

function item_getClassFeatures(ddb, weapon) {
  const warlockFeatures = getWarlockFeatures(ddb, weapon);
  const monkFeatures = getMonkFeatures(ddb, weapon);
  return warlockFeatures.concat(monkFeatures);
}

function getItemFlags(ddbCharacter, ddbItem) {
  const ddb = ddbCharacter.source.ddb;
  const character = ddbCharacter.raw.character;
  let flags = {
    damage: {
      parts: [],
    },
    // Some features, notably hexblade abilities we scrape out here
    classFeatures: item_getClassFeatures(ddb, ddbItem),
    martialArtsDie: getMartialArtsDie(ddb),
    maxMediumArmorDex: Math.max(...DDBHelper/* default.filterBaseModifiers */.Z.filterBaseModifiers(ddb, "set", "ac-max-dex-armored-modifier").map((mod) => mod.value), 2),
    magicItemAttackInt: DDBHelper/* default.filterBaseModifiers */.Z.filterBaseModifiers(ddb, "bonus", "magic-item-attack-with-intelligence").length > 0,
  };

  if (flags.classFeatures.includes("Lifedrinker")) {
    flags.damage.parts.push(["@mod", "necrotic"]);
  }
  // const addItemEffects = game.settings.get("ddb-importer", "character-update-policy-add-item-effects");
  const addCharacterEffects = game.settings.get("ddb-importer", "character-update-policy-add-character-effects");

  // for melee attacks get extras
  if (ddbItem.definition.attackType === 1) {
    // get improved divine smite etc for melee attacks
    const extraDamage = getExtraDamage(ddb, ["Melee Weapon Attacks"]);

    if (!!extraDamage.length > 0) {
      flags.damage.parts = flags.damage.parts.concat(extraDamage);
    }
    // do we have great weapon fighting?
    if (DDBHelper/* default.hasChosenCharacterOption */.Z.hasChosenCharacterOption(ddb, "Great Weapon Fighting")) {
      flags.classFeatures.push("greatWeaponFighting");
    }
    // do we have dueling fighting style?
    if (DDBHelper/* default.hasChosenCharacterOption */.Z.hasChosenCharacterOption(ddb, "Dueling") && !addCharacterEffects) {
      flags.classFeatures.push("Dueling");
    }
    // do we have two weapon fighting style?
    if (DDBHelper/* default.hasChosenCharacterOption */.Z.hasChosenCharacterOption(ddb, "Two-Weapon Fighting")) {
      flags.classFeatures.push("Two-Weapon Fighting");
    }
    if (DDBHelper/* default.getCustomValueFromCharacter */.Z.getCustomValueFromCharacter(ddbItem, character, 18)) {
      flags.classFeatures.push("OffHand");
    }
  }
  // ranged fighting style is added as a global modifier elsewhere
  // as is defensive style

  return flags;
}

async function getIcon(item, ddbItem) {
  if (ddbItem.definition?.avatarUrl || ddbItem.definition?.largeAvatarUrl) {
    const url = ddbItem.definition?.avatarUrl ?? ddbItem.definition?.largeAvatarUrl;
    const downloadOptions = { type: "item", name: `custom-${item.name}`, download: true };
    const img = await FileHelper/* default.getImagePath */.Z.getImagePath(url, downloadOptions);
    if (img) {
      // eslint-disable-next-line require-atomic-updates
      item.img = img;
      setProperty(item, "flags.ddbimporter.keepIcon", true);
    }
  }
  return item;
}


// TO DO: revisit to break up item parsing
DDBCharacter/* default.prototype.getInventory */.Z.prototype.getInventory = async function getInventory() {

  let items = [];
  // first, check custom name, price or weight
  this.source.ddb.character.characterValues.forEach((cv) => {
    // try to find a matching item based on the characterValues (an array of custom adjustements to different parts of the character)
    let item = this.source.ddb.character.inventory.find((item) => item.id === cv.valueId);
    if (item) {
      // check if this property is in the list of supported ones, based on our DICT
      let property = dictionary/* default.item.characterValues.find */.Z.item.characterValues.find((entry) => entry.typeId === cv.typeId);
      // overwrite the name, weight or price with the custom value
      if (property && cv.value.length !== 0) item.definition[property.value] = cv.value;
    }
  });

  // now parse all items
  const daeInstalled = game.modules.get("dae")?.active;
  const compendiumItem = this.raw.character.flags.ddbimporter.compendium;
  const addEffects = (compendiumItem)
    ? game.settings.get("ddb-importer", "munching-policy-add-effects")
    : game.settings.get("ddb-importer", "character-update-policy-add-item-effects");
  const generateArmorACEffect = (compendiumItem)
    ? game.settings.get("ddb-importer", "munching-policy-add-ac-armor-effects")
    : false;

  for (let ddbItem of this.source.ddb.character.inventory) {
    const originalName = ddbItem.definition.name;
    ddbItem.definition.name = DDBHelper/* default.getName */.Z.getName(this.source.ddb, ddbItem, this.raw.character);
    const flags = getItemFlags(this, ddbItem);

    const updateExisting = compendiumItem
      ? game.settings.get("ddb-importer", "munching-policy-update-existing")
      : false;
    ddbItem.definition.description = (0,table/* generateTable */.p)(ddbItem.definition.name, ddbItem.definition.description, updateExisting);

    let item = Object.assign({}, parseItem(this.source.ddb, ddbItem, this.raw.character, flags));

    if (item) {
      item = parseMagicItem(item, ddbItem, this.raw.itemSpells);
      item.flags.ddbimporter.originalName = originalName;
      item.flags.ddbimporter.version = CONFIG.DDBI.version;
      if (!item.effects) item.effects = [];
      if (!item.name || item.name === "") item.name = "Item";

      if (daeInstalled && addEffects) item = (0,effects_effects/* generateEffects */.K7)(this.source.ddb, this.raw.character, ddbItem, item, compendiumItem, "item");
      // if this is a piece of armor and not generating effects don't generate ac
      if (item.type === "equipment" && item.system.armor?.type && !["trinket", "clothing"].includes(item.system.armor.type)) {
        if (daeInstalled && generateArmorACEffect) {
          item = (0,acEffects/* generateBaseACItemEffect */.se)(this.source.ddb, this.raw.character, ddbItem, item, compendiumItem);
        }
      } else {
        // always generate other item ac effects
        item = (0,acEffects/* generateBaseACItemEffect */.se)(this.source.ddb, this.raw.character, ddbItem, item, compendiumItem);
      }

      // eslint-disable-next-line no-await-in-loop
      if (addEffects) item = await addRestrictionFlags(item);

      if (!compendiumItem) item = (0,infusions/* parseInfusion */.P)(this.source.ddb, this.raw.character, item, ddbItem, compendiumItem);
      // eslint-disable-next-line no-await-in-loop
      item = await (0,specialEquipment/* midiItemEffects */.i)(item);
      // eslint-disable-next-line no-await-in-loop
      item = await getIcon(item, ddbItem);

      items.push(item);
    }
  }

  fixItems(items);
  items = fixForItemCollections(this.source.ddb, items);
  return items;
};

// EXTERNAL MODULE: ./src/parser/features/special.js
var features_special = __webpack_require__(2243);
;// CONCATENATED MODULE: ./src/parser/features/features.js






function parseFeature(feat, ddb, character, source, type) {
  let features = [];
  // filter proficiencies and Ability Score Improvement
  const name = feat.definition ? feat.definition.name : feat.name;
  let item = {
    name: name.replace("â€™", "'").trim(),
    type: "feat",
    system: JSON.parse(utils/* default.getTemplate */.Z.getTemplate("feat")),
    flags: {
      ddbimporter: {
        id: feat.definition?.id ? feat.definition.id : feat.id,
        type: type,
        entityTypeId: feat.definition?.entityTypeId ? feat.definition.entityTypeId : feat.entityTypeId,
        dndbeyond: {
          requiredLevel: feat.requiredLevel,
          displayOrder:
            feat.definition && feat.definition.displayOrder ? feat.definition.displayOrder : feat.displayOrder,
        },
      },
      obsidian: {
        source: {
          type: type,
        },
      },
    },
  };

  setProperty(item, "system.type.value", type);

  src_logger/* default.debug */.Z.debug(`Getting Feature ${item.name}`);

  const klassAction = DDBHelper/* default.findComponentByComponentId */.Z.findComponentByComponentId(ddb, feat.id);
  if (klassAction) {
    setProperty(item.flags, "ddbimporter.dndbeyond.levelScale", klassAction.levelScale);
    setProperty(item.flags, "ddbimporter.dndbeyond.levelScales", klassAction.definition?.levelScales);
    setProperty(item.flags, "ddbimporter.dndbeyond.limitedUse", klassAction.definition?.limitedUse);
  }

  if (!klassAction) {
    const classOption = [ddb.character.options.race, ddb.character.options.class, ddb.character.options.feat]
      .flat()
      .find((option) => option.definition.id === feat.componentId);
    if (classOption) {
      const classOptionLink = DDBHelper/* default.findComponentByComponentId */.Z.findComponentByComponentId(ddb, classOption.componentId);
      if (classOptionLink) {
        setProperty(item.flags, "ddbimporter.dndbeyond.levelScale", classOptionLink.levelScale);
        setProperty(item.flags, "ddbimporter.dndbeyond.levelScales", classOptionLink.definition?.levelScales);
        setProperty(item.flags, "ddbimporter.dndbeyond.limitedUse", classOptionLink.definition?.limitedUse);
      }
    }
  }

  if (feat?.requiredLevel) {
    const klass = ddb.character.classes.find((klass) =>
      (feat.classId && (klass.definition.id === feat.classId || klass.subclassDefinition?.id === feat.classId))
      || (feat.className && klass.definition.name === feat.className
        && ((!feat.subclassName || feat.subclassName === "")
          || (feat.subclassName && klass.subclassDefinition?.name === feat.subclassName))
      )
    );
    if (klass && feat.requiredLevel > klass.level) return [];
  }

  src_logger/* default.debug */.Z.debug(`Searching for ${name} choices`);

  // Add choices to the textual description of that feat
  let choices = DDBHelper/* default.getChoices */.Z.getChoices(ddb, type, feat);

  if (type === "background") {
    src_logger/* default.debug */.Z.debug(`Found background ${feat.name}`);
    src_logger/* default.debug */.Z.debug(`Found ${choices.map((c) => c.label).join(",")}`);
    item.system.description = (0,features_special/* getDescription */.Eb)(ddb, character, feat, true);
    item.system.description.value += `<h3>Choices</h3><ul>`;
    item.system.source = source;
    choices.forEach((choice) => {
      let choiceItem = duplicate(item);
      item = (0,features_special/* addFeatEffects */.YL)(ddb, character, feat, choiceItem, choice, type);
      item.system.description.value += `<li>${choice.label}</li>`;
    });
    item.system.description.value += `</ul>`;
    features.push(item);
    item.type = "background";
    item.img = "icons/skills/trades/academics-book-study-purple.webp";
    item.name = item.name.split("Background: ").pop();

  } else if (choices.length > 0) {
    src_logger/* default.debug */.Z.debug(`Found ${choices.map((c) => c.label).join(",")}`);
    choices.forEach((choice) => {
      src_logger/* default.debug */.Z.debug(`Adding choice ${choice.label}`);
      let choiceItem = duplicate(item);
      let choiceFeat = feat.definition ? duplicate(feat.definition) : duplicate(feat);

      if (item.name === choice.label) return;

      choiceItem.name = choice.label
        ? `${choiceItem.name}: ${choice.label}`
        : choiceItem.name;
      choiceItem.name = choiceItem.name.replace("â€™", "'");
      if (choice.wasOption && choice.description) {
        choiceFeat.description = choice.description;
        choiceFeat.snippet = choice.snippet ? choice.snippet : "";
      } else {
        if (choiceFeat.description) {
          choiceFeat.description = choice.description
            ? choiceFeat.description + "<h3>" + choice.label + "</h3>" + choice.description
            : choiceFeat.description;
        }
        if (choiceFeat.snippet) {
          choiceFeat.snippet = choice.description
            ? choiceFeat.snippet + "<h3>" + choice.label + "</h3>" + choice.description
            : choiceFeat.snippet;
        }
      }
      // add these flags in so they can be used by the description parser
      setProperty(choiceFeat, "flags.ddbimporter.dndbeyond.choice", choice);

      choiceItem.system.description = (0,features_special/* getDescription */.Eb)(ddb, character, choiceFeat, false);
      choiceItem.system.source = source;
      choiceItem.flags.ddbimporter.dndbeyond.choice = {
        label: choice.label,
        choiceId: choice.choiceId,
        componentId: choice.componentId,
        componentTypeId: choice.componentTypeId,
        parentChoiceId: choice.parentChoiceId,
        subType: choice.subType,
        wasOption: choice.wasOption,
        entityTypeId: choice.entityTypeId,
        type: choice.type,
      };

      choiceItem = (0,features_special/* addFeatEffects */.YL)(ddb, character, feat, choiceItem, choice, type);
      features.push(choiceItem);
    });
  } else {
    item.system.description = (0,features_special/* getDescription */.Eb)(ddb, character, feat, true);
    item.system.source = source;
    item = (0,features_special/* addFeatEffects */.YL)(ddb, character, feat, item, undefined, type);

    features.push(item);
  }

  return features;
}

function isDuplicateFeature(items, item) {
  return items.some((dup) => dup.name === item.name && dup.system.description.value === item.system.description.value);
}

function getNameMatchedFeature(items, item) {
  return items.find((dup) => dup.name === item.name && item.flags.ddbimporter.type === dup.flags.ddbimporter.type);
}

const SKIPPED_FEATURES = [
  "Hit Points",
  "Languages",
  "Bonus Proficiency",
  "Speed",
];
function includedFeatureNameCheck(featName) {
  const nameAllowed = !featName.startsWith("Proficiencies")
    && !featName.startsWith("Ability Score")
    && !featName.startsWith("Size")
    && !SKIPPED_FEATURES.includes(featName);

  return nameAllowed;
}


function parseClassFeatures(ddb, character) {
  // class and subclass traits
  let classItems = [];
  let classesFeatureList = [];
  let subClassesFeatureList = [];
  let processedClassesFeatureList = [];
  const excludedFeatures = ddb.character.optionalClassFeatures
    .filter((f) => f.affectedClassFeatureId)
    .map((f) => f.affectedClassFeatureId);

  // subclass features can often be duplicates of class features.
  ddb.character.classes.forEach((klass) => {
    const classFeatures = klass.definition.classFeatures.filter(
      (feat) =>
        includedFeatureNameCheck(feat.name)
        && feat.requiredLevel <= klass.level
    );
    const klassName = klass.definition.name;
    const klassFeatureList = classFeatures
      .filter((feat) => !excludedFeatures.includes(feat.id))
      .map((feat) => {
        let items = parseFeature(feat, ddb, character, klassName, "class");
        return items.map((item) => {
          item.flags.ddbimporter.dndbeyond.class = klassName;
          item.flags.ddbimporter.class = klass.definition.name;
          item.flags.ddbimporter.subclass = hasProperty(klass, "subclassDefinition.name")
            ? klass.subclassDefinition.name
            : undefined;
          item.flags.obsidian.source.text = klassName;
          // add feature to all features list
          classesFeatureList.push(duplicate(item));
          return item;
        });
      })
      .flat()
      .sort((a, b) => {
        return a.flags.ddbimporter.dndbeyond.displayOrder - b.flags.ddbimporter.dndbeyond.displayOrder;
      });

    klassFeatureList.forEach((item) => {
      // have we already processed an identical item?
      if (!isDuplicateFeature(processedClassesFeatureList, item)) {
        const existingFeature = getNameMatchedFeature(classItems, item);
        const duplicateFeature = isDuplicateFeature(classItems, item);
        if (existingFeature && !duplicateFeature) {
          const levelAdjustment = `<h3>${klassName}: Level ${item.flags.ddbimporter.dndbeyond.requiredLevel}</h3>${item.system.description.value}`;
          existingFeature.system.description.value += levelAdjustment;
        } else if (!existingFeature) {
          classItems.push(item);
        }
      }
    });
    processedClassesFeatureList = processedClassesFeatureList.concat(classesFeatureList, klassFeatureList);

    // subclasses
    if (klass.subclassDefinition && klass.subclassDefinition.classFeatures) {
      let subClassItems = [];
      const subFeatures = klass.subclassDefinition.classFeatures.filter(
        (feat) =>
          includedFeatureNameCheck(feat.name)
          && feat.requiredLevel <= klass.level
          && !excludedFeatures.includes(feat.id)
      );
      const subKlassName = `${klassName} : ${klass.subclassDefinition.name}`;
      const subKlassFeatureList = subFeatures
        .map((feat) => {
          let subClassItems = parseFeature(feat, ddb, character, subKlassName, "class");
          return subClassItems.map((item) => {
            item.flags.ddbimporter.dndbeyond.class = subKlassName;
            item.flags.obsidian.source.text = klassName;
            item.flags.ddbimporter.class = klass.definition.name;
            item.flags.ddbimporter.subclass = hasProperty(klass, "subclassDefinition.name")
              ? klass.subclassDefinition.name
              : undefined;
            // add feature to all features list
            subClassesFeatureList.push(duplicate(item));
            return item;
          });
        })
        .flat()
        .sort((a, b) => {
          return a.flags.ddbimporter.dndbeyond.displayOrder - b.flags.ddbimporter.dndbeyond.displayOrder;
        });

      // parse out duplicate features from class features
      subKlassFeatureList.forEach((item) => {
        if (!isDuplicateFeature(classesFeatureList, item)) {
          const existingFeature = getNameMatchedFeature(subClassItems, item);
          const duplicateFeature = isDuplicateFeature(subClassItems, item);
          if (existingFeature && !duplicateFeature) {
            const levelAdjustment = `<h3>${subKlassName}: At Level ${item.flags.ddbimporter.dndbeyond.requiredLevel}</h3>${item.system.description.value}`;
            existingFeature.system.description.value += levelAdjustment;
          } else if (!existingFeature) {
            subClassItems.push(item);
          }
        }
      });
      // add features to list to indicate processed
      processedClassesFeatureList = processedClassesFeatureList.concat(subClassesFeatureList, subKlassFeatureList);

      // now we take the unique subclass features and add to class
      subClassItems.forEach((item) => {
        const existingFeature = getNameMatchedFeature(classItems, item);
        const duplicateFeature = isDuplicateFeature(classItems, item);
        if (existingFeature && !duplicateFeature) {
          const levelAdjustment = `<h3>${subKlassName}: At Level ${item.flags.ddbimporter.dndbeyond.requiredLevel}</h3>${item.system.description.value}`;
          existingFeature.system.description.value += levelAdjustment;
        } else if (!existingFeature) {
          classItems.push(item);
        }
      });
    }
  });
  return classItems;
}

DDBCharacter/* default.prototype._generateFeatures */.Z.prototype._generateFeatures = async function _generateFeatures() {
  const ddb = this.source.ddb;
  const character = this.raw.character;
  const classes = this.raw.classes;
  let items = [];

  const excludedOriginFeatures = ddb.character.optionalOrigins
    .filter((f) => f.affectedRacialTraitId)
    .map((f) => f.affectedRacialTraitId);

  // racial traits
  src_logger/* default.debug */.Z.debug("Parsing racial traits");
  ddb.character.race.racialTraits
    .filter(
      (trait) => includedFeatureNameCheck(trait.definition.name) && !trait.definition.hideInSheet && !excludedOriginFeatures.includes(trait.definition.id))
    .forEach((feat) => {
      const source = DDBHelper/* default.parseSource */.Z.parseSource(feat.definition);
      const features = parseFeature(feat, ddb, character, source, "race");
      features.forEach((item) => {
        const existingFeature = getNameMatchedFeature(items, item);
        const duplicateFeature = isDuplicateFeature(items, item);
        if (existingFeature && !duplicateFeature) {
          existingFeature.system.description.value += `<h3>Racial Trait Addition</h3>${item.system.description.value}`;
        } else if (!existingFeature) {
          items.push(item);
        }
      });
    });

  // class and subclass traits
  src_logger/* default.debug */.Z.debug("Parsing class and subclass features");
  let classItems = parseClassFeatures(ddb, character);

  // optional class features
  src_logger/* default.debug */.Z.debug("Parsing optional class features");
  if (ddb.classOptions) {
    ddb.classOptions
      .forEach((feat) => {
        src_logger/* default.debug */.Z.debug(`Parsing Optional Feature ${feat.name}`);
        const source = DDBHelper/* default.parseSource */.Z.parseSource(feat);
        const feats = parseFeature(feat, ddb, character, source, "class");
        feats.forEach((item) => {
          items.push(item);
        });
      });
  }

  // now we loop over class features and add to list, removing any that match racial traits, e.g. Darkvision
  src_logger/* default.debug */.Z.debug("Removing matching traits");
  classItems
    .forEach((item) => {
      const existingFeature = getNameMatchedFeature(items, item);
      const duplicateFeature = isDuplicateFeature(items, item);
      if (existingFeature && !duplicateFeature) {
        const klassAdjustment = `<h3>${item.flags.ddbimporter.dndbeyond.class}</h3>${item.system.description.value}`;
        existingFeature.system.description.value += klassAdjustment;
      } else if (!existingFeature) {
        items.push(item);
      }
    });

  // add feats
  src_logger/* default.debug */.Z.debug("Parsing feats");
  ddb.character.feats
    .forEach((feat) => {
      const source = DDBHelper/* default.parseSource */.Z.parseSource(feat.definition);
      const feats = parseFeature(feat, ddb, character, source, "feat");
      feats.forEach((item) => {
        items.push(item);
      });
    });

  src_logger/* default.debug */.Z.debug("Parsing backgrounds");
  const backgroundFeature = this.getBackgroundData();
  const backgroundSource = DDBHelper/* default.parseSource */.Z.parseSource(backgroundFeature.definition);
  const backgroundFeat = parseFeature(backgroundFeature, ddb, character, backgroundSource, "background");
  backgroundFeat.forEach((item) => {
    items.push(item);
  });

  src_logger/* default.debug */.Z.debug("Feature fixes");
  (0,features_special/* setLevelScales */.OV)(classes, items);
  (0,features_special/* fixFeatures */.tC)(items);
  this.raw.features = await (0,features_special/* addExtraEffects */.fg)(ddb, items, character);
};

// EXTERNAL MODULE: ./src/parser/companions/DDBCompanionFactory.js
var DDBCompanionFactory = __webpack_require__(3972);
;// CONCATENATED MODULE: ./src/parser/companions/companions.js





DDBCharacter/* default.prototype.addCompanionsToDocuments */.Z.prototype.addCompanionsToDocuments = async function() {
  for (const factory of this.companionFactories) {
    // eslint-disable-next-line no-await-in-loop
    const worldActors = await factory.getExistingWorldCompanions({ limitToFactory: true });
    const summons = worldActors
      .map((actor) => {
        return {
          name: actor.name,
          uuid: `Actor.${actor.id}`,
        };
      });
    if (factory.originDocument) {
      setProperty(factory.originDocument, "flags.arbron-summoner.summons", summons);
      setProperty(factory.originDocument, "system.actionType", "summon");
    }
  }
};

DDBCharacter/* default.prototype.getClassFeature */.Z.prototype.getClassFeature = function(name) {
  const klass = this.source.ddb.character.classes
    .find((k) => k.classFeatures.some((f) => f.definition.name == name));
  return klass?.classFeatures?.find((f) => f.definition.name == name);
};

DDBCharacter/* default.prototype._findDDBSpell */.Z.prototype._findDDBSpell = function(name) {
  const spells = [];
  this.source.ddb.character.classSpells.forEach((playerClass) => {
    spells.push(...playerClass.spells);
  });

  const klassSpell = spells.find((s) => s.definition?.name === name);
  if (klassSpell) return klassSpell;

  // Parse any spells granted by class features, such as Barbarian Totem
  const extraKlass = this.source.ddb.character.spells.class.find((s) => s.definition?.name === name);
  if (extraKlass) return extraKlass;

  // Race spells are handled slightly differently
  const race = this.source.ddb.character.spells.race.find((s) => s.definition?.name === name);
  if (race) return race;

  // feat spells are handled slightly differently
  const feat = this.source.ddb.character.spells.feat.find((s) => s.definition?.name === name);
  if (feat) return feat;

  // background spells are handled slightly differently
  if (!this.source.ddbdb.character.spells.background) this.source.ddb.character.spells.background = [];
  const background = this.source.ddb.character.spells.background.find((s) => s.definition?.name === name);
  if (background) return background;

  return undefined;
};

DDBCharacter/* default.prototype._parseCompanion */.Z.prototype._parseCompanion = async function(html, type, originDocument) {
  const ddbCompanionFactory = new DDBCompanionFactory/* default */.Z(this, html, { type, originDocument });
  await ddbCompanionFactory.parse();
  this.companionFactories.push(ddbCompanionFactory);
};

DDBCharacter/* default.prototype._importCompanions */.Z.prototype._importCompanions = async function() {
  for (const factory of this.companionFactories) {
    // eslint-disable-next-line no-await-in-loop
    await factory.updateOrCreateCompanions();
  }
};

DDBCharacter/* default.prototype._getCompanionSpell */.Z.prototype._getCompanionSpell = async function(name) {
  const spell = this.data.spells.find((s) => s.name === name || s.flags.ddbimporter?.originalName === name);
  if (!spell) return;
  const ddbSpell = this._findDDBSpell(spell.flags.ddbimporter?.originalName ?? spell.name);
  if (!ddbSpell) return;
  await this._parseCompanion(ddbSpell.definition.description, "spell", spell);
};

DDBCharacter/* default.prototype._getCompanionFeature */.Z.prototype._getCompanionFeature = async function(featureName) {
  const feature = this.data.features.concat(this.data.actions).find((s) =>
    s.name === featureName || s.flags.ddbimporter?.originalName === featureName
  );
  if (!feature) return;
  const ddbFeature = this.getClassFeature(featureName);
  if (!ddbFeature) return;
  await this._parseCompanion(ddbFeature.definition.description, "feature", feature);
};

DDBCharacter/* default.prototype._getCompanionOption */.Z.prototype._getCompanionOption = async function(parentFeature, childName) {
  const feature = this.data.features.concat(this.data.actions).find((s) =>
    s.name === parentFeature
    || s.flags.ddbimporter?.originalName === parentFeature
    || s.name === `${parentFeature}: ${childName}`
    || s.flags.ddbimporter?.originalName === `${parentFeature}: ${childName}`
  );
  if (!feature) return;
  const ddbOption = this.source.ddb.character.options.class.find((o) => o.definition.name == childName);
  if (!ddbOption) return;
  await this._parseCompanion(ddbOption.definition.description, "feature", feature);
};

DDBCharacter/* default.prototype.generateCompanions */.Z.prototype.generateCompanions = async function() {
  if (!game.modules.get("arbron-summoner")?.active) {
    src_logger/* default.warn */.Z.warn("Companion Parsing requires the Arbron Summoner module");
    return;
  }

  for (const name of settings/* default.COMPANIONS.COMPANION_FEATURES */.Z.COMPANIONS.COMPANION_FEATURES) {
    // eslint-disable-next-line no-await-in-loop
    await this._getCompanionFeature(name);
  }
  for (const name of settings/* default.COMPANIONS.COMPANION_SPELLS */.Z.COMPANIONS.COMPANION_SPELLS) {
    // eslint-disable-next-line no-await-in-loop
    await this._getCompanionSpell(name);
  }
  for (const [parentFeature, childNames] of Object.entries(settings/* default.COMPANIONS.COMPANION_OPTIONS */.Z.COMPANIONS.COMPANION_OPTIONS)) {
    for (const name of childNames) {
      // eslint-disable-next-line no-await-in-loop
      await this._getCompanionOption(parentFeature, name);
    }
  }

  await this._importCompanions();

  this.companions = this.companionFactories.map((factory) => factory.companions);

  src_logger/* default.debug */.Z.debug("parsed companions", {
    factories: this.companionFactories,
    parsed: this.companions,
  });

  await this.addCompanionsToDocuments();
  // different types of companion
  // ranger beast companions, classic and new
  // ranger drake warden
  // ranger other?
  // artificer steel defender
  // artificer homunculus
  // new summon spells
  // classic summons (not handled here)
  // druid circle of fire companion

};


;// CONCATENATED MODULE: ./src/parser/extendParsers.js
// monster parser

// load files with extensions here. this will add the functions to the class















// character parser

// load files with extensions here. this will add the functions to the class





























;// CONCATENATED MODULE: ./src/hooks/init/extendClasses.js


;// CONCATENATED MODULE: ./src/hooks/init/setupLogging.js


function downloadLog() {
  FileHelper/* default.download */.Z.download(JSON.stringify(CONFIG.debug.ddbimporter.log), `ddbimporter-log-data.json`, "application/json");
  setProperty(CONFIG.debug, "ddbimporter.log", []);
}

/* harmony default export */ function setupLogging() {
  const enabledDebugLogging = false;

  const defaults = {
    record: enabledDebugLogging,
    log: [],
    download: downloadLog,
  };

  setProperty(CONFIG.debug, "ddbimporter", defaults);
}

// EXTERNAL MODULE: ./src/muncher/DDBMonsterFactory.js
var DDBMonsterFactory = __webpack_require__(6870);
// EXTERNAL MODULE: ./src/muncher/spells.js + 1 modules
var spells = __webpack_require__(6502);
// EXTERNAL MODULE: ./src/muncher/items.js
var items = __webpack_require__(8638);
// EXTERNAL MODULE: ./src/muncher/vehicles.js + 10 modules
var vehicles = __webpack_require__(1187);
// EXTERNAL MODULE: ./src/muncher/tools.js
var tools = __webpack_require__(8089);
// EXTERNAL MODULE: ./src/muncher/compendiumFolders.js
var compendiumFolders = __webpack_require__(6269);
// EXTERNAL MODULE: ./src/lib/PatreonHelper.js
var PatreonHelper = __webpack_require__(8636);
// EXTERNAL MODULE: ./src/muncher/MuncherSettings.js
var MuncherSettings = __webpack_require__(7004);
// EXTERNAL MODULE: ./src/lib/Settings.js
var Settings = __webpack_require__(5406);
// EXTERNAL MODULE: ./src/muncher/adventure/AdventureMunchHelpers.js
var AdventureMunchHelpers = __webpack_require__(7801);
// EXTERNAL MODULE: ./src/muncher/dae.js
var dae = __webpack_require__(7728);
// EXTERNAL MODULE: ./src/icons/index.js
var icons = __webpack_require__(6547);
// EXTERNAL MODULE: ./vendor/lowdash/isequal.js
var isequal = __webpack_require__(846);
// EXTERNAL MODULE: ./src/lib/Secrets.js
var Secrets = __webpack_require__(2048);
;// CONCATENATED MODULE: ./src/parser/special/conditions.js





function getCondition(conditionName) {
  return dictionary/* default.conditions.find */.Z.conditions.find((condition) => condition.label === conditionName);
}

async function getActiveConditions(actor) {
  const conditions = await Promise.all(DICTIONARY.conditions.filter(async (condition) => {
    const conditionApplied = await game.dfreds.effectInterface.hasEffectApplied(condition.label, actor.uuid);
    return conditionApplied;
  }));
  return conditions;
}

async function effectAppliedAndActive(condition, actor) {
  return actor.effects.some(
    (activeEffect) =>
      activeEffect?.flags?.isConvenient
      && activeEffect?.label == condition.label
      && !activeEffect?.disabled
  );
}

async function getActorConditionStates(actor, ddb, keepLocal = false) {
  const conditions = await Promise.all(dictionary/* default.conditions.filter */.Z.conditions.filter((condition) => Number.isInteger(condition.ddbId)) // only ddb conditions
    .map(async (condition) => {
      const conditionApplied = await effectAppliedAndActive(condition, actor);
      const ddbCondition = ddb.character.conditions.some((conditionState) =>
        conditionState.id === condition.ddbId
        && conditionState.level === condition.levelId
      );
      // eslint-disable-next-line require-atomic-updates
      condition.ddbCondition = ddbCondition;
      // eslint-disable-next-line require-atomic-updates
      condition.applied = conditionApplied;
      // eslint-disable-next-line require-atomic-updates
      condition.needsUpdate = (ddbCondition && !conditionApplied) || (!ddbCondition && conditionApplied && !keepLocal);
      return condition;
    }));
  return conditions;
}

/**
 * Set conditions
 * @param {*} ddb
 * @param {*} actor
 */
async function setConditions(actor, ddb, keepLocal = false) {
  const dfConditionsOn = game.modules.get("dfreds-convenient-effects")?.active;
  const useCEConditions = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "apply-conditions-with-ce");
  if (dfConditionsOn && useCEConditions) {
    const conditionStates = await getActorConditionStates(actor, ddb, keepLocal);
    // console.warn(conditionStates);
    src_logger/* default.debug */.Z.debug(`Condition states for ${actor.name}`, conditionStates);
    await Promise.all(conditionStates.map(async (condition) => {
      // console.warn(condition);
      if (condition.needsUpdate) {
        const state = condition.conditionApplied ? "off" : "on";
        src_logger/* default.info */.Z.info(`Toggling condition to ${state} for ${condition.label} to ${actor.name} (${actor.uuid})`);
        await game.dfreds.effectInterface.toggleEffect(condition.label, { uuids: [actor.uuid] });
      } else {
        const state = condition.conditionApplied ? "on" : "off";
        src_logger/* default.info */.Z.info(`Condition ${condition.label} ignored (currently ${state}) for ${actor.name} (${actor.uuid})`);
      }
      return condition;
    }));
  }
}

;// CONCATENATED MODULE: ./src/parser/special/itemCollections.js
function getItemCollectionItems(actor) {
  const characterId = getProperty(actor, "flags.ddbimporter.dndbeyond.characterId");
  if (!game.modules.get("itemcollection")?.active && !Number.isInteger(characterId)) return [];
  const topLevelItems = actor.items
    .filter((item) =>
      hasProperty(item, "flags.ddbimporter.id")
      && hasProperty(item, "flags.ddbimporter.containerEntityId")
      && item.flags.ddbimporter.containerEntityId === parseInt(characterId)
      && !item.flags.ddbimporter?.ignoreItemImport
    );

  const itemCollectionItems = topLevelItems
    .map((topLevelItem) => {
      const containerId = getProperty(topLevelItem, "flags.ddbimporter.id");
      const containerEntityTypeId = getProperty(topLevelItem, "flags.ddbimporter.entityTypeId");
      const items = (getProperty(topLevelItem.flags, "itemcollection.contentsData") ?? [])
        .map((item) => {
          setProperty(item, "flags.ddbimporter.containerEntityId", containerId);
          setProperty(item, "flags.ddbimporter.containerEntityTypeId", containerEntityTypeId);
          setProperty(item, "flags.ddbimporter.updateDocumentId", topLevelItem.id);
          return item;
        });
      return items;
    })
    .flat();
  return itemCollectionItems;
}

/* eslint-disable no-await-in-loop */
async function addContainerItemsToContainers(ddb, actor) {
  if (!game.modules.get("itemcollection")?.active || !game.settings.get("ddb-importer", "character-update-policy-use-item-containers")) return;

  const topLevelItems = actor.items
    .filter((item) =>
      hasProperty(item, "flags.ddbimporter.id")
      && hasProperty(item, "flags.ddbimporter.containerEntityId")
      && item.flags.ddbimporter.containerEntityId === ddb.character.id
      && !item.flags.ddbimporter?.ignoreItemImport
    );

  for (const topLevelItem of topLevelItems) {
    const itemsToImport = actor.items
      .filter((item) =>
        hasProperty(item, "flags.ddbimporter.containerEntityId")
        && item.flags.ddbimporter.containerEntityId === topLevelItem.flags.ddbimporter.id
      )
      .map((item) => {
        return duplicate(item);
      });

    if (itemsToImport.length > 0) {
      const itemsToDelete = itemsToImport.map((item) => item._id);
      await actor.deleteEmbeddedDocuments("Item", itemsToDelete);
      await topLevelItem.createEmbeddedDocuments("Item", itemsToImport, { keepId: true });
    }

  }
}

async function addContainerItemsToActor(ddb, actor) {
  if (!game.modules.get("itemcollection")?.active || !game.settings.get("ddb-importer", "character-update-policy-use-item-containers")) return;

  const topLevelItems = actor.items
    .filter((item) =>
      hasProperty(item, "flags.ddbimporter.id")
      && hasProperty(item, "flags.ddbimporter.containerEntityId")
      && item.flags.ddbimporter.containerEntityId === ddb.character.id
      && hasProperty(item, "flags.itemcollection.contentsData")
      && item.flags.itemcollection.contentsData.length > 0
      && !item.flags.ddbimporter?.ignoreItemImport
    );

  for (const topLevelItem of topLevelItems) {
    const itemsToImport = duplicate(getProperty(topLevelItem.flags, "itemcollection.contentsData") ?? [])
      .map((item) => {
        if (hasProperty(item, "flags.ddbimporter.updateDocumentId")) {
          delete item.flags.ddbimporter.updateDocumentId;
        }
        return item;
      });
    const itemsToDelete = itemsToImport.map((item) => item._id);
    // const currency = duplicate(topLevelItem.system.currency);
    await topLevelItem.deleteEmbeddedDocuments("Item", itemsToDelete);
    await actor.createEmbeddedDocuments("Item", itemsToImport, { keepId: true });
  }
}

// EXTERNAL MODULE: ./src/lib/DDBProxy.js
var DDBProxy = __webpack_require__(546);
;// CONCATENATED MODULE: ./src/updater/character.js














function getFoundryItems(actor) {
  const characterId = actor.flags.ddbimporter.dndbeyond.characterId;
  const itemCollections = getItemCollectionItems(actor);
  const actorItems = duplicate(actor.items).map((item) => {
    // set the container entity id to the id of the character, if the character is the "container"
    setProperty(item, "flags.ddbimporter.containerEntityId", parseInt(characterId));
    delete item.flags.ddbimporter.updateDocumentId;
    return item;
  });
  return actorItems.concat(itemCollections);
}

async function getUpdateItemIndex() {
  if (hasProperty(CONFIG, "DDBI.update.itemIndex")) return getProperty(CONFIG, "DDBI.update.itemIndex");
  const compendium = await CompendiumHelper/* default.getCompendiumType */.Z.getCompendiumType("item", false);

  const indexFields = [
    "name",
    "type",
    "flags.ddbimporter.definitionId",
    "flags.ddbimporter.definitionEntityTypeId",
  ];
  // eslint-disable-next-line require-atomic-updates
  const itemIndex = await compendium.getIndex({ fields: indexFields });
  setProperty(CONFIG, "DDBI.update.itemIndex", itemIndex);

  return itemIndex;
}

async function getCompendiumItemInfo(item) {
  const index = await getUpdateItemIndex();
  const match = await (0,muncher_import/* looseItemNameMatch */.uc)(item, index, true, false, true);
  return match;
}

// flavor is just useful for debugging
async function updateCharacterCall(actor, path, bodyContent, flavor) {
  const characterId = actor.flags.ddbimporter.dndbeyond.characterId;
  const cobaltCookie = (0,Secrets/* getCobalt */.HF)(actor.id);
  const dynamicSync = settings/* default.STATUS.activeUpdate */.Z.STATUS.activeUpdate();
  const parsingApi = dynamicSync
    ? DDBProxy/* default.getDynamicProxy */.Z.getDynamicProxy()
    : DDBProxy/* default.getProxy */.Z.getProxy();
  const betaKey = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "beta-key");
  const campaignId = (0,Settings/* getCampaignId */.F9)();
  const proxyCampaignId = campaignId === "" ? null : campaignId;
  const coreBody = {
    cobalt: cobaltCookie,
    betaKey,
    characterId,
    campaignId: proxyCampaignId,
    dynamicSync,
    customApiVersion: 5.1,
  };
  const body = { ...coreBody, ...bodyContent };

  const url = dynamicSync
    ? `${parsingApi}/dynamic/update/${path}`
    : `${parsingApi}/proxy/update/${path}`;

  src_logger/* default.debug */.Z.debug("Update info:", {
    url,
    path,
    characterId,
    bodyContent,
    dynamicSync,
    flavor,
  });

  return new Promise((resolve, reject) => {
    fetch(url, {
      method: "POST",
      cache: "no-cache",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(body), // body data type must match "Content-Type" header
    })
      .then((response) => response.json())
      .then((data) => {
        if (!data.success) {
          const errorData = {
            url,
            path,
            errorData: data,
            bodyContent,
            characterId,
            dynamicSync,
            flavor,
          };
          src_logger/* default.error */.Z.error(`Update failed for ${actor.name}:`, errorData);
          ui.notifications.error(`Update failed: (${actor.name}) ${data.message} (see console log (F12) for more details)`);
          resolve(data);
        }
        src_logger/* default.debug */.Z.debug(`${path} updated, response`, data);
        return data;
      })
      .then((data) => resolve(data))
      .catch((error) => {
        const errorData = {
          error,
          bodyContent,
          characterId,
          dynamicSync,
        };
        src_logger/* default.error */.Z.error(`Setting ${path} failed`, errorData);
        src_logger/* default.error */.Z.error(error.stack);
        reject(error);
      });
  });
}

async function updateDDBSpellSlotsPact(actor) {
  return new Promise((resolve) => {
    let spellSlotPackData = {
      spellslots: {},
      pact: true,
    };
    spellSlotPackData.spellslots[`level${actor.system.spells.pact.level}`] = actor.system.spells.pact.value;
    const spellPactSlots = updateCharacterCall(actor, "spell/slots", spellSlotPackData, "Pact Spell Slots");
    resolve(spellPactSlots);
  });
}

async function spellSlotsPact(actor, ddbData) {
  return new Promise((resolve) => {
    if (!game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "sync-policy-spells-slots")) resolve();
    if (
      actor.system.spells.pact.max > 0
      && ddbData.character.character.system.spells.pact.value !== actor.system.spells.pact.value
    ) {
      resolve(updateDDBSpellSlotsPact(actor));
    } else {
      resolve();
    }
  });
}

async function updateDynamicDDBSpellSlots(actor, update) {
  return new Promise((resolve) => {
    let spellSlotData = { spellslots: {}, update: false };
    for (let i = 1; i <= 9; i++) {
      let spellData = actor.system.spells[`spell${i}`];
      if (spellData.max > 0 && update.system.spells[`spell${i}`]) {
        const used = spellData.max - spellData.value;
        spellSlotData.spellslots[`level${i}`] = used;
        spellSlotData["update"] = true;
      }
    }
    if (spellSlotData["update"]) {
      resolve(updateCharacterCall(actor, "spells/slots", spellSlotData, "Spell slots"));
    } else {
      resolve();
    }
  });
}

async function spellSlots(actor, ddbData) {
  return new Promise((resolve) => {
    if (!game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "sync-policy-spells-slots")) resolve();

    let spellSlotData = { spellslots: {}, update: false };
    for (let i = 1; i <= 9; i++) {
      let spellData = actor.system.spells[`spell${i}`];
      if (spellData.max > 0 && ddbData.character.character.system.spells[`spell${i}`].value !== spellData.value) {
        const used = spellData.max - spellData.value;
        spellSlotData.spellslots[`level${i}`] = used;
        spellSlotData["update"] = true;
      }
    }
    if (spellSlotData["update"]) {
      resolve(updateCharacterCall(actor, "spells/slots", spellSlotData, "Spell slots"));
    } else {
      resolve();
    }
  });
}

async function updateDDBCurrency(actor) {
  return new Promise((resolve) => {
    const value = {
      pp: Number.isInteger(actor.system.currency.pp) ? actor.system.currency.pp : 0,
      gp: Number.isInteger(actor.system.currency.gp) ? actor.system.currency.gp : 0,
      ep: Number.isInteger(actor.system.currency.ep) ? actor.system.currency.ep : 0,
      sp: Number.isInteger(actor.system.currency.sp) ? actor.system.currency.sp : 0,
      cp: Number.isInteger(actor.system.currency.cp) ? actor.system.currency.cp : 0,
    };

    resolve(updateCharacterCall(actor, "currency", value, "Currency"));

  });
}

async function currency(actor, ddbData) {
  return new Promise((resolve) => {
    if (!game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "sync-policy-currency")) resolve();

    const value = {
      pp: Number.isInteger(actor.system.currency.pp) ? actor.system.currency.pp : 0,
      gp: Number.isInteger(actor.system.currency.gp) ? actor.system.currency.gp : 0,
      ep: Number.isInteger(actor.system.currency.ep) ? actor.system.currency.ep : 0,
      sp: Number.isInteger(actor.system.currency.sp) ? actor.system.currency.sp : 0,
      cp: Number.isInteger(actor.system.currency.cp) ? actor.system.currency.cp : 0,
    };

    const same = (0,isequal/* isEqual */.X)(ddbData.character.character.system.currency, value);

    if (!same) {
      resolve(updateCharacterCall(actor, "currency", value));
    } else {
      resolve();
    }

  });
}

async function updateDDBXP(actor) {
  return new Promise((resolve) => {
    resolve(updateCharacterCall(actor, "xp", { currentXp: actor.system.details.xp.value ?? 0 }, "XP"));
  });
}

async function xp(actor, ddbData) {
  return new Promise((resolve) => {
    if (!game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "sync-policy-xp")) resolve();
    const same = ddbData.character.character.system.details.xp.value === actor.system.details.xp.value;

    if (!same) {
      resolve(updateDDBXP(actor));
    } else {
      resolve();
    }
  });
}

async function updateDDBHitPoints(actor) {
  return new Promise((resolve) => {
    const temporaryHitPoints = actor.system.attributes.hp.temp ?? 0;
    const removedHitPoints = actor.system.attributes.hp.max - (actor.system.attributes.hp.value ?? 0);
    const hitPointData = {
      removedHitPoints,
      temporaryHitPoints,
    };
    resolve(updateCharacterCall(actor, "hitpoints", hitPointData, "HP"));
  });
}

async function hitPoints(actor, ddbData) {
  return new Promise((resolve) => {
    if (!game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "sync-policy-hitpoints")) resolve();
    const same
      = ddbData.character.character.system.attributes.hp.value === (actor.system.attributes.hp.value ?? 0)
      && ddbData.character.character.system.attributes.hp.temp === (actor.system.attributes.hp.temp ?? 0);

    if (!same) {
      resolve(updateDDBHitPoints(actor));
    } else {
      resolve();
    }
  });
}

async function updateDDBInspiration(actor) {
  return new Promise((resolve) => {
    const inspiration = updateCharacterCall(actor, "inspiration", {
      inspiration: actor.system.attributes.inspiration,
    }, "Inspiration");
    resolve(inspiration);
  });
}

async function inspiration(actor, ddbData) {
  return new Promise((resolve) => {
    if (!game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "sync-policy-inspiration")) resolve();
    const same = ddbData.character.character.system.attributes.inspiration === actor.system.attributes.inspiration;

    if (!same) {
      resolve(updateDDBInspiration(actor));
    } else {
      resolve();
    }
  });
}

async function updateDDBExhaustion(actor) {
  return new Promise((resolve) => {
    let exhaustionData = {
      conditionId: 4,
      addCondition: false,
    };
    if (actor.system.attributes.exhaustion !== 0) {
      exhaustionData["level"] = actor.system.attributes.exhaustion;
      exhaustionData["totalHP"] = actor.system.attributes.hp.max;
      exhaustionData["addCondition"] = true;
    }
    resolve(updateCharacterCall(actor, "condition", exhaustionData, "Exhaustion"));
  });
}


async function exhaustion(actor, ddbData) {
  return new Promise((resolve) => {
    if (!game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "sync-policy-condition")) resolve();
    const same = ddbData.character.character.system.attributes.exhaustion === actor.system.attributes.exhaustion;

    if (!same) {
      resolve(updateDDBExhaustion(actor));
    } else {
      resolve();
    }

  });
}

async function updateDDBCondition(actor, condition) {
  return new Promise((resolve) => {
    const conditionData = {
      conditionId: condition.ddbId,
      addCondition: condition.applied,
      level: null,
      totalHP: actor.system.attributes.hp.max,
    };

    resolve(updateCharacterCall(actor, "condition", conditionData, { condition }));
  });
}

async function conditions(actor, ddbData) {
  return new Promise((resolve) => {
    const dfConditionsOn = game.modules.get("dfreds-convenient-effects")?.active;
    const useCEConditions = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "apply-conditions-with-ce");
    if (!game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "sync-policy-condition") || !dfConditionsOn || !useCEConditions) resolve([]);
    getActorConditionStates(actor, ddbData.ddb).then((conditions) => {
      let results = [];
      conditions.forEach((condition) => {
        // exhaustion handled separately
        if (condition.needsUpdate && condition.ddbId !== 4) {
          results.push(updateDDBCondition(actor, condition));
        }
      });
      resolve(results);
    });
  });
}

async function updateDDBDeathSaves(actor) {
  return new Promise((resolve) => {
    const deathSaveData = {
      failCount: actor.system.attributes.death.failure ?? 0,
      successCount: actor.system.attributes.death.success ?? 0,
    };
    resolve(updateCharacterCall(actor, "deathsaves", deathSaveData, "Death Saves"));
  });
}

async function deathSaves(actor, ddbData) {
  return new Promise((resolve) => {
    if (!game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "sync-policy-deathsaves")) resolve();
    const same = (0,isequal/* isEqual */.X)(ddbData.character.character.system.attributes.death, actor.system.attributes.death);

    if (!same) {
      resolve(updateDDBDeathSaves(actor));
    } else {
      resolve();
    }
  });
}

async function updateDDBHitDice(actor, klass, update) {
  return new Promise((resolve) => {
    if (klass.flags?.ddbimporter?.id) {
      let hitDiceData = {
        classHitDiceUsed: {},
        resetMaxHpModifier: false,
      };
      hitDiceData.classHitDiceUsed[klass.flags.ddbimporter.id] = update.system.hitDiceUsed;
      resolve(updateCharacterCall(actor, "hitdice", { shortRest: hitDiceData }, "Hit Dice"));
    } else {
      resolve();
    }
  });
}

async function hitDice(actor, ddbData) {
  return new Promise((resolve) => {
    if (!game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "sync-policy-hitdice")) resolve();

    const ddbClasses = ddbData.character.classes;

    const klasses = actor.items.filter(
      (item) => item.type === "class" && item.flags.ddbimporter.id && item.flags.ddbimporter.definitionId
    );

    let hitDiceData = {
      classHitDiceUsed: {},
      resetMaxHpModifier: false,
    };

    klasses.forEach((klass) => {
      const classMatch = ddbClasses.find((ddbClass) => ddbClass.flags.ddbimporter.id === klass.flags.ddbimporter.id);
      if (classMatch && classMatch.system.hitDiceUsed !== klass.system.hitDiceUsed) {
        hitDiceData.classHitDiceUsed[klass.flags.ddbimporter.id] = klass.system.hitDiceUsed;
      }
    });

    const same = (0,isequal/* isEqual */.X)({}, hitDiceData.classHitDiceUsed);
    if (!same) {
      resolve(updateCharacterCall(actor, "hitdice", { shortRest: hitDiceData }));
    }

    resolve();
  });
}

async function updateSpellsPrepared(actor, spellPreparedData) {
  return new Promise((resolve) => {
    resolve(updateCharacterCall(actor, "spell/prepare", spellPreparedData, "Spells Prepared"));
  });
}

async function updateDDBSpellsPrepared(actor, spells) {
  let promises = [];

  const preparedSpells = spells.filter((spell) =>
    spell.type === "spell"
    && spell.system.preparation?.mode === "prepared"
    && spell.flags.ddbimporter?.dndbeyond?.characterClassId
    && !spell.flags.ddbimporter.dndbeyond.granted
  ).map((spell) => {
    let spellPreparedData = {
      spellInfo: {
        spellId: spell.flags.ddbimporter.definitionId,
        characterClassId: spell.flags.ddbimporter.dndbeyond.characterClassId,
        entityTypeId: spell.flags.ddbimporter.entityTypeId,
        id: spell.flags.ddbimporter.id,
        prepared: spell.system.preparation.prepared === true,
      }
    };
    src_logger/* default.debug */.Z.debug(`Updating spell prepared state for ${spell.name} to ${spellPreparedData.spellInfo.prepared}`);
    return spellPreparedData;
  });

  preparedSpells.forEach((spellPreparedData) => {
    promises.push(updateSpellsPrepared(actor, spellPreparedData));
  });

  return Promise.all(promises);
}

async function spellsPrepared(actor, ddbData) {
  if (!game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "sync-policy-spells-prepared")) return [];
  const ddbSpells = ddbData.character.spells;

  const preparedSpells = actor.items.filter((item) => {
    const spellMatch = ddbSpells.find((s) =>
      s.name === item.name
      && item.system.preparation?.mode === "prepared"
      && item.flags.ddbimporter?.dndbeyond?.characterClassId
      && item.flags.ddbimporter?.dndbeyond?.characterClassId === s.flags.ddbimporter?.dndbeyond?.characterClassId
    );
    if (!spellMatch) return false;
    const select = item.type === "spell"
      && item.system.preparation?.mode === "prepared"
      && item.system.preparation.prepared !== spellMatch.system.preparation?.prepared;
    return spellMatch && select;
  });

  const results = updateDDBSpellsPrepared(actor, preparedSpells);

  return results;
}

async function updateItemsWithDDBInfo(itemsToAdd) {
  return Promise.all(itemsToAdd.map(async (item) => {
    if (!item.flags.ddbimporter?.definitionId && !item.flags.ddbimporter?.definitionEntityTypeId) {
      const ddbCompendiumMatch = await getCompendiumItemInfo(item);
      src_logger/* default.debug */.Z.debug(`Found item`, ddbCompendiumMatch);
      if (ddbCompendiumMatch
        && ddbCompendiumMatch.flags?.ddbimporter?.definitionId
        && ddbCompendiumMatch.flags?.ddbimporter?.definitionEntityTypeId
      ) {
        src_logger/* default.debug */.Z.debug(`Adding ${item.name} from DDB compendium match:`, ddbCompendiumMatch);
        setProperty(item, "flags.ddbimporter.definitionId", ddbCompendiumMatch.flags.ddbimporter.definitionId);
        setProperty(item, "flags.ddbimporter.definitionEntityTypeId", ddbCompendiumMatch.flags.ddbimporter.definitionEntityTypeId);
        setProperty(item, "name", ddbCompendiumMatch.name);
        setProperty(item, "type", ddbCompendiumMatch.type);
      }
    }
    return item;
  }));
}

function generateItemsToAdd(actor, itemsToAdd) {
  const results = {
    items: [],
    toAdd: [],
    custom: [],
  };

  for (let i = 0; i < itemsToAdd.length; i++) {
    let item = itemsToAdd[i];
    if (item.flags.ddbimporter?.definitionId && item.flags.ddbimporter?.definitionEntityTypeId) {
      const containerEntityId = hasProperty(item, "flags.ddbimporter.containerEntityId")
        ? parseInt(item.flags.ddbimporter.containerEntityId)
        : parseInt(actor.flags.ddbimporter.dndbeyond.characterId);
      const containerEntityTypeId = hasProperty(item, "flags.ddbimporter.containerEntityTypeId")
        ? parseInt(item.flags.ddbimporter.containerEntityTypeId)
        : parseInt("1581111423");
      results.toAdd.push({
        containerEntityId,
        containerEntityTypeId,
        entityId: parseInt(item.flags.ddbimporter.definitionId),
        entityTypeId: parseInt(item.flags.ddbimporter.definitionEntityTypeId),
        quantity: parseInt(item.system.quantity),
      });
    } else {
      results.custom.push(item);
    }
    results.items.push(item);
  }
  return results;
}

async function deleteDDBCustomItems(actor, itemsToDelete) {
  return new Promise((resolve) => {
    let customItemResults = [];
    for (let i = 0; i < itemsToDelete.length; i++) {
      const item = itemsToDelete[i];
      const customData = {
        itemState: "DELETE",
        customValues: {
          characterId: parseInt(actor.flags.ddbimporter.dndbeyond.characterId),
          id: item.flags.ddbimporter.definitionId,
          mappingId: item.flags.ddbimporter.id,
          partyId: null,
        }
      };
      if (getProperty(customData, "customValues.id") !== undefined
        && getProperty(customData, "customValues.mappingId") !== undefined
      ) {
        const result = updateCharacterCall(actor, "custom/item", customData, { name: item.name }).then((data) => {
          setProperty(item, "flags.ddbimporter.delete", data);
          setProperty(item, "flags.ddbimporter.custom", true);
          setProperty(item, "flags.ddbimporter.dndbeyond.isCustomItem", true);
          return item;
        });
        customItemResults.push(result);
      } else {
        src_logger/* default.error */.Z.error(`Custom item ${item.name} is missing metadata, please manually update and re-import`);
        ui.notifications.error(`Custom item ${item.name} is missing metadata, please manually update and re-import`);
      }
    }

    resolve(customItemResults);
  });
}

async function addDDBCustomItems(actor, itemsToAdd) {
  let customItemResults = [];
  for (let i = 0; i < itemsToAdd.length; i++) {
    const item = itemsToAdd[i];
    const containerEntityId = hasProperty(item, "flags.ddbimporter.containerEntityId")
      ? parseInt(item.flags.ddbimporter.containerEntityId)
      : parseInt(actor.flags.ddbimporter.dndbeyond.characterId);
    const containerEntityTypeId = hasProperty(item, "flags.ddbimporter.containerEntityTypeId")
      ? parseInt(item.flags.ddbimporter.containerEntityTypeId)
      : parseInt("1581111423");
    const customData = {
      itemState: "NEW",
      customValues: {
        characterId: parseInt(actor.flags.ddbimporter.dndbeyond.characterId),
        containerEntityId,
        containerEntityTypeId,
        name: item.name,
        description: utils/* default.stripHtml */.Z.stripHtml(item.system.description.value),
        quantity: parseInt(item.system.quantity),
        cost: null,
        weight: Number.isInteger(item.system.weight) ? parseInt(item.system.weight) : 0,
      }
    };
    const result = updateCharacterCall(actor, "custom/item", customData, { name: item.name }).then((data) => {
      setProperty(item, "flags.ddbimporter.id", data.data.addItems[0].id);
      setProperty(item, "flags.ddbimporter.custom", true);
      setProperty(item, "flags.ddbimporter.dndbeyond.isCustomItem", true);
      setProperty(item, "flags.ddbimporter.definitionId", data.data.addItems[0].definition.id);
      setProperty(item, "flags.ddbimporter.containerEntityId", data.data.addItems[0].definition.containerEntityId);
      setProperty(item, "flags.ddbimporter.containerEntityTypeId", data.data.addItems[0].definition.containerEntityTypeId);
      return item;
    });
    customItemResults.push(result);
  }

  return Promise.all(customItemResults);
}

async function addDDBEquipment(actor, itemsToAdd) {
  const ddbEnrichedItems = await updateItemsWithDDBInfo(itemsToAdd);
  const generatedItemsToAddData = generateItemsToAdd(actor, ddbEnrichedItems);

  src_logger/* default.debug */.Z.debug(`Generated items data`, generatedItemsToAddData);

  const addItemData = {
    equipment: generatedItemsToAddData.toAdd,
  };

  const customItems = await addDDBCustomItems(actor, generatedItemsToAddData.custom);
  src_logger/* default.debug */.Z.debug("Adding custom items:", customItems);

  try {
    const customItemResults = await actor.updateEmbeddedDocuments("Item", customItems);
    src_logger/* default.debug */.Z.debug("customItemResults", customItemResults);
  } catch (err) {
    src_logger/* default.error */.Z.error(`Unable to update character with equipment, got the error:`, err);
    src_logger/* default.error */.Z.error(err.stack);
    src_logger/* default.error */.Z.error(`Update payload:`, customItems);
  }

  if (addItemData.equipment.length > 0) {
    const itemResults = await updateCharacterCall(actor, "equipment/add", addItemData, "Adding equipment");
    try {
      const itemUpdates = itemResults.data.addItems
        .filter((addedItem) => ddbEnrichedItems.some((i) =>
          i.flags.ddbimporter
          && i.flags.ddbimporter.definitionId === addedItem.definition.id
          && i.flags.ddbimporter.definitionEntityTypeId === addedItem.definition.entityTypeId
        ))
        .map((addedItem) => {
          let updatedItem = ddbEnrichedItems.find((i) =>
            i.flags.ddbimporter
            && i.flags.ddbimporter.definitionId === addedItem.definition.id
            && i.flags.ddbimporter.definitionEntityTypeId === addedItem.definition.entityTypeId
          );
          setProperty(updatedItem, "flags.ddbimporter.id", addedItem.id);
          setProperty(updatedItem, "flags.ddbimporter.containerEntityId", addedItem.containerEntityId);
          setProperty(updatedItem, "flags.ddbimporter.containerEntityTypeId", addedItem.containerEntityTypeId);
          return updatedItem;
        });

      const characterItems = itemUpdates.filter((i) => !hasProperty(i, "flags.ddbimporter.updateDocumentId"));
      const containerItems = itemUpdates.filter((i) => hasProperty(i, "flags.ddbimporter.updateDocumentId"));
      const containerIds = [...new Set(containerItems.map((i) => i.flags.ddbimporter.updateDocumentId))];

      src_logger/* default.debug */.Z.debug("Character item updates:", characterItems);
      src_logger/* default.debug */.Z.debug("Container item updates:", containerItems);
      src_logger/* default.debug */.Z.debug("Character custom item updates:", customItems);

      try {
        if (characterItems.length > 0) await actor.updateEmbeddedDocuments("Item", characterItems);
        if (customItems.length > 0) await actor.updateEmbeddedDocuments("Item", customItems);
        for (const containerId of containerIds) {
          const containerItemsToUpdate = containerItems
            .filter((i) => i.flags.ddbimporter.updateDocumentId === containerId)
            .map((i) => {
              delete i.flags.ddbimporter.updateDocumentId;
              return i;
            });
          const containerDocument = actor.getEmbeddedDocument("Item", containerId);
          // eslint-disable-next-line max-depth
          if (containerItemsToUpdate.length > 0) {
            src_logger/* default.debug */.Z.debug(`Updating container ${containerDocument.name} with items:`, containerItemsToUpdate);
            // eslint-disable-next-line no-await-in-loop
            await containerDocument.updateEmbeddedDocuments("Item", containerItemsToUpdate);
          }
        }
      } catch (err) {
        src_logger/* default.error */.Z.error(`Unable to update character with equipment, got the error:`, err);
        src_logger/* default.error */.Z.error(`Update payload:`, itemUpdates);
        src_logger/* default.error */.Z.error(`Update custom payload:`, customItems);
        src_logger/* default.error */.Z.error(`Update containerIds:`, containerIds);
      }

    } catch (err) {
      src_logger/* default.error */.Z.error(`Unable to filter updated equipment, got the error:`, err);
      src_logger/* default.error */.Z.error(`itemsToAdd`, itemsToAdd);
      src_logger/* default.error */.Z.error(`ddbEnrichedItems`, ddbEnrichedItems);
      src_logger/* default.error */.Z.error(`equipmentToAdd`, generatedItemsToAddData);
      src_logger/* default.error */.Z.error(`itemResults`, itemResults);
      src_logger/* default.error */.Z.error(`customItems`, customItems);
    }

    return itemResults;
  } else {
    return [];
  }
}

async function addEquipment(actor, ddbData) {
  const syncItemReady = actor.flags.ddbimporter?.syncItemReady;
  if (syncItemReady && !game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "sync-policy-equipment")) return [];
  const ddbItems = ddbData.character.inventory;

  const items = getFoundryItems(actor);
  const itemsToAdd = items.filter((item) =>
    !item.flags.ddbimporter?.action
    && item.system.quantity !== 0
    && dictionary/* default.types.inventory.includes */.Z.types.inventory.includes(item.type)
    && !item.flags.ddbimporter?.custom
    && (!item.flags.ddbimporter?.id
    || !ddbItems.some((s) => s.flags.ddbimporter?.id === item.flags.ddbimporter?.id && s.type === item.type))
  );

  return addDDBEquipment(actor, itemsToAdd);
}


// updates custom names on regular items
async function updateDDBCustomNames(actor, items) {
  let promises = [];

  items.forEach((item) => {
    const customData = {
      customValues: {
        characterId: parseInt(actor.flags.ddbimporter.dndbeyond.characterId),
        contextId: null,
        contextTypeId: null,
        notes: null,
        typeId: 8,
        value: item.name.replaceAll("[Infusion]", "").trim(),
        valueId: `${item.flags.ddbimporter.id}`,
        valueTypeId: `${item.flags.ddbimporter.entityTypeId}`,
      }
    };
    // custom name on standard equipment
    promises.push(updateCharacterCall(actor, "equipment/custom", customData, "Updating custom names"));
  });

  return Promise.all(promises);

}

// updates names of items and actions
async function updateCustomNames(actor, ddbData) {
  const syncItemReady = actor.flags.ddbimporter?.syncItemReady;
  if (syncItemReady && !game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "sync-policy-equipment")) return [];
  const ddbItems = ddbData.character.inventory;

  const foundryItems = getFoundryItems(actor);

  const itemsToName = foundryItems.filter((item) =>
    item.system.quantity !== 0
    && (dictionary/* default.types.inventory.includes */.Z.types.inventory.includes(item.type) || item.flags.ddbimporter?.action)
    && item.flags.ddbimporter?.id
    && ddbItems.some((ddbItem) =>
      ddbItem.flags.ddbimporter?.id === item.flags.ddbimporter.id
      && ddbItem.type === item.type
      && ddbItem.name.replaceAll("[Infusion]", "").trim() !== item.name.replaceAll("[Infusion]", "").trim()
    )
  );

  return updateDDBCustomNames(actor, itemsToName);
}

async function removeDDBEquipment(actor, itemsToRemove) {
  let promises = [];

  itemsToRemove.forEach((item) => {
    if (item.flags?.ddbimporter?.id) {
      src_logger/* default.debug */.Z.debug(`Removing item ${item.name}`);
      if (item.flags?.ddbimporter?.custom) {
        promises.push(deleteDDBCustomItems(actor, [item]));
      } else {
        promises.push(updateCharacterCall(actor, "equipment/remove", { itemId: parseInt(item.flags.ddbimporter.id) }, "Removing equipment"));
      }
    }
  });

  return Promise.all(promises);
}

async function removeEquipment(actor, ddbData) {
  const syncItemReady = actor.flags.ddbimporter?.syncItemReady;
  if (syncItemReady && !game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "sync-policy-equipment")) return [];
  const ddbItems = ddbData.character.inventory;

  const items = getFoundryItems(actor);
  const itemsToRemove = ddbItems.filter((item) =>
    (!items.some((s) => (item.flags.ddbimporter?.id === s.flags.ddbimporter?.id && s.type === item.type) && !s.flags.ddbimporter?.action)
    || items.some((s) => (item.flags.ddbimporter?.id === s.flags.ddbimporter?.id && s.type === item.type) && !s.flags.ddbimporter?.action && s.system.quantity == 0))
    && dictionary/* default.types.inventory.includes */.Z.types.inventory.includes(item.type)
    && item.flags.ddbimporter?.id
  );

  return removeDDBEquipment(actor, itemsToRemove);
}

async function updateDDBEquipmentStatus(actor, updateItemDetails, ddbItems) {
  const itemsToEquip = updateItemDetails.itemsToEquip || [];
  const itemsToAttune = updateItemDetails.itemsToAttune || [];
  const itemsToCharge = updateItemDetails.itemsToCharge || [];
  const itemsToQuantity = updateItemDetails.itemsToQuantity || [];
  const itemsToName = updateItemDetails.itemsToName || [];
  const customItems = updateItemDetails.customItems || [];
  const itemsToMove = updateItemDetails.itemsToMove || [];

  let promises = [];

  itemsToMove.forEach((item) => {
    const itemData = {
      itemId: item.flags.ddbimporter.id,
      containerEntityId: item.flags.ddbimporter.containerEntityId,
      containerEntityTypeId: item.flags.ddbimporter.containerEntityTypeId,
    };
    promises.push(updateCharacterCall(actor, "equipment/move", itemData, { name: item.name }));
  });
  itemsToEquip.forEach((item) => {
    const itemData = { itemId: item.flags.ddbimporter.id, value: item.system.equipped };
    promises.push(updateCharacterCall(actor, "equipment/equipped", itemData, { name: item.name }));
  });
  itemsToAttune.forEach((item) => {
    const itemData = { itemId: item.flags.ddbimporter.id, value: (item.system.attunement === 2) };
    promises.push(updateCharacterCall(actor, "equipment/attuned", itemData, { name: item.name }));
  });
  itemsToCharge.forEach((item) => {
    const itemData = {
      itemId: item.flags.ddbimporter.id,
      charges: parseInt(item.system.uses.max) - parseInt(item.system.uses.value),
    };
    if (Number.isInteger(itemData.charges)) {
      promises.push(updateCharacterCall(actor, "equipment/charges", itemData, { name: item.name }));
    }
  });
  itemsToQuantity.forEach((item) => {
    const itemData = {
      itemId: item.flags.ddbimporter.id,
      quantity: parseInt(item.system.quantity),
    };
    promises.push(updateCharacterCall(actor, "equipment/quantity", itemData, { name: item.name }));
  });
  itemsToName.forEach((item) => {
    // historically items may not have this metadata
    const entityTypeId = item.flags?.ddbimporter?.entityTypeId
      ? item.flags.ddbimporter.entityTypeId
      : ddbItems.find((dItem) => dItem.id === item.flags.ddbimporter.id).entityTypeId;
    const customData = {
      customValues: {
        characterId: parseInt(actor.flags.ddbimporter.dndbeyond.characterId),
        contextId: null,
        contextTypeId: null,
        notes: null,
        typeId: 8,
        value: item.name.replaceAll("[Infusion]", "").trim(),
        valueId: `${item.flags.ddbimporter.id}`,
        valueTypeId: `${entityTypeId}`,
      }
    };
    const flavor = { detail: "Updating Name", name: item.name, originalName: item.flags?.ddbimporter?.originalName };
    promises.push(updateCharacterCall(actor, "equipment/custom", customData, flavor));
  });

  customItems
    .filter((item) => {
      const isValid = getProperty(item, "flags.ddbimporter.id") !== undefined
       && getProperty(item, "flags.ddbimporter.definitionId") !== undefined;
      if (!isValid) {
        src_logger/* default.error */.Z.error(`Custom item ${item.name} is missing metadata, please manually update and re-import`);
        ui.notifications.error(`Custom item ${item.name} is missing metadata, please manually update and re-import`);
      }
      return isValid;
    })
    .forEach((item) => {
      const customData = {
        itemState: "UPDATE",
        customValues: {
          characterId: parseInt(actor.flags.ddbimporter.dndbeyond.characterId),
          id: item.flags.ddbimporter.definitionId,
          mappingId: item.flags.ddbimporter.id,
          name: item.name,
          description: utils/* default.stripHtml */.Z.stripHtml(item.system.description.value),
          // revist these need to be ints
          // weight: `${item.data.weight}`,
          // cost: ${item.data.price},
          cost: null,
          weight: Number.isInteger(item.system.weight) ? parseInt(item.system.weight) : 0,
          quantity: parseInt(item.system.quantity),
        }
      };
      promises.push(updateCharacterCall(actor, "custom/item", customData, "Updating Custom Item"));
    });

  return Promise.all(promises);
}


async function equipmentStatus(actor, ddbData, addEquipmentResults) {
  const syncItemReady = actor.flags.ddbimporter?.syncItemReady;
  if (syncItemReady && !game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "sync-policy-equipment")) return [];
  // reload the actor following potential updates to equipment
  let ddbItems = ddbData.ddb.character.inventory;
  let customDDBItems = ddbData.ddb.character.customItems;
  if (addEquipmentResults?.system) {
    actor = game.actors.get(actor.id);
    ddbItems = ddbItems.concat(addEquipmentResults.system.addItems);
  }

  const foundryItems = getFoundryItems(actor);

  const itemsToEquip = foundryItems.filter((item) =>
    hasProperty(item, "system.equipped")
    && hasProperty(item, "flags.ddbimporter.id")
    && !getProperty(item, "flags.ddbimporter.action")
    && !getProperty(item, "flags.ddbimporter.custom")
    && ddbItems.some((dItem) =>
      getProperty(item, "flags.ddbimporter.id") === dItem.id
      && item.system.equipped !== dItem.equipped
    )
  );
  const itemsToAttune = foundryItems.filter((item) =>
    hasProperty(item, "system.attunement")
    && hasProperty(item, "flags.ddbimporter.id")
    && !getProperty(item, "flags.ddbimporter.action")
    && !getProperty(item, "flags.ddbimporter.custom")
    && ddbItems.some((dItem) =>
      getProperty(item, "flags.ddbimporter.id") === dItem.id
      && ((item.system.attunement === 2) !== dItem.isAttuned)
    )
  );
  const itemsToCharge = foundryItems.filter((item) =>
    hasProperty(item, "system.uses")
    && hasProperty(item, "flags.ddbimporter.id")
    && !getProperty(item, "flags.ddbimporter.action")
    && !getProperty(item, "flags.ddbimporter.custom")
    && ddbItems.some((dItem) =>
      getProperty(item, "flags.ddbimporter.id") === dItem.id
      && Number.isInteger(parseInt(item.system.uses?.max)) && Number.isInteger(parseInt(dItem.limitedUse?.numberUsed))
      && ((parseInt(item.system.uses.max) - parseInt(item.system.uses.value)) !== dItem.limitedUse.numberUsed)
    )
  );
  const itemsToQuantity = foundryItems.filter((item) =>
    hasProperty(item, "system.quantity")
    && item.system.quantity !== 0
    && !getProperty(item, "system.armor.type")
    && ((item.type !== "weapon" && item.type !== "armor") || getProperty(item, "flags.ddbimporter.dndbeyond.stackable"))
    && hasProperty(item, "flags.ddbimporter.id")
    && !getProperty(item, "flags.ddbimporter.action")
    && !getProperty(item, "flags.ddbimporter.custom")
    && ddbItems.some((dItem) =>
      getProperty(item, "flags.ddbimporter.id") === dItem.id
      && item.system.quantity !== dItem.quantity
    )
  );
  // this is for items that have been added and might have a different name
  const itemsToName = foundryItems.filter((item) =>
    hasProperty(item, "flags.ddbimporter.id")
    && item.system?.quantity !== 0
    && !getProperty(item, "flags.ddbimporter.custom")
    && ddbItems.some((dItem) =>
      item.flags.ddbimporter.originalName === dItem.definition.name
      && item.flags.ddbimporter.originalName !== item.name.replaceAll("[Infusion]", "").trim()
      && getProperty(item, "flags.ddbimporter.id") === dItem.id
      && item.name.replaceAll("[Infusion]", "").trim() !== dItem.definition.name
    )
  );

  // update.name || update.data?.description || update.data?.weight || update.data?.price || update.data?.quantity
  const customItems = foundryItems.filter((item) =>
    hasProperty(item, "flags.ddbimporter.id")
    && item.system?.quantity !== 0
    && (getProperty(item, "flags.ddbimporter.custom") === true || getProperty(item, "flags.ddbimporter.isCustom") === true)
    && customDDBItems.some((dItem) => dItem.id === item.flags.ddbimporter.id
      && (
        item.name !== dItem.name
        || utils/* default.stripHtml */.Z.stripHtml(item.system.description.value) != dItem.description
        || (hasProperty(item, "system.quantity") && item.system.quantity != dItem.quantity)
        || (hasProperty(item, "system.weight") && item.system.weight != dItem.weight)
        //  ||
        // item.data.price != dItem.cost
      )
    )
  );

  const itemsToMove = game.modules.get("itemcollection")?.active
    ? foundryItems.filter((item) =>
      hasProperty(item, "flags.ddbimporter.id")
      && !getProperty(item, "flags.ddbimporter.action")
      && hasProperty(item, "flags.ddbimporter.containerEntityId")
      && ddbItems.some((dItem) =>
        item.flags.ddbimporter.id === dItem.id
        && parseInt(item.flags.ddbimporter.containerEntityId) !== parseInt(dItem.containerEntityId)
      ))
    : [];

  const itemsToUpdate = {
    itemsToEquip,
    itemsToAttune,
    itemsToCharge,
    itemsToQuantity,
    itemsToName,
    customItems,
    itemsToMove,
  };

  return updateDDBEquipmentStatus(actor, itemsToUpdate, ddbItems);

}

async function updateActionUseStatus(actor, actionData, actionName) {
  return new Promise((resolve) => {
    resolve(updateCharacterCall(actor, "action/use", actionData, `Action Use for ${actionName}`));
  });
}

async function updateDDBActionUseStatus(actor, actions) {
  let promises = [];
  actions.forEach((action) => {
    const actionData = {
      actionId: action.flags.ddbimporter.id,
      entityTypeId: action.flags.ddbimporter.entityTypeId,
      uses: parseInt(action.system.uses.max) - parseInt(action.system.uses.value)
    };
    promises.push(updateActionUseStatus(actor, actionData, action.name));
  });
  return Promise.all(promises);
}

async function actionUseStatus(actor, ddbData) {
  const syncActionReady = actor.flags.ddbimporter?.syncActionReady;
  if (syncActionReady && !game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "sync-policy-action-use")) return [];

  let ddbActions = ddbData.character.actions;

  const foundryItems = getFoundryItems(actor);

  const actionsToChange = foundryItems.filter((item) =>
    (item.flags.ddbimporter?.action || item.type === "feat")
    && item.flags.ddbimporter?.id && item.flags.ddbimporter?.entityTypeId
    && ddbActions.some((dItem) =>
      item.flags.ddbimporter.id === dItem.flags.ddbimporter.id
      && item.flags.ddbimporter.entityTypeId === dItem.flags.ddbimporter.entityTypeId
      && item.name === dItem.name && item.type === dItem.type
      && Number.isInteger(parseInt(item.system.uses?.value))
      && Number.parseInt(item.system.uses.value) !== Number.parseInt(dItem.system.uses.value)
    )
  );
  const actionChanges = updateDDBActionUseStatus(actor, actionsToChange);

  return actionChanges;
}

async function updateDDBCharacter(actor) {
  const cobaltCheck = await (0,Secrets/* checkCobalt */.B)(actor.id);

  if (cobaltCheck.success) {
    src_logger/* default.debug */.Z.debug(`Cobalt checked`);
  } else {
    src_logger/* default.error */.Z.error(`Cobalt cookie expired, please reset`);
    src_logger/* default.error */.Z.error(cobaltCheck.message);
    throw cobaltCheck.message;
  }

  const characterId = actor.flags.ddbimporter.dndbeyond.characterId;
  const syncId = actor.flags["ddb-importer"]?.syncId ? actor.flags["ddb-importer"].syncId + 1 : 0;

  const ddbCharacterOptions = {
    currentActor: actor,
    characterId,
    resourceSelection: false
  };
  const getOptions = {
    syncId,
    localCobaltPostFix: actor.id,
  };
  const ddbCharacter = new DDBCharacter/* default */.Z(ddbCharacterOptions);
  const activeUpdateState = ddbCharacter.getCurrentDynamicUpdateState();
  await ddbCharacter.disableDynamicUpdates();
  let ddbData = await ddbCharacter.getCharacterData(getOptions);

  if (!ddbCharacter.source.ddb.character.canEdit) {
    src_logger/* default.debug */.Z.debug("Update DDB", { ddbCharacter, ddbData });
    throw new Error("User is not allowed to edit character on D&D Beyond.");
  }

  src_logger/* default.debug */.Z.debug("Current actor:", duplicate(actor));
  src_logger/* default.debug */.Z.debug("DDB Parsed data:", ddbData);

  let singlePromises = []
    .concat(
      currency(actor, ddbData),
      hitPoints(actor, ddbData),
      hitDice(actor, ddbData),
      spellSlots(actor, ddbData),
      spellSlotsPact(actor, ddbData),
      inspiration(actor, ddbData),
      exhaustion(actor, ddbData),
      deathSaves(actor, ddbData),
      xp(actor, ddbData),
    ).flat();

  const singleResults = await Promise.all(singlePromises);
  const spellsPreparedResults = await spellsPrepared(actor, ddbData);
  const actionStatusResults = await actionUseStatus(actor, ddbData);
  const nameUpdateResults = await updateCustomNames(actor, ddbData);
  const addEquipmentResults = await addEquipment(actor, ddbData);
  const removeEquipmentResults = await removeEquipment(actor, ddbData);
  const equipmentStatusResults = await equipmentStatus(actor, ddbData, addEquipmentResults);
  const conditionResults = await conditions(actor, ddbData);
  // if a known/choice spellcaster
  // and new spell/ spells removed
  // for each spell add or remove, e.g.
  // const spellsData = {
  //   characterClassId: 52134801,
  //   spellId: 2019,
  //   id: 136157,
  //   entityTypeId: 435869154,
  //   remove: true,
  // };
  // const spellSlots = updateCharacterCall(actor, "spells", spellsData);
  // promises.push(spellSlots);

  actor.setFlag("ddb-importer", "syncId", syncId);
  await ddbCharacter.setActiveSyncSpellsFlag(true);

  // we can now process item attunements and uses (not yet done)

  const results = singleResults.concat(
    nameUpdateResults,
    addEquipmentResults,
    spellsPreparedResults,
    removeEquipmentResults,
    equipmentStatusResults,
    actionStatusResults,
    conditionResults,
  ).filter((result) => result !== undefined);

  src_logger/* default.debug */.Z.debug("Update results", results);
  await ddbCharacter.updateDynamicUpdates(activeUpdateState);

  return results;
}

// Called when characters are updated
// will dynamically sync status back to DDB
async function activeUpdateActor(actor, update) {
  // eslint-disable-next-line complexity
  return new Promise((resolve) => {

    const promises = [];

    const actorActiveUpdate = actor.flags.ddbimporter?.activeUpdate;

    if (actorActiveUpdate) {
      const syncHP = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "dynamic-sync-policy-hitpoints");
      const syncCurrency = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "dynamic-sync-policy-currency");
      const syncSpellSlots = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "dynamic-sync-policy-spells-slots");
      const syncInspiration = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "dynamic-sync-policy-inspiration");
      const syncConditions = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "dynamic-sync-policy-condition");
      const syncDeathSaves = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "dynamic-sync-policy-deathsaves");
      const syncXP = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "dynamic-sync-policy-xp");


      if (syncHP && update.system?.attributes?.hp) {
        src_logger/* default.debug */.Z.debug("Updating DDB Hitpoints...");
        promises.push(updateDDBHitPoints(actor));
      }
      if (syncCurrency && update.system?.currency) {
        src_logger/* default.debug */.Z.debug("Updating DDB Currency...");
        promises.push(updateDDBCurrency(actor));
      }
      if (syncSpellSlots && update.system?.spells) {
        const spellKeys = Object.keys(update.system.spells);
        if (spellKeys.includes("pact")) {
          src_logger/* default.debug */.Z.debug("Updating DDB SpellSlots Pack...");
          promises.push(updateDDBSpellSlotsPact(actor));
        }
        const spellLevelKeys = ["spell1", "spell2", "spell3", "spell4", "spell5", "spell6", "spell7", "spell8", "spell9"];
        const foundSpells = spellKeys.some((spellKey) => spellLevelKeys.includes(spellKey));
        if (foundSpells) {
          src_logger/* default.debug */.Z.debug("Updating DDB SpellSlots...");
          promises.push(updateDynamicDDBSpellSlots(actor, update));
        }
      }
      if (syncInspiration
        && (update.system?.attributes?.inspiration === true || update.system?.attributes?.inspiration === false)
      ) {
        src_logger/* default.debug */.Z.debug("Updating DDB Inspiration...");
        promises.push(updateDDBInspiration(actor));
      }
      if (syncConditions && update.system?.attributes?.exhaustion) {
        src_logger/* default.debug */.Z.debug("Updating DDB Exhaustion...");
        promises.push(updateDDBExhaustion(actor));
      }
      if (syncDeathSaves && update.system?.attributes?.death) {
        src_logger/* default.debug */.Z.debug("Updating DDB DeathSaves...");
        promises.push(updateDDBDeathSaves(actor));
      }
      if (syncXP && update.system?.attributes?.xp) {
        src_logger/* default.debug */.Z.debug("Updating DDB XP...");
        promises.push(updateDDBXP(actor));
      }
    }
    resolve(promises);

  });
}

const DISABLE_FOUNDRY_UPGRADE = {
  applyFeatures: false,
  addFeatures: false,
  promptAddFeatures: false,
};

async function generateDynamicItemChange(actor, document, update) {
  const updateItemDetails = {
    itemsToEquip: [],
    itemsToAttune: [],
    itemsToCharge: [],
    itemsToQuantity: [],
    itemsToName: [],
    customItems: [],
    itemsToMove: [],
  };

  // console.warn("Document", document);
  // console.warn("ItemUpdate", update);

  if (getProperty(document, "flags.ddbimporter.custom") === true || getProperty(document, "flags.ddbimporter.isCustom") === true) {
    if (update.name || update.system?.description || update.system?.weight || update.system?.price || update.system?.quantity) {
      updateItemDetails.customItems.push(duplicate(document));
    }
  } else {
    if (update.system?.uses) {
      updateItemDetails.itemsToCharge.push(duplicate(document));
    }
    if (update.system?.attunement) {
      updateItemDetails.itemsToAttune.push(duplicate(document));
    }
    if (update.system?.quantity) {
      // if its a weapon or armor we actually need to push a new one
      if (!document.flags.ddbimporter?.dndbeyond?.stackable && update.system.quantity > 1) {
        // Some items are not stackable on DDB

        await document.update({ system: { quantity: 1 } });
        let newDocument = duplicate(document.toObject());
        delete newDocument._id;
        delete newDocument.flags.ddbimporter.id;

        let results = [];
        for (let i = 1; i < update.system.quantity; i++) {
          src_logger/* default.debug */.Z.debug(`Adding item # ${i}`);
          // eslint-disable-next-line no-await-in-loop
          let newDoc = await actor.createEmbeddedDocuments("Item", [newDocument], DISABLE_FOUNDRY_UPGRADE);
          results.push(newDoc);
          // new doc/item push to ddb handled by the add item hook
        }
        return results;
      } else {
        updateItemDetails.itemsToQuantity.push(duplicate(document));
      }
    }
    if (update.system?.equipped) {
      updateItemDetails.itemsToEquip.push(duplicate(document));
    }
    if (update.name) {
      updateItemDetails.itemsToName.push(duplicate(document));
    }
    if (update.flags?.itemcollection?.contentsData && hasProperty(document, "flags.ddbimporter.id")) {
      const newItems = [];
      const moveItems = [];
      for (const item of update.flags.itemcollection.contentsData) {
        setProperty(item, "flags.ddbimporter.containerEntityId", document.flags.ddbimporter.id);
        setProperty(item, "flags.ddbimporter.containerEntityTypeId", document.flags.ddbimporter.entityTypeId);
        if (parseInt(item.flags.ddbimporter.id) === 0) {
          setProperty(item, "flags.ddbimporter.updateDocumentId", document.id);
          newItems.push(item);
        } else {
          moveItems.push(item);
        }
      }

      addDDBEquipment(actor, newItems);
      updateItemDetails.itemsToMove.push(...moveItems);
    }
  }

  src_logger/* default.debug */.Z.debug("UpdateItemDetails", updateItemDetails);

  return updateDDBEquipmentStatus(actor, updateItemDetails, []);

}

async function updateSpellPrep(actor, document) {
  return new Promise((resolve) => {
    const spellSyncFlag = actor.flags.ddbimporter?.activeSyncSpells;
    if (spellSyncFlag) {
      src_logger/* default.debug */.Z.debug("Updating DDB SpellsPrepared...");
      // get spells class
      const klassName = document.flags.ddbimporter?.dndbeyond?.class;
      const klass = actor.items.find((item) => item.name === klassName && item.type === "class");
      if (klass) {
        resolve(updateDDBSpellsPrepared(actor, [document]));
      } else {
        resolve([]);
      }
    } else {
      src_logger/* default.warn */.Z.warn("Unable to sync spell prep status until character is imported or updated to DDB");
      resolve([]);
    }
  });
}

// Called when characters items are updated
// will dynamically sync status back to DDB
async function activeUpdateUpdateItem(document, update) {
  // eslint-disable-next-line complexity
  return new Promise((resolve) => {

    // we check to see if this is actually an embedded item
    const parentActor = document.parent;
    const actorActiveUpdate = parentActor && parentActor.flags.ddbimporter?.activeUpdate;

    if (!parentActor || !actorActiveUpdate) {
      resolve([]);
    } else {
      src_logger/* default.debug */.Z.debug("Preparing to sync item change to DDB...");
      const action = document.flags.ddbimporter?.action || document.type === "feat";
      const syncEquipment = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "dynamic-sync-policy-equipment");
      const syncActionUse = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "dynamic-sync-policy-action-use");
      const syncHD = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "dynamic-sync-policy-hitdice");
      const syncSpellsPrepared = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "dynamic-sync-policy-spells-prepared");
      const isDDBItem = document.flags.ddbimporter?.id;
      const customItem = document.flags.ddbimporter?.custom || false;

      const customNameAllowed = dictionary/* default.types.inventory.includes */.Z.types.inventory.includes(document.type) || document.flags.ddbimporter?.action;
      if (!customItem && update.name && customNameAllowed) {
        updateDDBCustomNames(parentActor, [document.toObject()]);
      }

      src_logger/* default.debug */.Z.debug("active update item details", { action, syncActionUse, isDDBItem });
      // is this a DDB action, or do we treat this as an item?
      if (action && syncActionUse && isDDBItem) {
        if (update.system?.uses) {
          src_logger/* default.debug */.Z.debug("Updating action uses", update);
          updateDDBActionUseStatus(parentActor, [duplicate(document)]);
        } else {
          resolve([]);
        }
      } else if (document.type === "class" && syncHD && update.system?.hitDiceUsed) {
        src_logger/* default.debug */.Z.debug("Updating hitdice on DDB");
        resolve(updateDDBHitDice(parentActor, document, update));
      } else if (document.type === "spell" && syncSpellsPrepared
        && update.system?.preparation && document.system.preparation.mode === "prepared"
      ) {
        src_logger/* default.debug */.Z.debug("Updating DDB SpellsPrepared...");
        updateSpellPrep(parentActor, document).then((results) => {
          src_logger/* default.debug */.Z.debug("Spell prep results", results);
          const failures = results.find((result) => result.success !== true);
          const ddbCharacterOptions = {
            currentActor: parentActor,
            characterId: undefined,
            resourceSelection: false
          };
          // when update is refactored to a class, change this
          const ddbCharacter = new DDBCharacter/* default */.Z(ddbCharacterOptions);
          if (failures) ddbCharacter.setActiveSyncSpellsFlag(false);
          resolve(results);
        });
      } else if (syncEquipment && !action) {
        resolve(generateDynamicItemChange(parentActor, document, update));
      }
    }
  });
}


// Called when characters items are added/deleted
// will dynamically sync status back to DDB
async function activeUpdateAddOrDeleteItem(document, state) {
  return new Promise((resolve) => {
    let promises = [];

    const syncEquipment = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "dynamic-sync-policy-equipment");
    // we check to see if this is actually an embedded item
    const parentActor = document.parent;
    const actorActiveUpdate = parentActor && getProperty(parentActor, "flags.ddbimporter.activeUpdate");

    if (parentActor && actorActiveUpdate && syncEquipment) {
      src_logger/* default.debug */.Z.debug(`Checking to see if ${state.toLowerCase()} can be added to DDB...`);
      const action = document.flags.ddbimporter?.action || ["feat", "class", "subclass", "spell", "background", "race"].includes(document.type);
      if (!action) {
        src_logger/* default.debug */.Z.debug(`Attempting to ${state.toLowerCase()} new Item`, document);

        switch (state) {
          case "CREATE": {
            const characterId = parseInt(parentActor.flags.ddbimporter.dndbeyond.characterId);
            const containerId = document.flags?.ddbimporter?.containerEntityId;
            if (Number.isInteger(containerId) && characterId != parseInt(containerId)) {
              // update item container
              src_logger/* default.debug */.Z.debug(`Moving item from container`, document);
              document.update({
                "flags.ddbimporter.containerEntityId": characterId,
              });
              const itemData = {
                itemId: parseInt(document.flags.ddbimporter.id),
                containerEntityId: characterId,
                containerEntityTypeId: 1581111423,
              };
              const flavor = { summary: "Moving item to character", name: document.name, containerId: duplicate(containerId) };
              promises.push(updateCharacterCall(parentActor, "equipment/move", itemData, flavor));
            } else {
              src_logger/* default.debug */.Z.debug(`Creating item`, document);
              promises.push(addDDBEquipment(parentActor, [document.toObject()]));
            }
            break;
          }
          case "DELETE": {
            const collectionItems = getItemCollectionItems(parentActor);
            const collectionItemDDBIds = collectionItems
              .filter((item) => hasProperty(item, "flags.ddbimporter.id"))
              .map((item) => item.flags.ddbimporter.id);
            if (hasProperty(document, "flags.ddbimporter.id")
              && collectionItemDDBIds.includes(document.flags.ddbimporter.id)
            ) {
              // we don't have to handle deletes as the item collection move is handled above
              src_logger/* default.debug */.Z.debug(`Moving item to container`, document);
            } else {
              promises.push(removeDDBEquipment(parentActor, [document.toObject()]));
            }
            break;
          }
          // no default
        }
      }
    }
    resolve(promises);
  });
}

// called when effects are added/deleted/updated
async function activeUpdateEffectTrigger(document, state) {
  return new Promise((resolve) => {
    let promises = [];

    const syncConditions = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "dynamic-sync-policy-condition");
    // we check to see if this is actually an embedded item
    const parentActor = document.parent;
    const actorActiveUpdate = parentActor && parentActor.flags.ddbimporter?.activeUpdate;

    if (parentActor && actorActiveUpdate && syncConditions) {
      src_logger/* default.debug */.Z.debug(`Preparing to ${state.toLowerCase()} condition on DDB...`);
      // is it a condition?
      // is it a suitable type?
      const isConvenient = document.system?.flags?.isConvenient;
      const condition = getCondition(document.system?.label);
      // exhaustion is a special case, but also a condition effect, handled by character update
      const notExhaustion = condition ? condition.ddbId !== 4 : false;

      if (isConvenient && condition && notExhaustion) {
        src_logger/* default.debug */.Z.debug(`Attempting to ${state.toLowerCase()} Condition`, document);
        switch (state) {
          case "CREATE":
            condition.applied = true;
            promises.push(updateDDBCondition(parentActor, condition));
            break;
          case "UPDATE":
            condition.applied = !document.system.disabled;
            promises.push(updateDDBCondition(parentActor, condition));
            break;
          case "DELETE":
            condition.applied = false;
            promises.push(updateDDBCondition(parentActor, condition));
            break;
          // no default
        }
      }
    }
    resolve(promises);
  });
}

function activateUpdateHooks() {
  // check to make sure we can sync back, currently only works for 1 gm user
  if (settings/* default.STATUS.activeUpdate */.Z.STATUS.activeUpdate()) {
    Hooks.on("updateActor", activeUpdateActor);
    Hooks.on("updateItem", activeUpdateUpdateItem);
    Hooks.on("createItem", (document) => activeUpdateAddOrDeleteItem(document, "CREATE"));
    Hooks.on("deleteItem", (document) => activeUpdateAddOrDeleteItem(document, "DELETE"));
    // conditions syncing relies of Conv Effects
    const dfConditionsOn = game.modules.get("dfreds-convenient-effects")?.active;
    const useCEConditions = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "apply-conditions-with-ce");
    if (dfConditionsOn && useCEConditions) {
      Hooks.on("createActiveEffect", (document) => activeUpdateEffectTrigger(document, "CREATE"));
      Hooks.on("updateActiveEffect", (document) => activeUpdateEffectTrigger(document, "UPDATE"));
      Hooks.on("deleteActiveEffect", (document) => activeUpdateEffectTrigger(document, "DELETE"));
    }
  }
}

// EXTERNAL MODULE: ./src/parser/extras/extras.js
var extras = __webpack_require__(1634);
;// CONCATENATED MODULE: ./src/effects/abilityOverrides.js



function buildBaseOverrideEffect(label) {
  let effect = {
    changes: [],
    duration: {
      seconds: null,
      startTime: null,
      rounds: null,
      turns: null,
      startRound: null,
      startTurn: null,
    },
    origin: "Ability.Override",
    label,
    tint: "",
    disabled: false,
    transfer: true,
    selectedKey: [],
    icon: "icons/svg/anchor.svg",
    flags: {
      dae: { transfer: true },
      ddbimporter: { disabled: false, itemId: null, entityTypeId: null }
    },
  };
  return effect;
}


function abilityOverrideEffects(overrides) {
  let effects = buildBaseOverrideEffect("Ability Overrides");

  dictionary/* default.character.abilities.forEach */.Z.character.abilities.forEach((ability) => {
    if (overrides[ability.value] === 0) return;
    effects.changes.push((0,effects_effects/* generateOverrideChange */.Pk)(overrides[ability.value], 50, `system.abilities.${ability.value}.value`));
  });

  return effects;
}

;// CONCATENATED MODULE: ./src/lib/DDBCharacterManager.js



















class DDBCharacterManager extends FormApplication {
  constructor(options, actor, ddbCharacter = null) {
    super(options);
    this.actor = game.actors.get(actor._id);
    this.migrateMetadata();
    this.actorOriginal = duplicate(this.actor);
    src_logger/* default.debug */.Z.debug("Current Actor (Original):", this.actorOriginal);
    this.result = {};
    this.nonMatchedItemIds = [];
    this.settings = {};
    this.ddbCharacter = ddbCharacter;
  }

  migrateMetadata() {
    if (this.actor.flags?.ddbimporter?.dndbeyond) {
      const url = this.actor.flags.ddbimporter.dndbeyond.url;

      if (url && !this.actor.flags.ddbimporter.characterId) {
        const characterId = DDBCharacter/* default.getCharacterId */.Z.getCharacterId(url);
        if (characterId) {
          this.actor.flags.ddbimporter.dndbeyond.characterId = characterId;
          this.actor.flags.ddbimporter.dndbeyond.url = url;
        } else {
          // clear the url, because it's malformed anyway
          this.actor.flags.ddbimporter.dndbeyond.url = null;
        }
      }
    }
  }

  static renderPopup(type, url) {
    if (settings/* default.POPUPS */.Z.POPUPS[type] && !settings/* default.POPUPS */.Z.POPUPS[type].close) {
      settings/* default.POPUPS */.Z.POPUPS[type].focus();
      settings/* default.POPUPS */.Z.POPUPS[type].location.href = url;
    } else {
      const ratio = window.innerWidth / window.innerHeight;
      const width = Math.round(window.innerWidth * 0.5);
      const height = Math.round(window.innerWidth * 0.5 * ratio);
      settings/* default.POPUPS */.Z.POPUPS[type] = window.open(
        url,
        "ddb_sheet_popup",
        `resizeable,scrollbars,location=no,width=${width},height=${height},toolbar=1`
      );
    }
    return true;
  }

  /**
   * Define default options
   */
  static get defaultOptions() {
    const options = super.defaultOptions;
    options.title = game.i18n.localize("ddb-importer.module-name");
    options.template = "modules/ddb-importer/handlebars/character.hbs";
    options.width = 900;
    options.height = "auto";
    options.classes = ["ddbimporter", "sheet"];
    options.tabs = [{ navSelector: ".tabs", contentSelector: "form", initial: "import" }];

    return options;
  }

  showCurrentTask(title, message = null, isError = false) {
    let element = $(this.html).find(".task-name");
    element.html(`<h2 ${isError ? " style='color:red'" : ""}>${title}</h2>${message ? `<p>${message}</p>` : ""}`);
    $(this.html).parent().parent().css("height", "auto");
  }

  static getCharacterUpdatePolicyTypes(invert = false) {
    let itemTypes = ["background", "race"];

    if (invert) {
      if (!game.settings.get("ddb-importer", "character-update-policy-class")) {
        itemTypes.push("class");
        itemTypes.push("subclass");
      }
      if (!game.settings.get("ddb-importer", "character-update-policy-feat")) itemTypes.push("feat");
      if (!game.settings.get("ddb-importer", "character-update-policy-weapon")) itemTypes.push("weapon");
      if (!game.settings.get("ddb-importer", "character-update-policy-equipment"))
        itemTypes = itemTypes.concat(dictionary/* default.types.equipment */.Z.types.equipment);
      if (!game.settings.get("ddb-importer", "character-update-policy-spell")) itemTypes.push("spell");
    } else {
      if (game.settings.get("ddb-importer", "character-update-policy-class")) {
        itemTypes.push("class");
        itemTypes.push("subclass");
      }
      if (game.settings.get("ddb-importer", "character-update-policy-feat")) itemTypes.push("feat");
      if (game.settings.get("ddb-importer", "character-update-policy-weapon")) itemTypes.push("weapon");
      if (game.settings.get("ddb-importer", "character-update-policy-equipment"))
        itemTypes = itemTypes.concat(dictionary/* default.types.equipment */.Z.types.equipment);
      if (game.settings.get("ddb-importer", "character-update-policy-spell")) itemTypes.push("spell");
    }
    return itemTypes;
  }

  /**
   * Returns a combined array of all items to process, filtered by the user's selection on what to skip and what to include
   * @param {object} result object containing all character items sectioned as individual properties
   * @param {array[string]} sections an array of object properties which should be filtered
   */
  filterItemsByUserSelection(invert = false) {
    let items = [];
    const validItemTypes = DDBCharacterManager.getCharacterUpdatePolicyTypes(invert);

    for (const section of settings/* default.FILTER_SECTIONS */.Z.FILTER_SECTIONS) {
      items = items.concat(this.result[section]).filter((item) => validItemTypes.includes(item.type));
    }
    return items;
  }

  filterActorItemsByUserSelection(invert = false) {
    const validItemTypes = DDBCharacterManager.getCharacterUpdatePolicyTypes(invert);

    const items = this.actorOriginal.items.filter((item) => validItemTypes.includes(item.type));

    return items;
  }

  /**
   * Loops through a characters items and updates flags
   * @param {*} items
   */
  async copySupportedCharacterItemFlags(items) {
    items.forEach((item) => {
      const originalItem = this.actorOriginal.items.find(
        (originalItem) => item.name === originalItem.name && item.type === originalItem.type
      );
      if (originalItem) {
        (0,muncher_import/* copySupportedItemFlags */.uf)(originalItem, item);
      }
    });
  }

  copyExistingJournalNotes() {
    if (!this.actorOriginal) return;
    const journalFields = [
      "notes1name",
      "notes2name",
      "notes3name",
      "notes4name",
      "notes1",
      "notes2",
      "notes3",
      "notes4",
      "notes",
    ];
    journalFields.forEach((field) => {
      if (this.actorOriginal.system.details[field]) {
        this.actor.system.details[field] = this.actorOriginal.system.details[field];
      }
    });
  }

  async copyCharacterItemEffects(items) {
    return new Promise((resolve) => {
      resolve(
        items.map((item) => {
          const originalItem = this.actorOriginal.items.find((originalItem) =>
            item.name === originalItem.name
            && item.type === originalItem.type
            && item.flags?.ddbimporter?.id === originalItem.flags?.ddbimporter?.id
          );
          if (originalItem) {
            if (!item.effects) item.effects = [];
            if (originalItem.effects) {
              src_logger/* default.info */.Z.info(`Copying Effects for ${originalItem.name}`);
              item.effects = originalItem.effects.map((m) => {
                delete m._id;
                return m;
              });
            }
          }
          return item;
        })
      );
    });
  }

  /**
   * Removes items
   * @param {*} items
   * @param {*} itemsToRemove
   */
  static async removeItems(items, itemsToRemove) {
    return new Promise((resolve) => {
      resolve(
        items.filter(
          (item) =>
            !itemsToRemove.some((originalItem) => {
              const originalNameMatch = originalItem.flags?.ddbimporter?.originalItemName
                ? originalItem.flags.ddbimporter.originalItemName === item.name
                : false;
              const nameMatch = item.name === originalItem.name || originalNameMatch;
              return nameMatch && item.type === originalItem.type;
            })
        )
      );
    });
  }

  /**
   * Deletes items from the inventory bases on which sections a user wants to update
   * Possible sections:
   * - class
   * - feat
   * - weapon
   * - equipment
   * - inventory: consumable, loot, tool and backpack
   * - spell
   */
  async clearItemsByUserSelection(excludedList = []) {
    const includedItems = DDBCharacterManager.getCharacterUpdatePolicyTypes();
    // collect all items belonging to one of those inventory item categories
    const ownedItems = this.actor.getEmbeddedCollection("Item");
    const toRemove = ownedItems
      .filter(
        (item) =>
          includedItems.includes(item.type)
          && !excludedList.some((excluded) => excluded._id === item.id)
          && !this.nonMatchedItemIds.includes(item.id)
      )
      .filter((item) => !item.flags.ddbimporter?.ignoreItemImport)
      .map((item) => item.id);

    src_logger/* default.debug */.Z.debug("Removing the following character items", toRemove);
    if (toRemove.length > 0) {
      await this.actor.deleteEmbeddedDocuments("Item", toRemove, {
        itemsWithSpells5e: { alsoDeleteChildSpells: false }
      });
    }
    return toRemove;
  }

  async updateImage(data) {
    src_logger/* default.debug */.Z.debug("Checking if image needs updating");
    // updating the image?
    let imagePath = this.actor.img;
    const decorations = data.character.decorations;
    const userHasPermission = !(game.settings.get("ddb-importer", "restrict-to-trusted") && !game.user.isTrusted);
    if (
      userHasPermission
      && decorations?.avatarUrl
      && decorations.avatarUrl !== ""
      && (!imagePath || imagePath.includes("mystery-man") || this.settings.updatePolicyImage)
    ) {
      this.showCurrentTask("Uploading avatar image");
      const filename = utils/* default.referenceNameString */.Z.referenceNameString(`${data.character.id}-${data.character.name}`);

      const uploadDirectory = game.settings.get("ddb-importer", "image-upload-directory").replace(/^\/|\/$/g, "");
      imagePath = await FileHelper/* default.uploadRemoteImage */.Z.uploadRemoteImage(decorations.avatarUrl, uploadDirectory, filename);
      this.result.character.img = imagePath;
      if (decorations?.frameAvatarUrl && decorations.frameAvatarUrl !== "") {
        const framePath = await FileHelper/* default.uploadRemoteImage */.Z.uploadRemoteImage(decorations.frameAvatarUrl, uploadDirectory, `frame-${filename}`);
        this.result.character.flags.ddbimporter["framePath"] = framePath;
      }
    } else {
      this.result.character.img = this.actor.img;
    }

    if (this.actorOriginal.prototypeToken.texture.src.includes("mystery-man")) {
      setProperty(this.result.character, "prototypeToken.texture.src", this.result.character.img);
    } else if (hasProperty(this.actorOriginal, "prototypeToken.texture.src")) {
      setProperty(this.result.character, "prototypeToken.texture.src", this.actorOriginal.prototypeToken.texture.src);
    }
  }

  /* -------------------------------------------- */

  async getData() {
    // loads settings for actor
    const importSettings = MuncherSettings/* default.getCharacterImportSettings */.Z.getCharacterImportSettings();

    const characterId = this.actor.flags?.ddbimporter?.dndbeyond?.characterId;
    const syncEnabled = characterId && importSettings.tiers.all;

    const trustedUsersOnly = game.settings.get("ddb-importer", "restrict-to-trusted");
    const allowAllSync = game.settings.get("ddb-importer", "allow-all-sync");
    const syncOnly = trustedUsersOnly && allowAllSync && !game.user.isTrusted;

    const localCobalt = (0,Secrets/* isLocalCobalt */.Mi)(this.actor.id);
    const cobaltCookie = (0,Secrets/* getCobalt */.HF)(this.actor.id);
    const cobaltSet = localCobalt && cobaltCookie && cobaltCookie != "";
    const itemCompendium = await CompendiumHelper/* default.getCompendiumType */.Z.getCompendiumType("item", false);

    const dynamicSync = game.settings.get("ddb-importer", "dynamic-sync");
    const updateUser = game.settings.get("ddb-importer", "dynamic-sync-user");
    const gmSyncUser = game.user.isGM && game.user.id == updateUser;
    const dynamicUpdateAllowed = dynamicSync && gmSyncUser && importSettings.tiers.experimentalMid;
    const dynamicUpdateStatus = this.actor.flags?.ddbimporter?.activeUpdate;
    const resourceSelection
      = !hasProperty(this.actor, "flags.ddbimporter.resources.ask")
      || getProperty(this.actor, "flags.ddbimporter.resources.ask") === true;

    const itemsMunched = syncEnabled && itemCompendium ? (await itemCompendium.index.size) !== 0 : false;

    const actorSettings = {
      actor: this.actor,
      localCobalt: localCobalt,
      cobaltSet: cobaltSet,
      syncEnabled: syncEnabled && itemsMunched,
      importAllowed: !syncOnly,
      itemsMunched: itemsMunched,
      dynamicUpdateAllowed,
      dynamicUpdateStatus,
      resourceSelection,
    };

    return mergeObject(importSettings, actorSettings);
  }

  /* -------------------------------------------- */

  activateListeners(html) {
    super.activateListeners(html);
    // watch the change of the import-policy-selector checkboxes
    $(html)
      .find(
        [
          '.import-policy input[type="checkbox"]',
          '.advanced-import-config input[type="checkbox"]',
          '.effect-policy input[type="checkbox"]',
          '.effect-import-config input[type="checkbox"]',
          '.extras-import-config input[type="checkbox"]',
          '.import-config input[type="checkbox"]',
        ].join(",")
      )
      .on("change", (event) => {
        this.html = html;
        MuncherSettings/* default.updateActorSettings */.Z.updateActorSettings(html, event);
      });

    $(html)
      .find("#default-effects")
      .on("click", async (event) => {
        event.preventDefault();
        MuncherSettings/* default.setRecommendedCharacterActiveEffectSettings */.Z.setRecommendedCharacterActiveEffectSettings(html);
      });

    $(html)
      .find(['.resource-selection input[type="checkbox"]'].join(","))
      .on("change", async (event) => {
        const updateData = { flags: { ddbimporter: { resources: { ask: event.currentTarget.checked } } } };
        await this.actor.update(updateData);
      });

    $(html)
      .find('.sync-policy input[type="checkbox"]')
      .on("change", (event) => {
        game.settings.set(
          "ddb-importer",
          "sync-policy-" + event.currentTarget.dataset.section,
          event.currentTarget.checked
        );
      });

    $(html)
      .find("#dndbeyond-character-dynamic-update")
      .on("change", async (event) => {
        const activeUpdateData = { flags: { ddbimporter: { activeUpdate: event.currentTarget.checked } } };
        await this.actor.update(activeUpdateData);
      });

    $(html)
      .find("#dndbeyond-character-import-start")
      .on("click", async (event) => {
        // retrieve the character data from the proxy
        event.preventDefault();
        this.html = html;

        try {
          $(html).find("#dndbeyond-character-import-start").prop("disabled", true);
          this.showCurrentTask("Getting Character data");
          const characterId = this.actor.flags.ddbimporter.dndbeyond.characterId;
          const ddbCharacterOptions = {
            currentActor: this.actor,
            characterId,
            resourceSelection: true,
            enableCompanions: true,
          };
          const getOptions = {
            syncId: null,
            localCobaltPostFix: this.actor.id,
          };
          this.ddbCharacter = new DDBCharacter/* default */.Z(ddbCharacterOptions);
          await this.ddbCharacter.getCharacterData(getOptions);
          src_logger/* default.debug */.Z.debug("import.js getCharacterData result", this.ddbCharacter.source);
          if (game.settings.get("ddb-importer", "debug-json")) {
            FileHelper/* default.download */.Z.download(JSON.stringify(this.ddbCharacter.source), `${characterId}.json`, "application/json");
          }
          if (this.ddbCharacter.source?.success) {
            // begin parsing the character data
            await this.processCharacterData();
            this.showCurrentTask("Loading Character data", "Done.", false);
            src_logger/* default.debug */.Z.debug("Character Load complete", { ddbCharacter: this.ddbCharacter, result: this.result, actor: this.actor, actorOriginal: this.actorOriginal });
            this.close();
          } else {
            this.showCurrentTask(this.ddbCharacter.source.message, null, true);
            return false;
          }
        } catch (error) {
          switch (error.message) {
            case "ImportFailure":
              src_logger/* default.error */.Z.error("Failure", { ddbCharacter: this.ddbCharacter, result: this.result });
              break;
            case "Forbidden":
              this.showCurrentTask("Error retrieving Character: " + error, error, true);
              break;
            default:
              src_logger/* default.error */.Z.error(error);
              src_logger/* default.error */.Z.error(error.stack);
              this.showCurrentTask("Error processing Character: " + error, error, true);
              src_logger/* default.error */.Z.error("Failure", { ddbCharacter: this.ddbCharacter, result: this.result });
              break;
          }
          return false;
        }

        $(html).find("#dndbeyond-character-import-start").prop("disabled", false);
        return true;
      });

    $(html)
      .find("#dndbeyond-character-update")
      .on("click", async () => {
        this.html = html;
        try {
          $(html).find("#dndbeyond-character-update").prop("disabled", true);
          await updateDDBCharacter(this.actor).then((result) => {
            const updateNotes = result
              .flat()
              .filter((r) => r !== undefined)
              .map((r) => r.message)
              .join(" ");
            src_logger/* default.debug */.Z.debug(updateNotes);
            this.showCurrentTask("Update complete", updateNotes);
            $(html).find("#dndbeyond-character-update").prop("disabled", false);
          });
        } catch (error) {
          src_logger/* default.error */.Z.error(error);
          src_logger/* default.error */.Z.error(error.stack);
          this.showCurrentTask("Error updating character", error, true);
        }
      });

    $(html)
      .find("#delete-local-cobalt")
      .on("click", async () => {
        this.html = html;
        try {
          (0,Secrets/* deleteLocalCobalt */.Tl)(this.actor.id);
          $(html).find("#delete-local-cobalt").prop("disabled", true);
        } catch (error) {
          src_logger/* default.error */.Z.error(error);
          src_logger/* default.error */.Z.error(error.stack);
          this.showCurrentTask("Error deleting local cookie", error, true);
        }
      });

    $(html)
      .find("#set-local-cobalt")
      .on("click", async () => {
        this.html = html;
        try {
          new Settings/* DDBCookie */.Bp({}, this.actor, true).render(true);
          $(html).find("#delete-local-cobalt").prop("disabled", false);
        } catch (error) {
          src_logger/* default.error */.Z.error(error);
          src_logger/* default.error */.Z.error(error.stack);
          this.showCurrentTask("Error updating character", error, true);
        }
      });

    $(html)
      .find("#dndbeyond-character-extras-start")
      .on("click", async () => {
        this.html = html;
        try {
          $(html).find("#dndbeyond-character-extras-start").prop("disabled", true);
          this.showCurrentTask("Fetching character data");
          const characterId = this.actor.flags.ddbimporter.dndbeyond.characterId;
          const ddbCharacterOptions = {
            currentActor: this.actor,
            ddb: null,
            characterId,
            resourceSelection: false
          };
          const getOptions = {
            syncId: null,
            localCobaltPostFix: this.actor.id,
          };
          this.ddbCharacter = new DDBCharacter/* default */.Z(ddbCharacterOptions);
          const characterData = await this.ddbCharacter.getCharacterData(getOptions);
          src_logger/* default.debug */.Z.debug("import.js getCharacterData result", characterData);
          const debugJson = game.settings.get("ddb-importer", "debug-json");
          if (debugJson) {
            FileHelper/* default.download */.Z.download(JSON.stringify(characterData), `${characterId}.json`, "application/json");
          }
          if (characterData.success) {
            await (0,extras/* generateCharacterExtras */._)(html, this.ddbCharacter, this.actor);
            this.showCurrentTask("Loading Extras", "Done.", false);
            $(html).find("#dndbeyond-character-extras-start").prop("disabled", true);
            this.close();
          } else {
            this.showCurrentTask(characterData.message, null, true);
            return false;
          }
        } catch (error) {
          switch (error.message) {
            case "ImportFailure":
              src_logger/* default.error */.Z.error("Failure");
              break;
            case "Forbidden":
              this.showCurrentTask("Error retrieving Character: " + error, error, true);
              break;
            default:
              src_logger/* default.error */.Z.error(error);
              src_logger/* default.error */.Z.error(error.stack);
              this.showCurrentTask("Error processing Character: " + error, error, true);
              break;
          }
          return false;
        }
        return true;
      });

    $(html)
      .find("input[name=dndbeyond-url]")
      .on("input", async (event) => {
        this.html = html;
        let URL = event.target.value;
        const characterId = DDBCharacter/* default.getCharacterId */.Z.getCharacterId(URL);

        if (characterId) {
          $(html)
            .find(".dndbeyond-url-status i")
            .replaceWith('<i class="fas fa-check-circle" style="color: green"></i>');
          $(html).find("span.dndbeyond-character-id").text(characterId);
          $(html).find("#dndbeyond-character-import-start").prop("disabled", false);
          $(html).find("#open-dndbeyond-url").prop("disabled", false);

          this.showCurrentTask("Saving reference");
          await this.actor.update({
            "flags.ddbimporter.dndbeyond": {
              url: URL,
              characterId,
            },
          });
          this.showCurrentTask("Status");
        } else {
          this.showCurrentTask("URL format incorrect", "That seems not to be the URL we expected...", true);
          $(html)
            .find(".dndbeyond-url-status i")
            .replaceWith('<i class="fas fa-exclamation-triangle" style="color:red"></i>');
        }
      });

    $(html)
      .find("#open-dndbeyond-url")
      .on("click", () => {
        this.html = html;
        try {
          const characterUrl = this.actor.flags.ddbimporter.dndbeyond.url;
          DDBCharacterManager.renderPopup("json", characterUrl);
        } catch (error) {
          this.showCurrentTask("Error opening JSON URL", error, true);
        }
      });
  }

  async enrichCharacterItems(items) {
    const useInbuiltIcons = game.settings.get("ddb-importer", "character-update-policy-use-inbuilt-icons");
    const useSRDCompendiumItems = game.settings.get("ddb-importer", "character-update-policy-use-srd");
    const useSRDCompendiumIcons = game.settings.get("ddb-importer", "character-update-policy-use-srd-icons");
    const ddbSpellIcons = game.settings.get("ddb-importer", "character-update-policy-use-ddb-spell-icons");
    const ddbItemIcons = game.settings.get("ddb-importer", "character-update-policy-use-ddb-item-icons");
    const ddbGenericItemIcons = game.settings.get("ddb-importer", "character-update-policy-use-ddb-generic-item-icons");
    const daeSRDInstalled = game.modules.get("Dynamic-Effects-SRD")?.active;
    const daeMidiInstalled = game.modules.get("midi-srd")?.active;
    const daeInstalled = game.modules.get("dae")?.active;

    // if we still have items to add, add them
    if (items.length > 0) {
      this.showCurrentTask("Copying existing data flags");
      await this.copySupportedCharacterItemFlags(items);

      if (ddbItemIcons) {
        this.showCurrentTask("Fetching DDB Inventory Images");
        items = await (0,muncher_import/* getDDBEquipmentIcons */.BO)(items, true);
      }

      if (useInbuiltIcons) {
        this.showCurrentTask("Adding SRD Icons");
        items = await (0,icons/* copyInbuiltIcons */.b)(items);
      }

      if (useSRDCompendiumIcons && !useSRDCompendiumItems) {
        this.showCurrentTask("Adding SRD Icons");
        items = await (0,muncher_import/* copySRDIcons */.u4)(items);
      }

      if (ddbSpellIcons) {
        this.showCurrentTask("Fetching DDB Spell School Images");
        items = await (0,muncher_import/* getDDBSpellSchoolIcons */.pV)(items, true);
      }

      if (ddbGenericItemIcons) {
        this.showCurrentTask("Fetching DDB Generic Item Images");
        items = await (0,muncher_import/* getDDBGenericItemIcons */.m$)(items, true);
      }

      if (this.settings.activeEffectCopy) {
        this.showCurrentTask("Copying Item Active Effects");
        items = await this.copyCharacterItemEffects(items);
      }

      if (this.settings.daeEffectCopy && daeInstalled && (daeSRDInstalled || daeMidiInstalled)) {
        this.showCurrentTask("Importing DAE Effects");
        items = await (0,dae/* addItemsDAESRD */.$n)(items);
      }

      if (daeInstalled && (this.settings.addItemEffects || this.settings.addCharacterEffects)) {
        items = await (0,muncher_import/* addItemEffectIcons */.oU)(items);
      }

      items = await (0,muncher_import/* retainExistingIcons */.X9)(items);
    }

    items = items.map((item) => {
      if (!item.effects) item.effects = [];
      return item;
    });

    return Promise.all(items);
  }

  async createCharacterItems(items, keepIds) {
    const options = duplicate(settings/* default.DISABLE_FOUNDRY_UPGRADE */.Z.DISABLE_FOUNDRY_UPGRADE);
    if (keepIds) options["keepId"] = true;

    // we have to break these out into class and non-class because of
    // https://gitlab.com/foundrynet/foundryvtt/-/issues/5312
    const klassItems = items.filter((item) => ["class", "subclass"].includes(item.type));
    const nonKlassItems = items.filter((item) => !["class", "subclass"].includes(item.type));

    if (klassItems.length > 0) {
      src_logger/* default.debug */.Z.debug(`Adding the following class items, keep Ids? ${keepIds}`, { options, items: duplicate(klassItems) });
      await this.actor.createEmbeddedDocuments("Item", klassItems, options);
    }
    if (nonKlassItems.length > 0) {
      src_logger/* default.debug */.Z.debug(`Adding the following non-class items, keep Ids? ${keepIds}`, { options, items: duplicate(nonKlassItems) });
      await this.actor.createEmbeddedDocuments("Item", nonKlassItems, options);
    }
  }

  async importCharacterItems(items, keepIds = false) {
    if (items.length > 0) {
      this.showCurrentTask("Adding items to character");

      const newItems = items.filter((i) => !i._id || i._id === null || i._id === undefined);
      const updateItems = items.filter((i) => i._id && i._id !== null && i._id !== undefined);

      await this.createCharacterItems(newItems, false);
      await this.createCharacterItems(updateItems, keepIds);
    }
  }

  async keepNonDDBItems(ddbItems) {
    const lastImportId = getProperty(this.actorOriginal, "flags.ddbimporter.importId");
    if (this.settings.ignoreNonDDBItems) {
      const items = this.actor.getEmbeddedCollection("Item");
      await items.forEach((item) => {
        const ddbMatchedItem = ddbItems.some((ddbItem) =>
          item.name === ddbItem.name
          && item.type === ddbItem.type
          && item.flags?.ddbimporter?.id === ddbItem.flags?.ddbimporter?.id
        );
        if (!ddbMatchedItem) {
          // if item not replaced by compendium swap or
          if (item.flags?.ddbimporter?.importId !== lastImportId) {
            this.nonMatchedItemIds.push(item.id);
          }
        }
      });
    }
  }

  // checks for existing items, and depending on options will keep or replace with imported item
  async mergeExistingItems(items) {
    if (this.actorOriginal.flags.ddbimporter) {
      const ownedItems = this.actor.getEmbeddedCollection("Item");

      let nonMatchedItems = [];
      let matchedItems = [];

      await items.forEach((item) => {
        let ddbMatchedItem = ownedItems.find((owned) => {
          const simpleMatch
            = item.name === owned.name
            && item.type === owned.type
            && item.flags?.ddbimporter?.id === owned.flags?.ddbimporter?.id;
          const isChoice
            = hasProperty(item, "flags.ddbimporter.dndbeyond.choice.choiceId")
            && hasProperty(owned, "flags.ddbimporter.dndbeyond.choice.choiceId");
          const choiceMatch = isChoice
            ? item.flags.ddbimporter.dndbeyond.choice.choiceId
              === owned.flags.ddbimporter.dndbeyond.choice.choiceId
            : true;
          const overrideDetails = getProperty(owned, "flags.ddbimporter.overrideItem");
          const overrideMatch
            = overrideDetails
            && item.name === overrideDetails.name
            && item.type === overrideDetails.type
            && item.flags?.ddbimporter?.id === overrideDetails.ddbId;

          return (simpleMatch && choiceMatch) || overrideMatch;
        });

        if (ddbMatchedItem) {
          if (hasProperty(ddbMatchedItem, "flags.ddbimporter.overrideId")) {
            setProperty(item, "flags.ddbimporter.overrideId", ddbMatchedItem.flags.ddbimporter.overrideId);
            if ((hasProperty(ddbMatchedItem, "flags.ddbimporter.overrideItem"))) {
              setProperty(item, "flags.ddbimporter.overrideItem", ddbMatchedItem.flags.ddbimporter.overrideItem);
            }
          }
          if (!ddbMatchedItem.flags.ddbimporter?.ignoreItemImport) {
            item["_id"] = ddbMatchedItem["id"];
            if (ddbMatchedItem.flags.ddbimporter?.ignoreIcon) {
              src_logger/* default.debug */.Z.debug(`Retaining icons for ${item.name}`);
              item.flags.ddbimporter.matchedImg = ddbMatchedItem.img;
              item.flags.ddbimporter.ignoreIcon = true;
            }
            if (getProperty(ddbMatchedItem, "flags.ddbimporter.retainResourceConsumption")) {
              src_logger/* default.debug */.Z.debug(`Retaining resources for ${item.name}`);
              item.system.consume = deepClone(ddbMatchedItem.system.consume);
              item.flags.ddbimporter.retainResourceConsumption = true;
              if (hasProperty(ddbMatchedItem, "flags.link-item-resource-5e")) {
                setProperty(item, "flags.link-item-resource-5e", ddbMatchedItem.flags["link-item-resource-5e"]);
              }
            }

            matchedItems.push(item);
          }
        } else {
          nonMatchedItems.push(item);
        }
      });

      src_logger/* default.debug */.Z.debug("Finished retaining items");
      return nonMatchedItems.concat(matchedItems);
    } else {
      return items;
    }
  }

  async fetchCharacterItems() {
    const magicItemsInstalled = game.modules.get("magicitems")?.active;
    const itemsWithSpellsInstalled = game.modules.get("items-with-spells-5e")?.active;
    // items for actor
    let items = [];

    // process spells for magic items
    if ((magicItemsInstalled || itemsWithSpellsInstalled) && Array.isArray(this.result.itemSpells)) {
      this.showCurrentTask("Preparing magicitem spells");
      src_logger/* default.debug */.Z.debug("Preparing magicitem spells");
      await (0,muncher_import/* addMagicItemSpells */.ah)(this.result);
    }

    src_logger/* default.debug */.Z.debug("Calculating items to create and update...");
    this.showCurrentTask("Calculating items to create and update...");
    items = this.filterItemsByUserSelection();

    src_logger/* default.debug */.Z.debug("Checking existing items for details...");
    this.showCurrentTask("Checking existing items for details...");

    items = await this.mergeExistingItems(items);
    await this.keepNonDDBItems(items);

    src_logger/* default.debug */.Z.debug("Removing found items...");
    this.showCurrentTask("Clearing items for recreation...");
    await this.clearItemsByUserSelection();

    // If there is no magicitems module fall back to importing the magic
    // item spells as normal spells fo the character
    if (!magicItemsInstalled && !itemsWithSpellsInstalled) {
      src_logger/* default.debug */.Z.debug("No magic items module(s) found, adding spells to sheet.");
      items.push(
        this.result.itemSpells.filter((item) => {
          const active = item.flags.ddbimporter.dndbeyond && item.flags.ddbimporter.dndbeyond.active === true;
          if (!active) src_logger/* default.warn */.Z.warn(`Missing active flag on item spell ${item.name}`);
          return active;
        })
      );
      items = items.flat();
    }
    src_logger/* default.debug */.Z.debug("Finished item fetch");
    return items;
  }

  async processCharacterItems(items) {
    let compendiumItems = [];
    let srdCompendiumItems = [];
    let overrideCompendiumItems = [];
    let individualCompendiumItems = [];

    // First we do items that are individually marked as override
    const individualOverrideItems = items.filter((item) => {
      const overrideId = getProperty(item, "flags.ddbimporter.overrideId");
      return overrideId !== undefined && overrideId !== "NONE";
    });

    if (individualOverrideItems.length > 0) {
      const individualOverrideCompendiumItems = await (0,muncher_import/* getIndividualOverrideItems */.pt)(individualOverrideItems);
      individualCompendiumItems = individualOverrideCompendiumItems;
      // remove existing items from those to be imported
      src_logger/* default.info */.Z.info("Removing matching Override compendium items");
      items = await DDBCharacterManager.removeItems(items, individualCompendiumItems);
    }

    /**
     * First choice is override compendium
     */
    if (this.settings.useOverrideCompendiumItems) {
      src_logger/* default.info */.Z.info("Removing matching Override compendium items");
      const compendiumOverrideItems = await (0,muncher_import/* getCompendiumItems */.pI)(items, "custom");
      overrideCompendiumItems = compendiumOverrideItems;
      // remove existing items from those to be imported
      items = await DDBCharacterManager.removeItems(items, overrideCompendiumItems);
    }

    /**
     * If SRD is selected, we prefer this
     */
    if (this.settings.useSRDCompendiumItems) {
      src_logger/* default.info */.Z.info("Removing compendium items");
      const compendiumFeatureItems = await (0,muncher_import/* getSRDCompendiumItems */.wW)(items, "features");
      const compendiumInventoryItems = await (0,muncher_import/* getSRDCompendiumItems */.wW)(items, "inventory");
      const compendiumSpellItems = await (0,muncher_import/* getSRDCompendiumItems */.wW)(items, "spells");

      srdCompendiumItems = compendiumItems.concat(
        compendiumInventoryItems,
        compendiumSpellItems,
        compendiumFeatureItems
      );
      // remove existing items from those to be imported
      items = await DDBCharacterManager.removeItems(items, srdCompendiumItems);
    }

    if (this.settings.useExistingCompendiumItems) {
      src_logger/* default.info */.Z.info("Removing compendium items");
      const compendiumFeatureItems = await (0,muncher_import/* getCompendiumItems */.pI)(items, "features");
      const compendiumInventoryItems = await (0,muncher_import/* getCompendiumItems */.pI)(items, "inventory");
      const compendiumSpellItems = await (0,muncher_import/* getCompendiumItems */.pI)(items, "spells");
      const compendiumClassItems = await (0,muncher_import/* getCompendiumItems */.pI)(items, "classes");
      const compendiumSubClassItems = await (0,muncher_import/* getCompendiumItems */.pI)(items, "subclasses");
      const compendiumRaceItems = await (0,muncher_import/* getCompendiumItems */.pI)(items, "races");
      const compendiumTraitsItems = await (0,muncher_import/* getCompendiumItems */.pI)(items, "traits");
      const compendiumBackgroundsItems = await (0,muncher_import/* getCompendiumItems */.pI)(items, "backgrounds");

      compendiumItems = compendiumItems.concat(
        compendiumInventoryItems,
        compendiumSpellItems,
        compendiumFeatureItems,
        compendiumClassItems,
        compendiumSubClassItems,
        compendiumRaceItems,
        compendiumTraitsItems,
        compendiumBackgroundsItems,
      );
      // remove existing items from those to be imported
      items = await DDBCharacterManager.removeItems(items, compendiumItems);
    }

    // import remaining items to character
    if (items.length > 0) {
      this.showCurrentTask("Adding DDB generated items");
      src_logger/* default.debug */.Z.debug(`Adding DDB generated items...`, items);
      items = await this.enrichCharacterItems(items);
      await this.importCharacterItems(items, true);
    }

    // now import any compendium items that we matched
    if (this.settings.useExistingCompendiumItems) {
      this.showCurrentTask("Adding DDB compendium items");
      src_logger/* default.info */.Z.info("Adding DDB compendium items:", compendiumItems);
      await this.createCharacterItems(compendiumItems, false);
    }

    if (this.settings.useSRDCompendiumItems) {
      this.showCurrentTask("Adding SRD compendium items");
      src_logger/* default.info */.Z.info("Adding SRD compendium items:", srdCompendiumItems);
      await this.createCharacterItems(srdCompendiumItems, false);
    }

    if (this.settings.useOverrideCompendiumItems) {
      this.showCurrentTask("Adding Override compendium items");
      src_logger/* default.info */.Z.info("Adding Override compendium items:", overrideCompendiumItems);
      await this.createCharacterItems(overrideCompendiumItems, false);
    }

    if (individualCompendiumItems.length > 0) {
      this.showCurrentTask("Adding Individual Override compendium items");
      src_logger/* default.info */.Z.info("Adding Individual Override compendium items:", individualCompendiumItems);
      await this.createCharacterItems(individualCompendiumItems, false);
    }

    src_logger/* default.debug */.Z.debug("Finished importing items");
  }

  async preActiveEffects() {
    this.effectBackup = duplicate(this.actor.effects);
    for (const e of this.effectBackup) {
      if (e.origin?.includes(".Item.")) {
        // eslint-disable-next-line no-await-in-loop
        const parent = await fromUuid(e.origin);
        src_logger/* default.debug */.Z.debug("Effect Backup flags", { e, parent });
        if (parent) setProperty(e, "flags.ddbimporter.type", parent.type);
      }
    }
    await this.actor.deleteEmbeddedDocuments("ActiveEffect", [], { deleteAll: true });
  }

  async processActiveEffects() {
    src_logger/* default.debug */.Z.debug("Removing active effects");

    // remove current active effects
    const excludedItems = this.filterActorItemsByUserSelection(true);
    const ignoredItemIds = this.actorOriginal.items
      .filter((item) =>
        item.effects
        && item.effects.length > 0
        && (item.flags.ddbimporter?.ignoreItemImport
          || excludedItems.some((ei) => ei._id === item._id)
          || this.nonMatchedItemIds.includes(item._id)
        )
      )
      .map((item) => item._id);

    const itemEffects = this.effectBackup.filter((ae) =>
      ae.origin?.includes(".Item.")
    );
    const ignoredEffects = this.effectBackup.filter((ae) =>
      ignoredItemIds.includes(ae.origin?.split(".").slice(-1)[0])
    );
    const coreStatusEffects = this.effectBackup.filter((ae) => {
      const status = getProperty(ae, "flags.core.statusId");
      const itemEffect = ae.origin?.includes(".Item.");
      return status && String(status).trim() !== "" && !itemEffect;
    });
    // effects on the character that are not from items, or corestatuses
    // nor added by ddb importer
    const charEffects = this.effectBackup.filter((ae) =>
      !ignoredItemIds.some((id) => ae._id === id)
      && !ae.flags.ddbimporter?.characterEffect
      && !ae.flags?.core?.statusId
      && !ae.origin?.includes(".Item.")
    );
    // effects that are added by the ddb importer that are not item effects
    const ddbGeneratedCharEffects = this.effectBackup.filter((ae) =>
      !ae.origin?.includes(".Item.") && ae.flags.ddbimporter?.characterEffect
    );

    const spellEffects = [];
    for (const e of itemEffects) {
      const isOther = coreStatusEffects.some((ae) => ae._id === e._id)
        || charEffects.some((ae) => ae._id === e._id)
        || ddbGeneratedCharEffects.some((ae) => ae._id === e._id);
      if (!isOther && getProperty(e, "flags.ddbimporter.type") === "spell") {
        spellEffects.push(e);
      }
    }

    const remainingEffects = this.effectBackup
      .filter((e) =>
        // remove existing active item effects
        !itemEffects.map((ae) => ae._id).includes(e._id)
        // clear down ddb generated character effects such as skill bonuses
        && !ddbGeneratedCharEffects.map((ae) => ae._id).includes(e._id)
        // ignored effects always remain
        && !ignoredEffects.map((ae) => ae._id).includes(e._id)
        // clear down char effects
        && !charEffects.map((ae) => ae._id).includes(e._id)
        // clear down status effects
        && !coreStatusEffects.map((ae) => ae._id).includes(e._id)
        // ignore spell effects
        && !spellEffects.map((ae) => ae._id).includes(e._id)
      );

    src_logger/* default.debug */.Z.debug("Effect Removal Results", {
      ignoredItemIds, itemEffects, ignoredEffects, charEffects, coreStatusEffects, spellEffects,
      ddbGeneratedCharEffects, remainingEffects, backupEffects: this.effectBackup,
    });

    // are we trying to retain existing effects?
    if (this.settings.activeEffectCopy) {
      // add retained character effects to result
      const effects = ignoredEffects.concat(charEffects, coreStatusEffects, spellEffects, remainingEffects);
      this.result.character.effects = this.result.character.effects.concat(effects);
    } else {
      this.result.character.effects = this.result.character.effects.concat(ignoredEffects);
    }
  }

  fixUpCharacterEffects() {
    let abilityOverrides = abilityOverrideEffects(this.result.character.flags.ddbimporter.dndbeyond.abilityOverrides);
    if (abilityOverrides.changes.length > 0) {
      this.result.character.effects = this.result.character.effects.concat(abilityOverrides);
    }
    this.result.character.effects = this.result.character.effects.filter((e) => e !== undefined);
    this.result.character.effects.forEach((effect) => {
      const origins = ["Ability.Override", "AC", `Actor.${this.actor.flags.ddbimporter.dndbeyond.characterId}`];
      if (origins.includes(effect.origin)) {
        effect.origin = `Actor.${this.actor.id}`;
      }
    });
  }

  async addImportIdToItems() {
    const importId = this.importId;
    function addImportId(items) {
      return items.map((item) => {
        setProperty(item, "flags.ddbimporter.importId", importId);
        return item;
      });
    }
    this.result.actions = addImportId(this.result.actions);
    this.result.classes = addImportId(this.result.classes);
    this.result.features = addImportId(this.result.features);
    this.result.inventory = addImportId(this.result.inventory);
    this.result.itemSpells = addImportId(this.result.itemSpells);
    this.result.spells = addImportId(this.result.spells);
  }

  async resetActor() {
    await this.actor.deleteEmbeddedDocuments("Item", [], {
      deleteAll: true,
      itemsWithSpells5e: { alsoDeleteChildSpells: false },
    });
    await this.actor.deleteEmbeddedDocuments("ActiveEffect", [], { deleteAll: true });
    await this.actor.update(this.actorOriginal, { recursive: true, keepId: true });
  }

  getSettings() {
    this.settings = {
      updatePolicyHP: game.settings.get("ddb-importer", "character-update-policy-hp"),
      updatePolicyHitDie: game.settings.get("ddb-importer", "character-update-policy-hit-die"),
      updatePolicyCurrency: game.settings.get("ddb-importer", "character-update-policy-currency"),
      updatePolicyBio: game.settings.get("ddb-importer", "character-update-policy-bio"),
      updatePolicySpellUse: game.settings.get("ddb-importer", "character-update-policy-spell-use"),
      updatePolicyLanguages: game.settings.get("ddb-importer", "character-update-policy-languages"),
      updatePolicyImage: game.settings.get("ddb-importer", "character-update-policy-image"),
      activeEffectCopy: game.settings.get("ddb-importer", "character-update-policy-active-effect-copy"),
      daeEffectCopy: game.settings.get("ddb-importer", "character-update-policy-dae-effect-copy"),
      addItemEffects: game.settings.get("ddb-importer", "character-update-policy-add-item-effects"),
      addCharacterEffects: game.settings.get("ddb-importer", "character-update-policy-add-character-effects"),
      ignoreNonDDBItems: game.settings.get("ddb-importer", "character-update-policy-ignore-non-ddb-items"),
      useExistingCompendiumItems: game.settings.get("ddb-importer", "character-update-policy-use-existing"),
      useSRDCompendiumItems: game.settings.get("ddb-importer", "character-update-policy-use-srd"),
      useOverrideCompendiumItems: game.settings.get("ddb-importer", "character-update-policy-use-override"),
    };
  }

  async processCharacterData() {
    this.getSettings();
    this.result = duplicate(this.ddbCharacter.data);

    // disable active sync
    const activeUpdateState = this.ddbCharacter.getCurrentDynamicUpdateState();
    await this.ddbCharacter.disableDynamicUpdates();

    try {
      await addContainerItemsToActor(this.ddbCharacter.source.ddb, this.actor);

      this.importId = randomID();
      setProperty(this.result.character, "flags.ddbimporter.importId", this.importId);
      await this.addImportIdToItems();

      // handle active effects
      this.showCurrentTask("Calculating Active Effect Changes");
      this.fixUpCharacterEffects();
      await this.preActiveEffects();
      // we need to process the items first to find out if we are ignoring any effects
      let items = await this.fetchCharacterItems();
      await this.processActiveEffects();

      // update image
      await this.updateImage(this.ddbCharacter.source.ddb);

      // manage updates of basic character data more intelligently
      // revert some data if update not wanted
      if (!this.settings.updatePolicyHP) {
        this.result.character.system.attributes.hp = this.actorOriginal.system.attributes.hp;
      }
      if (!this.settings.updatePolicyHitDie) {
        this.result.character.system.attributes.hd = this.actorOriginal.system.attributes.hd;
        this.result.classes = this.result.classes.map((klass) => {
          const originalKlass = this.actorOriginal.items.find(
            (original) => original.name === klass.name && original.type === "class"
          );
          if (originalKlass) {
            klass.system.hitDiceUsed = originalKlass.system.hitDiceUsed;
          }
          return klass;
        });
      }
      if (!this.settings.updatePolicyCurrency) {
        this.result.character.system.currency = this.actorOriginal.system.currency;
      }
      if (!this.settings.updatePolicyBio) {
        const bioUpdates = ["alignment", "appearance", "background", "biography", "bond", "flaw", "ideal", "trait"];
        bioUpdates.forEach((option) => {
          this.result.character.system.details[option] = this.actorOriginal.system.details[option];
        });
      }
      if (!this.settings.updatePolicySpellUse) {
        this.result.character.system.spells = this.actorOriginal.system.spells;
      }
      if (!this.settings.updatePolicyLanguages) {
        this.result.character.system.traits.languages = this.actorOriginal.system.traits.languages;
      }
      // if resource mode is in disable and not asking, then we use the previous resources
      if (
        hasProperty(this.result.character, "flags.ddbimporter.resources.ask")
        && !this.result.character.flags.ddbimporter.resources.ask
        && this.result.character.flags.ddbimporter.resources.type === "disable"
      ) {
        this.result.character.system.resources = this.actorOriginal.system.resources;
      }

      // flag as having items ids
      this.result.character.flags.ddbimporter["syncItemReady"] = true;
      this.result.character.flags.ddbimporter["syncActionReady"] = true;
      this.result.character.flags.ddbimporter["activeUpdate"] = false;
      this.result.character.flags.ddbimporter["activeSyncSpells"] = true;
      // remove unneeded flags (used for character parsing)
      this.result.character.flags.ddbimporter.dndbeyond["templateStrings"] = null;
      this.result.character.flags.ddbimporter.dndbeyond["characterValues"] = null;
      this.result.character.flags.ddbimporter.dndbeyond["proficiencies"] = null;
      this.result.character.flags.ddbimporter.dndbeyond["proficienciesIncludingEffects"] = null;
      this.result.character.flags.ddbimporter.dndbeyond["effectAbilities"] = null;
      this.result.character.flags.ddbimporter.dndbeyond["abilityOverrides"] = null;
      setProperty(this.result.character.flags, "ddb-importer.version", CONFIG.DDBI.version);

      if (this.actorOriginal.flags.dnd5e?.wildMagic === true) {
        this.result.character.flags.dnd5e["wildMagic"] = true;
      }

      // midi fixes
      const actorOnUseMacroName = getProperty(this.result.character, "flags.midi-qol.onUseMacroName");
      if (!actorOnUseMacroName || actorOnUseMacroName === "") {
        setProperty(this.result.character, "flags.midi-qol.onUseMacroName", "[postActiveEffects]");
      }

      // basic import
      this.showCurrentTask("Updating core character information");
      src_logger/* default.debug */.Z.debug("Character data importing: ", this.result.character);
      await this.actor.update(this.result.character);

      // copy existing journal notes
      this.copyExistingJournalNotes();

      // items import
      await this.processCharacterItems(items);

      if (this.settings.activeEffectCopy) {
        // find effects with a matching name that existed on previous actor
        // and that have a different active state and activate them
        const targetEffects = this.actor.effects.filter((ae) => {
          const previousEffectDiff = this.actorOriginal.effects.find(
            (oae) => oae.label === ae.label && oae.disabled !== ae.disabled
          );
          if (previousEffectDiff) return true;
          return false;
        });
        const updatedEffects = targetEffects.map((ae) => {
          return { _id: ae._id, disabled: !ae.disabled };
        });
        await this.actor.updateEmbeddedDocuments("ActiveEffect", updatedEffects);
      }

      await this.ddbCharacter.autoLinkResources();
      await setConditions(this.actor, this.ddbCharacter.source.ddb, this.settings.activeEffectCopy);
      await addContainerItemsToContainers(this.ddbCharacter.source.ddb, this.actor);

    } catch (error) {
      src_logger/* default.error */.Z.error("Error importing character: ", { error, ddbCharacter: this.ddbCharacter, result: this.result });
      src_logger/* default.error */.Z.error(error.stack);
      this.showCurrentTask("Error importing character, attempting rolling back, see console (F12) for details.", error, true);
      await this.resetActor();
      throw new Error("ImportFailure");
    } finally {
      await this.ddbCharacter.updateDynamicUpdates(activeUpdateState);
      this.actor.render();
    }
  }
}

async function importCharacter(actor, html) {
  try {
    const actorData = actor.toObject();
    const characterId = actorData.flags.ddbimporter.dndbeyond.characterId;

    const ddbCharacterOptions = {
      currentActor: actor,
      characterId,
      resourceSelection: true
    };
    const getOptions = {
      syncId: null,
      localCobaltPostFix: actorData._id,
    };
    const ddbCharacter = new DDBCharacter/* default */.Z(ddbCharacterOptions);
    await ddbCharacter.getCharacterData(getOptions);

    src_logger/* default.debug */.Z.debug("import.js importCharacter getCharacterData result", ddbCharacter.source);
    if (game.settings.get("ddb-importer", "debug-json")) {
      FileHelper/* default.download */.Z.download(JSON.stringify(ddbCharacter.source), `${characterId}.json`, "application/json");
    }
    if (ddbCharacter.source.success) {
      // begin parsing the character data
      const importer = new DDBCharacterManager(DDBCharacterManager.defaultOptions, actorData, ddbCharacter);
      importer.html = html ? html : utils/* default.htmlToDoc */.Z.htmlToDoc("");
      await importer.processCharacterData();
      importer.showCurrentTask("Loading Character data", "Done.", false);
      src_logger/* default.info */.Z.info("Loading Character data");
      return true;
    } else {
      src_logger/* default.error */.Z.error("Error Loading Character data", { message: ddbCharacter.source.message, ddbCharacter });
      return false;
    }
  } catch (error) {
    switch (error.message) {
      case "ImportFailure":
        src_logger/* default.error */.Z.error("Failure");
        break;
      case "Forbidden":
        src_logger/* default.error */.Z.error("Error retrieving Character: ", error);
        break;
      default:
        src_logger/* default.error */.Z.error("Error processing Character: ", error);
        src_logger/* default.error */.Z.error(error.stack);
        break;
    }
    return false;
  }
}

async function importCharacterById(characterId, html) {
  const actor = await Actor.create({
    name: "New Actor",
    type: "character",
    flags: {
      ddbimporter: {
        dndbeyond: {
          characterId: characterId,
          url: `https://www.dndbeyond.com/characters/${characterId}`,
        },
      },
    },
  });

  const result = await importCharacter(actor, html);
  return result;
}

;// CONCATENATED MODULE: ./src/parser/encounters/DDBEncounters.js









class DDBEncounters {

  constructor() {
    this.encounters = [];
  }

  static DIFFICULTY_LEVELS = [
    { id: null, name: "No challenge", color: "grey" },
    { id: 1, name: "Easy", color: "green" },
    { id: 2, name: "Medium", color: "brown" },
    { id: 3, name: "Hard", color: "orange" },
    { id: 4, name: "Deadly", color: "red" },
  ];

  static async getEncounterData() {
    const cobaltCookie = (0,Secrets/* getCobalt */.HF)();
    const betaKey = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "beta-key");
    const parsingApi = DDBProxy/* default.getProxy */.Z.getProxy();
    const debugJson = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "debug-json");

    const body = {
      cobalt: cobaltCookie,
      betaKey: betaKey,
    };

    return new Promise((resolve, reject) => {
      fetch(`${parsingApi}/proxy/encounters`, {
        method: "POST",
        mode: "cors",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(body), // body data type must match "Content-Type" header
      })
        .then((response) => response.json())
        .then((data) => {
          if (!data.success) {
            DDBEncounterMunch.munchNote(`API Failure: ${data.message}`);
            reject(data.message);
          }
          if (debugJson) {
            FileHelper/* default.download */.Z.download(JSON.stringify(data), `encounters-raw.json`, "application/json");
          }
          return data;
        })
        .then((data) => {
          DDBEncounterMunch.munchNote(`Retrieved ${data.data.length} encounters, starting parse...`, true, false);
          src_logger/* default.info */.Z.info(`Retrieved ${data.data.length} encounters`);
          resolve(data.data);
        })
        .catch((error) => reject(error));
    });
  }

  async parseEncounters() {
    this.encounters = await DDBEncounters.getEncounterData();
    src_logger/* default.debug */.Z.debug("Fetched encounters", this.encounters);
    DDBEncounterMunch.munchNote(`Fetched Available DDB Encounters`);
    DDBEncounterMunch.munchNote("");
    return this.encounters;
  }

  async filterEncounters(campaignId) {
    const campaigns = await (0,Settings/* getAvailableCampaigns */.s1)();
    const campaignIds = campaigns.map((c) => c.id);
    const allEncounters = this.encounters.length !== 0 ? this.encounters : await this.parseEncounters();

    src_logger/* default.debug */.Z.debug(`${allEncounters.length} encounters`, allEncounters);
    src_logger/* default.debug */.Z.debug("CampaignIds", campaignIds);
    if (!campaignId || campaignId === "" || !campaignIds.includes(parseInt(campaignId))) return allEncounters;
    src_logger/* default.debug */.Z.debug(`CampaignId to find ${campaignId}`, { allEncounters, campaignId });
    const filteredEncounters = allEncounters.filter((encounter) => encounter.campaign?.id == campaignId);
    src_logger/* default.debug */.Z.debug(`${filteredEncounters.length} filtered encounters`, filteredEncounters);
    return filteredEncounters;
  }
}

;// CONCATENATED MODULE: ./src/parser/encounters/DDBEncounterMunch.js












class DDBEncounterMunch extends Application {

  constructor(options = {}) {
    super(options);
    this.encounter = {};
    this.img = "";
    this.sceneId = "";
    this.journal = undefined;
    this.combat = undefined;
    this.tokens = [];
    this.folders = {};
    this.ddbEncounters = new DDBEncounters();
  }

  static SCENE_IMG = [
    { name: "Bar", img: "modules/ddb-importer/img/encounters/bar.webp" },
    { name: "Cobbles", img: "modules/ddb-importer/img/encounters/cobbles.webp" },
    { name: "Dungeon", img: "modules/ddb-importer/img/encounters/dungeon.png" },
    { name: "Grass", img: "modules/ddb-importer/img/encounters/grass.webp" },
    { name: "Snow", img: "modules/ddb-importer/img/encounters/snow.webp" },
    { name: "Stone", img: "modules/ddb-importer/img/encounters/stone.webp" },
    { name: "Void", img: "modules/ddb-importer/img/encounters/void.webp" },
  ];

  /**
   * Display information when Munching
   * @param {*} note
   * @param {*} nameField
   * @param {*} monsterNote
   */
  static munchNote(note, nameField = false, monsterNote = false) {
    if (nameField) {
      $("#munching-task-name").text(note);
      $("#ddb-importer-monsters").css("height", "auto");
    } else if (monsterNote) {
      $("#munching-task-monster").text(note);
      $("#ddb-importer-monsters").css("height", "auto");
    } else {
      $("#munching-task-notes").text(note);
      $("#ddb-importer-monsters").css("height", "auto");
    }
  }

  static get defaultOptions() {
    const options = super.defaultOptions;
    options.baseApplication = "DDBEncounterMuncher";
    options.id = "ddb-importer-encounters";
    options.template = "modules/ddb-importer/handlebars/encounters.hbs";
    options.resizable = false;
    options.height = "auto";
    options.width = 800;
    options.title = "MrPrimate's DDB Encounter Muncher";
    options.classes = ["ddb-muncher", "sheet"];
    options.tabs = [{ navSelector: ".tabs", contentSelector: "div", initial: "settings" }];
    return options;
  }

  async parseEncounter(id) {
    src_logger/* default.debug */.Z.debug(`Looking for Encounter "${id}"`);
    if (this.ddbEncounters.encounters.length === 0) return this.encounter;
    const monsterPack = CompendiumHelper/* default.getCompendiumType */.Z.getCompendiumType("monster", false);
    await monsterPack.getIndex({ fields: ["name", "flags.ddbimporter.id"] });

    const encounter = this.ddbEncounters.encounters.find((e) => e.id == id.trim());

    let goodMonsterIds = [];
    let missingMonsterIds = [];
    src_logger/* default.debug */.Z.debug("Parsing encounter", encounter);
    encounter.monsters.forEach((monster) => {
      const id = monster.id;
      const monsterInPack = monsterPack.index.find((f) => f.flags?.ddbimporter?.id == id);
      if (monsterInPack) {
        goodMonsterIds.push({ ddbId: id, name: monsterInPack.name, id: monsterInPack._id, quantity: monster.quantity });
      } else {
        missingMonsterIds.push({ ddbId: id, quantity: monster.quantity });
      }
    });

    let goodCharacterData = [];
    let missingCharacterData = [];
    encounter.players
      .filter((character) => !character.hidden)
      .forEach((character) => {
        const characterInGame = game.actors.find(
          (actor) =>
            actor.flags?.ddbimporter?.dndbeyond?.characterId
            && actor.flags.ddbimporter.dndbeyond.characterId == character.id
        );
        if (characterInGame) {
          goodCharacterData.push({ id: characterInGame.id, name: characterInGame.name, ddbId: character.id });
        } else {
          missingCharacterData.push({ ddbId: character.id, name: character.name });
        }
      });

    const difficulty = DDBEncounters.DIFFICULTY_LEVELS.find((level) => level.id == encounter.difficulty);

    this.encounter = {
      id,
      name: encounter.name,
      inProgress: encounter.inProgress,
      turnNum: encounter.turnNum,
      roundNum: encounter.roundNum,
      difficulty,
      description: encounter.description,
      rewards: encounter.rewards,
      summary: encounter.flavorText,
      campaign: encounter.campaign,
      monsters: encounter.monsters,
      characters: encounter.players,
      goodMonsterIds,
      missingMonsterIds,
      goodCharacterData,
      missingCharacterData,
      missingMonsters: missingMonsterIds.length !== 0,
      missingCharacters: missingCharacterData.length !== 0,
    };

    this.folders = {};

    src_logger/* default.debug */.Z.debug("Current encounter", this.encounter);

    return this.encounter;
  }

  resetEncounter(html) {
    const nameHtml = html.find("#ddb-encounter-name");
    const summaryHtml = html.find("#ddb-encounter-summary");
    const charactersHtml = html.find("#ddb-encounter-characters");
    const monstersHtml = html.find("#ddb-encounter-monsters");
    const difficultyHtml = html.find("#ddb-encounter-difficulty");
    const rewardsHtml = html.find("#ddb-encounter-rewards");
    const progressHtml = html.find("#ddb-encounter-progress");

    nameHtml[0].innerHTML = `<p id="ddb-encounter-name"><i class='fas fa-question'></i> <b>Encounter:</b></p>`;
    summaryHtml[0].innerHTML = `<p id="ddb-encounter-summary"><i class='fas fa-question'></i> <b>Summary:</b></p>`;
    charactersHtml[0].innerHTML = `<p id="ddb-encounter-characters"><i class='fas fa-question'></i> <b>Characters:</b></p>`;
    monstersHtml[0].innerHTML = `<p id="ddb-encounter-monsters"><i class='fas fa-question'></i> <b>Monsters:</b></p>`;
    difficultyHtml[0].innerHTML = `<p id="ddb-encounter-difficulty"><i class='fas fa-question'></i> <b>Difficulty:</b></p>`;
    rewardsHtml[0].innerHTML = `<p id="ddb-encounter-rewards"><i class='fas fa-question'></i> <b>Rewards:</b></p>`;
    progressHtml[0].innerHTML = `<p id="ddb-encounter-progress"><i class='fas fa-question'></i> <b>In Progress:</b></p>`;

    $("#ddb-importer-encounters").css("height", "auto");
    $("#encounter-button").prop("disabled", true);
    $("#encounter-button").prop("innerText", "Import Encounter");
    $("#encounter-import-policy-use-ddb-save").prop("disabled", true);
    this.encounter = {};
    this.journal = undefined;
    this.combat = undefined;
    this.tokens = [];
  }

  async importMonsters() {
    const importMonsters = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "encounter-import-policy-missing-monsters");

    if (importMonsters && this.encounter.missingMonsters && this.encounter.missingMonsterIds.length > 0) {
      src_logger/* default.debug */.Z.debug("Importing missing monsters from DDB");
      const monsterFactory = new DDBMonsterFactory/* default */.Z({ munchNote: DDBEncounterMunch.munchNote });
      await monsterFactory.processIntoCompendium(this.encounter.missingMonsterIds.map((monster) => monster.ddbId));
      src_logger/* default.debug */.Z.debug("Finised Importing missing monsters from DDB");
    }

    const monsterPack = CompendiumHelper/* default.getCompendiumType */.Z.getCompendiumType("monster", false);
    await monsterPack.getIndex({ fields: ["name", "flags.ddbimporter.id"] });
    const compendiumName = CompendiumHelper/* default.getCompendiumLabel */.Z.getCompendiumLabel("monster");

    let monstersToAddToWorld = [];
    this.encounter.monsterData = [];
    this.encounter.worldMonsters = [];
    let journalMonsterInfo = new Map();
    this.encounter.monsters.forEach((monster) => {
      const id = monster.id;
      const monsterInPack = monsterPack.index.find((f) => f.flags?.ddbimporter?.id == id);
      if (monsterInPack) {
        let monsterData = {
          ddbId: id,
          name: monsterInPack.name,
          id: monsterInPack._id,
          quantity: monster.quantity,
          journalLink: `@Compendium[${compendiumName}.${monsterInPack._id}]{${monsterInPack.name}}`,
        };
        if (journalMonsterInfo.has(monsterData.ddbId)) {
          monsterData = journalMonsterInfo.get(monsterData.ddbId);
          monsterData.quantity += monster.quantity;
        }
        journalMonsterInfo.set(monsterData.ddbId, monsterData);

        for (let i = 0; i < monster.quantity; i++) {
          let addData = deepClone(monsterData);
          addData.quantity = 1;
          addData.uniqueId = monster.uniqueId;
          addData.initiative = monster.initiative;
          addData.currentHitPoints = monster.currentHitPoints;
          addData.maximumHitPoints = monster.maximumHitPoints;
          addData.temporaryHitPoints = monster.temporaryHitPoints;
          addData.ddbName = monster.name ? monster.name : monsterInPack.name;
          monstersToAddToWorld.push(addData);
        }
      }
    });
    this.encounter.monsterData = Object.values(journalMonsterInfo);

    const encounterMonsterFolder = await utils/* default.getFolder */.Z.getFolder(
      "npc",
      this.encounter.name,
      "D&D Beyond Encounters",
      "#6f0006",
      "#98020a",
      false
    );

    src_logger/* default.debug */.Z.debug("Trying to import monsters from compendium", monstersToAddToWorld);
    await AdventureMunchHelpers/* default.asyncForEach */.Z.asyncForEach(monstersToAddToWorld, async (actor) => {
      let worldActor = game.actors.find(
        (a) => a.folder?.id == encounterMonsterFolder.id && a.flags?.ddbimporter?.id == actor.ddbId
      );
      if (!worldActor) {
        src_logger/* default.info */.Z.info(
          `Importing monster ${actor.name} with DDB ID ${actor.ddbId} from ${monsterPack.metadata.name} with id ${actor.id}`
        );
        try {
          worldActor = await game.actors.importFromCompendium(monsterPack, actor.id, {
            folder: encounterMonsterFolder.id,
          });
        } catch (err) {
          src_logger/* default.error */.Z.error(err);
          src_logger/* default.warn */.Z.warn(`Unable to import actor ${actor.name} with id ${actor.id} from DDB Compendium`);
          src_logger/* default.debug */.Z.debug(
            `Failed on: game.actors.importFromCompendium(monsterCompendium, "${actor.id}", { folder: "${encounterMonsterFolder.id}" });`
          );
        }
      }
      this.encounter.worldMonsters.push(mergeObject(actor, { id: worldActor.id }));
    });

    return new Promise((resolve) => {
      resolve(this.encounter.worldMonsters);
    });
  }

  async importCharacters(html) {
    const importCharacters = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "encounter-import-policy-missing-characters");
    if (importCharacters && this.encounter.missingCharacters) {
      await AdventureMunchHelpers/* default.asyncForEach */.Z.asyncForEach(this.encounter.missingCharacterData, async (character) => {
        await importCharacterById(character.ddbId, html);
      });
    }
  }

  async createJournalEntry() {
    src_logger/* default.debug */.Z.debug(`Creating journal entry`);
    const journal = {
      name: this.encounter.name,
      flags: {
        ddbimporter: {
          encounterId: this.encounter.id,
        },
      },
    };

    const importJournal = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "encounter-import-policy-create-journal");
    if (importJournal) {
      const journalFolder = await utils/* default.getFolder */.Z.getFolder(
        "journal",
        this.encounter.name,
        "D&D Beyond Encounters",
        "#6f0006",
        "#98020a",
        false
      );
      journal.folder = journalFolder.id;
      journal.content = `<h1>${this.encounter.name}</h1>`;
      if (this.encounter.summary && this.encounter.summary != "") {
        journal.content += `<h2>Summary</h2>${this.encounter.summary}`;
      }
      if (this.encounter.monsterData && this.encounter.monsterData.length > 0) {
        journal.content += `<h2>Monsters</h2><ul>`;
        this.encounter.monsterData.forEach((monster) => {
          journal.content += `<li><p>${monster.journalLink} x${monster.quantity}</p></li>`;
        });
        journal.content += `</ul>`;
      }
      if (this.encounter.difficulty && this.encounter.difficulty != "") {
        journal.content += `<h2>Difficulty: <span style="color: ${this.encounter.difficulty.color}">${this.encounter.difficulty.name}</span></h3>`;
      }
      if (this.encounter.description && this.encounter.description != "") {
        journal.content += `<h2>Description</h2>${this.encounter.description}`;
      }
      if (this.encounter.rewards && this.encounter.rewards != "") {
        journal.content += `<h2>Rewards</h2>${this.encounter.rewards}`;
      }

      let worldJournal = game.journal.find(
        (a) => a.folder == journalFolder.id && a.flags?.ddbimporter?.encounterId == this.encounter.id
      );
      if (!worldJournal) {
        src_logger/* default.info */.Z.info(`Importing journal ${journal.name}`);
        try {
          worldJournal = await JournalEntry.create(journal);
        } catch (err) {
          src_logger/* default.error */.Z.error(err);
          src_logger/* default.warn */.Z.warn(`Unable to create journal ${journal.name}`);
        }
      } else {
        src_logger/* default.info */.Z.info(`Updating journal ${journal.name}`);
        journal._id = worldJournal.id;
        await worldJournal.update(journal);
      }
      this.journal = worldJournal;
    }

    return new Promise((resolve) => {
      resolve(journal);
    });
  }


  async createNewScene() {
    this.folders["scene"] = await utils/* default.getFolder */.Z.getFolder(
      "scene",
      this.encounter.name,
      "D&D Beyond Encounters",
      "#6f0006",
      "#98020a",
      false
    );

    let sceneData = {
      name: this.encounter.name,
      flags: {
        ddbimporter: {
          encounterId: this.encounter.id,
          encounters: true,
        },
      },
      width: 1000,
      height: 1000,
      grid: {
        type: 1,
        size: 100,
        distance: 5,
        units: "ft",
      },
      padding: 0.25,
      initial: {
        x: 500,
        y: 500,
        scale: 0.57,
      },
      img: this.img,
      tokenVision: false,
      fogExploration: false,
      folder: this.folders["scene"].id,
    };

    return sceneData;

  }

  async createScene() {
    const importDDBIScene = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "encounter-import-policy-create-scene");
    const useExistingScene = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "encounter-import-policy-existing-scene");

    if (!importDDBIScene && !useExistingScene) return undefined;

    let sceneData;
    let worldScene;

    if (importDDBIScene) {
      src_logger/* default.debug */.Z.debug(`Creating scene for encounter "${this.encounter.name}""`);
      sceneData = await this.createNewScene();
    } else if (useExistingScene) {
      worldScene = game.scenes.find((s) => s.id == this.sceneId);
      if (worldScene) {
        sceneData = worldScene.toObject();
        src_logger/* default.debug */.Z.debug(`Using existing scene "${worldScene.name}" for encounter "${this.encounter.name}""`, { worldScene, sceneData });
      } else {
        src_logger/* default.warn */.Z.warn(`Unable to find scene ${this.sceneId}, creating a new scene `);
        throw new Error(`Unable to find scene ${this.sceneId}, creating a new scene `);
      }
      this.scene = worldScene;
    }

    if (sceneData) {
      let tokenData = [];
      const useDDBSave
        = this.encounter.inProgress && game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "encounter-import-policy-use-ddb-save");
      const xSquares = sceneData.width / sceneData.grid.size;
      const ySquares = sceneData.height / sceneData.grid.size;
      const midSquareOffset = sceneData.grid.size / 2;
      const widthPaddingOffset = sceneData.width * sceneData.padding;
      const heightPaddingOffset = sceneData.height * sceneData.padding;
      const xPCOffset = sceneData.grid.size * (xSquares - 1);
      const xStartPixelMonster = widthPaddingOffset + midSquareOffset;
      const xStartPixelPC = xStartPixelMonster + xPCOffset;
      const yStartPixel = heightPaddingOffset + midSquareOffset;
      let characterCount = 0;
      this.encounter.characters
        .filter((character) => !character.hidden)
        .forEach(async (character) => {
          src_logger/* default.info */.Z.info(`Generating token ${character.name} for ${this.encounter.name}`);
          const characterInGame = game.actors.find(
            (actor) =>
              actor.flags?.ddbimporter?.dndbeyond?.characterId
              && actor.flags.ddbimporter.dndbeyond.characterId == character.id
          );
          if (characterInGame) {
            const onScene = useExistingScene && worldScene.tokens
              .some((t) => t.actor.flags?.ddbimporter?.id == character.id && t.actor.type == "character");

            if (!onScene) {
              const linkedToken = duplicate(await characterInGame.getTokenDocument());
              if (useDDBSave) {
                setProperty(linkedToken, "flags.ddbimporter.dndbeyond.initiative", character.initiative);
              }
              setProperty(linkedToken, "actorData.flags.ddbimporter.encounters", true);
              setProperty(linkedToken, "actorData.flags.ddbimporter.encounterId", this.encounter.id);
              linkedToken.x = xStartPixelPC;
              const yOffsetChange = characterCount * sceneData.grid.size;
              linkedToken.y = yStartPixel + yOffsetChange;
              tokenData.push(linkedToken);
              characterCount++;
            }
          }
        });

      let monsterDepth = 0;
      let monsterRows = 0;
      let rowMonsterWidth = 1;
      for (const worldMonster of this.encounter.worldMonsters) {
        src_logger/* default.info */.Z.info(`Generating token ${worldMonster.ddbName} (${worldMonster.name}) for ${this.encounter.name}`);
        const monster = game.actors.get(worldMonster.id);
        // eslint-disable-next-line no-await-in-loop
        const linkedToken = duplicate(await monster.getTokenDocument());
        if (monsterDepth + linkedToken.height > ySquares) {
          monsterDepth = 0;
          monsterRows += rowMonsterWidth;
          rowMonsterWidth = 1;
        }

        setProperty(linkedToken, "name", worldMonster.ddbName);
        setProperty(linkedToken, "actorData.name", worldMonster.ddbName);
        setProperty(linkedToken, "flags.ddbimporter.dndbeyond.uniqueId", worldMonster.uniqueId);
        setProperty(linkedToken, "flags.ddbimporter.encounterId", this.encounter.id);
        setProperty(linkedToken, "actorData.flags.ddbimporter.dndbeyond.uniqueId", worldMonster.uniqueId);
        setProperty(linkedToken, "actorData.flags.ddbimporter.encounters", true);
        setProperty(linkedToken, "actorData.flags.ddbimporter.encounterId", this.encounter.id);
        const xOffsetChange = sceneData.grid.size * monsterRows;
        const yOffsetChange = monsterDepth * sceneData.grid.size;
        linkedToken.x = xStartPixelMonster + xOffsetChange;
        linkedToken.y = yStartPixel + yOffsetChange;
        if (useDDBSave) {
          setProperty(linkedToken, "flags.ddbimporter.dndbeyond.initiative", worldMonster.initiative);
          // if no hp changes have been made on a monster on ddb it says 0 here
          if (worldMonster.maximumHitPoints !== 0) {
            setProperty(linkedToken, "actorData.system.attributes.hp.max", worldMonster.maximumHitPoints);
            setProperty(
              linkedToken,
              "actorData.system.attributes.hp.value",
              worldMonster.currentHitPoints + worldMonster.temporaryHitPoints
            );
          }
        }

        tokenData.push(linkedToken);
        monsterDepth += linkedToken.height;
        if (linkedToken.width > rowMonsterWidth) rowMonsterWidth = linkedToken.width;
      }

      if (this.journal?.id) sceneData.journal = this.journal.id;

      if (importDDBIScene) {
        worldScene = game.scenes.find(
          (a) => a.folder == this.folders["scene"].id
          && a.flags?.ddbimporter?.encounterId == this.encounter.id
        );
      }

      if (worldScene) {
        src_logger/* default.info */.Z.info(`Updating scene ${sceneData.name}`);
        const existingCombats = game.combats.filter((c) =>
          c.scene?.id == worldScene.id
          && c.flags?.ddbimporter?.encounterId == this.encounter.id
        );
        await Combat.deleteDocuments(existingCombats.map((c) => c.id));
        if (importDDBIScene) {
          src_logger/* default.info */.Z.info(`Updating DDBI scene ${sceneData.name}`);
          sceneData._id = worldScene.id;
          await worldScene.deleteEmbeddedDocuments("Token", [], { deleteAll: true });
          await worldScene.update(mergeObject(worldScene.toObject(), sceneData));
        } else if (useExistingScene) {
          src_logger/* default.info */.Z.info(`Checking existing scene ${sceneData.name} for encounter monsters`);
          const existingSceneMonsterIds = worldScene.tokens
            .filter((t) => t.flags?.ddbimporter?.encounterId == this.encounter.id && t.actor.type == "npc")
            .map((t) => t.id);
          await worldScene.deleteEmbeddedDocuments("Token", existingSceneMonsterIds);
        }
      } else if (importDDBIScene) {
        src_logger/* default.info */.Z.info(`Importing scene ${sceneData.name}`);
        try {
          // eslint-disable-next-line require-atomic-updates
          worldScene = await Scene.create(sceneData);
        } catch (err) {
          src_logger/* default.error */.Z.error(err);
          src_logger/* default.warn */.Z.warn(`Unable to create scene ${sceneData.name}`);
        }
      }

      const thumbData = await worldScene.createThumbnail();
      const thumbScene = worldScene.toObject();
      thumbScene["thumb"] = thumbData.thumb;

      src_logger/* default.debug */.Z.debug("Creating tokenens on scene", tokenData);
      // eslint-disable-next-line require-atomic-updates
      worldScene = await worldScene.update(thumbScene, { keepId: true });

      await worldScene.createEmbeddedDocuments("Token", tokenData);

      this.scene = worldScene;
    }
    src_logger/* default.debug */.Z.debug("Scene created", this.scene);

    this.scene.render();

    return this.scene;
  }

  async createCombatEncounter() {
    const importCombat = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "encounter-import-policy-create-scene")
      || game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "encounter-import-policy-existing-scene");

    if (!importCombat) return undefined;
    src_logger/* default.debug */.Z.debug(`Creating combat for encounter ${this.encounter.name}`);

    const useDDBSave
      = this.encounter.inProgress && game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "encounter-import-policy-use-ddb-save");

    await this.scene.view();
    const flags = {
      "ddbimporter.encounterId": this.encounter.id,
    };
    this.combat = await Combat.create({ scene: this.scene.id, flags: flags });
    await this.combat.activate();

    let toCreate = [];
    const tokens = canvas.tokens.placeables
      .filter((t) => t.document.flags?.ddbimporter?.encounterId == this.encounter.id || t.actor.type == "character");
    if (tokens.length) {
      tokens.forEach((t) => {
        let combatant = { tokenId: t.id, actorId: t.document.actorId, hidden: t.document.hidden };
        if (useDDBSave && t.document.flags.ddbimporter?.dndbeyond?.initiative)
          combatant.initiative = t.document.flags.ddbimporter.dndbeyond.initiative;
        if (!t.inCombat) toCreate.push(combatant);
      });
      const combatants = await this.combat.createEmbeddedDocuments("Combatant", toCreate);

      const rollMonsterInitiative = game.settings.get(
        "ddb-importer",
        "encounter-import-policy-roll-monster-initiative"
      );
      combatants
        .filter((c) => rollMonsterInitiative && c.actor.type === "npc" && c.initiative === null)
        .forEach(async (c) => {
          if (c.initiative === null) await this.combat.rollInitiative(c.id);
        });
    }

    return this.combat;
  }

  activateListeners(html) {
    super.activateListeners(html);

    $(html)
      .find(
        ['.munching-generic-config input[type="checkbox"]', '.munching-monster-config input[type="checkbox"]'].join(",")
      )
      .on("change", (event) => {
        MuncherSettings/* default.updateMuncherSettings */.Z.updateMuncherSettings(html, event);
      });

    $(html)
      .find(
        [
          '.import-policy input[type="checkbox"]',
          '.advanced-import-config input[type="checkbox"]',
          '.effect-policy input[type="checkbox"]',
          '.effect-import-config input[type="checkbox"]',
          '.extras-import-config input[type="checkbox"]',
          '.import-config input[type="checkbox"]',
        ].join(",")
      )
      .on("change", (event) => {
        MuncherSettings/* default.updateActorSettings */.Z.updateActorSettings(html, event);
      });

    $(html)
      .find("#default-effects")
      .on("click", async (event) => {
        event.preventDefault();
        MuncherSettings/* default.setRecommendedCharacterActiveEffectSettings */.Z.setRecommendedCharacterActiveEffectSettings(html);
      });

    $(html)
      .find('.sync-policy input[type="checkbox"]')
      .on("change", (event) => {
        game.settings.set(
          "ddb-importer",
          "sync-policy-" + event.currentTarget.dataset.section,
          event.currentTarget.checked
        );
      });

    $(html)
      .find('.encounter-config input[type="checkbox"]')
      .on("change", (event) => {
        switch (event.currentTarget.dataset.section) {
          case "create-scene": {
            game.settings.set(settings/* default.MODULE_ID */.Z.MODULE_ID, "encounter-import-policy-existing-scene", false);
            if (event.currentTarget.checked) $("#encounter-scene-select").prop("disabled", true);
            $("#encounter-scene-img-select").prop("disabled", !event.currentTarget.checked);
            $("#encounter-import-policy-existing-scene").prop('checked', false);
            break;
          }
          case "existing-scene": {
            game.settings.set(settings/* default.MODULE_ID */.Z.MODULE_ID, "encounter-import-policy-create-scene", false);
            if (event.currentTarget.checked) $("#encounter-scene-img-select").prop("disabled", true);
            $("#encounter-scene-select").prop("disabled", !event.currentTarget.checked);
            $("#encounter-import-policy-create-scene").prop('checked', false);
            break;
          }
          // no default
        };
        game.settings.set(
          "ddb-importer",
          "encounter-import-policy-" + event.currentTarget.dataset.section,
          event.currentTarget.checked
        );
      });

    // img change
    html.find("#encounter-scene-img-select").on("change", async () => {
      const imgSelect = html.find("#encounter-scene-img-select");
      this.img = imgSelect[0].selectedOptions[0] ? imgSelect[0].selectedOptions[0].value : "";
    });

    html.find("#encounter-scene-select").on("change", async () => {
      const imgSelect = html.find("#encounter-scene-select");
      this.sceneId = imgSelect[0].selectedOptions[0] ? imgSelect[0].selectedOptions[0].value : "";
    });

    // filter campaigns
    html.find("#encounter-campaign-select").on("change", async () => {
      const campaignSelection = html.find("#encounter-campaign-select");
      // get selected campaign from html selection
      const campaignId = campaignSelection[0].selectedOptions[0]
        ? campaignSelection[0].selectedOptions[0].value
        : undefined;
      const encounters = await this.ddbEncounters.filterEncounters(campaignId);
      const campaignSelected = campaignId && campaignId !== "";
      let encounterList = `<option value="">Select encounter:</option>`;
      encounters.forEach((encounter) => {
        encounterList += `<option value="${encounter.id}">${encounter.name}${
          campaignSelected || !encounter.campaign ? "" : ` (${encounter.campaign.name})`
        }</option>\n`;
      });
      const list = html.find("#encounter-select");
      list[0].innerHTML = encounterList;
      this.resetEncounter(html);
    });

    // encounter change
    html.find("#encounter-select").on("change", async () => {
      this.resetEncounter(html);
      const encounterSelection = html.find("#encounter-select");
      const encounterId = encounterSelection[0].selectedOptions[0]
        ? encounterSelection[0].selectedOptions[0].value
        : undefined;

      const encounter = await this.parseEncounter(encounterId);
      // console.warn(encounter);

      const nameHtml = html.find("#ddb-encounter-name");
      const summaryHtml = html.find("#ddb-encounter-summary");
      const charactersHtml = html.find("#ddb-encounter-characters");
      const monstersHtml = html.find("#ddb-encounter-monsters");
      const difficultyHtml = html.find("#ddb-encounter-difficulty");
      const rewardsHtml = html.find("#ddb-encounter-rewards");
      const progressHtml = html.find("#ddb-encounter-progress");

      const missingCharacters = encounter.missingCharacters
        ? `fa-times-circle' style='color: red`
        : `fa-check-circle' style='color: green`;
      const missingMonsters = encounter.missingMonsters
        ? `fa-times-circle' style='color: red`
        : `fa-check-circle' style='color: green`;

      const goodCharacters = encounter.goodCharacterData.map((character) => `${character.name}`).join(", ");
      const goodMonsters = encounter.goodMonsterIds.map((monster) => `${monster.name}`).join(", ");
      const neededCharactersHTML = encounter.missingCharacters
        ? ` <span style="color: red"> Missing ${
          encounter.missingCharacterData.length
        }: ${encounter.missingCharacterData.map((character) => character.name).join(", ")}</span>`
        : "";
      const neededMonstersHTML = encounter.missingMonsters
        ? ` <span style="color: red"> Missing ${
          encounter.missingMonsterIds.length
        }. DDB Id's: ${encounter.missingMonsterIds.map((monster) => monster.ddbId).join(", ")}</span>`
        : "";

      nameHtml[0].innerHTML = `<i class='fas fa-check-circle' style='color: green'></i> <b>Encounter:</b> ${encounter.name}`;
      if (encounter.summary && encounter.summary.trim() !== "") {
        summaryHtml[0].innerHTML = `<i class='fas fa-check-circle' style='color: green'></i> <b>Summary:</b> ${encounter.summary}`;
      }
      if (encounter.goodCharacterData.length > 0 || encounter.missingCharacterData.length > 0) {
        charactersHtml[0].innerHTML = `<i class='fas ${missingCharacters}'></i> <b>Characters:</b> ${goodCharacters}${neededCharactersHTML}`;
      }
      if (encounter.goodMonsterIds.length > 0 || encounter.missingMonsterIds.length > 0) {
        monstersHtml[0].innerHTML = `<i class='fas ${missingMonsters}'></i> <b>Monsters:</b> ${goodMonsters}${neededMonstersHTML}`;
      }
      difficultyHtml[0].innerHTML = `<i class='fas fa-check-circle' style='color: green'></i> <b>Difficulty:</b> <span style="color: ${encounter.difficulty.color}">${encounter.difficulty.name}</span>`;
      if (encounter.rewards && encounter.rewards.trim() !== "") {
        rewardsHtml[0].innerHTML = `<i class='fas fa-check-circle' style='color: green'></i> <b>Rewards:</b> ${encounter.rewards}`;
      }

      progressHtml[0].innerHTML = encounter.inProgress
        ? `<i class='fas fa-times-circle' style='color: red'></i> <b>In Progress:</b> <span style="color: red"> Encounter in progress on <a href="https://www.dndbeyond.com/combat-tracker/${this.encounter.id}">D&D Beyond!</a></span>`
        : `<i class='fas fa-check-circle' style='color: green'></i> <b>In Progress:</b> No`;

      $("#encounter-import-policy-use-ddb-save").prop("disabled", !encounter.inProgress);
      $("#ddb-importer-encounters").css("height", "auto");
      $("#encounter-button").prop("disabled", false);
    });

    // import encounter
    html.find("#encounter-button").click(async (event) => {
      event.preventDefault();
      $("#encounter-button").prop("disabled", true);
      $("#encounter-button").prop("innerText", "Munching...");

      await this.importMonsters();
      await this.importCharacters(html);
      await this.createJournalEntry();
      const scene = await this.createScene();
      if (scene) {
        src_logger/* default.info */.Z.info(`Scene ${scene.id} created`);
        await this.createCombatEncounter();
      };

      // to do:
      // adjust monsters hp?
      // add initiative if combat in progress?
      // - extra import?
      // - attempt to find magic items and add them to the world?

      $("#encounter-button").prop("innerText", "Encounter Munched");
      const campaignFluff
        = this.encounter.campaign?.name && this.encounter.campaign.name.trim() !== "" ? ` of ${this.encounter.name}` : "";
      ui.notifications.warn(`Prepare to battle heroes${campaignFluff}, your doom awaits in ${this.encounter.name}!`);
    });
  }

  // eslint-disable-next-line class-methods-use-this
  async getData() {
    const tier = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "patreon-tier");
    const tiers = PatreonHelper/* default.getPatreonTiers */.Z.getPatreonTiers(tier);
    const availableCampaigns = await (0,Settings/* getAvailableCampaigns */.s1)();
    const availableEncounters = await this.ddbEncounters.filterEncounters();

    const characterSettings = MuncherSettings/* default.getCharacterImportSettings */.Z.getCharacterImportSettings();
    const muncherSettings = MuncherSettings/* default.getMuncherSettings */.Z.getMuncherSettings(false);

    const importSettings = mergeObject(characterSettings, muncherSettings);

    const encounterConfig = [
      {
        name: "missing-characters",
        isChecked: game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "encounter-import-policy-missing-characters"),
        enabled: true,
        description: "Import missing characters?",
      },
      {
        name: "missing-monsters",
        isChecked: game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "encounter-import-policy-missing-monsters"),
        enabled: true,
        description: "Import missing monsters?",
      },
      {
        name: "create-journal",
        isChecked: game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "encounter-import-policy-create-journal"),
        enabled: true,
        description: "Create encounter journal entry?",
      },
      {
        name: "use-ddb-save",
        isChecked: game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "encounter-import-policy-use-ddb-save"),
        enabled: false,
        description: "Use save information from Encounter (HP for monsters and initiative for all)?",
      },
      {
        name: "create-scene",
        isChecked: game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "encounter-import-policy-create-scene"),
        enabled: true,
        description: "Create/update a scene to use, and add available characters and NPC's?",
      },
      {
        name: "existing-scene",
        isChecked: game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "encounter-import-policy-existing-scene"),
        enabled: true,
        description: "Use an existing scene?",
      },
    ];

    const scenes = game.scenes.filter((scene) => !scene.flags?.ddbimporter?.encounters)
      .map((scene) => {
        const folderName = scene.folder ? `[${scene.folder.name}] ` : "";
        const s = {
          name: `${folderName}${scene.name}`,
          id: scene.id,
        };
        return s;
      })
      .sort((a, b) => a.name.localeCompare(b.name));

    const encounterSettings = {
      tiers,
      availableCampaigns,
      availableEncounters,
      encounterConfig,
      sceneImg: DDBEncounterMunch.SCENE_IMG,
      scenes,
      createSceneSelect: game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "encounter-import-policy-create-scene"),
      existingSceneSelect: game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "encounter-import-policy-existing-scene"),
    };

    const data = mergeObject(importSettings, encounterSettings);
    src_logger/* default.debug */.Z.debug("Encounter muncher form data", data);

    return data;
  }
}

// EXTERNAL MODULE: ./src/muncher/adventure.js
var adventure = __webpack_require__(9441);
// EXTERNAL MODULE: ./src/lib/base64Check.js
var base64Check = __webpack_require__(9460);
// EXTERNAL MODULE: ./src/muncher/feats/feats.js
var feats = __webpack_require__(267);
// EXTERNAL MODULE: ./src/muncher/importMonster.js
var importMonster = __webpack_require__(9633);
// EXTERNAL MODULE: ./src/lib/DirectoryPicker.js
var DirectoryPicker = __webpack_require__(4222);
// EXTERNAL MODULE: ./src/lib/icons.js
var lib_icons = __webpack_require__(3716);
// EXTERNAL MODULE: ./src/parser/companions/DDBCompanion.js
var DDBCompanion = __webpack_require__(1126);
;// CONCATENATED MODULE: ./src/effects/helpers.js


/**
 * If a custom AA condition animation exists for the specified name, registers the appropriate hook with AA
 * to be able to replace the default condition animation by the custom one.
 *
 * @param {*} condition condition for which to replace its AA animation by a custom one (it must be a value from CONFIG.DND5E.conditionTypes).
 * @param {*} macroData the midi-qol macro data.
 * @param {*} originItemName the name of item used for AA customization of the condition.
 * @param {*} conditionItemUuid the UUID of the item applying the condition.
 */
function configureCustomAAForCondition(condition, macroData, originItemName, conditionItemUuid) {
  // Get default condition label
  const statusName = CONFIG.DND5E.conditionTypes[condition];
  const customStatusName = `${statusName} [${originItemName}]`;
  if (AutomatedAnimations.AutorecManager.getAutorecEntries().aefx.find((a) => a.label === customStatusName)) {
    const aaHookId = Hooks.on("AutomatedAnimations-WorkflowStart", (data) => {
      if (
        data.item instanceof CONFIG.ActiveEffect.documentClass
        && data.item.label === statusName
        && data.item.origin === macroData.sourceItemUuid
      ) {
        data.recheckAnimation = true;
        data.item.label = customStatusName;
        Hooks.off("AutomatedAnimations-WorkflowStart", aaHookId);
      }
    });
    // Make sure that the hook is removed when the special spell effect is completed
    Hooks.once(`midi-qol.RollComplete.${conditionItemUuid}`, () => {
      Hooks.off("AutomatedAnimations-WorkflowStart", aaHookId);
    });
  }
}

/**
 * Adds a save advantage effect for the next save on the specified target actor.
 *
 * @param {*} targetActor the target actor on which to add the effect.
 * @param {*} originItem the item that is the origin of the effect.
 * @param {*} ability the short ability name to use for save, e.g. str
 */
async function addSaveAdvantageToTarget(targetActor, originItem, ability, additionLabel = "", icon = null) {
  const effectData = {
    _id: randomID(),
    changes: [
      {
        key: `flags.midi-qol.advantage.ability.save.${ability}`,
        mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
        value: "1",
        priority: 20,
      },
    ],
    origin: originItem.uuid,
    disabled: false,
    transfer: false,
    icon,
    label: `${originItem.name}${additionLabel}: Save Advantage Large Creature`,
    duration: { turns: 1 },
    flags: {
      dae: {
        specialDuration: [`isSave.${ability}`],
      },
    },
  };
  await MidiQOL.socket().executeAsGM("createEffects", { actorUuid: targetActor.uuid, effects: [effectData] });
}

/**
 * Returns ids of tokens in template
 *
 * @param {*} templateDoc the templatedoc to check
 */
function findContainedTokensInTemplate(templateDoc) {
  const contained = new Set();
  for (const tokenDoc of templateDoc.parent.tokens) {
    const startX = tokenDoc.width >= 1 ? 0.5 : tokenDoc.width / 2;
    const startY = tokenDoc.height >= 1 ? 0.5 : tokenDoc.height / 2;
    for (let x = startX; x < tokenDoc.width; x++) {
      for (let y = startY; y < tokenDoc.width; y++) {
        const curr = {
          x: tokenDoc.x + (x * templateDoc.parent.grid.size) - templateDoc.x,
          y: tokenDoc.y + (y * templateDoc.parent.grid.size) - templateDoc.y,
        };
        const contains = templateDoc.object.shape.contains(curr.x, curr.y);
        if (contains) contained.add(tokenDoc.id);
      }
    }
  }
  return [...contained];
}

async function checkTargetInRange({ sourceUuid, targetUuid, distance }) {
  if (!game.modules.get("midi-qol")?.active) {
    ui.notifications.error("checkTargetInRange requires midiQoL, not checking");
    src_logger/* default.error */.Z.error("checkTargetInRange requires midiQoL, not checking");
    return true;
  }
  const sourceToken = await fromUuid(sourceUuid);
  if (!sourceToken) return false;
  const targetsInRange = MidiQOL.findNearby(null, sourceUuid, distance);
  const isInRange = targetsInRange.reduce((result, possible) => {
    const collisionRay = new Ray(sourceToken, possible);
    const collision = canvas.walls.checkCollision(collisionRay, { mode: "any", type: "sight" });
    if (possible.uuid === targetUuid && !collision) result = true;
    return result;
  }, false);
  return isInRange;
}

;// CONCATENATED MODULE: ./src/hooks/init/api.js
// for exports































function resetSecrets() {
  game.settings.set("ddb-importer", "cobalt-cookie-local", false);
  game.settings.set("ddb-importer", "cobalt-cookie", "");
  game.settings.set("ddb-importer", "campaign-id", "");
}

// eslint-disable-next-line no-unused-vars
function migrateAllCompendiums(value, key, map) {
  if (!value.locked) game.dnd5e.migrations.migrateCompendium(value);
}

function migrateCompendiums() {
  const compendiumNames = CompendiumHelper/* default.getCompendiumNames */.Z.getCompendiumNames();
  game.packs
    .filter((pack) => compendiumNames.includes(pack.collection))
    .forEach(migrateAllCompendiums);
}

function debugStart() {
  CONFIG.debug.ddbimporter.record = true;
}

function debugStop() {
  CONFIG.debug.ddbimporter.download();
}

function registerApi() {
  const API = {
    base64Check: base64Check/* base64Check */.g,
    checkCobalt: Secrets/* checkCobalt */.B,
    checkPatreon: PatreonHelper/* default.checkPatreon */.Z.checkPatreon,
    createCompendiumFolderStructure: compendiumFolders/* createCompendiumFolderStructure */.FT,
    createMacro: macros/* createMacro */.UG,
    executeDDBMacro: macros/* executeDDBMacro */.ob,
    generateAdventureConfig: adventure/* generateAdventureConfig */.k,
    generateItemMacroFlag: macros/* generateItemMacroFlag */.gL,
    getPatreonTier: PatreonHelper/* default.getPatreonTier */.Z.getPatreonTier,
    getPatreonTiers: PatreonHelper/* default.getPatreonTiers */.Z.getPatreonTiers,
    importCharacter: importCharacter,
    importCharacterById: importCharacterById,
    loadMacroFile: macros/* loadMacroFile */.dp,
    migrateCompendiums,
    migrateExistingCompendiumToCompendiumFolders: compendiumFolders/* migrateExistingCompendium */.W3,
    parseCritters: tools/* parseCritters */.CY,
    parseTransports: vehicles/* parseTransports */.b,
    parseFeats: feats/* getFeats */.S,
    parseItems: items/* parseItems */.S,
    DDBMonster: DDBMonster/* default */.Z,
    DDBMonsterFactory: DDBMonsterFactory/* default */.Z,
    parseSpells: spells/* parseSpells */.Z,
    DDBCharacterManager: DDBCharacterManager,
    DDBProxy: DDBProxy/* default */.Z,
    DDBEncounters: DDBEncounters,
    DDBEncounterMunch: DDBEncounterMunch,
    MuncherSettings: MuncherSettings/* default */.Z,
    resetProxy: DDBProxy/* default.resetProxy */.Z.resetProxy,
    resetSecrets,
    setPatreonTier: PatreonHelper/* default.setPatreonTier */.Z.setPatreonTier,
    updateDDBCharacter: updateDDBCharacter,
    updateWorldMonsters: tools/* updateWorldMonsters */.BU,
    getIconPath: icons/* iconPath */.H,
    iconPath: icons/* iconPath */.H,
    generateIcon: lib_icons/* generateIcon */.r,
    loadSRDRules: DDBTemplateStrings/* loadSRDRules */.xz,
    importCacheLoad: DDBTemplateStrings/* importCacheLoad */.uB,
    macros: macros/* MACROS */.Vw,
    getNPCImage: importMonster/* getNPCImage */.xD,
    resetCompendiumActorImages: tools/* resetCompendiumActorImages */.mk,
    CompendiumHelper: CompendiumHelper/* default */.Z,
    FileHelper: FileHelper/* default */.Z,
    DirectoryPicker: DirectoryPicker/* DirectoryPicker */.B,
    getCompendiumLabel: CompendiumHelper/* default.getCompendiumLabel */.Z.getCompendiumLabel,
    getCompendiumType: CompendiumHelper/* default.getCompendiumType */.Z.getCompendiumType,
    getCompendiumNames: CompendiumHelper/* default.getCompendiumNames */.Z.getCompendiumNames,
    deleteDefaultCompendiums: CompendiumHelper/* default.deleteDefaultCompendiums */.Z.deleteDefaultCompendiums,
    muncherSettings: MuncherSettings/* default.getMuncherSettings */.Z.getMuncherSettings,
    characterSettings: MuncherSettings/* default.getCharacterImportSettings */.Z.getCharacterImportSettings,
    DDBCompanion: DDBCompanion/* default */.Z,
    DDBCompanionFactory: DDBCompanionFactory/* default */.Z,
    effects: {
      addSaveAdvantageToTarget: addSaveAdvantageToTarget,
      configureCustomAAForCondition: configureCustomAAForCondition,
      findContainedTokensInTemplate: findContainedTokensInTemplate,
      checkTargetInRange: checkTargetInRange,
    },
    debug: {
      start: debugStart,
      stop: debugStop,
    }
  };

  window.DDBImporter = API;
  game.modules.get(settings/* default.MODULE_ID */.Z.MODULE_ID).api = API;
}

;// CONCATENATED MODULE: ./src/hooks/init/chatHooks.js

function chatHooks() {
  Hooks.on("renderChatMessage", (message, html) => {
    const chatImg = html.find("img.ddbimporter-chat-image");
    chatImg.click((event) => {
      event.preventDefault();
      event.stopPropagation();
      new ImagePopout($(chatImg).attr("src"), { shareable: true }).render(true);
    });
  });
}

;// CONCATENATED MODULE: ./src/lib/DDBAdventureImporter.js



class DDBAdventureImporter extends AdventureImporter {

  constructor(adventure, options) {
    super(adventure, options);
    this.options.classes.push(settings/* default.ADVENTURE_CSS */.Z.ADVENTURE_CSS);
    this.importOptions = {};
  }

  /** @inheritDoc */
  async getData() {
    return foundry.utils.mergeObject(await super.getData(), {
      importOptions: this.importOptions || {}
    });
  }

  /** @inheritDoc */
  async _renderInner(data) {
    const html = await super._renderInner(data);

    let options = `<section class="import-form"><h2>Importer Options</h2>`;
    for (const [name, option] of Object.entries(this.importOptions)) {
      options += `<div class="form-group">
        <label class="checkbox">
            <input type="checkbox" name="${name}" title="${option.label}" ${option.default ? "checked" : ""}/>
            ${option.label}
        </label>
    </div>`;
    }
    options += `</section>`;

    html.find(".adventure-contents").append(options);
    return html;
  }

  /** @inheritDoc */
  async _importContent(toCreate, toUpdate, documentCount) {
    const importResult = await super._importContent(toCreate, toUpdate, documentCount);
    for (let [name, option] of Object.entries(this.importOptions || {})) {
      if (option.handler) {
        // eslint-disable-next-line no-await-in-loop
        await option.handler(this.document, option, this.submitOptions[name]);
      }
    }
    return importResult;
  }

}

;// CONCATENATED MODULE: ./src/hooks/init/adventureImporter.js



/* harmony default export */ function adventureImporter() {
  DocumentSheetConfig.registerSheet(Adventure, settings/* default.MODULE_ID */.Z.MODULE_ID, DDBAdventureImporter, {
    label: "DDB Adventure Importer"
  });

  // Hooks.on("renderJournalSheet", (app, html) => {
  //   const journal = app.document;
  //   if (journal.getFlag(SETTINGS.FLAG_NAME, SETTINGS.ADVENTURE_FLAG)) html[0].classList.add(SETTINGS.ADVENTURE_CSS);
  // });

  // Hooks.on("renderJournalPageSheet", (app, html) => {
  //   const journal = app.document.parent;
  //   if (journal.getFlag(SETTINGS.FLAG_NAME, SETTINGS.ADVENTURE_FLAG)) html[0].classList.add(SETTINGS.ADVENTURE_CSS);
  // });

}

;// CONCATENATED MODULE: ./src/lib/DDBAdventureFlags.js



class DDBAdventureFlags extends FormApplication {
  static get defaultOptions() {
    const options = super.defaultOptions;
    options.title = "DDB Adventure Imported Flags";
    options.template = "modules/ddb-importer/handlebars/flag-details.hbs";
    options.classes = ["ddb-importer-flags", "sheet"];
    options.width = 800;
    return options;
  }

  /** @override */
  async getData() { // eslint-disable-line class-methods-use-this
    // console.warn(this);
    // console.warn(this.object);
    const item = this.object;

    let flags = {};

    const flagGroups = ["ddb", "ddbimporter", "monsterMunch", "ddb-importer"];
    const ignoredSubFlagGroups = ["ddbimporter.acEffects", "ddbimporter.autoAC"];

    function generateFlagLookup(flagData, flagName, flagGroupName) {
      src_logger/* default.debug */.Z.debug(`FlagName ${flagName}, flagGroupName ${flagGroupName}`, flagData);
      for (const flagKey in flagData) {
        src_logger/* default.debug */.Z.debug("flagkey", flagKey);
        const flagValue = (flagKey === "userData") ? flagData[flagKey]["userDisplayName"] : flagData[flagKey];
        const flagGroupSubName = `${flagGroupName}.${flagKey}`;
        if (typeof flagValue === "object" && !ignoredSubFlagGroups.includes(flagGroupName) && !Array.isArray(flagValue)) {
          src_logger/* default.info */.Z.info(`recursive generateFlag call for ${flagName}`);
          generateFlagLookup(flagValue, flagKey, flagGroupSubName);
        } else if (!ignoredSubFlagGroups.includes(flagGroupName) && !ignoredSubFlagGroups.includes(flagGroupSubName)) {
          if (!flags[flagGroupName]) flags[flagGroupName] = [];
          flags[flagGroupName].push({
            key: flagKey,
            value: Array.isArray(flagValue) ? JSON.stringify(flagValue) : flagValue,
          });
        }
      }
    };

    flagGroups.forEach((flagGroup) => {
      src_logger/* default.debug */.Z.debug(`Flag group ${flagGroup}`, item.flags);
      generateFlagLookup(item.flags[flagGroup], flagGroup, flagGroup);
    });

    const result = {
      name: item.name,
      flags,
      monster: {
        isMonster: this.object.type == "npc",
        flags: [
          {
            name: "keepItems",
            description: "Keep this monsters item configuration for Adventure Muncher",
            isChecked: item.flags?.ddbimporter?.keepItems ?? false,
          },
          {
            name: "keepToken",
            description: "Keep token? (The image needs to be manually set in the export data)",
            isChecked: item.flags?.ddbimporter?.keepToken ?? false,
          },
          {
            name: "keepAvatar",
            description: "Keep avatar?  (The image needs to be manually set in the export data)",
            isChecked: item.flags?.ddbimporter?.keepAvatar ?? false,
          },
        ]
      },
      item: {
        isItem: dictionary/* default.types.monster.includes */.Z.types.monster.includes(this.object.type) || this.object.type === "spell",
        flags: [
          {
            name: "customItem",
            description: "Keep this custom item",
            isChecked: item.flags?.ddbimporter?.customItem ?? false,
          }
        ]
      },
    };

    if (item.link) result["link"] = item.link;
    if (flags.bookCode && flags.slug) result["ddbLink"] = `https://www.dndbeyond.com/${flags.bookCode}/${flags.slug}`;

    src_logger/* default.debug */.Z.debug("flags", flags);
    return result;
  }


  activateListeners(html) {
    super.activateListeners(html);
    // watch the change of the import-policy-selector checkboxes
    $(html)
      .find(
        [
          '.flag-policy input[type="checkbox"]',
        ].join(",")
      )
      .on("change", async (event) => {
        const selection = event.currentTarget.dataset.section;
        const checked = event.currentTarget.checked;
        src_logger/* default.debug */.Z.debug(`Updating flag-policy for ${this.object.name}, ${selection} to ${checked}`);

        await this.object.update({
          flags: {
            "ddbimporter": {
              [selection]: checked
            }
          }
        });
      });
  }
}

;// CONCATENATED MODULE: ./src/hooks/ready/registerSheets.js





const API_ENDPOINT = "https://character-service.dndbeyond.com/character/v5/character/";
// reference to the D&D Beyond popup
const POPUPS = {
  json: null,
  web: null,
};
const renderPopup = (type, url) => {
  if (POPUPS[type] && !POPUPS[type].close) {
    POPUPS[type].focus();
    POPUPS[type].location.href = url;
  } else {
    const ratio = window.innerWidth / window.innerHeight;
    const width = Math.round(window.innerWidth * 0.5);
    const height = Math.round(window.innerWidth * 0.5 * ratio);
    POPUPS[type] = window.open(
      url,
      "ddb_sheet_popup",
      `resizeable,scrollbars,location=no,width=${width},height=${height},toolbar=1`
    );
  }
  return true;
};

/* harmony default export */ function registerSheets() {
  /**
   * Character sheets
   */
  const pcSheetNames = Object.values(CONFIG.Actor.sheetClasses.character)
    .map((sheetClass) => sheetClass.cls)
    .map((sheet) => sheet.name);

  const trustedUsersOnly = game.settings.get("ddb-importer", "restrict-to-trusted");
  const allowAllSync = game.settings.get("ddb-importer", "allow-all-sync");
  const characterLink = game.settings.get("ddb-importer", "character-link-title");
  const monsterLink = game.settings.get("ddb-importer", "monster-link-title");
  const whiteTitle = (game.settings.get("ddb-importer", "link-title-colour-white")) ? " white" : "";

  pcSheetNames.forEach((sheetName) => {
    Hooks.on("render" + sheetName, (app, html, data) => {
      // only for GMs or the owner of this character
      if (!data.owner || !data.actor || (!allowAllSync && trustedUsersOnly && !game.user.isTrusted)) return;

      let url = null;
      if (app.document.flags.ddbimporter?.dndbeyond?.url) {
        url = app.document.flags.ddbimporter.dndbeyond.url;
      }

      let jsonURL = null;
      if (app.document.flags.ddbimporter?.dndbeyond?.json) {
        jsonURL = app.document.flags.ddbimporter.dndbeyond.json;
      }

      let button;

      if (characterLink) {
        button = $(`<a class="ddb-open-url" title="DDB Importer"><i class="fab fa-d-and-d-beyond${whiteTitle}"></i></a>`);
      } else {
        // don't add the button multiple times
        if ($(html).find("#ddbImporterButton").length > 0) return;
        button = $('<button type="button" id="ddbImporterButton" class="inactive"><i class="fab fa-d-and-d-beyond"></button>');
        if (app.document.flags.ddbimporter?.dndbeyond?.url) button.removeClass("inactive");
      }

      button.click((event) => {
        if (event.shiftKey && event.ctrlKey) {
          new DDBAdventureFlags(app.document, {}).render(true);
        } else if (event.shiftKey) {
          event.preventDefault();
          return renderPopup("web", url);
        } else if (event.altKey && jsonURL) {
          event.preventDefault();
          return renderPopup("json", jsonURL);
        } else if (event.altKey && !jsonURL) {
          // get the character ID
          const characterId = url.split("/").pop();
          if (characterId) {
            event.preventDefault();
            return renderPopup("json", API_ENDPOINT + characterId);
          }
        } else if ((!event.shiftKey && !event.ctrlKey && !event.altKey) || url === null) {
          const setupComplete = (0,Settings/* isSetupComplete */.pV)(false);

          if (setupComplete) {
            const characterImport = new DDBCharacterManager(DDBCharacterManager.defaultOptions, data.actor);
            characterImport.render(true);
          } else {
            new Settings/* DDBSetup */.lR().render(true);
          }

          return true;
        }

        return false;
      });

      if (characterLink) {
        html.closest('.app').find('.ddb-open-url').remove();
        let titleElement = html.closest('.app').find('.window-title');
        if (!app._minimized) button.insertAfter(titleElement);
      } else {
        let wrap = $('<div class="ddbCharacterName"></div>');
        $(html).find("input[name='name']").wrap(wrap);
        $(html).find("input[name='name']").parent().prepend(button);
      }
    });
  });


  /**
   * NPC sheets
   */
  const npcSheetNames = Object.values(CONFIG.Actor.sheetClasses.npc)
    .map((sheetClass) => sheetClass.cls)
    .map((sheet) => sheet.name);

  npcSheetNames.forEach((sheetName) => {
    Hooks.on("render" + sheetName, (app, html, data) => {
      // only for GMs or the owner of this npc
      if (!data.owner || !data.actor) return;
      if (!app.document.flags?.monsterMunch?.url) return;
      let url = app.document.flags.monsterMunch.url;

      let button;

      if (monsterLink) {
        button = $(`<a class="ddb-open-url" title="D&D Beyond"><i class="fab fa-d-and-d-beyond${whiteTitle}"></i></a>`);
      } else {
        // don't add the button multiple times
        if ($(html).find("#ddbImporterButton").length > 0) return;
        button = $('<button type="button" id="ddbImporterButton"><i class="fab fa-d-and-d-beyond"></button>');
      }

      // eslint-disable-next-line no-unused-vars
      button.click((event) => {
        if (event.shiftKey && event.ctrlKey) {
          new DDBAdventureFlags(app.document, {}).render(true);
        } else {
          src_logger/* default.debug */.Z.debug(`Clicked for url ${url}`);
          renderPopup("web", url);
        }
      });

      if (monsterLink) {
        html.closest('.app').find('.ddb-open-url').remove();
        let titleElement = html.closest('.app').find('.window-title');
        if (!app._minimized) button.insertAfter(titleElement);
      } else {
        let wrap = $('<div class="ddbCharacterName"></div>');
        $(html).find("input[name='name']").wrap(wrap);
        $(html).find("input[name='name']").parent().prepend(button);
      }
    });
  });
}

;// CONCATENATED MODULE: ./src/hooks/ready/checkCompendiums.js



/* harmony default export */ async function checkCompendiums() {
  if (game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "auto-create-compendium")) {
    for (const compendium of settings/* default.COMPENDIUMS */.Z.COMPENDIUMS) {
      const compendiumName = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, compendium.setting);
      const compendiumData = { id: compendiumName, type: compendium.type, label: `DDB ${compendium.title}` };
      // eslint-disable-next-line no-await-in-loop
      const result = await CompendiumHelper/* default.createIfNotExists */.Z.createIfNotExists(compendiumData);

      if (result.created) {
        // eslint-disable-next-line no-await-in-loop
        await game.settings.set(settings/* default.MODULE_ID */.Z.MODULE_ID, compendium.setting, result.compendium.metadata.id);
      }
    };
  }
}

;// CONCATENATED MODULE: ./src/lib/DDBProxySetup.js




class DDBProxySetup extends FormApplication {
  static get defaultOptions() {
    const options = super.defaultOptions;
    options.id = "ddb-importer-proxy";
    options.template = "modules/ddb-importer/handlebars/ddbProxySetup.hbs";
    options.width = 500;
    return options;
  }

  get title() { // eslint-disable-line class-methods-use-this
    return game.i18n.localize(`${settings/* default.MODULE_ID */.Z.MODULE_ID}.Dialogs.DDBProxy.AppTitle`);
  }

  /** @override */
  async getData() { // eslint-disable-line class-methods-use-this
    const useCustomProxy = DDBProxy/* default.isCustom */.Z.isCustom();
    const defaultAddress = settings/* default.URLS.PROXY */.Z.URLS.PROXY;
    const proxyAddress = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "api-endpoint");

    return {
      useCustomProxy,
      proxyAddress,
      defaultAddress,
    };
  }

  /** @override */
  async _updateObject(event, formData) { // eslint-disable-line class-methods-use-this
    event.preventDefault();

    const useCustomProxy = formData['custom-proxy'];
    const proxyAddress = formData['api-endpoint'];

    await game.settings.set(settings/* default.MODULE_ID */.Z.MODULE_ID, "custom-proxy", useCustomProxy);
    await game.settings.set(settings/* default.MODULE_ID */.Z.MODULE_ID, "api-endpoint", proxyAddress);
  }
}

;// CONCATENATED MODULE: ./src/hooks/ready/registerGameSettings.js





setProperty(CONFIG, "DDBI", {
  module: "DDB Importer",
  schemaVersion: 4.2,
  ADVENTURE: {},
  MACROS: {
    spell: {},
    gm: {},
    item: {},
    feat: {},
  },
  KNOWN: {
    CHECKED_DIRS: new Set(),
    FILES: new Set(),
    FORGE: {
      TARGET_URL_PREFIX: {},
      TARGETS: {},
    },
  },
  ICONS: {},
  TABLES: {},
  SRD_LOAD: {
    mapLoaded: false,
    iconMap: {},
    packsLoaded: {},
    packs: {},
  },
  DEV: {
    enabled: false,
    clippy: {},
    tableInUse: false,
  },
  EFFECT_CONFIG: {
    MONSTERS: {
      installedModules: null,
      configured: false,
    },
    FEATS: {
      installedModules: null,
      configured: false,
    },
    SPELLS: {
      installedModules: null,
      configured: false,
    },
  },
});

async function resetSettings() {
  for (const [name, data] of Object.entries(settings/* default.GET_DEFAULT_SETTINGS */.Z.GET_DEFAULT_SETTINGS())) {
    // eslint-disable-next-line no-await-in-loop
    await game.settings.set(settings/* default.MODULE_ID */.Z.MODULE_ID, name, data.default);
  }
  for (const [name, data] of Object.entries(settings/* default.GET_DEFAULT_SETTINGS */.Z.GET_DEFAULT_SETTINGS(true))) {
    // eslint-disable-next-line no-await-in-loop
    await game.settings.set(settings/* default.MODULE_ID */.Z.MODULE_ID, name, data.default);
  }
  window.location.reload();
}

class ResetSettingsDialog extends FormApplication {
  constructor(...args) {
    super(...args);
    // eslint-disable-next-line no-constructor-return
    return new Dialog({
      title: game.i18n.localize(`${settings/* default.MODULE_ID */.Z.MODULE_ID}.Dialogs.ResetSettings.Title`),
      content: `<p class="${settings/* default.MODULE_ID */.Z.MODULE_ID}-dialog-important">${game.i18n.localize(
        `${settings/* default.MODULE_ID */.Z.MODULE_ID}.Dialogs.ResetSettings.Content`
      )}</p>`,
      buttons: {
        confirm: {
          icon: '<i class="fas fa-check"></i>',
          label: game.i18n.localize(`${settings/* default.MODULE_ID */.Z.MODULE_ID}.Dialogs.ResetSettings.Confirm`),
          callback: () => {
            resetSettings();
          },
        },
        cancel: {
          icon: '<i class="fas fa-times"></i>',
          label: game.i18n.localize(`${settings/* default.MODULE_ID */.Z.MODULE_ID}.Dialogs.ResetSettings.Cancel`),
        },
      },
      default: "cancel",
    });
  }
}

function createFolderPaths() {
  if (game.user.isGM) {
    const characterUploads = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "image-upload-directory");
    const otherUploads = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "other-image-upload-directory");
    if (characterUploads !== "[data] ddb-images/characters" && otherUploads === "[data] ddb-images/other") {
      game.settings.set(settings/* default.MODULE_ID */.Z.MODULE_ID, "other-image-upload-directory", characterUploads);
    } else {
      DirectoryPicker/* DirectoryPicker.verifyPath */.B.verifyPath(DirectoryPicker/* DirectoryPicker.parse */.B.parse(otherUploads));
    }
    DirectoryPicker/* DirectoryPicker.verifyPath */.B.verifyPath(DirectoryPicker/* DirectoryPicker.parse */.B.parse(characterUploads));

    const frameUploads = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "frame-image-upload-directory");
    DirectoryPicker/* DirectoryPicker.verifyPath */.B.verifyPath(DirectoryPicker/* DirectoryPicker.parse */.B.parse(frameUploads));

    const adventureUploads = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "adventure-upload-path");
    DirectoryPicker/* DirectoryPicker.verifyPath */.B.verifyPath(DirectoryPicker/* DirectoryPicker.parse */.B.parse(adventureUploads));

    const iconUploads = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "adventure-misc-path");
    DirectoryPicker/* DirectoryPicker.verifyPath */.B.verifyPath(DirectoryPicker/* DirectoryPicker.parse */.B.parse(iconUploads));
  }
}

/* harmony default export */ function registerGameSettings() {

  game.settings.registerMenu(settings/* default.MODULE_ID */.Z.MODULE_ID, 'setupMenu', {
    name: `${settings/* default.MODULE_ID */.Z.MODULE_ID}.settings.setup.name`,
    label: `${settings/* default.MODULE_ID */.Z.MODULE_ID}.settings.setup.name`,
    hint: `${settings/* default.MODULE_ID */.Z.MODULE_ID}.settings.setup.hint`,
    icon: 'fas fa-wrench',
    type: Settings/* DDBSetup */.lR,
    restricted: true
  });

  game.settings.registerMenu(settings/* default.MODULE_ID */.Z.MODULE_ID, 'compendiumMenu', {
    name: `${settings/* default.MODULE_ID */.Z.MODULE_ID}.settings.compendium-setup.name`,
    label: `${settings/* default.MODULE_ID */.Z.MODULE_ID}.settings.compendium-setup.name`,
    hint: `${settings/* default.MODULE_ID */.Z.MODULE_ID}.settings.compendium-setup.hint`,
    icon: 'fas fa-wrench',
    type: Settings/* DDBCompendiumSetup */.L0,
    restricted: true
  });

  game.settings.registerMenu(settings/* default.MODULE_ID */.Z.MODULE_ID, 'folderMenu', {
    name: `${settings/* default.MODULE_ID */.Z.MODULE_ID}.settings.folder-setup.name`,
    label: `${settings/* default.MODULE_ID */.Z.MODULE_ID}.settings.folder-setup.name`,
    hint: `${settings/* default.MODULE_ID */.Z.MODULE_ID}.settings.folder-setup.hint`,
    icon: 'fas fa-wrench',
    type: Settings/* DDBLocationSetup */.HI,
    restricted: true
  });

  game.settings.registerMenu(settings/* default.MODULE_ID */.Z.MODULE_ID, 'dynamicUpdateMenu', {
    name: `${settings/* default.MODULE_ID */.Z.MODULE_ID}.settings.dynamic-update-setup.name`,
    label: `${settings/* default.MODULE_ID */.Z.MODULE_ID}.settings.dynamic-update-setup.name`,
    hint: `${settings/* default.MODULE_ID */.Z.MODULE_ID}.settings.dynamic-update-setup.hint`,
    icon: 'fas fa-wrench',
    type: Settings/* DDBDynamicUpdateSetup */.wW,
    restricted: true,
  });

  for (const [name, data] of Object.entries(settings/* default.GET_DEFAULT_SETTINGS */.Z.GET_DEFAULT_SETTINGS())) {
    game.settings.register(settings/* default.MODULE_ID */.Z.MODULE_ID, name, data);
  }

  // SETTING TWEAKS AND MIGRATIONS
  createFolderPaths();

  if (game.user.isGM && game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "cobalt-cookie-local")
    && game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "cobalt-cookie") != "") {
    game.settings.set(settings/* default.MODULE_ID */.Z.MODULE_ID, "cobalt-cookie-local", false);
  }

  if (game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "dynamic-sync-user") === "" && game.user.isGM) {
    game.settings.set(settings/* default.MODULE_ID */.Z.MODULE_ID, "dynamic-sync-user", game.user.id);
  }

  // reset settings
  game.settings.registerMenu(settings/* default.MODULE_ID */.Z.MODULE_ID, "resetToDefaults", {
    name: `${settings/* default.MODULE_ID */.Z.MODULE_ID}.Dialogs.ResetSettings.Title`,
    label: `${settings/* default.MODULE_ID */.Z.MODULE_ID}.Dialogs.ResetSettings.Label`,
    hint: `${settings/* default.MODULE_ID */.Z.MODULE_ID}.Dialogs.ResetSettings.Hint`,
    icon: "fas fa-refresh",
    type: ResetSettingsDialog,
    restricted: true,
  });

  // reset settings
  game.settings.registerMenu(settings/* default.MODULE_ID */.Z.MODULE_ID, "ddbProxy", {
    name: `${settings/* default.MODULE_ID */.Z.MODULE_ID}.Dialogs.DDBProxy.Title`,
    label: `${settings/* default.MODULE_ID */.Z.MODULE_ID}.Dialogs.DDBProxy.Label`,
    hint: `${settings/* default.MODULE_ID */.Z.MODULE_ID}.Dialogs.DDBProxy.Hint`,
    icon: "fas fa-ethernet",
    type: DDBProxySetup,
    restricted: true,
  });


  if (game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "developer-mode")) {
    CONFIG.DDBI.DEV.enabled = true;
  }

  // disable srd/midi srd copy as v10 does not work
  game.settings.set(settings/* default.MODULE_ID */.Z.MODULE_ID, "character-update-policy-dae-effect-copy", false);
  game.settings.set(settings/* default.MODULE_ID */.Z.MODULE_ID, "munching-policy-dae-copy", false);
  game.settings.set(settings/* default.MODULE_ID */.Z.MODULE_ID, "munching-policy-use-dae-effects", false);

}

;// CONCATENATED MODULE: ./src/lib/DDBItemConfig.js


class DDBItemConfig extends FormApplication {
  static get defaultOptions() {
    const options = super.defaultOptions;
    options.title = "DDB Owned Item Config";
    options.template = "modules/ddb-importer/handlebars/item-config.hbs";
    options.classes = ["ddbimporter", "sheet"];
    options.width = 500;
    return options;
  }

  /** @override */
  async getData() { // eslint-disable-line class-methods-use-this
    // console.warn(this);
    // console.warn(this.object);
    let item = this.object;

    const icon = item.flags.ddbimporter?.ignoreIcon;
    const itemImport = item.flags.ddbimporter?.ignoreItemImport;
    const resource = item.flags.ddbimporter?.retainResourceConsumption;
    // const itemSync = item.flags.ddbimporter?.ignoreItemSync;
    const overrideId = item.flags.ddbimporter?.overrideId;

    const settings = [
      {
        name: "ignoreItemImport",
        isChecked: itemImport,
        description: "Ignore this item when importing the character (implies all other settings here).",
      },
      {
        name: "ignoreIcon",
        isChecked: icon,
        description: "Ignore icon updates.",
      },
      {
        name: "retainResourceConsumption",
        isChecked: resource,
        description: "Retain Resource Consumption linking.",
      },
      // {
      //   name: "ignoreItemSync",
      //   isChecked: itemSync,
      //   description: "Ignore this item when when syncing the character",
      // },
    ];

    const overrides = {
      "NONE": {
        label: `None`,
        selected: false
      }
    };

    const label = CompendiumHelper/* default.getCompendiumLabel */.Z.getCompendiumLabel("custom");
    const compendium = CompendiumHelper/* default.getCompendium */.Z.getCompendium(label);
    const index = await compendium.getIndex();

    index.forEach((item) => {
      overrides[item._id] = {
        label: `${item.name} (${item.type})`,
        selected: false,
      };
    });

    const selectedOverrideId = overrideId || "NONE";
    overrides[selectedOverrideId].selected = true;

    const result = {
      name: item.name,
      img: item.img,
      character: this.object.actor.name,
      settings,
      overrides,
    };

    return result;
  }

  get id() {
    const actor = this.object;
    let id = `ddb-actor-${actor.id}`;
    return id;
  }

  /** @override */
  // eslint-disable-next-line no-unused-vars
  async _updateObject(event, formData) {
    event.preventDefault();

    let item = {
      _id: this.object._id,
      flags: this.object.flags,
    };

    if (!item.flags.ddbimporter) item.flags.ddbimporter = {};
    item.flags.ddbimporter['overrideId'] = formData['override'];
    item.flags.ddbimporter['ignoreIcon'] = formData['ignoreIcon'];
    item.flags.ddbimporter['ignoreItemImport'] = formData['ignoreItemImport'];
    item.flags.ddbimporter['retainResourceConsumption'] = formData['retainResourceConsumption'];
    // item.flags.ddbimporter['ignoreItemSync'] = formData['ignoreItemSync'];

    this.object.actor.updateEmbeddedDocuments("Item", [item]);

  }
}

;// CONCATENATED MODULE: ./src/hooks/ready/items.js



function initItemSheetHook(app, html) {
  if (!app.document.isOwned) return;
  // console.error(app.entity);
  // console.log(data);
  const title = `DDB Importer Item Config`;
  const whiteTitle = (game.settings.get("ddb-importer", "link-title-colour-white")) ? " white" : "";
  let button = $(`<a class="open-item-ddb-importer" title="${title}"><i class="fab fa-d-and-d-beyond${whiteTitle}"></i></a>`);
  button.click((event) => {
    if (event.shiftKey && event.ctrlKey) {
      new DDBAdventureFlags(app.document, {}).render(true);
    } else {
      new DDBItemConfig(app.document, {}).render(true);
    }
  });
  html.closest('.app').find('.open-item-ddb-importer').remove();
  let titleElement = html.closest('.app').find('.window-title');
  button.insertAfter(titleElement);
}

function itemSheets() {
  Hooks.on('renderItemSheet', initItemSheetHook);
}


;// CONCATENATED MODULE: ./src/hooks/ready/checkVersion.js



const MODULE_TITLE = "DDB Importer";
const MODULE_NAME = "ddb-importer";
const MODULE_AUTHOR = "MrPrimate";
const _GITHUB_API_LATEST = `https://api.github.com/repos/${MODULE_AUTHOR}/${MODULE_NAME}/releases/latest`;
const _GITHUB_MODULE_JSON_LATEST = `https://raw.githubusercontent.com/${MODULE_AUTHOR}/${MODULE_NAME}/master/module-template.json`;
const MINIMUM_5E_VERSION = "2.0.1";

// eslint-disable-next-line consistent-return
async function getLatestModuleVersion() {
  try {
    const { tag_name: latestVersion, prerelease } = await $.getJSON(_GITHUB_API_LATEST);
    return { latestVersion, prerelease };
  } catch (error) {
    src_logger/* default.error */.Z.error(error);
  }
}

// eslint-disable-next-line consistent-return
async function getLatestModuleMinimumCoreVersion() {
  try {
    const { minimumCoreVersion, compatibleCoreVersion } = await $.getJSON(_GITHUB_MODULE_JSON_LATEST);
    return { minimumCoreVersion, compatibleCoreVersion };
  } catch (error) {
    src_logger/* default.error */.Z.error(error);
  }
}

/* harmony default export */ const checkVersion = (async () => {
  const moduleInfo = game.modules.get(MODULE_NAME);
  const installedVersion = moduleInfo.version;
  setProperty(CONFIG, "DDBI.version", installedVersion);
  try {
    if (!game.user.isGM) return;
    const { minimumCoreVersion, compatibleCoreVersion } = await getLatestModuleMinimumCoreVersion();
    const compatibleMinimumSystem = utils/* default.versionCompare */.Z.versionCompare(game.data.system.version, MINIMUM_5E_VERSION) >= 0;

    if (!compatibleMinimumSystem) {
      ui.notifications.error(`${MODULE_TITLE} strongly recommends 5e system v${MINIMUM_5E_VERSION} to run correctly. Please update your 5e version.`, { permanent: true });
    }

    // check version number only for GMs
    const coreCheck = game.settings.get("ddb-importer", "update-check");
    if (!coreCheck) return;

    const { latestVersion, prerelease: preRelease } = await getLatestModuleVersion();

    const newModuleVersion = utils/* default.versionCompare */.Z.versionCompare(latestVersion, installedVersion) === 1;
    const compatibleCore = utils/* default.versionCompare */.Z.versionCompare(game.version, compatibleCoreVersion) >= 0;
    const compatibleMinimumCore = utils/* default.versionCompare */.Z.versionCompare(game.version, minimumCoreVersion) >= 0;

    const needToUpdate = newModuleVersion && compatibleCore && compatibleMinimumCore;

    // console.log(utils.versionCompare("1.0.1", "1.0.1")); // 0
    // console.log(utils.versionCompare("1.0.0", "1.0.1")); // -1
    // console.log(utils.versionCompare("2.0.0", "1.0.1")); // 1

    if (preRelease) src_logger/* default.debug */.Z.debug(`Prerelease of ${MODULE_TITLE} detected`);

    if (needToUpdate) {
      let text = $(
        `<h2>${MODULE_TITLE} Update!</h2><p>A new <b>${MODULE_NAME}</b> version is available. Please update to <b>v${latestVersion}</b> if you are experiencing issues and before reporting a bug.</p>`
      );
      game.modules.get("ddb-importer").api?.notification.show(text, null);
    }
  } catch (error) {
    src_logger/* default.warn */.Z.warn(error);
    game.modules.get("ddb-importer").api?.notification.show(`Could not retrieve latest ${MODULE_NAME} version`);
  }
});

;// CONCATENATED MODULE: ./src/hooks/ready/fallbackConfig.js
const fallbackDDBConfig = {
  armor: [
    {
      id: 3,
      entityTypeId: 701257905,
      name: "Studded Leather",
      categoryId: 1,
    },
    {
      id: 6,
      entityTypeId: 701257905,
      name: "Scale Mail",
      categoryId: 2,
    },
    {
      id: 8,
      entityTypeId: 701257905,
      name: "Shield",
      categoryId: 4,
    },
    {
      id: 9,
      entityTypeId: 701257905,
      name: "Padded",
      categoryId: 1,
    },
    {
      id: 10,
      entityTypeId: 701257905,
      name: "Leather",
      categoryId: 1,
    },
    {
      id: 11,
      entityTypeId: 701257905,
      name: "Hide",
      categoryId: 2,
    },
    {
      id: 12,
      entityTypeId: 701257905,
      name: "Chain Shirt",
      categoryId: 2,
    },
    {
      id: 13,
      entityTypeId: 701257905,
      name: "Breastplate",
      categoryId: 2,
    },
    {
      id: 14,
      entityTypeId: 701257905,
      name: "Half Plate",
      categoryId: 2,
    },
    {
      id: 15,
      entityTypeId: 701257905,
      name: "Ring Mail",
      categoryId: 3,
    },
    {
      id: 16,
      entityTypeId: 701257905,
      name: "Chain Mail",
      categoryId: 3,
    },
    {
      id: 17,
      entityTypeId: 701257905,
      name: "Splint",
      categoryId: 3,
    },
    {
      id: 18,
      entityTypeId: 701257905,
      name: "Plate",
      categoryId: 3,
    },
    {
      id: 19,
      entityTypeId: 701257905,
      name: "Spiked Armor",
      categoryId: 2,
    },
    {
      id: 20,
      entityTypeId: 701257905,
      name: "Pride Silk Outfit",
      categoryId: 1,
    },
  ],
  tools: [
    {
      id: 102,
      name: "Alchemist's Supplies",
    },
    {
      id: 103,
      name: "Brewer's Supplies",
    },
    {
      id: 104,
      name: "Calligrapher's Supplies",
    },
    {
      id: 105,
      name: "Carpenter's Tools",
    },
    {
      id: 106,
      name: "Cartographer's Tools",
    },
    {
      id: 107,
      name: "Cobbler's Tools",
    },
    {
      id: 108,
      name: "Cook's Utensils",
    },
    {
      id: 109,
      name: "Glassblower's Tools",
    },
    {
      id: 110,
      name: "Jeweler's Tools",
    },
    {
      id: 111,
      name: "Leatherworker's Tools",
    },
    {
      id: 112,
      name: "Mason's Tools",
    },
    {
      id: 113,
      name: "Painter's Supplies",
    },
    {
      id: 114,
      name: "Potter's Tools",
    },
    {
      id: 115,
      name: "Smith's Tools",
    },
    {
      id: 116,
      name: "Tinker's Tools",
    },
    {
      id: 117,
      name: "Weaver's Tools",
    },
    {
      id: 118,
      name: "Woodcarver's Tools",
    },
    {
      id: 119,
      name: "Disguise Kit",
    },
    {
      id: 120,
      name: "Forgery Kit",
    },
    {
      id: 121,
      name: "Dice Set",
    },
    {
      id: 122,
      name: "Playing Card Set",
    },
    {
      id: 123,
      name: "Herbalism Kit",
    },
    {
      id: 124,
      name: "Navigator's Tools",
    },
    {
      id: 125,
      name: "Poisoner's Kit",
    },
    {
      id: 126,
      name: "Thieves' Tools",
    },
    {
      id: 127,
      name: "Bagpipes",
    },
    {
      id: 128,
      name: "Drum",
    },
    {
      id: 129,
      name: "Dulcimer",
    },
    {
      id: 130,
      name: "Flute",
    },
    {
      id: 131,
      name: "Lute",
    },
    {
      id: 132,
      name: "Horn",
    },
    {
      id: 133,
      name: "Pan Flute",
    },
    {
      id: 134,
      name: "Shawm",
    },
    {
      id: 135,
      name: "Lyre",
    },
    {
      id: 136,
      name: "Viol",
    },
    {
      id: 189,
      name: "Three-Dragon Ante Set",
    },
    {
      id: 190,
      name: "Dragonchess Set",
    },
    {
      id: 232,
      name: "Birdpipes",
    },
    {
      id: 233,
      name: "Glaur",
    },
    {
      id: 234,
      name: "Hand Drum",
    },
    {
      id: 235,
      name: "Longhorn",
    },
    {
      id: 236,
      name: "Songhorn",
    },
    {
      id: 237,
      name: "Tantan",
    },
    {
      id: 238,
      name: "Thelarr",
    },
    {
      id: 239,
      name: "Tocken",
    },
    {
      id: 240,
      name: "Wargong",
    },
    {
      id: 241,
      name: "Yarting",
    },
    {
      id: 242,
      name: "Zulkoon",
    },
    {
      id: 301,
      name: "Whistle-Stick",
    },
  ],
  weapons: [
    {
      id: 1,
      entityTypeId: 1782728300,
      name: "Crossbow, Hand",
      categoryId: 2,
    },
    {
      id: 2,
      entityTypeId: 1782728300,
      name: "Glaive",
      categoryId: 2,
    },
    {
      id: 3,
      entityTypeId: 1782728300,
      name: "Dagger",
      categoryId: 1,
    },
    {
      id: 4,
      entityTypeId: 1782728300,
      name: "Longsword",
      categoryId: 2,
    },
    {
      id: 5,
      entityTypeId: 1782728300,
      name: "Club",
      categoryId: 1,
    },
    {
      id: 6,
      entityTypeId: 1782728300,
      name: "Greatclub",
      categoryId: 1,
    },
    {
      id: 7,
      entityTypeId: 1782728300,
      name: "Handaxe",
      categoryId: 1,
    },
    {
      id: 8,
      entityTypeId: 1782728300,
      name: "Javelin",
      categoryId: 1,
    },
    {
      id: 10,
      entityTypeId: 1782728300,
      name: "Light Hammer",
      categoryId: 1,
    },
    {
      id: 11,
      entityTypeId: 1782728300,
      name: "Mace",
      categoryId: 1,
    },
    {
      id: 12,
      entityTypeId: 1782728300,
      name: "Quarterstaff",
      categoryId: 1,
    },
    {
      id: 13,
      entityTypeId: 1782728300,
      name: "Sickle",
      categoryId: 1,
    },
    {
      id: 14,
      entityTypeId: 1782728300,
      name: "Spear",
      categoryId: 1,
    },
    {
      id: 15,
      entityTypeId: 1782728300,
      name: "Crossbow, Light",
      categoryId: 1,
    },
    {
      id: 16,
      entityTypeId: 1782728300,
      name: "Dart",
      categoryId: 1,
    },
    {
      id: 17,
      entityTypeId: 1782728300,
      name: "Shortbow",
      categoryId: 1,
    },
    {
      id: 18,
      entityTypeId: 1782728300,
      name: "Sling",
      categoryId: 1,
    },
    {
      id: 19,
      entityTypeId: 1782728300,
      name: "Battleaxe",
      categoryId: 2,
    },
    {
      id: 20,
      entityTypeId: 1782728300,
      name: "Flail",
      categoryId: 2,
    },
    {
      id: 21,
      entityTypeId: 1782728300,
      name: "Greataxe",
      categoryId: 2,
    },
    {
      id: 22,
      entityTypeId: 1782728300,
      name: "Greatsword",
      categoryId: 2,
    },
    {
      id: 23,
      entityTypeId: 1782728300,
      name: "Halberd",
      categoryId: 2,
    },
    {
      id: 24,
      entityTypeId: 1782728300,
      name: "Lance",
      categoryId: 2,
    },
    {
      id: 25,
      entityTypeId: 1782728300,
      name: "Maul",
      categoryId: 2,
    },
    {
      id: 26,
      entityTypeId: 1782728300,
      name: "Morningstar",
      categoryId: 2,
    },
    {
      id: 27,
      entityTypeId: 1782728300,
      name: "Pike",
      categoryId: 2,
    },
    {
      id: 28,
      entityTypeId: 1782728300,
      name: "Rapier",
      categoryId: 2,
    },
    {
      id: 29,
      entityTypeId: 1782728300,
      name: "Scimitar",
      categoryId: 2,
    },
    {
      id: 30,
      entityTypeId: 1782728300,
      name: "Shortsword",
      categoryId: 2,
    },
    {
      id: 31,
      entityTypeId: 1782728300,
      name: "Trident",
      categoryId: 2,
    },
    {
      id: 32,
      entityTypeId: 1782728300,
      name: "War Pick",
      categoryId: 2,
    },
    {
      id: 33,
      entityTypeId: 1782728300,
      name: "Warhammer",
      categoryId: 2,
    },
    {
      id: 34,
      entityTypeId: 1782728300,
      name: "Whip",
      categoryId: 2,
    },
    {
      id: 35,
      entityTypeId: 1782728300,
      name: "Blowgun",
      categoryId: 2,
    },
    {
      id: 36,
      entityTypeId: 1782728300,
      name: "Crossbow, Heavy",
      categoryId: 2,
    },
    {
      id: 37,
      entityTypeId: 1782728300,
      name: "Longbow",
      categoryId: 2,
    },
    {
      id: 38,
      entityTypeId: 1782728300,
      name: "Net",
      categoryId: 2,
    },
    {
      id: 40,
      entityTypeId: 1782728300,
      name: "Boomerang",
      categoryId: 1,
    },
    {
      id: 41,
      entityTypeId: 1782728300,
      name: "Yklwa",
      categoryId: 1,
    },
    {
      id: 42,
      entityTypeId: 1782728300,
      name: "Pistol",
      categoryId: 3,
    },
    {
      id: 43,
      entityTypeId: 1782728300,
      name: "Musket",
      categoryId: 3,
    },
    {
      id: 44,
      entityTypeId: 1782728300,
      name: "Pistol, Automatic",
      categoryId: 3,
    },
    {
      id: 45,
      entityTypeId: 1782728300,
      name: "Revolver",
      categoryId: 3,
    },
    {
      id: 46,
      entityTypeId: 1782728300,
      name: "Rifle, Hunting",
      categoryId: 3,
    },
    {
      id: 47,
      entityTypeId: 1782728300,
      name: "Rifle, Automatic",
      categoryId: 3,
    },
    {
      id: 48,
      entityTypeId: 1782728300,
      name: "Shotgun",
      categoryId: 3,
    },
    {
      id: 49,
      entityTypeId: 1782728300,
      name: "Laser Pistol",
      categoryId: 3,
    },
    {
      id: 50,
      entityTypeId: 1782728300,
      name: "Antimatter Rifle",
      categoryId: 3,
    },
    {
      id: 51,
      entityTypeId: 1782728300,
      name: "Laser Rifle",
      categoryId: 3,
    },
    {
      id: 52,
      entityTypeId: 1782728300,
      name: "Palm Pistol (Exandria)",
      categoryId: 3,
    },
    {
      id: 53,
      entityTypeId: 1782728300,
      name: "Pepperbox (Exandria)",
      categoryId: 3,
    },
    {
      id: 54,
      entityTypeId: 1782728300,
      name: "Pistol (Exandria)",
      categoryId: 3,
    },
    {
      id: 55,
      entityTypeId: 1782728300,
      name: "Blunderbuss (Exandria)",
      categoryId: 3,
    },
    {
      id: 56,
      entityTypeId: 1782728300,
      name: "Bad News (Exandria)",
      categoryId: 3,
    },
    {
      id: 57,
      entityTypeId: 1782728300,
      name: "Hand Mortar (Exandria)",
      categoryId: 3,
    },
    {
      id: 58,
      entityTypeId: 1782728300,
      name: "Musket (Exandria)",
      categoryId: 3,
    },
    {
      id: 59,
      entityTypeId: 1782728300,
      name: "Double-Bladed Scimitar",
      categoryId: 2,
    },
  ],
  languages: [
    { id: 1, name: "Common" },
    { id: 2, name: "Dwarvish" },
    { id: 3, name: "Elvish" },
    { id: 4, name: "Giant" },
    { id: 5, name: "Gnomish" },
    { id: 6, name: "Goblin" },
    { id: 7, name: "Halfling" },
    { id: 8, name: "Orc" },
    { id: 9, name: "Abyssal" },
    { id: 10, name: "Celestial" },
    { id: 11, name: "Draconic" },
    { id: 12, name: "Deep Speech" },
    { id: 13, name: "Infernal" },
    { id: 14, name: "Primordial" },
    { id: 15, name: "Sylvan" },
    { id: 16, name: "Undercommon" },
    { id: 18, name: "Telepathy" },
    { id: 19, name: "Aquan" },
    { id: 20, name: "Auran" },
    { id: 21, name: "Ignan" },
    { id: 22, name: "Terran" },
    { id: 23, name: "Druidic" },
    { id: 24, name: "Giant Eagle" },
    { id: 25, name: "Giant Elk" },
    { id: 26, name: "Giant Owl" },
    { id: 27, name: "Gnoll" },
    { id: 28, name: "Otyugh" },
    { id: 29, name: "Sahuagin" },
    { id: 30, name: "Sphinx" },
    { id: 31, name: "Winter Wolf" },
    { id: 32, name: "Worg" },
    { id: 33, name: "Blink Dog" },
    { id: 34, name: "Yeti" },
    { id: 35, name: "All" },
    { id: 36, name: "Aarakocra" },
    { id: 37, name: "Slaad" },
    { id: 38, name: "Bullywug" },
    { id: 39, name: "Gith" },
    { id: 40, name: "Grell" },
    { id: 41, name: "Hook Horror" },
    { id: 42, name: "Modron" },
    { id: 43, name: "Thri-kreen" },
    { id: 44, name: "Troglodyte" },
    { id: 45, name: "Umber Hulk" },
    { id: 46, name: "Thieves' Cant" },
    { id: 47, name: "Grung" },
    { id: 48, name: "Tlincalli" },
    { id: 49, name: "Vegepygmy" },
    { id: 50, name: "Yikaria" },
    { id: 51, name: "Bothii" },
    { id: 52, name: "Ixitxachitl" },
    { id: 53, name: "Thayan" },
    { id: 54, name: "Netherese" },
    { id: 55, name: "Ice Toad" },
    { id: 56, name: "Olman" },
    { id: 57, name: "Quori" },
    { id: 58, name: "Minotaur" },
    { id: 59, name: "Loxodon" },
    { id: 60, name: "Kraul" },
    { id: 61, name: "Vedalken" },
    { id: 62, name: "Daelkyr" },
    { id: 64, name: "Riedran" },
    { id: 66, name: "Zemnian" },
    { id: 67, name: "Marquesian" },
    { id: 68, name: "Naush" },
    { id: 69, name: "Leonin" },
    { id: 70, name: "Grippli" },
    { id: 71, name: "Skitterwidget" },
    { id: 72, name: "Ziklight" },
    { id: 73, name: "Kruthik" },
    { id: 74, name: "CitlanÃ©s" },
    { id: 75, name: "Djaynaian" },
    { id: 76, name: "Godstongue" },
    { id: 77, name: "Halri" },
    { id: 78, name: "Maynah" },
    { id: 79, name: "Nâ€™warian" },
    { id: 80, name: "Quirapu" },
    { id: 81, name: "Sensan" },
    { id: 82, name: "Shankhi" },
    { id: 83, name: "Tletlahtolli" },
    { id: 84, name: "Xingyu" },
    { id: 85, name: "Zabaani" },
    { id: 86, name: "Dohwar" },
    { id: 87, name: "Hadozee" },
    { id: 88, name: "Aartuk" },
    { id: 89, name: "Abanasinian" },
    { id: 90, name: "Ergot" },
    { id: 91, name: "Istarian" },
    { id: 92, name: "Kenderspeak" },
    { id: 93, name: "Kharolian" },
    { id: 94, name: "Khur" },
    { id: 95, name: "Kothian" },
    { id: 96, name: "Nerakese" },
    { id: 97, name: "Nordmaarian" },
    { id: 98, name: "Ogre" },
    { id: 99, name: "Solamnic" },
  ],
  restoreTypes: [
    { id: 1, name: "Full", description: "Restore life with full HP" },
    { id: 2, name: "OneHP", description: "Restore life with 1 HP" },
  ],
  raceGroups: [
    { id: 1, name: "Human", avatarUrl: "https://www.dndbeyond.com/avatars/316/819/636620994416798583.jpeg" },
    { id: 2, name: "Half-Orc", avatarUrl: "https://www.dndbeyond.com/avatars/316/817/636620994330373054.jpeg" },
    { id: 3, name: "Elf", avatarUrl: "https://www.dndbeyond.com/avatars/316/807/636620993866733375.jpeg" },
    { id: 4, name: "Aarakocra", avatarUrl: "https://www.dndbeyond.com/avatars/316/802/636620993394513358.jpeg" },
    { id: 5, name: "Tiefling", avatarUrl: "https://www.dndbeyond.com/avatars/316/825/636620994695575306.jpeg" },
    { id: 6, name: "Dwarf", avatarUrl: "https://www.dndbeyond.com/avatars/316/806/636620993762055484.jpeg" },
    { id: 7, name: "Halfling", avatarUrl: "https://www.dndbeyond.com/avatars/316/816/636620994265008086.jpeg" },
    { id: 8, name: "Dragonborn", avatarUrl: "https://www.dndbeyond.com/avatars/316/805/636620993696690483.jpeg" },
    { id: 9, name: "Gnome", avatarUrl: "https://www.dndbeyond.com/avatars/316/811/636620994035528201.jpeg" },
    { id: 10, name: "Half-Elf", avatarUrl: "https://www.dndbeyond.com/avatars/316/814/636620994184198696.jpeg" },
    { id: 11, name: "Goliath", avatarUrl: "https://www.dndbeyond.com/avatars/316/813/636620994135369890.jpeg" },
    { id: 12, name: "Genasi", avatarUrl: "https://www.dndbeyond.com/avatars/316/809/636620993978899042.jpeg" },
    { id: 13, name: "Aasimar", avatarUrl: "https://www.dndbeyond.com/avatars/316/803/636620993510579220.jpeg" },
    { id: 14, name: "Firbolg", avatarUrl: "https://www.dndbeyond.com/avatars/316/808/636620993924142291.jpeg" },
    { id: 15, name: "Kenku", avatarUrl: "https://www.dndbeyond.com/avatars/316/820/636620994458763373.jpeg" },
    { id: 16, name: "Lizardfolk", avatarUrl: "https://www.dndbeyond.com/avatars/316/822/636620994561880989.jpeg" },
    { id: 17, name: "Tabaxi", avatarUrl: "https://www.dndbeyond.com/avatars/316/824/636620994652518517.jpeg" },
    { id: 18, name: "Triton", avatarUrl: "https://www.dndbeyond.com/avatars/316/827/636620994792452860.jpeg" },
    { id: 19, name: "Bugbear", avatarUrl: "https://www.dndbeyond.com/avatars/316/804/636620993577660502.jpeg" },
    { id: 20, name: "Goblin", avatarUrl: "https://www.dndbeyond.com/avatars/316/812/636620994081080899.jpeg" },
    { id: 21, name: "Hobgoblin", avatarUrl: "https://www.dndbeyond.com/avatars/316/818/636620994370309752.jpeg" },
    { id: 22, name: "Kobold", avatarUrl: "https://www.dndbeyond.com/avatars/316/821/636620994500727959.jpeg" },
    { id: 23, name: "Orc", avatarUrl: "https://www.dndbeyond.com/avatars/316/823/636620994608993950.jpeg" },
    {
      id: 24,
      name: "Yuan-ti Pureblood",
      avatarUrl: "https://www.dndbeyond.com/avatars/316/828/636620994846117422.jpeg",
    },
    { id: 25, name: "Tortle", avatarUrl: "https://www.dndbeyond.com/avatars/316/826/636620994747056231.jpeg" },
    { id: 27, name: "Gith", avatarUrl: "https://www.dndbeyond.com/avatars/318/759/636621911421792248.jpeg" },
    { id: 28, name: "Warforged", avatarUrl: "https://www.dndbeyond.com/avatars/2490/554/636680421772857650.jpeg" },
    { id: 29, name: "Shifter", avatarUrl: "https://www.dndbeyond.com/avatars/2490/562/636680421866916694.jpeg" },
    { id: 30, name: "Draconic Races", avatarUrl: null },
    { id: 31, name: "Lineages", avatarUrl: null },
  ],
  spellRangeTypes: [
    { id: 1, name: "Self" },
    { id: 2, name: "Touch" },
    { id: 3, name: "Ranged" },
    { id: 4, name: "Sight" },
    { id: 9, name: "Unlimited" },
  ],
  adjustmentDataTypes: [
    { id: 1, name: "Integer" },
    { id: 2, name: "Decimal" },
    { id: 3, name: "String" },
    { id: 4, name: "Boolean" },
  ],
  coverTypes: [
    { type: "half", name: "Half" },
    { type: "three-quarters", name: "Three-Quarters" },
    { type: "full", name: "Full" },
  ],
  spellConditionTypes: [
    { id: 1, name: "Apply" },
    { id: 2, name: "Remove" },
    { id: 3, name: "Suppress" },
  ],
  rangeTypes: [
    { id: 1, name: "Melee" },
    { id: 2, name: "Ranged" },
  ],
  damageTypes: [
    { id: 1, name: "Bludgeoning" },
    { id: 2, name: "Piercing" },
    { id: 3, name: "Slashing" },
    { id: 4, name: "Necrotic" },
    { id: 5, name: "Acid" },
    { id: 6, name: "Cold" },
    { id: 7, name: "Fire" },
    { id: 8, name: "Lightning" },
    { id: 9, name: "Thunder" },
    { id: 10, name: "Poison" },
    { id: 11, name: "Psychic" },
    { id: 12, name: "Radiant" },
    { id: 13, name: "Force" },
  ],
  privacyTypes: [
    { id: 1, name: "Private" },
    { id: 2, name: "CampaignOnly" },
    { id: 3, name: "Public" },
  ],
  sharingTypes: [
    { id: 1, name: "Full" },
    { id: 2, name: "Limited" },
    { id: 3, name: "StatBlock" },
  ],
  abilityScoreDisplayTypes: [
    { id: 1, name: "ScoresTop" },
    { id: 2, name: "ModifiersTop" },
  ],
  stealthCheckTypes: [
    { id: 1, name: "None" },
    { id: 2, name: "Disadvantage" },
  ],
  conditionTypes: [
    { id: 1, name: "Standard" },
    { id: 2, name: "Special" },
  ],
  operators: [
    { id: 1, name: "Addition" },
    { id: 2, name: "Multiplication" },
  ],
  monsterSubTypes: [
    { id: 1, name: "aarakocra" },
    { id: 2, name: "gnome" },
    { id: 3, name: "gnoll" },
    { id: 4, name: "grimlock" },
    { id: 5, name: "any race" },
    { id: 6, name: "elf" },
    { id: 7, name: "tortle" },
    { id: 8, name: "yugoloth" },
    { id: 9, name: "demon" },
    { id: 10, name: "devil" },
    { id: 11, name: "shapechanger" },
    { id: 12, name: "nagpa" },
    { id: 13, name: "meazel" },
    { id: 14, name: "inevitable" },
    { id: 15, name: "gith" },
    { id: 16, name: "dwarf" },
    { id: 17, name: "derro" },
    { id: 18, name: "kuo-toa" },
    { id: 19, name: "titan" },
    { id: 20, name: "yuan-ti" },
    { id: 21, name: "xvart" },
    { id: 22, name: "orc" },
    { id: 23, name: "goblinoid" },
    { id: 24, name: "kobold" },
    { id: 25, name: "grung" },
    { id: 26, name: "kenku" },
    { id: 27, name: "firenewt" },
    { id: 28, name: "troglodyte" },
    { id: 29, name: "thri-kreen" },
    { id: 30, name: "sahuagin" },
    { id: 31, name: "quaggoth" },
    { id: 32, name: "merfolk" },
    { id: 33, name: "human" },
    { id: 34, name: "lizardfolk" },
    { id: 35, name: "cloud giant" },
    { id: 36, name: "fire giant" },
    { id: 37, name: "frost giant" },
    { id: 38, name: "hill giant" },
    { id: 39, name: "stone giant" },
    { id: 40, name: "storm giant" },
    { id: 41, name: "bullywug" },
    { id: 42, name: "saurial" },
    { id: 43, name: "tabaxi" },
    { id: 44, name: "half-elf" },
    { id: 45, name: "half-dragon" },
    { id: 46, name: "simic hybrid" },
    { id: 47, name: "angel" },
    { id: 48, name: "kraul" },
    { id: 49, name: "tiefling" },
    { id: 50, name: "half-orc" },
    { id: 51, name: "halfling" },
    { id: 52, name: "locathah" },
    { id: 53, name: "triton" },
    { id: 54, name: "dragonborn" },
    { id: 55, name: "warforged" },
    { id: 56, name: "water genasi" },
    { id: 57, name: "fire genasi" },
    { id: 58, name: "earth genasi" },
    { id: 59, name: "air genasi" },
    { id: 60, name: "changeling" },
    { id: 61, name: "kalashtar" },
    { id: 62, name: "shifter" },
    { id: 63, name: "blindheim" },
    { id: 64, name: "dire corby" },
    { id: 65, name: "jermlaine" },
    { id: 66, name: "goliath" },
    { id: 67, name: "Giff" },
    { id: 68, name: "Skulk" },
    { id: 69, name: "Leonin" },
    { id: 70, name: "grippli" },
    { id: 71, name: "mongrelfolk" },
    { id: 72, name: "Harengon" },
    { id: 73, name: "Hag" },
    { id: 74, name: "Wizard" },
    { id: 75, name: "Sorcerer" },
    { id: 76, name: "Warlock" },
    { id: 77, name: "Cleric" },
    { id: 78, name: "Shadar-Kai" },
    { id: 79, name: "Paladin" },
    { id: 80, name: "Gem" },
    { id: 81, name: "Metallic" },
    { id: 82, name: "Chromatic" },
    { id: 83, name: "High-Elf" },
    { id: 84, name: "half-black dragon" },
    { id: 85, name: "Druid" },
    { id: 89, name: "Bard" },
    { id: 90, name: "shield dwarf" },
    { id: 91, name: "Ranger" },
    { id: 92, name: "Goblin" },
    { id: 93, name: "Drow" },
    { id: 94, name: "Ogre" },
    { id: 95, name: "Monk" },
  ],
  creatureGroupFlags: [
    { id: 1, name: "Armor Add Proficiency Bonus", key: "ACPB", value: null, valueContextId: null },
    { id: 2, name: "Attack Rolls Add Proficiency Bonus", key: "ARPB", value: null, valueContextId: null },
    { id: 3, name: "Damage Rolls Add Proficiency Bonus", key: "DRPB", value: null, valueContextId: null },
    { id: 4, name: "Proficient Skills Add Proficiency Bonus", key: "PSPB", value: null, valueContextId: null },
    { id: 5, name: "Proficient Saving Throws Add Proficiency Bonus", key: "STPB", value: null, valueContextId: null },
    { id: 6, name: "Max Hit Points Level Multiplier Option", key: "HPLM", value: 4, valueContextId: 5 },
    { id: 7, name: "Evaluate Owner Skill Proficiencies", key: "EOSKP", value: null, valueContextId: null },
    { id: 8, name: "Evaluate Owner Save Proficiencies", key: "EOSVP", value: null, valueContextId: null },
    { id: 9, name: "Cannot Be Swarm", key: "CBS", value: null, valueContextId: null },
    { id: 10, name: "Cannot Use Legendary Actions", key: "CULGA", value: null, valueContextId: null },
    { id: 11, name: "Cannot Use Lair Actions", key: "CULRA", value: null, valueContextId: null },
    { id: 12, name: "Evaluate_Updated_Passive_Perception", key: "EUPP", value: null, valueContextId: null },
    { id: 13, name: "Evaluate Owner Passive Perception", key: "EOPP", value: null, valueContextId: null },
    { id: 14, name: "Artificer HP Multiplier", key: "AHM", value: 5, valueContextId: 252717 },
    { id: 15, name: "Max Hit Points Add Int Modifier", key: "MHPAIM", value: null, valueContextId: 4 },
    { id: 16, name: "Max Hit Points Add Monster CON Modifier", key: "MHPAMCM", value: null, valueContextId: 3 },
    { id: 17, name: "Use Challenge Rating As Level", key: "UCRAL", value: null, valueContextId: null },
    { id: 18, name: "Max Hit Points Base Artificer Level", key: "MHPBAL", value: null, valueContextId: 252717 },
  ],
  monsterTypes: [
    {
      pluralizedName: "aberrations",
      avatarUrl: "https://www.dndbeyond.com/avatars/4675/665/636747837392078487.jpeg",
      id: 1,
      name: "Aberration",
      description:
        "Aberrations are utterly alien beings. Many of them have innate magical abilities drawn from the creature's alien mind rather than the mystical forces of the world. The quintessential aberrations are aboleths, and slaadi. ",
    },
    {
      pluralizedName: "beasts",
      avatarUrl: "https://www.dndbeyond.com/avatars/4675/664/636747837303835953.jpeg",
      id: 2,
      name: "Beast",
      description:
        "Beasts are nonhumanoid creatures that are a natural part of the fantasy ecology. Some of them have magical powers, but most are unintelligent and lack any society or language. Beasts include all varieties of ordinary animals, dinosaurs, and giant versions of animals. ",
    },
    {
      pluralizedName: "celestials",
      avatarUrl: "https://www.dndbeyond.com/avatars/4675/666/636747837434463638.jpeg",
      id: 3,
      name: "Celestial",
      description:
        "Celestials are creatures native to the Upper Planes. Many of them are the servants of deities, employed as messengers or agents in the mortal realm and throughout the planes. Celestials are good by nature, so the exceptional celestial who strays from a good alignment is a horrifying rarity. ",
    },
    {
      pluralizedName: "constructs",
      avatarUrl: "https://www.dndbeyond.com/avatars/4675/667/636747837482013331.jpeg",
      id: 4,
      name: "Construct",
      description:
        "Constructs include angels, couatls, and pegasi. Constructs are made, not born. Some are programmed by their creators to follow a simple set of instructions, while others are imbued with sentience and capable of independent thought. Golems are the iconic constructs. Many creatures native to the outer plane of Mechanus, such as modrons, are constructs shaped from the raw material of the plane by the will of more powerful creatures. ",
    },
    {
      pluralizedName: "dragons",
      avatarUrl: "https://www.dndbeyond.com/avatars/4675/668/636747837521115242.jpeg",
      id: 6,
      name: "Dragon",
      description:
        "Dragons are large reptilian creatures of ancient origin and tremendous power. True dragons, including the good metallic dragons and the evil chromatic dragons, are highly intelligent and have innate magic. Also in this category are creatures distantly related to true dragons, but less powerful, less intelligent, and less magical, such as wyverns and pseudodragons. ",
    },
    {
      pluralizedName: "elementals",
      avatarUrl: "https://www.dndbeyond.com/avatars/4675/669/636747837569942785.jpeg",
      id: 7,
      name: "Elemental",
      description:
        "Elementals are creatures native to the elemental planes. Some creatures of this type are little more than animate masses of their respective elements, including the creatures simply called elementals. Others have biological forms infused with elemental energy. The races of genies, including djinn and efreet, form the most important civilizations on the elemental planes. Other elemental creatures include azers, invisible stalkers, and water weirds. ",
    },
    {
      pluralizedName: "fey",
      avatarUrl: "https://www.dndbeyond.com/avatars/4675/671/636747837638112910.jpeg",
      id: 8,
      name: "Fey",
      description:
        "Fey are magical creatures closely tied to the forces of nature. They dwell in twilight groves and misty forests. In some worlds, they are closely tied to the Feywild, also called the Plane of Faerie. Some are also found in the Outer Planes, particularly the planes of Arborea and the Beastlands. Fey include dryads, pixies, and satyrs. ",
    },
    {
      pluralizedName: "fiends",
      avatarUrl: "https://www.dndbeyond.com/avatars/4675/672/636747837699453839.jpeg",
      id: 9,
      name: "Fiend",
      description:
        "Fiends are creatures of wickedness that are native to the Lower Planes. A few are the servants of deities, but many more labor under the leadership of archdevils and demon princes. Evil priests and mages sometimes summon fiends to the material world to do their bidding. If an evil celestial is a rarity, a good fiend is almost inconceivable. Fiends include demons, devils, hell hounds, rakshasas, and yugoloths.",
    },
    {
      pluralizedName: "giants",
      avatarUrl: "https://www.dndbeyond.com/avatars/4675/674/636747837751071918.jpeg",
      id: 10,
      name: "Giant",
      description:
        "Giants tower over humans and their kind. They are humanlike in shape, though some have multiple heads (ettins) or deformities (fomorians). The six varieties of true giant are hill giants, stone giants, frost giants, fire giants, cloud giants, and storm giants. Besides these, creatures such as ogres and trolls are giants. ",
    },
    {
      pluralizedName: "humanoids",
      avatarUrl: "https://www.dndbeyond.com/avatars/4675/675/636747837794884984.jpeg",
      id: 11,
      name: "Humanoid",
      description:
        "Humanoids are the main peoples of a fantasy gaming world, both civilized and savage, including humans and a tremendous variety of other species. They have language and culture, few if any innate magical abilities (though most humanoids can learn spellcasting), and a bipedal form. The most common humanoid races are the ones most suitable as player characters: humans, dwarves, elves, and halflings. Almost as numerous but far more savage and brutal, and almost uniformly evil, are the races of goblinoids (goblins, hobgoblins, and bugbears), orcs, gnolls, lizardfolk, and kobolds. ",
    },
    {
      pluralizedName: "monstrosities",
      avatarUrl: "https://www.dndbeyond.com/avatars/4675/676/636747837839875603.jpeg",
      id: 13,
      name: "Monstrosity",
      description:
        "Monstrosities are monsters in the strictest sense--frightening creatures that are not ordinary, not truly natural, and almost never benign. Some are the results of magical experimentation gone awry (such as owlbears), and others are the product of terrible curses (including minotaurs). They defy categorization, and in some sense serve as a catch-all category for creatures that don't fit into any other type.",
    },
    {
      pluralizedName: "oozes",
      avatarUrl: "https://www.dndbeyond.com/avatars/4675/678/636747837893364274.jpeg",
      id: 14,
      name: "Ooze",
      description:
        "Oozes are gelatinous creatures that rarely have a fixed shape. They are mostly subterranean, dwelling in caves and dungeons and feeding on refuse, carrion, or creatures unlucky enough to get in their way. Black puddings and gelatinous cubes are among the most recognizable oozes. ",
    },
    {
      pluralizedName: "plants",
      avatarUrl: "https://www.dndbeyond.com/avatars/4675/679/636747837952193011.jpeg",
      id: 15,
      name: "Plant",
      description:
        "Plants in this context are vegetable creatures, not ordinary flora. Most of them are ambulatory, and some are carnivorous. The quintessential plants are the shambling mound and the treant. Fungal creatures such as the gas spore and the myconid also fall into this category. ",
    },
    {
      pluralizedName: "undead",
      avatarUrl: "https://www.dndbeyond.com/avatars/4675/680/636747837998336262.jpeg",
      id: 16,
      name: "Undead",
      description:
        "Undead are once-living creatures brought to a horrifying state of undeath through the practice of necromantic magic or some unholy curse. Undead include walking corpses, such as vampires and zombies, as well as bodiless spirits, such as ghosts and specters.\n\n",
    },
  ],
  challengeRatings: [
    { id: 1, value: 0.0, proficiencyBonus: 2, xp: 10 },
    { id: 2, value: 0.125, proficiencyBonus: 2, xp: 25 },
    { id: 3, value: 0.25, proficiencyBonus: 2, xp: 50 },
    { id: 4, value: 0.5, proficiencyBonus: 2, xp: 100 },
    { id: 5, value: 1.0, proficiencyBonus: 2, xp: 200 },
    { id: 6, value: 2.0, proficiencyBonus: 2, xp: 450 },
    { id: 7, value: 3.0, proficiencyBonus: 2, xp: 700 },
    { id: 8, value: 4.0, proficiencyBonus: 2, xp: 1100 },
    { id: 9, value: 5.0, proficiencyBonus: 3, xp: 1800 },
    { id: 10, value: 6.0, proficiencyBonus: 3, xp: 2300 },
    { id: 11, value: 7.0, proficiencyBonus: 3, xp: 2900 },
    { id: 12, value: 8.0, proficiencyBonus: 3, xp: 3900 },
    { id: 13, value: 9.0, proficiencyBonus: 4, xp: 5000 },
    { id: 14, value: 10.0, proficiencyBonus: 4, xp: 5900 },
    { id: 15, value: 11.0, proficiencyBonus: 4, xp: 7200 },
    { id: 16, value: 12.0, proficiencyBonus: 4, xp: 8400 },
    { id: 17, value: 13.0, proficiencyBonus: 5, xp: 10000 },
    { id: 18, value: 14.0, proficiencyBonus: 5, xp: 11500 },
    { id: 19, value: 15.0, proficiencyBonus: 5, xp: 13000 },
    { id: 20, value: 16.0, proficiencyBonus: 5, xp: 15000 },
    { id: 21, value: 17.0, proficiencyBonus: 6, xp: 18000 },
    { id: 22, value: 18.0, proficiencyBonus: 6, xp: 20000 },
    { id: 23, value: 19.0, proficiencyBonus: 6, xp: 22000 },
    { id: 24, value: 20.0, proficiencyBonus: 6, xp: 25000 },
    { id: 25, value: 21.0, proficiencyBonus: 7, xp: 33000 },
    { id: 26, value: 22.0, proficiencyBonus: 7, xp: 41000 },
    { id: 27, value: 23.0, proficiencyBonus: 7, xp: 50000 },
    { id: 29, value: 24.0, proficiencyBonus: 7, xp: 62000 },
    { id: 30, value: 25.0, proficiencyBonus: 8, xp: 75000 },
    { id: 31, value: 26.0, proficiencyBonus: 8, xp: 90000 },
    { id: 32, value: 27.0, proficiencyBonus: 8, xp: 105000 },
    { id: 33, value: 28.0, proficiencyBonus: 8, xp: 120000 },
    { id: 34, value: 29.0, proficiencyBonus: 9, xp: 135000 },
    { id: 35, value: 30.0, proficiencyBonus: 9, xp: 155000 },
  ],
  creatureGroups: [
    {
      id: 1,
      name: "Wild Shape",
      categoryId: 2,
      enabledByDefault: false,
      allowDuplicates: true,
      allowCombat: true,
      isPrimary: true,
      isMisc: false,
      specialQualityTitle: "Wild Shape",
      specialQualityText:
        "You can stay in a beast shape for a number of hours equal to half your druid level (rounded down). You then revert to your normal form unless you expend another use of this feature. You can revert to your normal form earlier by using a bonus action on your turn. You automatically revert if you fall unconscious, drop to 0 hit points, or die.",
      flags: ["EOSKP", "EOSVP", "CBS", "CULGA", "CULRA", "EUPP", "EOPP"],
      monsterTypes: [],
      ownerStats: [4, 5, 6],
      description:
        "<p>You can use your action to magically assume the shape of a beast (or sometimes another creature) that you have seen before.</p>",
      actionSnippet:
        "<p><strong><em>Revert Form.</em></strong> You can revert to your normal form by using a bonus action on your turn.</p>",
    },
    {
      id: 2,
      name: "Familiar",
      categoryId: 1,
      enabledByDefault: true,
      allowDuplicates: true,
      allowCombat: false,
      isPrimary: true,
      isMisc: false,
      specialQualityTitle: "Familiar",
      specialQualityText:
        "In combat, a familiar rolls its own initiative and acts on its own turn. A familiar can't attack, but it can take other actions as normal. When a familiar drops to 0 hit points, it disappears, leaving behind no physical form.",
      flags: [],
      monsterTypes: [3, 8, 9],
      ownerStats: [],
      description:
        "<p>You gain the service of a familiar, a spirit that takes an animal (or sometimes another creature) form you choose.</p>",
      actionSnippet:
        "<p><strong><em>Attack Restriction.</em></strong> A familiar can't attack, but it can take other actions as normal.</p>",
    },
    {
      id: 3,
      name: "Beast Companion",
      categoryId: 1,
      enabledByDefault: false,
      allowDuplicates: true,
      allowCombat: true,
      isPrimary: true,
      isMisc: false,
      specialQualityTitle: "Ranger's Companion",
      specialQualityText:
        "The beast obeys your commands as best as it can. It takes its turn on your initiative. On your turn, you can verbally command the beast where to move (no action required by you). You can use your action to verbally command it to take the Attack, Dash, Disengage, or Help action. If you don't issue a command, the beast takes the Dodge action. Once you have the Extra Attack feature, you can make one weapon attack yourself when you command the beast to take the Attack action.\n\nIf you are incapacitated or absent, the beast acts on its own, focusing on protecting you and itself. The beast never requires your command to use its reaction, such as when making an opportunity attack.",
      flags: ["ACPB", "ARPB", "DRPB", "PSPB", "STPB", "HPLM", "EUPP"],
      monsterTypes: [],
      ownerStats: [],
      description:
        "<p>You gain a beast companion that accompanies you on your adventures and is trained to fight alongside you.</p>",
      actionSnippet:
        "<p><strong><em>Beast Master Bonus.</em></strong> The companion gains an additional bonus to attack and damage rolls equal to the ranger's proficiency bonus (not included in the attack descriptions below).</p>",
    },
    {
      id: 4,
      name: "Mount",
      categoryId: 1,
      enabledByDefault: true,
      allowDuplicates: true,
      allowCombat: true,
      isPrimary: false,
      isMisc: false,
      specialQualityTitle: null,
      specialQualityText: null,
      flags: [],
      monsterTypes: [],
      ownerStats: [],
      description:
        "<p>A good mount can help you move more quickly through the wilderness, but its primary purpose is to carry the gear that would otherwise slow you down.</p>",
      actionSnippet: null,
    },
    {
      id: 5,
      name: "Pet",
      categoryId: 1,
      enabledByDefault: true,
      allowDuplicates: true,
      allowCombat: true,
      isPrimary: false,
      isMisc: false,
      specialQualityTitle: null,
      specialQualityText: null,
      flags: [],
      monsterTypes: [],
      ownerStats: [],
      description:
        "<p>Allows you to display a creature special to you, such as a <em>figurine of wondrous power</em>.</p>",
      actionSnippet: null,
    },
    {
      id: 6,
      name: "Summoned",
      categoryId: 1,
      enabledByDefault: true,
      allowDuplicates: true,
      allowCombat: true,
      isPrimary: false,
      isMisc: false,
      specialQualityTitle: null,
      specialQualityText: null,
      flags: [],
      monsterTypes: [],
      ownerStats: [],
      description:
        "<p>Allows you to display stat block references to summoned creatures from spells such as <em>conjure woodland beings</em>.</p>",
      actionSnippet: null,
    },
    {
      id: 7,
      name: "Misc",
      categoryId: 3,
      enabledByDefault: true,
      allowDuplicates: true,
      allowCombat: true,
      isPrimary: false,
      isMisc: true,
      specialQualityTitle: null,
      specialQualityText: null,
      flags: [],
      monsterTypes: [],
      ownerStats: [],
      description: "<p>Allows you to display any other type of monster or NPC stat block.</p>",
      actionSnippet: null,
    },
    {
      id: 10,
      name: "Battle Smith Defender",
      categoryId: 3,
      enabledByDefault: false,
      allowDuplicates: true,
      allowCombat: true,
      isPrimary: true,
      isMisc: false,
      specialQualityTitle: null,
      specialQualityText: null,
      flags: ["ARPB", "DRPB", "PSPB", "AHM", "MHPAIM", "MHPAMCM"],
      monsterTypes: [],
      ownerStats: [],
      description:
        "<p>The tinkering you have done in your free time has borne you a faithful companion, an iron defender.</p>",
      actionSnippet: null,
    },
    {
      id: 11,
      name: "Sidekick",
      categoryId: 3,
      enabledByDefault: true,
      allowDuplicates: true,
      allowCombat: true,
      isPrimary: true,
      isMisc: false,
      specialQualityTitle: null,
      specialQualityText: null,
      flags: ["UCRAL"],
      monsterTypes: [],
      ownerStats: [],
      description:
        "<p>On your adventures, the DM might reveal that youâ€™ve befriended a special character called a sidekick, who joins your party.</p><p>The DM will either tell you which type of sidekick to use or let you choose one. Itâ€™s up to you and the DM to decide who controls the sidekick in play.</p>",
      actionSnippet: null,
    },
    {
      id: 12,
      name: "Infusion",
      categoryId: 3,
      enabledByDefault: false,
      allowDuplicates: true,
      allowCombat: true,
      isPrimary: true,
      isMisc: true,
      specialQualityTitle: null,
      specialQualityText: null,
      flags: [],
      monsterTypes: [],
      ownerStats: [],
      description: "<p>You learn intricate methods for magically creating a creature that serves you.</p>",
      actionSnippet: null,
    },
  ],
  creatureGroupCategories: [
    { id: 1, name: "Companion" },
    { id: 2, name: "Shapechange" },
    { id: 3, name: "Other" },
  ],
  environments: [
    { id: 1, name: "Arctic" },
    { id: 2, name: "Coastal" },
    { id: 3, name: "Desert" },
    { id: 4, name: "Forest" },
    { id: 5, name: "Grassland" },
    { id: 6, name: "Hill" },
    { id: 7, name: "Mountain" },
    { id: 8, name: "Swamp" },
    { id: 9, name: "Underdark" },
    { id: 10, name: "Underwater" },
    { id: 11, name: "Urban" },
  ],
  armorTypes: [
    { id: 1, name: "Light Armor" },
    { id: 2, name: "Medium Armor" },
    { id: 3, name: "Heavy Armor" },
    { id: 4, name: "Shield" },
  ],
  gearTypes: [
    { id: 1, name: "Adventuring Gear" },
    { id: 2, name: "Armor" },
    { id: 3, name: "Artifact" },
    { id: 4, name: "Mount" },
    { id: 5, name: "Poison" },
    { id: 6, name: "Potion" },
    { id: 7, name: "Ring" },
    { id: 8, name: "Rod" },
    { id: 9, name: "Scroll" },
    { id: 10, name: "Staff" },
    { id: 11, name: "Tool" },
    { id: 12, name: "Vehicle (Land)" },
    { id: 13, name: "Wand" },
    { id: 14, name: "Weapon" },
    { id: 15, name: "Wondrous Item" },
    { id: 16, name: "Equipment Pack" },
    { id: 17, name: "Vehicle (Water)" },
    { id: 18, name: "Gemstone" },
  ],
  naturalActions: [
    {
      id: 1,
      entityTypeId: 1120657896,
      limitedUse: null,
      name: "Unarmed Strike",
      description:
        "Instead of using a weapon to make a melee weapon attack, you can use an unarmed strike: a punch, kick, head-butt, or similar forceful blow (none of which count as weapons). On a hit, an unarmed strike deals bludgeoning damage equal to 1 + your Strength modifier. You are proficient with your unarmed strikes.",
      snippet:
        "You can punch, kick, head-butt, or use a similar forceful blow and deal bludgeoning damage equal to 1 + STR modifier",
      abilityModifierStatId: 1,
      onMissDescription: null,
      saveFailDescription: null,
      saveSuccessDescription: null,
      saveStatId: null,
      fixedSaveDc: null,
      attackTypeRange: 1,
      actionType: 1,
      attackSubtype: 3,
      dice: null,
      value: 1,
      damageTypeId: 1,
      isMartialArts: true,
      isProficient: true,
      spellRangeType: null,
      displayAsAttack: null,
      range: null,
      activation: { activationTime: 1, activationType: 1 },
      attackCustomData: {
        name: null,
        notes: null,
        damageBonus: null,
        toHitBonus: null,
        toHit: null,
        isOffhand: null,
        isSilver: null,
        isAdamantine: null,
        isProficient: null,
        saveDcBonus: null,
        saveDc: null,
        weight: null,
        displayAsAttack: null,
        cost: null,
      },
      componentId: 0,
      componentTypeId: 0,
    },
  ],
  adjustmentTypes: [
    {
      id: 2,
      name: "Additional Magic Bonus",
      dataType: 1,
      constraints: [
        { id: 1, name: "Minimum", value: -10 },
        { id: 2, name: "Maximum", value: 10 },
      ],
    },
    {
      id: 3,
      name: "Additional Misc Bonus",
      dataType: 1,
      constraints: [
        { id: 1, name: "Minimum", value: -10 },
        { id: 2, name: "Maximum", value: 10 },
      ],
    },
    { id: 32, name: "Armor Proficiency Level", dataType: 1, constraints: [] },
    { id: 49, name: "Capacity Override", dataType: 3, constraints: [] },
    { id: 50, name: "Capacity Weight Override", dataType: 2, constraints: [] },
    { id: 19, name: "Cost Override", dataType: 2, constraints: [] },
    {
      id: 42,
      name: "Creature AC",
      dataType: 1,
      constraints: [
        { id: 1, name: "Minimum", value: 1 },
        { id: 2, name: "Maximum", value: 999 },
      ],
    },
    { id: 45, name: "Creature Alignment", dataType: 1, constraints: [] },
    {
      id: 43,
      name: "Creature Hit Points",
      dataType: 1,
      constraints: [
        { id: 1, name: "Minimum", value: 1 },
        { id: 2, name: "Maximum", value: 999 },
      ],
    },
    { id: 47, name: "Creature Notes", dataType: 3, constraints: [] },
    { id: 46, name: "Creature Size", dataType: 1, constraints: [] },
    { id: 44, name: "Creature Type Override", dataType: 1, constraints: [] },
    { id: 31, name: "Dice Count Override", dataType: 1, constraints: [] },
    { id: 30, name: "Dice Type Override", dataType: 1, constraints: [] },
    { id: 16, name: "Display As Attack", dataType: 4, constraints: [] },
    { id: 18, name: "Dual Wield", dataType: 4, constraints: [] },
    { id: 10, name: "Fixed Value Bonus", dataType: 1, constraints: [] },
    { id: 11, name: "Fixed Value Override", dataType: 1, constraints: [] },
    { id: 21, name: "Is Adamantine", dataType: 4, constraints: [] },
    { id: 48, name: "Is Dedicated Weapon", dataType: 4, constraints: [] },
    { id: 29, name: "Is Hexblade", dataType: 4, constraints: [] },
    { id: 28, name: "Is Pact Weapon", dataType: 4, constraints: [] },
    { id: 17, name: "Is Proficient", dataType: 4, constraints: [] },
    { id: 20, name: "Is Silver", dataType: 4, constraints: [] },
    { id: 35, name: "Language Proficiency Level", dataType: 1, constraints: [] },
    { id: 37, name: "Movement Override", dataType: 1, constraints: [] },
    { id: 8, name: "Name Override", dataType: 3, constraints: [] },
    { id: 9, name: "Notes", dataType: 3, constraints: [] },
    {
      id: 1,
      name: "Override AC",
      dataType: 1,
      constraints: [
        { id: 1, name: "Minimum", value: 0 },
        { id: 2, name: "Maximum", value: 2000000000 },
      ],
    },
    {
      id: 4,
      name: "Override Base Armor + DEX",
      dataType: 1,
      constraints: [
        { id: 1, name: "Minimum", value: 0 },
        { id: 2, name: "Maximum", value: 2000000000 },
      ],
    },
    {
      id: 7,
      name: "Override Passive Insight",
      dataType: 1,
      constraints: [
        { id: 1, name: "Minimum", value: 0 },
        { id: 2, name: "Maximum", value: 2000000000 },
      ],
    },
    {
      id: 6,
      name: "Override Passive Investigation",
      dataType: 1,
      constraints: [
        { id: 1, name: "Minimum", value: 0 },
        { id: 2, name: "Maximum", value: 2000000000 },
      ],
    },
    {
      id: 5,
      name: "Override Passive Perception",
      dataType: 1,
      constraints: [
        { id: 1, name: "Minimum", value: 0 },
        { id: 2, name: "Maximum", value: 2000000000 },
      ],
    },
    { id: 14, name: "Save DC Bonus", dataType: 1, constraints: [] },
    { id: 15, name: "Save DC Override", dataType: 1, constraints: [] },
    { id: 40, name: "Saving Throw Magic Bonus", dataType: 1, constraints: [] },
    { id: 39, name: "Saving Throw Misc Bonus", dataType: 1, constraints: [] },
    { id: 38, name: "Saving Throw Override", dataType: 1, constraints: [] },
    { id: 41, name: "Saving Throw Proficiency Level", dataType: 1, constraints: [] },
    { id: 36, name: "Sense Override", dataType: 1, constraints: [] },
    { id: 25, name: "Skill Magic Bonus", dataType: 1, constraints: [] },
    { id: 24, name: "Skill Misc Bonus", dataType: 1, constraints: [] },
    { id: 23, name: "Skill Override", dataType: 1, constraints: [] },
    { id: 26, name: "Skill Proficiency Level", dataType: 1, constraints: [] },
    { id: 27, name: "Skill Stat Override", dataType: 1, constraints: [] },
    { id: 12, name: "To Hit Bonus", dataType: 1, constraints: [] },
    { id: 13, name: "To Hit Override", dataType: 1, constraints: [] },
    { id: 34, name: "Tool Proficiency Level", dataType: 1, constraints: [] },
    { id: 33, name: "Weapon Proficiency Level", dataType: 1, constraints: [] },
    { id: 22, name: "Weight Override", dataType: 2, constraints: [] },
  ],
  weaponCategories: [
    { id: 1, entityTypeId: 660121713, name: "Simple" },
    { id: 2, entityTypeId: 660121713, name: "Martial" },
    { id: 3, entityTypeId: 660121713, name: "Firearms" },
  ],
  spellComponents: [
    {
      id: 1,
      name: "Verbal",
      shortName: "V",
      description:
        "Most spells require the chanting of mystic words. The words themselves aren't the source of the spell's power; rather, the particular combination of sounds, with specific pitch and resonance, sets the threads of magic in motion. Thus, a character who is gagged or in an area of silence, such as one created by the silence spell, can't cast a spell with a verbal component.\n\n",
    },
    {
      id: 2,
      name: "Somatic",
      shortName: "S",
      description:
        "Spellcasting gestures might include a forceful gesticulation or an intricate set of gestures. If a spell requires a somatic component, the caster must have free use of at least one hand to perform these gestures.\n\n",
    },
    {
      id: 3,
      name: "Material",
      shortName: "M",
      description:
        "Casting some spells requires particular objects, specified in parentheses in the component entry. A character can use a component pouch or a spellcasting focus (found in â€œEquipmentâ€) in place of the components specified for a spell. But if a cost is indicated for a component, a character must have that specific component before he or she can cast the spell. \nIf a spell states that a material component is consumed by the spell, the caster must provide this component for each casting of the spell. A spellcaster must have a hand free to access a spell's material components--or to hold a spellcasting focus--but it can be the same hand that he or she uses to perform somatic components.\n\n",
    },
    {
      id: 4,
      name: "Royalty",
      shortName: "R",
      description:
        "To cast a spell that employs a royalty component (including using a spell scroll or other magic item that stores such a spell), a caster must have sufficient funds on their person. The cost of the casting is set by the caster who creates the spell, but is typically 1 gp per spell slot level. When the spell is cast, the royalty is magically transported to a coffer or other object designated by the creating spellcaster. This payment is made whether the caster using the spell is aware of the royalty component or not. If the caster does not have sufficient funds, the spell is not lost but it cannot be cast.\n\nThough many casters have tried to circumvent the royalty component, none have ever fully succeeded. However, it is said that a character can attempt a DC 15 Intelligence (Arcana) check while casting a spell with a royalty component. With a successful check, the payment is taken from a random creature within 10 feet of the caster, without that creatureâ€™s knowledge.",
    },
  ],
  activationTypes: [
    { id: 1, name: "Action", prerequisite: null, description: "", requiredLevel: null, displayOrder: null },
    { id: 2, name: "No Action", prerequisite: null, description: "", requiredLevel: null, displayOrder: null },
    { id: 3, name: "Bonus Action", prerequisite: null, description: "", requiredLevel: null, displayOrder: null },
    { id: 4, name: "Reaction", prerequisite: null, description: "", requiredLevel: null, displayOrder: null },
    { id: 6, name: "Minute", prerequisite: null, description: "", requiredLevel: null, displayOrder: null },
    { id: 7, name: "Hour", prerequisite: null, description: "", requiredLevel: null, displayOrder: null },
    { id: 8, name: "Special", prerequisite: null, description: "", requiredLevel: null, displayOrder: null },
  ],
  basicActions: [
    {
      id: 1,
      name: "Attack",
      description:
        '<p>The most common action to take in combat is the Attack action, whether you are swinging a sword, firing an arrow from a bow, or brawling with your fists.</p>\n<p>With this action, you make one melee or ranged attack. See the "Making an Attack" section for the rules that govern attacks.</p>\n<p>Certain features, such as the Extra Attack feature of the fighter, allow you to make more than one attack with this action.</p>',
      activation: { activationTime: null, activationType: 1 },
    },
    {
      id: 2,
      name: "Cast a Spell",
      description:
        "<p>Spellcasters such as wizards and clerics, as well as many monsters, have access to spells and can use them to great effect in combat. Each spell has a casting time, which specifies whether the caster must use an action, a reaction, minutes, or even hours to cast the spell. Casting a spell is, therefore, not necessarily an action. Most spells do have a casting time of 1 action, so a spellcaster often uses his or her action in combat to cast such a spell.</p>",
      activation: { activationTime: null, activationType: 1 },
    },
    {
      id: 4,
      name: "Dash",
      description:
        "<p>When you take the Dash action, you gain extra movement for the current turn. The increase equals your speed, after applying any modifiers. With a speed of 30 feet, for example, you can move up to 60 feet on your turn if you dash.</p>\n<p>Any increase or decrease to your speed changes this additional movement by the same amount. If your speed of 30 feet is reduced to 15 feet, for instance, you can move up to 30 feet this turn if you dash.</p>",
      activation: { activationTime: null, activationType: 1 },
    },
    {
      id: 5,
      name: "Disengage",
      description:
        "<p>If you take the Disengage action, your movement doesn't provoke opportunity attacks for the rest of the turn.</p>",
      activation: { activationTime: null, activationType: 1 },
    },
    {
      id: 6,
      name: "Dodge",
      description:
        "<p>When you take the Dodge action, you focus entirely on avoiding attacks. Until the start of your next turn, any attack roll made against you has disadvantage if you can see the attacker, and you make Dexterity saving throws with advantage. You lose this benefit if you are incapacitated or if your speed drops to 0.</p>",
      activation: { activationTime: null, activationType: 1 },
    },
    {
      id: 7,
      name: "Help",
      description:
        "<p>You can lend your aid to another creature in the completion of a task. When you take the Help action, the creature you aid gains advantage on the next ability check it makes to perform the task you are helping with, provided that it makes the check before the start of your next turn.</p>\n<p>Alternatively, you can aid a friendly creature in attacking a creature within 5 feet of you. You feint, distract the target, or in some other way team up to make your ally's attack more effective. If your ally attacks the target before your next turn, the first attack roll is made with advantage.</p>",
      activation: { activationTime: null, activationType: 1 },
    },
    {
      id: 8,
      name: "Hide",
      description:
        '<p>When you take the Hide action, you make a Dexterity (Stealth) check in an attempt to hide, following the rules for hiding. If you succeed, you gain certain benefits, as described in the "Unseen Attackers and Targets" section later in this chapter.</p>',
      activation: { activationTime: null, activationType: 1 },
    },
    {
      id: 9,
      name: "Ready",
      description:
        '<p>Sometimes you want to get the jump on a foe or wait for a particular circumstance before you act. To do so, you can take the Ready action on your turn, which lets you act using your reaction before the start of your next turn.</p>\n<p>First, you decide what perceivable circumstance will trigger your reaction. Then, you choose the action you will take in response to that trigger, or you choose to move up to your speed in response to it. Examples include "If the cultist steps on the trapdoor, I\'ll pull the lever that opens it," and "If the goblin steps next to me, I move away."</p>\n<p>When the trigger occurs, you can either take your reaction right after the trigger finishes or ignore the trigger. Remember that you can take only one reaction per round.</p>\n<p>When you ready a spell, you cast it as normal but hold its energy, which you release with your reaction when the trigger occurs. To be readied, a spell must have a casting time of 1 action, and holding onto the spell\'s magic requires concentration. If your concentration is broken, the spell dissipates without taking effect. For example, if you are concentrating on the <strong>web</strong> spell and ready <strong>magic missile</strong>, your <strong>web</strong> spell ends, and if you take damage before you release <strong>magic missile</strong> with your reaction, your concentration might be broken.</p>',
      activation: { activationTime: null, activationType: 1 },
    },
    {
      id: 10,
      name: "Search",
      description:
        "<p>When you take the Search action, you devote your attention to finding something. Depending on the nature of your search, the GM might have you make a Wisdom (Perception) check or an Intelligence (Investigation) check.</p>",
      activation: { activationTime: null, activationType: 1 },
    },
    {
      id: 11,
      name: "Use an Object",
      description:
        "<p>You normally interact with an object while doing something else, such as when you draw a sword as part of an attack. When an object requires your action for its use, you take the Use an Object action. This action is also useful when you want to interact with more than one object on your turn.</p>",
      activation: { activationTime: null, activationType: 1 },
    },
    {
      id: 1001,
      name: "Opportunity Attack",
      description:
        "<p>You can make an opportunity attack when a hostile creature that you can see moves out of your reach. To make the opportunity attack, you use your reaction to make one melee attack against the provoking creature. The attack occurs right before the creature leaves your reach</p><p></p>",
      activation: { activationTime: null, activationType: 4 },
    },
    {
      id: 1002,
      name: "Grapple",
      description:
        "<p>When you want to grab a creature or wrestle with it, you can use the Attack action to make a special melee attack, a grapple. If you're able to make multiple attacks with the Attack action, this attack replaces one of them.</p>\n<p>The target of your grapple must be no more than one size larger than you and must be within your reach. Using at least one free hand, you try to seize the target by making a grapple check instead of an attack roll: a Strength (Athletics) check contested by the target's Strength (Athletics) or Dexterity (Acrobatics) check (the target chooses the ability to use). If you succeed, you subject the target to the grappled condition. The condition specifies the things that end it, and you can release the target whenever you like (no action required).</p>\n<p><strong>Escaping a Grapple.</strong> A grappled creature can use its action to escape. To do so, it must succeed on a Strength (Athletics) or Dexterity (Acrobatics) check contested by your Strength (Athletics) check.</p>\n<p><strong>Moving a Grappled Creature.</strong> When you move, you can drag or carry the grappled creature with you, but your speed is halved, unless the creature is two or more sizes smaller than you.</p>",
      activation: { activationTime: null, activationType: 1 },
    },
    {
      id: 1003,
      name: "Shove",
      description:
        "<p>Using the Attack action, you can make a special melee attack to shove a creature, either to knock it prone or push it away from you. If you're able to make multiple attacks with the Attack action, this attack replaces one of them.</p>\n<p>The target must be no more than one size larger than you and must be within your reach. Instead of making an attack roll, you make a Strength (Athletics) check contested by the target's Strength (Athletics) or Dexterity (Acrobatics) check (the target chooses the ability to use). You succeed automatically if the target is incapacitated. If you succeed, you either knock the target prone or push it 5 feet away from you.</p>",
      activation: { activationTime: null, activationType: 1 },
    },
    {
      id: 1004,
      name: "Improvise",
      description:
        "<p>Your character can do things not covered by the actions in this chapter, such as breaking down doors, intimidating enemies, sensing weaknesses in magical defenses, or calling for a parley with a foe. The only limits to the actions you can attempt are your imagination and your character's ability scores. See the descriptions of the ability scores in chapter 7 for inspiration as you improvise.</p>\n<p>When you describe an action not detailed elsewhere in the rules, the DM tells you whether that action is possible and what kind of roll you need to make, if any, to determine success or failure.</p>",
      activation: { activationTime: null, activationType: 1 },
    },
    {
      id: 1005,
      name: "Two-Weapon Fighting",
      description:
        "<p>When you take the Attack action and attack with a light melee weapon that you're holding in one hand, you can use a bonus action to attack with a different light melee weapon that you're holding in the other hand. You don't add your ability modifier to the damage of the bonus attack, unless that modifier is negative.</p>\n<p>If either weapon has the thrown property, you can throw the weapon, instead of making a melee attack with it.</p>",
      activation: { activationTime: null, activationType: 3 },
    },
    {
      id: 1006,
      name: "Interact with an Object",
      description:
        "<p>Here are a few examples of the sorts of thing you can do in tandem with your movement and action:</p>\n<ul>\n<li>draw or sheathe a sword</li>\n<li>open or close a door</li>\n<li>withdraw a potion from your backpack</li>\n<li>pick up a dropped axe</li>\n<li>take a bauble from a table</li>\n<li>remove a ring from your finger</li>\n<li>stuff some food into your mouth</li>\n<li>plant a banner in the ground</li>\n<li>fish a few coins from your belt pouch</li>\n<li>drink all the ale in a flagon</li>\n<li>throw a lever or a switch</li>\n<li>pull a torch from a sconce</li>\n<li>take a book from a shelf you can reach</li>\n<li>extinguish a small flame</li>\n<li>don a mask</li>\n<li>pull the hood of your cloak up and over your head</li>\n<li>put your ear to a door</li>\n<li>kick a small stone</li>\n<li>turn a key in a lock</li>\n<li>tap the floor with a 10-foot pole</li>\n<li>hand an item to another character</li>\n</ul>",
      activation: { activationTime: null, activationType: 8 },
    },
  ],
  rules: [
    {
      id: 34,
      name: "Race",
      description:
        "Your choice of race affects many different aspects of your character. It establishes fundamental qualities that exist throughout your characterâ€™s adventuring career. When making this decision, keep in mind the kind of character you want to play. For example, a halfling could be a good choice for a sneaky rogue, a dwarf makes a tough warrior, and an elf can be a master of arcane magic.",
    },
    {
      id: 35,
      name: "Class",
      description:
        "Class is the primary definition of what your character can do. Itâ€™s more than a profession; itâ€™s your characterâ€™s calling. Class shapes the way you think about the world and interact with it and your relationship with other people and powers in the multiverse. A fighter, for example, might view the world in pragmatic terms of strategy and maneuvering, and see herself as just a pawn in a much larger game. A cleric, by contrast, might see himself as a willing servant in a godâ€™s unfolding plan or a conflict brewing among various deities. While the fighter has contacts in a mercenary company or army, the cleric might know a number of priests, paladins, and devotees who share his faith.",
    },
    {
      id: 36,
      name: "Level",
      description:
        "Starting off at 1st level marks your characterâ€™s entry into the adventuring life. As your character goes on adventures and overcomes challenges, he or she gains experience, represented by experience points. A character who reaches a specified experience point total advances in capability. This advancement is called gaining a level.",
    },
    {
      id: 37,
      name: "Experience Points",
      description:
        "As your character goes on adventures and overcomes challenges, he or she gains experience, represented by experience points. A character who reaches a specified experience point total advances in capability. This advancement is called gaining a level.",
    },
    {
      id: 38,
      name: "Hit Points",
      description:
        "Hit points represent a combination of physical and mental durability, the will to live, and luck. Creatures with more hit points are more difficult to kill. Those with fewer hit points are more fragile. \n\nA creature's current hit points (usually just called hit points) can be any number from the creature's hit point maximum down to 0. This number changes frequently as a creature takes damage or receives healing. \n\nWhenever a creature takes damage, that damage is subtracted from its hit points. The loss of hit points has no effect on a creature's capabilities until the creature drops to 0 hit points.",
    },
    {
      id: 39,
      name: "Hit Dice",
      description:
        "Your hit points are determined by your Hit Dice (short for Hit Point Dice).\n\nAt 1st level, your character has 1 Hit Die, and the die type is determined by your class. You start with hit points equal to the highest roll of that die, as indicated in your class description. (You also add your Constitution modifier.)",
    },
    {
      id: 40,
      name: "Proficiency Bonus",
      description:
        '<p>Characters have a proficiency bonus determined by level, as detailed in <a href="https://www.dndbeyond.com/compendium/rules/phb/step-by-step-characters">chapter 1</a>. Monsters also have this bonus, which is incorporated in their stat blocks. The bonus is used in the rules on ability checks, saving throws, and attack rolls.</p>\n<p>Your proficiency bonus canâ€™t be added to a single die roll or other number more than once. For example, if two different rules say you can add your proficiency bonus to a Wisdom saving throw, you nevertheless add the bonus only once when you make the save.</p>\n<p>Occasionally, your proficiency bonus might be multiplied or divided (doubled or halved, for example) before you apply it. For example, the rogueâ€™s Expertise feature doubles the proficiency bonus for certain ability checks. If a circumstance suggests that your proficiency bonus applies more than once to the same roll, you still add it only once and multiply or divide it only once.</p>\n<p>By the same token, if a feature or effect allows you to multiply your proficiency bonus when making an ability check that wouldnâ€™t normally benefit from your proficiency bonus, you still donâ€™t add the bonus to the check. For that check your proficiency bonus is 0, given the fact that multiplying 0 by any number is still 0. For instance, if you lack proficiency in the History skill, you gain no benefit from a feature that lets you double your proficiency bonus when you make Intelligence (History) checks.</p>\n<p>In general, you donâ€™t multiply your proficiency bonus for attack rolls or saving throws. If a feature or effect allows you to do so, these same rules apply.</p>',
    },
    {
      id: 41,
      name: "Ability Scores",
      description:
        "Each of a creature's abilities has a score, a number that defines the magnitude of that ability. An ability score is not just a measure of innate capabilities, but also encompasses a creature's training and competence in activities related to that ability. \n\nA score of 10 or 11 is the normal human average, but adventurers and many monsters are a cut above average in most abilities. A score of 18 is the highest that a person usually reaches. Adventurers can have scores as high as 20, and monsters and divine beings can have scores as high as 30. \n\nEach ability also has a modifier, derived from the score and ranging from -5 (for an ability score of 1) to +10 (for a score of 30). The Ability Scores and Modifiers table notes the ability modifiers for the range of possible ability scores, from 1 to 30.",
    },
    {
      id: 42,
      name: "Alignment",
      description:
        "A typical creature in the game world has an alignment, which broadly describes its moral and personal attitudes. Alignment is a combination of two factors: one identifies morality (good, evil, or neutral), and the other describes attitudes toward society and order (lawful, chaotic, or neutral). Thus, nine distinct alignments define the possible combinations.",
    },
    {
      id: 43,
      name: "Lawful Good",
      description:
        "Lawful good (LG) creatures can be counted on to do the right thing as expected by society. Gold dragons, paladins, and most dwarves are lawful good.",
    },
    {
      id: 44,
      name: "Neutral Good",
      description:
        "Neutral good (NG) folk do the best they can to help others according to their needs. Many celestials, some cloud giants, and most gnomes are neutral good.",
    },
    {
      id: 45,
      name: "Chaotic Good",
      description:
        "Chaotic good (CG) creatures act as their conscience directs, with little regard for what others expect. Copper dragons, many elves, and unicorns are chaotic good.",
    },
    {
      id: 46,
      name: "Neutral",
      description:
        "Neutral (N) is the alignment of those who prefer to steer clear of moral questions and donâ€™t take sides, doing what seems best at the time. Lizardfolk, most druids, and many humans are neutral.",
    },
    {
      id: 47,
      name: "Lawful Evil",
      description:
        "Lawful evil (LE) creatures methodically take what they want, within the limits of a code of tradition, loyalty, or order. Devils, blue dragons, and hobgoblins are lawful evil.",
    },
    {
      id: 48,
      name: "Neutral Evil",
      description:
        "Neutral evil (NE) is the alignment of those who do whatever they can get away with, without compassion or qualms. Many drow, some cloud giants, and goblins are neutral evil.",
    },
    {
      id: 49,
      name: "Chaotic Evil",
      description:
        "Chaotic evil (CE) creatures act with arbitrary violence, spurred by their greed, hatred, or bloodlust. Demons, red dragons, and orcs are chaotic evil.",
    },
    {
      id: 50,
      name: "Lawful Neutral",
      description:
        "Lawful neutral (LN) individuals act in accordance with law, tradition, or personal codes. Many monks and some wizards are lawful neutral.",
    },
    {
      id: 51,
      name: "Chaotic Neutral",
      description:
        "Chaotic neutral (CN) creatures follow their whims, holding their personal freedom above all else. Many barbarians and rogues, and some bards, are chaotic neutral.",
    },
    {
      id: 52,
      name: "Background",
      description:
        "Every story has a beginning. Your characterâ€™s background reveals where you came from, how you became an adventurer, and your place in the world. Your fighter might have been a courageous knight or a grizzled soldier. Your wizard could have been a sage or an artisan. Your rogue might have gotten by as a guild thief or commanded audiences as a jester.",
    },
    {
      id: 53,
      name: "Personality Traits",
      description:
        "Personality traits are small, simple ways to help you set your character apart from every other character. Your personality traits should tell you something interesting and fun about your character. They should be self-descriptions that are specific about what makes your character stand out.\n\nPersonality traits might describe the things your character likes, his or her past accomplishments, things your character dislikes or fears, your characterâ€™s self-attitude or mannerisms, or the influence of his or her ability scores.",
    },
    {
      id: 54,
      name: "Bonds",
      description:
        "Bonds represent a characterâ€™s connections to people, places, and events in the world. They tie you to things from your background. They might inspire you to heights of heroism, or lead you to act against your own best interests if they are threatened. They can work very much like ideals, driving a characterâ€™s motivations and goals. \n\nBonds might answer any of these questions: Whom do you care most about? To what place do you feel a special connection? What is your most treasured possession?",
    },
    {
      id: 55,
      name: "Ideals",
      description:
        "Your ideals are the things that you believe in most strongly, the fundamental moral and ethical principles that compel you to act as you do. Ideals encompass everything from your life goals to your core belief system. \n\nIdeals might answer any of these questions: What are the principles that you will never betray? What would prompt you to make sacrifices? What drives you to act and guides your goals and ambitions? What is the single most important thing you strive for?",
    },
    {
      id: 56,
      name: "Flaws",
      description:
        "Your characterâ€™s flaw represents some vice, compulsion, fear, or weaknessâ€”in particular, anything that someone else could exploit to bring you to ruin or cause you to act against your best interests. More significant than negative personality traits, a flaw might answer any of these questions: What enrages you? Whatâ€™s the one person, concept, or event that you are terrified of? What are your vices?",
    },
    {
      id: 57,
      name: "Armor Class",
      description:
        "Your Armor Class (AC) represents how well your character avoids being wounded in battle. Things that contribute to your AC include the armor you wear, the shield you carry, and your Dexterity modifier. Not all characters wear armor or carry shields, however. \n\nWithout armor or a shield, your characterâ€™s AC equals 10 + his or her Dexterity modifier. If your character wears armor, carries a shield, or both, calculate your AC using the rules in the Equipment section. Record your AC on your character sheet.",
    },
    {
      id: 58,
      name: "Acid Damage",
      description:
        "The corrosive spray of an adult black dragon's breath and the dissolving enzymes secreted by a black pudding deal acid damage.",
    },
    {
      id: 59,
      name: "Bludgeoning Damage",
      description: "Blunt force attacks--hammers, falling, constriction, and the like--deal bludgeoning damage.",
    },
    {
      id: 60,
      name: "Cold Damage",
      description:
        "The infernal chill radiating from an ice devil's spear and the frigid blast of a young white dragon's breath deal cold damage.",
    },
    {
      id: 61,
      name: "Fire Damage",
      description: "Ancient red dragons breathe fire, and many spells conjure flames to deal fire damage.",
    },
    {
      id: 62,
      name: "Force Damage",
      description:
        "Force is pure magical energy focused into a damaging form. Most effects that deal force damage are spells, including magic missile and spiritual weapon.",
    },
    {
      id: 63,
      name: "Lightning Damage",
      description: "A lightning bolt spell and a blue dragon wyrmling's breath deal lightning damage.",
    },
    {
      id: 64,
      name: "Necrotic Damage",
      description:
        "Necrotic damage, dealt by certain undead and a spell such as chill touch, withers matter and even the soul.",
    },
    {
      id: 65,
      name: "Piercing Damage",
      description: "Puncturing and impaling attacks, including spears and monsters' bites, deal piercing damage.",
    },
    {
      id: 66,
      name: "Poison Damage",
      description: "Venomous stings and the toxic gas of an adult green dragon's breath deal poison damage.",
    },
    { id: 67, name: "Psychic Damage", description: "Mental abilities such as a psionic blast deal psychic damage." },
    {
      id: 68,
      name: "Radiant Damage",
      description:
        "Radiant damage, dealt by a cleric's flame strike spell or an angel's smiting weapon, sears the flesh like fire and overloads the spirit with power.",
    },
    { id: 69, name: "Slashing Damage", description: "Swords, axes, and monsters' claws deal slashing damage." },
    {
      id: 70,
      name: "Thunder Damage",
      description: "A concussive burst of sound, such as the effect of the thunderwave spell, deals thunder damage.",
    },
    {
      id: 71,
      name: "Critical Hits",
      description:
        "When you score a critical hit, you get to roll extra dice for the attack's damage against the target. Roll all of the attack's damage dice twice and add them together. Then add any relevant modifiers as normal. To speed up play, you can roll all the damage dice at once.",
    },
    {
      id: 72,
      name: "Damage Resistance",
      description:
        "Some creatures and objects are exceedingly difficult to hurt with certain types of damage.\n\nIf a creature or an object has resistance to a damage type, damage of that type is halved against it.\n\nResistance is applied after all other modifiers to damage. For example, a creature has resistance to bludgeoning damage and is hit by an attack that deals 25 bludgeoning damage. The creature is also within a magical aura that reduces all damage by 5. The 25 damage is first reduced by 5 and then halved, so the creature takes 10 damage.\n\nMultiple instances of resistance that affect the same damage type count as only one instance. For example, if a creature has resistance to fire damage as well as resistance to all nonmagical damage, the damage of a nonmagical fire is reduced by half against the creature, not reduced by three-quarters.",
    },
    {
      id: 73,
      name: "Damage Vulnerability",
      description:
        "Some creatures and objects are unusually easy to hurt with certain types of damage. \n\nIf a creature or an object has vulnerability to a damage type, damage of that type is doubled against it. \n\nMultiple instances of vulnerability that affect the same damage type count as only one instance.",
    },
    {
      id: 74,
      name: "Instant Death",
      description:
        "Massive damage can kill you instantly. When damage reduces you to 0 hit points and there is damage remaining, you die if the remaining damage equals or exceeds your hit point maximum. \n\nFor example, a cleric with a maximum of 12 hit points currently has 6 hit points. If she takes 18 damage from an attack, she is reduced to 0 hit points, but 12 damage remains. Because the remaining damage equals her hit point maximum, the cleric dies.",
    },
    {
      id: 75,
      name: "Death Saving Throws",
      description:
        "Whenever you start your turn with 0 hit points, you must make a special saving throw, called a death saving throw, to determine whether you creep closer to death or hang onto life. Unlike other saving throws, this one isn't tied to any ability score. You are in the hands of fate now, aided only by spells and features that improve your chances of succeeding on a saving throw. \n\nRoll a d20. If the roll is 10 or higher, you succeed. Otherwise, you fail. A success or failure has no effect by itself. On your third success, you become stable (see below). On your third failure, you die. The successes and failures don't need to be consecutive; keep track of both until you collect three of a kind. The number of both is reset to zero when you regain any hit points or become stable.",
    },
    {
      id: 76,
      name: "Temporary Hit Points",
      description:
        "Some spells and special abilities confer temporary hit points to a creature. Temporary hit points aren't actual hit points; they are a buffer against damage, a pool of hit points that protect you from injury. \n\nWhen you have temporary hit points and take damage, the temporary hit points are lost first, and any leftover damage carries over to your normal hit points. For example, if you have 5 temporary hit points and take 7 damage, you lose the temporary hit points and then take 2 damage. \n\nBecause temporary hit points are separate from your actual hit points, they can exceed your hit point maximum. A character can, therefore, be at full hit points and receive temporary hit points.",
    },
    {
      id: 77,
      name: "Saving Throws",
      description:
        "<p>A saving throw â€” also called a save â€” represents an attempt to resist a spell, a trap, a poison, a disease, or a similar threat. You donâ€™t normally decide to make a saving throw; you are forced to make one because your character or monster is at risk of harm.</p>\n<p>To make a saving throw, roll a d20 and add the appropriate ability modifier. For example, you use your Dexterity modifier for a Dexterity saving throw.</p>\n<p>A saving throw can be modified by a situational bonus or penalty and can be affected by advantage and disadvantage, as determined by the DM.</p>\n<p>Each class gives proficiency in at least two saving throws. The wizard, for example, is proficient in Intelligence saves. As with skill proficiencies, proficiency in a saving throw lets a character add his or her proficiency bonus to saving throws made using a particular ability score. Some monsters have saving throw proficiencies as well.</p>\n<p>The Difficulty Class for a saving throw is determined by the effect that causes it. For example, the DC for a saving throw allowed by a spell is determined by the casterâ€™s spellcasting ability and proficiency bonus.</p>\n<p>The result of a successful or failed saving throw is also detailed in the effect that allows the save. Usually, a successful save means that a creature suffers no harm, or reduced harm, from an effect.</p>",
    },
    {
      id: 78,
      name: "Senses (Passive Checks)",
      description:
        '<h3 id="PassiveChecks">Passive Checks</h3>\n<p>A passive check is a special kind of ability check that doesn\'t involve any die rolls. Such a check can represent the average result for a task done repeatedly, such as searching for secret doors over and over again, or can be used when the DM wants to secretly determine whether the characters succeed at something without rolling dice, such as noticing a hidden monster.</p>\n<p>Here\'s how to determine a character\'s total for a passive check:</p>\n<p><strong>10 + all modifiers that normally apply to the check</strong></p>\n<p>If the character has advantage on the check, add 5. For disadvantage, subtract 5. The game refers to a passive check total as a <strong>score</strong>.</p>\n<p>For example, if a 1st-level character has a Wisdom of 15 and proficiency in Perception, he or she has a passive Wisdom (Perception) score of 14.</p>\n<p>The rules on hiding in the â€œ<a href="https://www.dndbeyond.com/compendium/rules/phb/using-ability-scores#Dexterity">Dexterity</a>â€ section below rely on passive checks, as do the exploration rules in chapter 8, â€œ<a href="https://www.dndbeyond.com/compendium/rules/phb/adventuring">Adventuring</a><span class="No-Break">.â€</span></p>',
    },
    {
      id: 79,
      name: "Initiative",
      description:
        "<p>Initiative determines the order of turns during combat. When combat starts, every participant makes a Dexterity check to determine their place in the initiative order. The DM makes one roll for an entire group of identical creatures, so each member of the group acts at the same time.</p>\n<p>The DM ranks the combatants in order from the one with the highest Dexterity check total to the one with the lowest. This is the order (called the initiative order) in which they act during each round. The initiative order remains the same from round to round.</p>\n<p>If a tie occurs, the DM decides the order among tied DM-controlled creatures, and the players decide the order among their tied characters. The DM can decide the order if the tie is between a monster and a player character. Optionally, the DM can have the tied characters and monsters each roll a d20 to determine the order, highest roll going first.</p>",
    },
    {
      id: 80,
      name: "Inspiration",
      description:
        '<p>Inspiration is a rule the game master can use to reward you for playing your character in a way thatâ€™s true to his or her personality traits, ideal, bond, and flaw. By using inspiration, you can draw on your personality trait of compassion for the downtrodden to give you an edge in negotiating with the Beggar Prince. Or inspiration can let you call on your bond to the defense of your home village to push past the effect of a spell that has been laid on you.</p>\n<h3 id="GainingInspiration">Gaining Inspiration</h3>\n<p>Your DM can choose to give you inspiration for a variety of reasons. Typically, DMs award it when you play out your personality traits, give in to the drawbacks presented by a flaw or bond, and otherwise portray your character in a compelling way. Your DM will tell you how you can earn inspiration in the game.</p>\n<p>You either have inspiration or you donâ€™t - you canâ€™t stockpile multiple â€œinspirationsâ€ for later use.</p>\n<h3 id="UsingInspiration">Using Inspiration</h3>\n<p>If you have inspiration, you can expend it when you make an attack roll, saving throw, or ability check. Spending your inspiration gives you advantage on that roll.</p>\n<p>Additionally, if you have inspiration, you can reward another player for good roleplaying, clever thinking, or simply doing something exciting in the game. When another player character does something that really contributes to the story in a fun and interesting way, you can give up your inspiration to give that character inspiration.</p>',
    },
    {
      id: 81,
      name: "Speed",
      description:
        '<p>Every character has a speed, which is the distance in feet that the character can walk in 1 round. This number assumes short bursts of energetic movement in the midst of a life-threatening situation.</p>\n<p>While climbing or swimming, each foot of movement costs 1 extra foot (2 extra feet in difficult terrain), unless a creature has a climbing or swimming speed. At the DMâ€™s option, climbing a slippery vertical surface or one with few handholds requires a successful Strength (<span class="error"></span>Athletics<span class="error"></span>) check. Similarly, gaining any distance in rough water might require a successful Strength (<span class="error"></span>Athletics<span class="error"></span>) check.</p>\n<p>Your Strength determines how far you can jump.</p>\n<p><b>Long Jump.</b>&nbsp;When you make a long jump, you cover a number of feet up to your Strength score if you move at least 10 feet on foot immediately before the jump. When you make a standing long jump, you can leap only half that distance. Either way, each foot you clear on the jump costs a foot of movement.</p>\n<p>This rule assumes that the height of your jump doesn\'t matter, such as a jump across a stream or chasm. At your DM\'s option, you must succeed on a DC 10 Strength (Athletics) check to clear a low obstacle (no taller than a quarter of the jump\'s distance), such as a hedge or low wall. Otherwise, you hit it.</p>\n<p>When you land in difficult terrain, you must succeed on a DC 10 Dexterity (Acrobatics) check to land on your feet. Otherwise, you land prone.</p>\n<p><b>High Jump.</b>&nbsp;When you make a high jump, you leap into the air a number of feet equal to 3 + your Strength modifier (minimum of 0 feet) if you move at least 10 feet on foot immediately before the jump. When you make a standing high jump, you can jump only half that distance. Either way, each foot you clear on the jump costs a foot of movement. In some circumstances, your DM might allow you to make a Strength (Athletics) check to jump higher than you normally can.</p>\n<p>You can extend your arms half your height above yourself during the jump. Thus, you can reach above you a distance equal to the height of the jump plus 1 1/2 times your height.</p>',
    },
    {
      id: 82,
      name: "Senses",
      description:
        "<p><b>Passive Checks</b><br>A passive check is a special kind of ability check that doesn't involve any die rolls. Such a check can represent the average result for a task done repeatedly, such as searching for secret doors over and over again, or can be used when the DM wants to secretly determine whether the characters succeed at something without rolling dice, such as noticing a hidden monster.</p>\n<p>Special senses are described below.</p>\n<p><b>Blindsight</b><br>A monster with blindsight can perceive its surroundings without relying on sight, within a specific radius.</p>\n<p>Creatures without eyes, such as grimlocks and gray oozes, typically have this special sense, as do creatures with echolocation or heightened senses, such as bats and true dragons.</p>\n<p>If a monster is naturally blind, it has a parenthetical note to this effect, indicating that the radius of its blindsight defines the maximum range of its perception.</p>\n<p><b>Darkvision</b><br>A monster with darkvision can see in the dark within a specific radius. The monster can see in dim light within the radius as if it were bright light, and in darkness as if it were dim light. The monster can't discern color in darkness, only shades of gray. Many creatures that live underground have this special sense.</p>\n<p><b>Tremorsense</b><br>A monster with tremorsense can detect and pinpoint the origin of vibrations within a specific radius, provided that the monster and the source of the vibrations are in contact with the same ground or substance.</p>\n<p>Tremorsense can't be used to detect flying or incorporeal creatures. Many burrowing creatures, such as ankhegs, have this special sense.</p>\n<p><b>Truesight</b><br>A monster with truesight can, out to a specific range, see in normal and magical darkness, see invisible creatures and objects, automatically detect visual illusions and succeed on saving throws against them, and perceive the original form of a shapechanger or a creature that is transformed by magic. Furthermore, the monster can see into the Ethereal Plane within the same range.</p>",
    },
    {
      id: 83,
      name: "Half Cover",
      description:
        "A target with half cover has a +2 bonus to AC and Dexterity saving throws. A target has half cover if an obstacle blocks at least half of its body. The obstacle might be a low wall, a large piece of furniture, a narrow tree trunk, or a creature, whether that creature is an enemy or a friend.",
    },
    {
      id: 84,
      name: "Three-Quarters Cover",
      description:
        "A target with three-quarters cover has a +5 bonus to AC and Dexterity saving throws. A target has three-quarters cover if about three-quarters of it is covered by an obstacle. The obstacle might be a portcullis, an arrow slit, or a thick tree trunk.",
    },
    {
      id: 85,
      name: "Total Cover",
      description:
        "A target with total cover cannot be targeted directly by an attack or a spell, although some spells can reach such a target by including it in an area of effect. A target has total cover if it is completely concealed by an obstacle.",
    },
    {
      id: 86,
      name: "Difficult Terrain",
      description:
        "You move at half speed in difficult terrain--moving 1 foot in difficult terrain costs 2 feet of speed--so you can cover only half the normal distance in a minute, an hour, or a day.",
    },
    {
      id: 87,
      name: "Falling",
      description:
        "A fall from a great height is one of the most common hazards facing an adventurer. At the end of a fall, a creature takes 1d6 bludgeoning damage for every 10 feet it fell, to a maximum of 20d6. The creature lands prone, unless it avoids taking damage from the fall.",
    },
    {
      id: 88,
      name: "Suffocating",
      description:
        "A creature can hold its breath for a number of minutes equal to 1 + its Constitution modifier (minimum of 30 seconds). When a creature runs out of breath or is choking, it can survive for a number of rounds equal to its Constitution modifier (minimum of 1 round). At the start of its next turn, it drops to 0 hit points and is dying, and it cannot regain hit points or be stabilized until it can breathe again.",
    },
    {
      id: 89,
      name: "Lightly Obscured",
      description:
        "In a lightly obscured area, such as dim light, patchy fog, or moderate foliage, creatures have disadvantage on Wisdom (Perception) checks that rely on sight.",
    },
    {
      id: 90,
      name: "Heavily Obscured",
      description:
        "A heavily obscured area--such as darkness, opaque fog, or dense foliage--blocks vision entirely. A creature effectively suffers from the blinded condition when trying to see something in that area.",
    },
    {
      id: 91,
      name: "Climbing Swimming Crawling",
      description:
        "Each foot of movement costs 1 extra foot (2 extra feet in difficult terrain) when youâ€™re climbing, swimming, or crawling. You ignore this extra cost if you have a climbing speed and use it to climb or a swimming speed and use it to swim. At the DMâ€™s option, climbing a slippery vertical surface or one with few handholds requires a successful Strength (Athletics) check. Similarly, gaining any distance in rough water might require a successful Strength (Athletics) check.",
    },
    {
      id: 92,
      name: "Surprise",
      description:
        "If you are surprised, you cannot move or take an action on your first turn of the combat, and you cannot take a reaction until that turn ends. A member of a group can be surprised even if the other members are not.",
    },
    {
      id: 93,
      name: "Flying",
      description:
        "Flying creatures enjoy many benefits of mobility, but they must also deal with the danger of falling. If a flying creature is knocked prone, has its speed reduced to 0, or is otherwise deprived of the ability to move, the creature falls, unless it has the ability to hover or it is being held aloft by magic, such as by the fly spell.",
    },
    {
      id: 94,
      name: "Underwater",
      description:
        "When making a melee weapon attack, a creature that does not have a swimming speed (either natural or granted by magic) has disadvantage on the attack roll unless the weapon is a dagger, javelin, shortsword, spear, or trident. A ranged weapon attack automatically misses a target beyond the weapon's normal range. Even against a target within normal range, the attack roll has disadvantage unless the weapon is a crossbow, a net, or a weapon that is thrown like a javelin (including a spear, trident, or dart). Creatures and objects that are fully immersed in water have resistance to fire damage.",
    },
    {
      id: 96,
      name: "Advantage",
      description:
        "Sometimes a special ability or spell tells you that you have advantage or disadvantage on an ability check, a saving throw, or an attack roll. When that happens, you roll a second d20 when you make the roll. Use the higher of the two rolls if you have advantage.",
    },
    {
      id: 98,
      name: "Disadvantage",
      description:
        "Sometimes a special ability or spell tells you that you have advantage or disadvantage on an ability check, a saving throw, or an attack roll. When that happens, you roll a second d20 when you make the roll. Use the lower roll if you have disadvantage.",
    },
  ],
  additionalLevelTypes: [
    { id: 1, name: "Additional Targets", prerequisite: null, description: "", requiredLevel: null, displayOrder: null },
    { id: 3, name: "Extended Duration", prerequisite: null, description: "", requiredLevel: null, displayOrder: null },
    { id: 9, name: "Extended Area", prerequisite: null, description: "", requiredLevel: null, displayOrder: null },
    {
      id: 11,
      name: "Additional Creatures",
      prerequisite: null,
      description: "",
      requiredLevel: null,
      displayOrder: null,
    },
    { id: 12, name: "Special", prerequisite: null, description: "", requiredLevel: null, displayOrder: null },
    { id: 15, name: "Additional Points", prerequisite: null, description: "", requiredLevel: null, displayOrder: null },
    { id: 16, name: "Additional Count", prerequisite: null, description: "", requiredLevel: null, displayOrder: null },
    { id: 17, name: "Extended Range", prerequisite: null, description: "", requiredLevel: null, displayOrder: null },
  ],
  weaponProperties: [
    {
      id: 1,
      name: "Ammunition",
      prerequisite: null,
      description:
        'You can use a weapon that has the ammunition property to make a ranged attack only if you have ammunition to fire from the weapon. Each time you attack with the weapon, you expend one piece of ammunition. Drawing the ammunition from a quiver, case, or other container is part of the attack (you need a free hand to load a one-handed weapon). At the end of the battle, you can recover half your expended ammunition by taking a minute to search the battlefield. \nIf you use a weapon that has the ammunition property to make a melee attack, you treat the weapon as an improvised weapon (see "Improvised Weapons" later in the section). A sling must be loaded to deal any damage when used in this way. ',
      requiredLevel: null,
      displayOrder: null,
    },
    {
      id: 2,
      name: "Finesse",
      prerequisite: null,
      description:
        "When making an attack with a finesse weapon, you use your choice of your Strength or Dexterity modifier for the attack and damage rolls. You must use the same modifier for both rolls. ",
      requiredLevel: null,
      displayOrder: null,
    },
    {
      id: 3,
      name: "Heavy",
      prerequisite: null,
      description:
        "Creatures that are Small or Tiny have disadvantage on attack rolls with heavy weapons. A heavy weapon's size and bulk make it too large for a Small or Tiny creature to use effectively.",
      requiredLevel: null,
      displayOrder: null,
    },
    {
      id: 4,
      name: "Light",
      prerequisite: null,
      description:
        "A light weapon is small and easy to handle, making it ideal for use when fighting with two weapons. ",
      requiredLevel: null,
      displayOrder: null,
    },
    {
      id: 5,
      name: "Loading",
      prerequisite: null,
      description:
        "Because of the time required to load this weapon, you can fire only one piece of ammunition from it when you use an action, bonus action, or reaction to fire it, regardless of the number of attacks you can normally make. ",
      requiredLevel: null,
      displayOrder: null,
    },
    {
      id: 7,
      name: "Range",
      prerequisite: null,
      description:
        "A weapon that can be used to make a ranged attack has a range in parentheses after the ammunition or thrown property. The range lists two numbers. The first is the weapon's normal range in feet, and the second indicates the weapon's long range. When attacking a target beyond normal range, you have disadvantage on the attack roll. You can't attack a target beyond the weapon's long range. ",
      requiredLevel: null,
      displayOrder: null,
    },
    {
      id: 8,
      name: "Reach",
      prerequisite: null,
      description:
        "This weapon adds 5 feet to your reach when you attack with it, as well as when determining your reach for opportunity attacks with it. ",
      requiredLevel: null,
      displayOrder: null,
    },
    {
      id: 9,
      name: "Special",
      prerequisite: null,
      description:
        "A weapon with the special property has unusual rules governing its use, explained in the weapon's description .",
      requiredLevel: null,
      displayOrder: null,
    },
    {
      id: 10,
      name: "Thrown",
      prerequisite: null,
      description:
        "If a weapon has the thrown property, you can throw the weapon to make a ranged attack. If the weapon is a melee weapon, you use the same ability modifier for that attack roll and damage roll that you would use for a melee attack with the weapon. For example, if you throw a handaxe, you use your Strength, but if you throw a dagger, you can use either your Strength or your Dexterity, since the dagger has the finesse property. ",
      requiredLevel: null,
      displayOrder: null,
    },
    {
      id: 11,
      name: "Two-Handed",
      prerequisite: null,
      description: "This weapon requires two hands when you attack with it. ",
      requiredLevel: null,
      displayOrder: null,
    },
    {
      id: 12,
      name: "Versatile",
      prerequisite: null,
      description:
        "This weapon can be used with one or two hands. A damage value in parentheses appears with the property--the damage when the weapon is used with two hands to make a melee attack.\n\n",
      requiredLevel: null,
      displayOrder: null,
    },
    {
      id: 13,
      name: "Ammunition (Firearms)",
      prerequisite: null,
      description:
        "The ammunition of a firearm is destroyed upon use. Renaissance and modern firearms use bullets. Futuristic firearms are powered by a special type of ammunition called energy cells. An energy cell contains enough power for all the shots its firearm can make.",
      requiredLevel: null,
      displayOrder: null,
    },
    {
      id: 14,
      name: "Burst Fire",
      prerequisite: null,
      description:
        "A weapon that has the burst fire property can make a normal single-target attack, or it can spray a 10-foot-cube area within normal range with shots. Each creature in the area must succeed on a DC 15 Dexterity saving throw or take the weaponâ€™s normal damage. This action uses ten pieces of ammunition.",
      requiredLevel: null,
      displayOrder: null,
    },
    {
      id: 15,
      name: "Reload",
      prerequisite: null,
      description:
        "A limited number of shots can be made with a weapon that has the reload property. A character must then reload it using an action or a bonus action (the characterâ€™s choice).",
      requiredLevel: null,
      displayOrder: null,
    },
    { id: 16, name: "Misfire", prerequisite: null, description: "", requiredLevel: null, displayOrder: null },
    { id: 17, name: "Explosive", prerequisite: null, description: "", requiredLevel: null, displayOrder: null },
  ],
  aoeTypes: [
    {
      id: 1,
      name: "Cone",
      prerequisite: null,
      description:
        "A cone extends in a direction you choose from its point of origin. A cone's width at a given point along its length is equal to that point's distance from the point of origin. A cone's area of effect specifies its maximum length. \nA cone's point of origin is not included in the cone's area of effect, unless you decide otherwise.\n\n",
      requiredLevel: null,
      displayOrder: null,
    },
    {
      id: 2,
      name: "Cube",
      prerequisite: null,
      description:
        "You select a cube's point of origin, which lies anywhere on a face of the cubic effect. The cube's size is expressed as the length of each side. \nA cube's point of origin is not included in the cube's area of effect, unless you decide otherwise.\n\n",
      requiredLevel: null,
      displayOrder: null,
    },
    {
      id: 3,
      name: "Cylinder",
      prerequisite: null,
      description:
        "A cylinder's point of origin is the center of a circle of a particular radius, as given in the spell description. The circle must either be on the ground or at the height of the spell effect. The energy in a cylinder expands in straight lines from the point of origin to the perimeter of the circle, forming the base of the cylinder. The spell's effect then shoots up from the base or down from the top, to a distance equal to the height of the cylinder. \nA cylinder's point of origin is included in the cylinder's area of effect.\n\n",
      requiredLevel: null,
      displayOrder: null,
    },
    {
      id: 4,
      name: "Line",
      prerequisite: null,
      description:
        "A line extends from its point of origin in a straight path up to its length and covers an area defined by its width. \nA line's point of origin is not included in the line's area of effect, unless you decide otherwise.\n\n",
      requiredLevel: null,
      displayOrder: null,
    },
    {
      id: 5,
      name: "Sphere",
      prerequisite: null,
      description:
        "You select a sphere's point of origin, and the sphere extends outward from that point. The sphere's size is expressed as a radius in feet that extends from the point. \nA sphere's point of origin is included in the sphere's area of effect.\n\n",
      requiredLevel: null,
      displayOrder: null,
    },
    { id: 9, name: "Square", prerequisite: null, description: "", requiredLevel: null, displayOrder: null },
    { id: 13, name: "Square Feet", prerequisite: null, description: "", requiredLevel: null, displayOrder: null },
  ],
  lifestyles: [
    {
      id: 1,
      name: "Wretched",
      description:
        "You live in inhumane conditions. With no place to call home, you shelter wherever you can, sneaking into barns, huddling in old crates, and relying on the good graces of people better off than you. A wretched lifestyle presents abundant dangers. Violence, disease, and hunger follow you wherever you go. Other wretched people covet your armor, weapons, and adventuring gear, which represent a fortune by their standards. You are beneath the notice of most people. ",
      cost: "-",
    },
    {
      id: 3,
      name: "Squalid",
      description:
        "You live in a leaky stable, a mud-floored hut just outside town, or a vermin-infested boarding house in the worst part of town. You have shelter from the elements, but you live in a desperate and often violent environment, in places rife with disease, hunger, and misfortune. You are beneath the notice of most people, and you have few legal protections. Most people at this lifestyle level have suffered some terrible setback. They might be disturbed, marked as exiles, or suffer from disease. ",
      cost: "1SP",
    },
    {
      id: 4,
      name: "Poor",
      description:
        "A poor lifestyle means going without the comforts available in a stable community. Simple food and lodgings, threadbare clothing, and unpredictable conditions result in a sufficient, though probably unpleasant, experience. Your accommodations might be a room in a flophouse or in the common room above a tavern. You benefit from some legal protections, but you still have to contend with violence, crime, and disease. People at this lifestyle level tend to be unskilled laborers, costermongers, peddlers, thieves, mercenaries, and other disreputable types. ",
      cost: "2SP",
    },
    {
      id: 5,
      name: "Modest",
      description:
        "A modest lifestyle keeps you out of the slums and ensures that you can maintain your equipment. You live in an older part of town, renting a room in a boarding house, inn, or temple. You don't go hungry or thirsty, and your living conditions are clean, if simple. Ordinary people living modest lifestyles include soldiers with families, laborers, students, priests, hedge wizards, and the like.",
      cost: "1GP",
    },
    {
      id: 6,
      name: "Comfortable",
      description:
        "Choosing a comfortable lifestyle means that you can afford nicer clothing and can easily maintain your equipment. You live in a small cottage in a middle-class neighborhood or in a private room at a fine inn. You associate with merchants, skilled tradespeople, and military officers. ",
      cost: "2GP",
    },
    {
      id: 7,
      name: "Wealthy",
      description:
        "Choosing a wealthy lifestyle means living a life of luxury, though you might not have achieved the social status associated with the old money of nobility or royalty. You live a lifestyle comparable to that of a highly successful merchant, a favored servant of the royalty, or the owner of a few small businesses. You have respectable lodgings, usually a spacious home in a good part of town or a comfortable suite at a fine inn. You likely have a small staff of servants. ",
      cost: "4GP",
    },
    {
      id: 8,
      name: "Aristocratic",
      description:
        "You live a life of plenty and comfort. You move in circles populated by the most powerful people in the community. You have excellent lodgings, perhaps a townhouse in the nicest part of town or rooms in the finest inn. You dine at the best restaurants, retain the most skilled and fashionable tailor, and have servants attending to your every need. You receive invitations to the social gatherings of the rich and powerful, and spend evenings in the company of politicians, guild leaders, high priests, and nobility. You must also contend with the highest levels of deceit and treachery. The wealthier you are, the greater the chance you will be drawn into political intrigue as a pawn or participant.\n\n",
      cost: "10GP minimum",
    },
  ],
  conditions: [
    {
      definition: {
        id: 1,
        entityTypeId: 1737492944,
        name: "Blinded",
        type: 1,
        description:
          "<ul>\n<li>A blinded creature can't see and automatically fails any ability check that requires sight.</li>\n<li>Attack rolls against the creature have advantage, and the creature's attack rolls have disadvantage.</li>\n</ul>",
        slug: "blinded",
        levels: [],
      },
    },
    {
      definition: {
        id: 2,
        entityTypeId: 1737492944,
        name: "Charmed",
        type: 1,
        description:
          "<ul>\n<li>A charmed creature can't attack the charmer or target the charmer with harmful abilities or magical effects.</li>\n<li>The charmer has advantage on any ability check to interact socially with the creature.</li>\n</ul>",
        slug: "charmed",
        levels: [],
      },
    },
    {
      definition: {
        id: 3,
        entityTypeId: 1737492944,
        name: "Deafened",
        type: 1,
        description:
          "<ul>\n<li>A deafened creature can't hear and automatically fails any ability check that requires hearing.</li>\n</ul>",
        slug: "deafened",
        levels: [],
      },
    },
    {
      definition: {
        id: 4,
        entityTypeId: 1737492944,
        name: "Exhaustion",
        type: 2,
        description:
          '<p>Some special abilities and environmental hazards, such as starvation and the long-term effects of freezing or scorching temperatures, can lead to a special condition called exhaustion. Exhaustion is measured in six levels. An effect can give a creature one or more levels of exhaustion, as specified in the effect\'s description.</p>\n<table class="exhaustion-levels">\n<thead>\n<tr>\n<th class="exhaustionlevel">Level</th>\n<th>Effect</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td style="text-align: left">Disadvantage on ability checks</td>\n</tr>\n<tr>\n<td>2</td>\n<td style="text-align: left">Speed halved</td>\n</tr>\n<tr>\n<td>3</td>\n<td style="text-align: left">Disadvantage on attack rolls and saving throws</td>\n</tr>\n<tr>\n<td>4</td>\n<td style="text-align: left">Hit point maximum halved</td>\n</tr>\n<tr>\n<td>5</td>\n<td style="text-align: left">Speed reduced to 0</td>\n</tr>\n<tr>\n<td>6</td>\n<td style="text-align: left">Death</td>\n</tr>\n</tbody>\n</table>\n<p>If an already exhausted creature suffers another effect that causes exhaustion, its current level of exhaustion increases by the amount specified in the effect\'s description.</p>\n<p>A creature suffers the effect of its current level of exhaustion as well as all lower levels. For example, a creature suffering level 2 exhaustion has its speed halved and has disadvantage on ability checks.</p>\n<p>An effect that removes exhaustion reduces its level as specified in the effect\'s description, with all exhaustion effects ending if a creature\'s exhaustion level is reduced below 1. <br> Finishing a long rest reduces a creature\'s exhaustion level by 1, provided that the creature has also ingested some food and drink.</p>',
        slug: "exhaustion",
        levels: [
          { definition: { id: 1, entityTypeId: 2064013312, level: 1, effect: "Disadvantage on ability checks" } },
          { definition: { id: 2, entityTypeId: 2064013312, level: 2, effect: "Speed halved" } },
          {
            definition: {
              id: 3,
              entityTypeId: 2064013312,
              level: 3,
              effect: "Disadvantage on attack rolls and saving throws",
            },
          },
          { definition: { id: 4, entityTypeId: 2064013312, level: 4, effect: "Hit point maximum halved" } },
          { definition: { id: 5, entityTypeId: 2064013312, level: 5, effect: "Speed reduced to 0" } },
          { definition: { id: 6, entityTypeId: 2064013312, level: 6, effect: "Death" } },
        ],
      },
    },
    {
      definition: {
        id: 5,
        entityTypeId: 1737492944,
        name: "Frightened",
        type: 1,
        description:
          "<ul>\n<li>A frightened creature has disadvantage on ability checks and attack rolls while the source of its fear is within line of sight.</li>\n<li>The creature can't willingly move closer to the source of its fear.</li>\n</ul>",
        slug: "frightened",
        levels: [],
      },
    },
    {
      definition: {
        id: 6,
        entityTypeId: 1737492944,
        name: "Grappled",
        type: 1,
        description:
          "<ul>\n<li>A grappled creature's speed becomes 0, and it can't benefit from any bonus to its speed.</li>\n<li>The condition ends if the grappler is incapacitated (see the condition).</li>\n<li>The condition also ends if an effect removes the grappled creature from the reach of the grappler or grappling effect, such as when a creature is hurled away by the <strong>thunder-wave</strong> spell.</li>\n</ul>",
        slug: "grappled",
        levels: [],
      },
    },
    {
      definition: {
        id: 7,
        entityTypeId: 1737492944,
        name: "Incapacitated",
        type: 1,
        description: "<ul>\n<li>An incapacitated creature can't take actions or reactions.</li>\n</ul>",
        slug: "incapacitated",
        levels: [],
      },
    },
    {
      definition: {
        id: 8,
        entityTypeId: 1737492944,
        name: "Invisible",
        type: 1,
        description:
          "<ul>\n<li>An invisible creature is impossible to see without the aid of magic or a special sense. For the purpose of hiding, the creature is heavily obscured. The creature's location can be detected by any noise it makes or any tracks it leaves.</li>\n<li>Attack rolls against the creature have disadvantage, and the creature's attack rolls have advantage.</li>\n</ul>",
        slug: "invisible",
        levels: [],
      },
    },
    {
      definition: {
        id: 9,
        entityTypeId: 1737492944,
        name: "Paralyzed",
        type: 1,
        description:
          "<ul>\n<li>A paralyzed creature is incapacitated (see the condition) and can't move or speak.</li>\n<li>The creature automatically fails Strength and Dexterity saving throws. Attack rolls against the creature have advantage.</li>\n<li>Any attack that hits the creature is a critical hit if the attacker is within 5 feet of the creature.</li>\n</ul>",
        slug: "paralyzed",
        levels: [],
      },
    },
    {
      definition: {
        id: 10,
        entityTypeId: 1737492944,
        name: "Petrified",
        type: 1,
        description:
          "<ul>\n<li>A petrified creature is transformed, along with any nonmagical object it is wearing or carrying, into a solid inanimate substance (usually stone). Its weight increases by a factor of ten, and it ceases aging.</li>\n<li>The creature is incapacitated (see the condition), can't move or speak, and is unaware of its surroundings.</li>\n<li>Attack rolls against the creature have advantage.</li>\n<li>The creature automatically fails Strength and Dexterity saving throws.</li>\n<li>The creature has resistance to all damage.</li>\n<li>The creature is immune to poison and disease, although a poison or disease already in its system is suspended, not neutralized.</li>\n</ul>",
        slug: "petrified",
        levels: [],
      },
    },
    {
      definition: {
        id: 11,
        entityTypeId: 1737492944,
        name: "Poisoned",
        type: 1,
        description: "<ul>\n<li>A poisoned creature has disadvantage on attack rolls and ability checks.</li>\n</ul>",
        slug: "poisoned",
        levels: [],
      },
    },
    {
      definition: {
        id: 12,
        entityTypeId: 1737492944,
        name: "Prone",
        type: 1,
        description:
          "<ul>\n<li>A prone creature's only movement option is to crawl, unless it stands up and thereby ends the condition.</li>\n<li>The creature has disadvantage on attack rolls.</li>\n<li>An attack roll against the creature has advantage if the attacker is within 5 feet of the creature. Otherwise, the attack roll has disadvantage.</li>\n</ul>",
        slug: "prone",
        levels: [],
      },
    },
    {
      definition: {
        id: 13,
        entityTypeId: 1737492944,
        name: "Restrained",
        type: 1,
        description:
          "<ul>\n<li>A restrained creature's speed becomes 0, and it can't benefit from any bonus to its speed.</li>\n<li>Attack rolls against the creature have advantage, and the creature's attack rolls have disadvantage.</li>\n<li>The creature has disadvantage on Dexterity saving throws.</li>\n</ul>",
        slug: "restrained",
        levels: [],
      },
    },
    {
      definition: {
        id: 14,
        entityTypeId: 1737492944,
        name: "Stunned",
        type: 1,
        description:
          "<ul>\n<li>A stunned creature is incapacitated (see the condition), can't move, and can speak only falteringly.</li>\n<li>The creature automatically fails Strength and Dexterity saving throws.</li>\n<li>Attack rolls against the creature have advantage.</li>\n</ul>",
        slug: "stunned",
        levels: [],
      },
    },
    {
      definition: {
        id: 15,
        entityTypeId: 1737492944,
        name: "Unconscious",
        type: 1,
        description:
          "<ul>\n<li>An unconscious creature is incapacitated (see the condition), can't move or speak, and is unaware of its surroundings</li>\n<li>The creature drops whatever it's holding and falls prone.</li>\n<li>The creature automatically fails Strength and Dexterity saving throws.</li>\n<li>Attack rolls against the creature have advantage.</li>\n<li>Any attack that hits the creature is a critical hit if the attacker is within 5 feet of the creature.</li>\n</ul>",
        slug: "unconscious",
        levels: [],
      },
    },
  ],
  damageAdjustments: [
    { id: 1, name: "Bludgeoning", type: 1, slug: "bludgeoning", isMulti: false, displayOrder: 2 },
    { id: 2, name: "Piercing", type: 1, slug: "piercing", isMulti: false, displayOrder: 8 },
    { id: 3, name: "Slashing", type: 1, slug: "slashing", isMulti: false, displayOrder: 12 },
    { id: 4, name: "Lightning", type: 1, slug: "lightning", isMulti: false, displayOrder: 6 },
    { id: 5, name: "Thunder", type: 1, slug: "thunder", isMulti: false, displayOrder: 13 },
    { id: 6, name: "Poison", type: 1, slug: "poison", isMulti: false, displayOrder: 9 },
    { id: 7, name: "Cold", type: 1, slug: "cold", isMulti: false, displayOrder: 3 },
    { id: 8, name: "Radiant", type: 1, slug: "radiant", isMulti: false, displayOrder: 11 },
    { id: 9, name: "Fire", type: 1, slug: "fire", isMulti: false, displayOrder: 4 },
    { id: 10, name: "Necrotic", type: 1, slug: "necrotic", isMulti: false, displayOrder: 7 },
    { id: 11, name: "Acid", type: 1, slug: "acid", isMulti: false, displayOrder: 1 },
    { id: 12, name: "Psychic", type: 1, slug: "psychic", isMulti: false, displayOrder: 10 },
    {
      id: 13,
      name: "Bludgeoning, Piercing, and Slashing from Nonmagical Attacks",
      type: 1,
      slug: "bludgeoning-piercing-and-slashing-from-nonmagical-attacks",
      isMulti: true,
      displayOrder: 14,
    },
    {
      id: 14,
      name: "Bludgeoning, Piercing, and Slashing from Nonmagical Attacks that aren't Silvered",
      type: 1,
      slug: "bludgeoning-piercing-and-slashing-from-nonmagical-attacks-that-arent-silvered",
      isMulti: true,
      displayOrder: 15,
    },
    {
      id: 15,
      name: "Bludgeoning, Piercing, and Slashing from Nonmagical Attacks that aren't Adamantine",
      type: 1,
      slug: "bludgeoning-piercing-and-slashing-from-nonmagical-attacks-that-arent-adamantine",
      isMulti: true,
      displayOrder: 16,
    },
    {
      id: 16,
      name: "Piercing and Slashing from Nonmagical Attacks that aren't Adamantine",
      type: 1,
      slug: "piercing-and-slashing-from-nonmagical-attacks-that-arent-adamantine",
      isMulti: true,
      displayOrder: 17,
    },
    { id: 17, name: "Bludgeoning", type: 2, slug: "bludgeoning", isMulti: false, displayOrder: 2 },
    { id: 18, name: "Piercing", type: 2, slug: "piercing", isMulti: false, displayOrder: 8 },
    { id: 19, name: "Slashing", type: 2, slug: "slashing", isMulti: false, displayOrder: 12 },
    { id: 20, name: "Lightning", type: 2, slug: "lightning", isMulti: false, displayOrder: 6 },
    { id: 21, name: "Thunder", type: 2, slug: "thunder", isMulti: false, displayOrder: 13 },
    { id: 22, name: "Poison", type: 2, slug: "poison", isMulti: false, displayOrder: 9 },
    { id: 23, name: "Cold", type: 2, slug: "cold", isMulti: false, displayOrder: 3 },
    { id: 24, name: "Radiant", type: 2, slug: "radiant", isMulti: false, displayOrder: 11 },
    { id: 25, name: "Fire", type: 2, slug: "fire", isMulti: false, displayOrder: 4 },
    { id: 26, name: "Necrotic", type: 2, slug: "necrotic", isMulti: false, displayOrder: 7 },
    { id: 27, name: "Acid", type: 2, slug: "acid", isMulti: false, displayOrder: 1 },
    { id: 28, name: "Psychic", type: 2, slug: "psychic", isMulti: false, displayOrder: 10 },
    {
      id: 29,
      name: "Bludgeoning, Piercing, and Slashing from Nonmagical Attacks",
      type: 2,
      slug: "bludgeoning-piercing-and-slashing-from-nonmagical-attacks",
      isMulti: true,
      displayOrder: 14,
    },
    {
      id: 30,
      name: "Bludgeoning, Piercing, and Slashing from Nonmagical Attacks that aren't Silvered",
      type: 2,
      slug: "bludgeoning-piercing-and-slashing-from-nonmagical",
      isMulti: true,
      displayOrder: 16,
    },
    {
      id: 31,
      name: "Bludgeoning, Piercing, and Slashing from Nonmagical Attacks that aren't Adamantine",
      type: 2,
      slug: "bludgeoning-piercing-and-slashing-from-nonmagical",
      isMulti: true,
      displayOrder: 15,
    },
    {
      id: 32,
      name: "Piercing and Slashing from Nonmagical Attacks that aren't Adamantine",
      type: 2,
      slug: "piercing-and-slashing-from-nonmagical-attacks-that",
      isMulti: true,
      displayOrder: 17,
    },
    { id: 33, name: "Bludgeoning", type: 3, slug: "bludgeoning", isMulti: false, displayOrder: 2 },
    { id: 34, name: "Piercing", type: 3, slug: "piercing", isMulti: false, displayOrder: 8 },
    { id: 35, name: "Slashing", type: 3, slug: "slashing", isMulti: false, displayOrder: 12 },
    { id: 36, name: "Lightning", type: 3, slug: "lightning", isMulti: false, displayOrder: 6 },
    { id: 37, name: "Thunder", type: 3, slug: "thunder", isMulti: false, displayOrder: 13 },
    { id: 38, name: "Poison", type: 3, slug: "poison", isMulti: false, displayOrder: 9 },
    { id: 39, name: "Cold", type: 3, slug: "cold", isMulti: false, displayOrder: 3 },
    { id: 40, name: "Radiant", type: 3, slug: "radiant", isMulti: false, displayOrder: 11 },
    { id: 41, name: "Fire", type: 3, slug: "fire", isMulti: false, displayOrder: 4 },
    { id: 42, name: "Necrotic", type: 3, slug: "necrotic", isMulti: false, displayOrder: 7 },
    { id: 43, name: "Acid", type: 3, slug: "acid", isMulti: false, displayOrder: 1 },
    { id: 44, name: "Psychic", type: 3, slug: "psychic", isMulti: false, displayOrder: 10 },
    {
      id: 45,
      name: "Piercing from Magic Weapons Wielded by Good Creatures",
      type: 3,
      slug: "piercing-from-magic-weapons-wielded-by-good",
      isMulti: true,
      displayOrder: 14,
    },
    {
      id: 46,
      name: "Bludgeoning, Piercing, and Slashing from Magic Weapons",
      type: 1,
      slug: "bludgeoning-piercing-and-slashing-from-magic-weapons",
      isMulti: true,
      displayOrder: 18,
    },
    { id: 47, name: "Force", type: 1, slug: "force", isMulti: false, displayOrder: 5 },
    { id: 48, name: "Force", type: 2, slug: "force", isMulti: false, displayOrder: 5 },
    { id: 49, name: "Force", type: 3, slug: "force", isMulti: false, displayOrder: 5 },
    {
      id: 50,
      name: "Bludgeoning, Piercing, and Slashing from Nonmagical Attacks while in Dim Light or Darkness",
      type: 1,
      slug: "bludgeoning-piercing-and-slashing-from-nonmagical-attacks-while-in-dim-light-or-darkness",
      isMulti: true,
      displayOrder: 19,
    },
    { id: 51, name: "Ranged Attacks", type: 1, slug: "ranged-attacks", isMulti: false, displayOrder: 20 },
    { id: 52, name: "Damage Dealt By Traps", type: 1, slug: "damage-dealt-by-traps", isMulti: false, displayOrder: 21 },
    { id: 53, name: "All", type: 1, slug: "all", isMulti: true, displayOrder: 22 },
    {
      id: 54,
      name: "Bludgeoning from non magical attacks",
      type: 1,
      slug: "bludgeoning-from-non-magical-attacks",
      isMulti: false,
      displayOrder: 23,
    },
    {
      id: 55,
      name: "Bludgeoning, Piercing, and Slashing from Metal Weapons",
      type: 2,
      slug: "slashing-from-metal-weapons",
      isMulti: true,
      displayOrder: 18,
    },
    {
      id: 56,
      name: "Bludgeoning, Piercing, and Slashing while in Dim Light or Darkness",
      type: 1,
      slug: "bludgeoning-piercing-and-slashing-while-in-dim-or-light-darkness",
      isMulti: true,
      displayOrder: 24,
    },
    { id: 57, name: "Damage from Spells", type: 1, slug: "damage-from-spells", isMulti: false, displayOrder: 25 },
    {
      id: 60,
      name: "Bludgeoning, Piercing, and Slashing from Nonmagical Attacks that aren't Adamantine or Silvered",
      type: 2,
      slug: "bludgeoning-piercing-and-slashing-from-nonmagical-attacks-that-arent-adamantine-or-silvered",
      isMulti: true,
      displayOrder: 19,
    },
    {
      id: 61,
      name: "Nonmagical Bludgeoning, Piercing, and Slashing (from Stoneskin)",
      type: 1,
      slug: "nonmagical-bludgeoning-piercing-and-slashing-from-stoneskin",
      isMulti: true,
      displayOrder: 27,
    },
    {
      id: 62,
      name: "All damage but Force, Radiant, and Psychic",
      type: 1,
      slug: "all-damage-but-force-radiant-and-psychic",
      isMulti: true,
      displayOrder: 29,
    },
    {
      id: 63,
      name: "Petrified (Aberrant Armor Only)",
      type: 2,
      slug: "petrified-aberrant-armor-only",
      isMulti: false,
      displayOrder: 28,
    },
    {
      id: 64,
      name: "Slashing from a Vorpal Sword",
      type: 3,
      slug: "slashing-from-a-vorpal-sword",
      isMulti: false,
      displayOrder: 30,
    },
    {
      id: 65,
      name: "Damage of the type matching the animated breath's form (acid, cold, fire, lightning, or poison)",
      type: 1,
      slug: "damage-of-the-type-matching-the-animated-breaths-form-acid-cold-fire-lightning-or-poison",
      isMulti: false,
      displayOrder: 31,
    },
    {
      id: 66,
      name: "Psychic (granted by Ruidium Armor)",
      type: 1,
      slug: "psychic-granted-by-ruidium-armor",
      isMulti: false,
      displayOrder: 32,
    },
  ],
  statModifiers: [
    { value: 1, modifier: -5 },
    { value: 2, modifier: -4 },
    { value: 3, modifier: -4 },
    { value: 4, modifier: -3 },
    { value: 5, modifier: -3 },
    { value: 6, modifier: -2 },
    { value: 7, modifier: -2 },
    { value: 8, modifier: -1 },
    { value: 9, modifier: -1 },
    { value: 10, modifier: 0 },
    { value: 11, modifier: 0 },
    { value: 12, modifier: 1 },
    { value: 13, modifier: 1 },
    { value: 14, modifier: 2 },
    { value: 15, modifier: 2 },
    { value: 16, modifier: 3 },
    { value: 17, modifier: 3 },
    { value: 18, modifier: 4 },
    { value: 19, modifier: 4 },
    { value: 20, modifier: 5 },
    { value: 21, modifier: 5 },
    { value: 22, modifier: 6 },
    { value: 23, modifier: 6 },
    { value: 24, modifier: 7 },
    { value: 25, modifier: 7 },
    { value: 26, modifier: 8 },
    { value: 27, modifier: 8 },
    { value: 28, modifier: 9 },
    { value: 29, modifier: 9 },
    { value: 30, modifier: 10 },
  ],
  alignments: [
    {
      id: 1,
      name: "Lawful Good",
      description:
        "Lawful good (LG) creatures can be counted on to do the right thing as expected by society. Gold dragons, paladins, and most dwarves are lawful good.",
      availableToCharacter: true,
    },
    {
      id: 2,
      name: "Neutral Good",
      description:
        "Neutral good (NG) folk do the best they can to help others according to their needs. Many celestials, some cloud giants, and most gnomes are neutral good.",
      availableToCharacter: true,
    },
    {
      id: 3,
      name: "Chaotic Good",
      description:
        "Chaotic good (CG) creatures act as their conscience directs, with little regard for what others expect. Copper dragons, many elves, and unicorns are chaotic good.",
      availableToCharacter: true,
    },
    {
      id: 4,
      name: "Lawful Neutral",
      description:
        "Lawful neutral (LN) individuals act in accordance with law, tradition, or personal codes. Many monks and some wizards are lawful neutral.",
      availableToCharacter: true,
    },
    {
      id: 5,
      name: "Neutral",
      description:
        "Neutral (N) is the alignment of those who prefer to steer clear of moral questions and don't take sides, doing what seems best at the time. Lizardfolk, most druids, and many humans are neutral.",
      availableToCharacter: true,
    },
    {
      id: 6,
      name: "Chaotic Neutral",
      description:
        "Chaotic neutral (CN) creatures follow their whims, holding their personal freedom above all else. Many barbarians and rogues, and some bards, are chaotic neutral.",
      availableToCharacter: true,
    },
    {
      id: 7,
      name: "Lawful Evil",
      description:
        "Lawful evil (LE) creatures methodically take what they want, within the limits of a code of tradition, loyalty, or order. Devils, blue dragons, and hobgoblins are lawful evil.",
      availableToCharacter: true,
    },
    {
      id: 8,
      name: "Neutral Evil",
      description:
        "Neutral evil (NE) is the alignment of those who do whatever they can get away with, without compassion or qualms. Many drow, some cloud giants, and goblins are neutral evil.",
      availableToCharacter: true,
    },
    {
      id: 9,
      name: "Chaotic Evil",
      description:
        "Chaotic evil (CE) creatures act with arbitrary violence, spurred by their greed, hatred, or bloodlust. Demons, red dragons, and orcs are chaotic evil.",
      availableToCharacter: true,
    },
    { id: 10, name: "Unaligned", description: null, availableToCharacter: false },
    { id: 11, name: "Any Alignment", description: "Any Alignment", availableToCharacter: false },
    { id: 13, name: "Any Evil Alignment", description: "Any Evil Alignment", availableToCharacter: false },
    { id: 14, name: "Any Good Alignment", description: "Any Good Alignment", availableToCharacter: false },
    { id: 15, name: "Any Chaotic Alignment", description: "Any Chaotic Alignment", availableToCharacter: false },
    { id: 16, name: "Any Lawful Alignment", description: "Any Lawful Alignment", availableToCharacter: false },
    { id: 18, name: "Any Non-Good Alignment", description: "Any Non-Good Alignment", availableToCharacter: false },
    { id: 19, name: "Any Non-Lawful Alignment", description: "Any Non-Lawful Alignment", availableToCharacter: false },
    {
      id: 20,
      name: "Typically Chaotic Neutral",
      description: "Typically Chaotic Neutral",
      availableToCharacter: false,
    },
    { id: 21, name: "Typically Neutral Good", description: "Typically Neutral Good", availableToCharacter: false },
    { id: 22, name: "Typically Lawful Good", description: "Typically Lawful Good", availableToCharacter: false },
    { id: 23, name: "Typically Chaotic Evil", description: "Typically Chaotic Evil", availableToCharacter: false },
    { id: 24, name: "Typically Neutral Evil", description: "Typically Neutral Evil", availableToCharacter: false },
    { id: 25, name: "Typically Chaotic Good", description: "Typically Chaotic Good", availableToCharacter: false },
    { id: 26, name: "Typically Neutral", description: "Typically Neutral", availableToCharacter: false },
    { id: 27, name: "Typically Lawful Evil", description: "Typically Lawful Evil", availableToCharacter: false },
    { id: 28, name: "Typically Lawful Neutral", description: "Typically Lawful Neutral", availableToCharacter: false },
  ],
  sources: [
    {
      id: 1,
      name: "BR",
      description: "Basic Rules",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/10434/136/637248073409717512.jpeg",
      sourceURL: "sources/basic-rules",
    },
    {
      id: 2,
      name: "PHB",
      description: "Player's Handbook",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/10435/389/637248131811862290.jpeg",
      sourceURL: "sources/phb",
    },
    {
      id: 3,
      name: "DMG",
      description: "Dungeon Master's Guide",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/10367/593/637245347063211867.jpeg",
      sourceURL: "sources/dmg",
    },
    {
      id: 4,
      name: "EE",
      description: "Elemental Evil Player's Companion",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/",
      sourceURL: "",
    },
    {
      id: 5,
      name: "MM",
      description: "Monster Manual",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/10434/816/637248105832999293.jpeg",
      sourceURL: "sources/mm",
    },
    {
      id: 6,
      name: "CoS",
      description: "Curse of Strahd",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/10349/296/637244603965977140.jpeg",
      sourceURL: "sources/cos",
    },
    {
      id: 7,
      name: "HotDQ",
      description: "Hoard of the Dragon Queen",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/10432/68/637247937818392417.jpeg",
      sourceURL: "sources/hotdq",
    },
    {
      id: 8,
      name: "LMoP",
      description: "Lost Mine of Phandelver",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/10434/616/637248096401764265.jpeg",
      sourceURL: "sources/lmop",
    },
    {
      id: 9,
      name: "OotA",
      description: "Out of the Abyss",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/19/735/636383500945700817.jpeg",
      sourceURL: "sources/oota",
    },
    {
      id: 10,
      name: "PotA",
      description: "Princes of the Apocalypse",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/10435/524/637248137744435932.jpeg",
      sourceURL: "sources/pota",
    },
    {
      id: 11,
      name: "RoT",
      description: "Rise of Tiamat",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/10435/605/637248141604547323.jpeg",
      sourceURL: "sources/rot",
    },
    {
      id: 12,
      name: "SKT",
      description: "Storm King's Thunder",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/19/740/636383501361665378.jpeg",
      sourceURL: "sources/skt",
    },
    {
      id: 13,
      name: "SCAG",
      description: "Sword Coast Adventurer's Guide",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/10435/793/637248149475504723.jpeg",
      sourceURL: "sources/scag",
    },
    {
      id: 14,
      name: "TftYP",
      description: "Tales from the Yawning Portal",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/10449/177/637248652153094716.jpeg",
      sourceURL: "sources/tftyp",
    },
    {
      id: 15,
      name: "VGtM",
      description: "Volo's Guide to Monsters",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/10449/464/637248679743732719.jpeg",
      sourceURL: "sources/vgtm",
    },
    {
      id: 16,
      name: "TSC",
      description: "The Sunless Citadel",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/10449/402/637248674372576676.jpeg",
      sourceURL: "sources/tftyp/a1",
    },
    {
      id: 17,
      name: "TFoF",
      description: "The Forge of Fury",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/10436/4/637248156999902689.jpeg",
      sourceURL: "sources/tftyp/a2",
    },
    {
      id: 18,
      name: "THSoT",
      description: "The Hidden Shrine of Tamoachan",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/10449/236/637248657347161458.jpeg",
      sourceURL: "sources/tftyp/a3",
    },
    {
      id: 19,
      name: "WPM",
      description: "White Plume Mountain",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/10449/751/637248705560259195.jpeg",
      sourceURL: "sources/tftyp/a4",
    },
    {
      id: 20,
      name: "DiT",
      description: "Dead in Thay",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/10434/246/637248079254127234.jpeg",
      sourceURL: "sources/tftyp/a5",
    },
    {
      id: 21,
      name: "AtG",
      description: "Against the Giants",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/10433/315/637248029897296032.jpeg",
      sourceURL: "sources/tftyp/a6",
    },
    {
      id: 22,
      name: "ToH",
      description: "Tomb of Horrors",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/10449/371/637248671854035769.jpeg",
      sourceURL: "sources/tftyp/a7",
    },
    {
      id: 25,
      name: "ToA",
      description: "Tomb of Annihilation",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/10449/339/637248669136195626.jpeg",
      sourceURL: "sources/toa",
    },
    {
      id: 26,
      name: "CoSCO",
      description: "Curse of Strahd: Character Options",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/10349/289/637244603748885696.jpeg",
      sourceURL: "",
    },
    {
      id: 27,
      name: "XGtE",
      description: "Xanathar's Guide to Everything",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/10449/803/637248709455777906.jpeg",
      sourceURL: "sources/xgte",
    },
    {
      id: 28,
      name: "TTP",
      description: "The Tortle Package",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/39/300/636411199124473334.png",
      sourceURL: "sources/ttp",
    },
    {
      id: 29,
      name: "UA",
      description: "Unearthed Arcana",
      sourceCategoryId: 3,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/100/464/636506973225556542.png",
      sourceURL: "",
    },
    {
      id: 31,
      name: "CR",
      description: "Critical Role",
      sourceCategoryId: 2,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/",
      sourceURL: "",
    },
    {
      id: 33,
      name: "MToF",
      description: "Mordenkainenâ€™s Tome of Foes",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/10434/949/637248111148617766.jpeg",
      sourceURL: "sources/mtof",
    },
    {
      id: 34,
      name: "DDIA-MORD",
      description: "Rrakkma",
      sourceCategoryId: 12,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/319/345/636622116959280867.jpeg",
      sourceURL: "sources/ddia-mord",
    },
    {
      id: 35,
      name: "WDH",
      description: "Waterdeep: Dragon Heist",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/343/499/636632335939805190.jpeg",
      sourceURL: "sources/wdh",
    },
    {
      id: 36,
      name: "WDotMM",
      description: "Waterdeep: Dungeon of the Mad Mage",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/10449/493/637248684031810278.jpeg",
      sourceURL: "sources/wdotmm",
    },
    {
      id: 37,
      name: "WGtE",
      description: "Wayfinder's Guide to Eberron",
      sourceCategoryId: 8,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/10449/715/637248702538222765.jpeg",
      sourceURL: "sources/wgte",
    },
    {
      id: 38,
      name: "GGtR",
      description: "Guildmasters' Guide to Ravnica",
      sourceCategoryId: 7,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/10369/823/637245482341163840.jpeg",
      sourceURL: "sources/ggtr",
    },
    {
      id: 40,
      name: "LLoK",
      description: "Lost Laboratory of Kwalish",
      sourceCategoryId: 12,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/10434/498/637248091075319276.jpeg",
      sourceURL: "sources/llok",
    },
    {
      id: 41,
      name: "DoIP",
      description: "Dragon of Icespire Peak",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/10350/957/637244676648122088.jpeg",
      sourceURL: "sources/doip",
    },
    {
      id: 42,
      name: "TMR",
      description: "Tactical Maps Reincarnated",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/5336/630/636850745475942698.jpeg",
      sourceURL: "",
    },
    {
      id: 43,
      name: "GoS",
      description: "Ghosts of Saltmarsh",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/10370/66/637245493047936420.jpeg",
      sourceURL: "sources/gos",
    },
    {
      id: 44,
      name: "AI",
      description: "Acquisitions Incorporated",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/10350/905/637244674570907870.jpeg",
      sourceURL: "sources/ai",
    },
    {
      id: 47,
      name: "HftT",
      description: "Hunt for the Thessalhydra",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/10432/12/637247932786703735.jpeg",
      sourceURL: "sources/hftt",
    },
    {
      id: 48,
      name: "BGDiA",
      description: "Baldur's Gate: Descent into Avernus",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/10350/927/637244675832719441.jpeg",
      sourceURL: "sources/bgdia",
    },
    {
      id: 49,
      name: "ERftLW",
      description: "Eberron: Rising from the Last War",
      sourceCategoryId: 8,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/10368/6/637245381196842264.jpeg",
      sourceURL: "sources/erftlw",
    },
    {
      id: 50,
      name: "SLW",
      description: "Storm Lordâ€™s Wrath",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/10350/964/637244676927254855.jpeg",
      sourceURL: "sources/slw",
    },
    {
      id: 51,
      name: "SDW",
      description: "Sleeping Dragonâ€™s Wake",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/10350/959/637244676820916158.jpeg",
      sourceURL: "sources/sdw",
    },
    {
      id: 52,
      name: "DC",
      description: "Divine Contention",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/10350/951/637244676535367295.jpeg",
      sourceURL: "sources/dc",
    },
    {
      id: 53,
      name: "SAC",
      description: "Sage Advice Compendium",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/10435/702/637248145947271474.jpeg",
      sourceURL: "sources/sac",
    },
    {
      id: 54,
      name: "DDvRaM",
      description: "Dungeons &amp; Dragons vs. Rick and Morty",
      sourceCategoryId: 10,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/10367/229/637245316031917098.jpeg",
      sourceURL: "sources/ddvram",
    },
    {
      id: 55,
      name: "LR",
      description: "Locathah Rising",
      sourceCategoryId: 12,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/10434/650/637248098360957592.jpeg",
      sourceURL: "sources/lr",
    },
    {
      id: 56,
      name: "IMR",
      description: "Infernal Machine Rebuild",
      sourceCategoryId: 12,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/10434/395/637248086063224834.jpeg",
      sourceURL: "sources/imr",
    },
    {
      id: 57,
      name: "MFFV1",
      description: "Mordenkainen's Fiendish Folio Volume 1",
      sourceCategoryId: 12,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/10434/743/637248102793792401.jpeg",
      sourceURL: "sources/mffv1",
    },
    {
      id: 58,
      name: "SD",
      description: "Sapphire Dragon",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/10435/899/637248153278056972.jpeg",
      sourceURL: "",
    },
    {
      id: 59,
      name: "EGtW",
      description: "Explorer's Guide to Wildemount",
      sourceCategoryId: 2,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/10367/769/637245363413951140.jpeg",
      sourceURL: "sources/egtw",
    },
    {
      id: 60,
      name: "OGA",
      description: "One Grung Above",
      sourceCategoryId: 12,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/10435/68/637248116464990081.jpeg",
      sourceURL: "sources/oga",
    },
    {
      id: 61,
      name: "MOoT",
      description: "Mythic Odysseys of Theros",
      sourceCategoryId: 7,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/10434/885/637248108609488365.jpeg",
      sourceURL: "sources/moot",
    },
    {
      id: 62,
      name: "WA",
      description: "Frozen Sick",
      sourceCategoryId: 2,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/9193/755/637200909525723425.jpeg",
      sourceURL: "sources/wa",
    },
    {
      id: 66,
      name: "IDRotF",
      description: "Icewind Dale: Rime of the Frostmaiden",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/11095/550/637278965847502335.jpeg",
      sourceURL: "sources/idrotf",
    },
    {
      id: 67,
      name: "TCoE",
      description: "Tashaâ€™s Cauldron of Everything",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/13665/613/637400361423035085.jpeg",
      sourceURL: "sources/tcoe",
    },
    {
      id: 68,
      name: "CM",
      description: "Candlekeep Mysteries",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/14917/783/637456355214291364.jpeg",
      sourceURL: "sources/cm",
    },
    {
      id: 69,
      name: "VRGtR",
      description: "Van Richtenâ€™s Guide to Ravenloft",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/15973/81/637496917952314322.jpeg",
      sourceURL: "sources/vrgtr",
    },
    {
      id: 79,
      name: "TWBtW",
      description: "The Wild Beyond the Witchlight",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/18223/997/637587419509160992.jpeg",
      sourceURL: "sources/twbtw",
    },
    {
      id: 80,
      name: "SACoC",
      description: "Strixhaven: A Curriculum of Chaos",
      sourceCategoryId: 7,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/18228/52/637587668398315568.jpeg",
      sourceURL: "sources/sacoc",
    },
    {
      id: 81,
      name: "FToD",
      description: "Fizban's Treasury of Dragons",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/19075/983/637620380256293999.jpeg",
      sourceURL: "sources/ftod",
    },
    {
      id: 83,
      name: "CotN",
      description: "Critical Role: Call of the Netherdeep",
      sourceCategoryId: 2,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/20906/943/637695655261542821.jpeg",
      sourceURL: "sources/cotn",
    },
    {
      id: 85,
      name: "MotM",
      description: "Mordenkainen Presents: Monsters of the Multiverse",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/22937/354/637776964748720726.jpeg",
      sourceURL: "sources/motm",
    },
    {
      id: 87,
      name: "JttRC",
      description: "Journeys through the Radiant Citadel",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/24454/511/637830510509865265.jpeg",
      sourceURL: "sources/jttrc",
    },
    {
      id: 89,
      name: "MCv1",
      description: "Monstrous Compendium Volume One: Spelljammer Creatures",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/25098/972/637854763136224645.jpeg",
      sourceURL: "sources/mcv1",
    },
    {
      id: 90,
      name: "SAiS",
      description: "Spelljammer: Adventures in Space",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/25228/876/637859890823057854.jpeg",
      sourceURL: "sources/sais",
    },
    {
      id: 91,
      name: "TVD",
      description: "The Vecna Dossier",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/26305/340/637901114717317528.jpeg",
      sourceURL: "sources/tvd",
    },
    {
      id: 92,
      name: "TRC",
      description: "The Radiant Citadel",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/26479/568/637907273106559243.jpeg",
      sourceURL: "sources/trc",
    },
    {
      id: 93,
      name: "SJA",
      description: "Spelljammer Academy",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/26848/192/637920417931102595.jpeg",
      sourceURL: "sources/sja",
    },
    {
      id: 94,
      name: "DoSI",
      description: "Dragons of Stormwreck Isle",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/26865/226/637921086362458107.jpeg",
      sourceURL: "sources/dosi",
    },
    {
      id: 95,
      name: "SotDQ",
      description: "Dragonlance: Shadow of the Dragon Queen",
      sourceCategoryId: 14,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/27777/666/637951679601337771.jpeg",
      sourceURL: "sources/sotdq",
    },
    {
      id: 101,
      name: "MCv2",
      description: "Monstrous Compendium Volume Two: Dragonlance Creatures",
      sourceCategoryId: 14,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/30591/814/638054153540284547.jpeg",
      sourceURL: "sources/mcv2",
    },
    {
      id: 102,
      name: "ToD",
      description: "Tyranny of Dragons",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/31000/357/638070661674299942.jpeg",
      sourceURL: "sources/tod",
    },
    {
      id: 103,
      name: "KftGV",
      description: "Keys from the Golden Vault",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/31000/595/638070671792143197.jpeg",
      sourceURL: "sources/kftgv",
    },
    {
      id: 105,
      name: "P13",
      description: "Prisoner 13",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/31678/948/638097617627683009.jpeg",
      sourceURL: "sources/p13",
    },
  ],
  levelProficiencyBonuses: [
    { level: 1, bonus: 2 },
    { level: 2, bonus: 2 },
    { level: 3, bonus: 2 },
    { level: 4, bonus: 2 },
    { level: 5, bonus: 3 },
    { level: 6, bonus: 3 },
    { level: 7, bonus: 3 },
    { level: 8, bonus: 3 },
    { level: 9, bonus: 4 },
    { level: 10, bonus: 4 },
    { level: 11, bonus: 4 },
    { level: 12, bonus: 4 },
    { level: 13, bonus: 5 },
    { level: 14, bonus: 5 },
    { level: 15, bonus: 5 },
    { level: 16, bonus: 5 },
    { level: 17, bonus: 6 },
    { level: 18, bonus: 6 },
    { level: 19, bonus: 6 },
    { level: 20, bonus: 6 },
  ],
  levelExperiencePoints: [
    0, 300, 900, 2700, 6500, 14000, 23000, 34000, 48000, 64000, 85000, 100000, 120000, 140000, 165000, 195000, 225000,
    265000, 305000, 355000,
  ],
  diceValues: [4, 6, 8, 10, 12, 20],
  stats: [
    {
      id: 1,
      entityTypeId: 1472902489,
      key: "STR",
      name: "Strength",
      compendiumText:
        '<p>Strength measures bodily power, athletic training, and the extent to which you can exert raw physical force.</p>\n<h4 id="StrengthChecks">Strength Checks</h4>\n<p>A Strength check can model any attempt to lift, push, pull, or break something, to force your body through a space, or to otherwise apply brute force to a situation. The Athletics skill reflects aptitude in certain kinds of Strength checks.</p>\n<h5 id="Athletics">Athletics</h5>\n<p>Your Strength (Athletics) check covers difficult situations you encounter while climbing, jumping, or swimming. Examples include the following activities:</p>\n<ul>\n<li>You attempt to climb a sheer or slippery cliff, avoid hazards while scaling a wall, or cling to a surface while something is trying to knock you off.</li>\n<li>You try to jump an unusually long distance or pull off a stunt midjump.</li>\n<li>You struggle to swim or stay afloat in treacherous currents, storm-tossed waves, or areas of thick seaweed. Or another creature tries to push or pull you underwater or otherwise interfere with your swimming.</li>\n</ul>\n<h5 id="OtherStrengthChecks">Other Strength Checks</h5>\n<p>The DM might also call for a Strength check when you try to accomplish tasks like the following:</p>\n<ul>\n<li>Force open a stuck, locked, or barred door</li>\n<li>Break free of bonds</li>\n<li>Push through a tunnel that is too small</li>\n<li>Hang on to a wagon while being dragged behind it</li>\n<li>Tip over a statue</li>\n<li>Keep a boulder from rolling</li>\n</ul>\n<h4 id="AttackRollsandDamage">Attack Rolls and Damage</h4>\n<p>You add your Strength modifier to your attack roll and your damage roll when attacking with a melee weapon such as a mace, a battleaxe, or a javelin. You use melee weapons to make melee attacks in hand-to-hand combat, and some of them can be thrown to make a ranged attack.</p>\n<h4 id="LiftingandCarrying">Lifting and Carrying</h4>\n<p>Your Strength score determines the amount of weight you can bear. The following terms define what you can lift or carry.</p>\n<p><strong>Carrying Capacity.</strong> Your carrying capacity is your Strength score multiplied by 15. This is the weight (in pounds) that you can carry, which is high enough that most characters don\'t usually have to worry about it.</p>\n<p><strong>Push, Drag, or Lift.</strong> You can push, drag, or lift a weight in pounds up to twice your carrying capacity (or 30 times your Strength score). While pushing or dragging weight in excess of your carrying capacity, your speed drops to 5 feet.</p>\n<p><strong>Size and Strength.</strong> Larger creatures can bear more weight, whereas Tiny creatures can carry less. For each size category above Medium, double the creature\'s carrying capacity and the amount it can push, drag, or lift. For a Tiny creature, halve these weights.</p>\n<h4 id="VariantEncumbrance">Variant: Encumbrance</h4>\n<p>The rules for lifting and carrying are intentionally simple. Here is a variant if you are looking for more detailed rules for determining how a character is hindered by the weight of equipment. When you use this variant, ignore the Strength column of the Armor table in <a href="https://www.dndbeyond.com/compendium/rules/phb/equipment#ArmorandShields">chapter 5</a>.</p>\n<p>If you carry weight in excess of 5 times your Strength score, you are <strong>encumbered</strong>, which means your speed drops by 10 feet.</p>\n<p>If you carry weight in excess of 10 times your Strength score, up to your maximum carrying capacity, you are instead <strong>heavily encumbered</strong>, which means your speed drops by 20 feet and you have disadvantage on ability checks, attack rolls, and saving throws that use Strength, Dexterity, or Constitution.</p>',
    },
    {
      id: 2,
      entityTypeId: 1472902489,
      key: "DEX",
      name: "Dexterity",
      compendiumText:
        '<p>Dexterity measures agility, reflexes, and balance.</p>\n<h4 id="DexterityChecks">Dexterity Checks</h4>\n<p>A Dexterity check can model any attempt to move nimbly, quickly, or quietly, or to keep from falling on tricky footing. The Acrobatics, Sleight of Hand, and Stealth skills reflect aptitude in certain kinds of Dexterity checks.</p>\n<h5 id="Acrobatics">Acrobatics</h5>\n<p>Your Dexterity (Acrobatics) check covers your attempt to stay on your feet in a tricky situation, such as when you\'re trying to run across a sheet of ice, balance on a tightrope, or stay upright on a rocking ship\'s deck. The DM might also call for a Dexterity (Acrobatics) check to see if you can perform acrobatic stunts, including dives, rolls, somersaults, and flips.</p>\n<h5 id="SleightofHand">Sleight of Hand</h5>\n<p>Whenever you attempt an act of legerdemain or manual trickery, such as planting something on someone else or concealing an object on your person, make a Dexterity (Sleight of Hand) check. The DM might also call for a Dexterity (Sleight of Hand) check to determine whether you can lift a coin purse off another person or slip something out of another person\'s pocket.</p>\n<h5 id="Stealth">Stealth</h5>\n<p>Make a Dexterity (Stealth) check when you attempt to conceal yourself from enemies, slink past guards, slip away without being noticed, or sneak up on someone without being seen or heard.</p>\n<h5 id="OtherDexterityChecks">Other Dexterity Checks</h5>\n<p>The DM might call for a Dexterity check when you try to accomplish tasks like the following:</p>\n<ul>\n<li>Control a heavily laden cart on a steep descent</li>\n<li>Steer a chariot around a tight turn</li>\n<li>Pick a lock</li>\n<li>Disable a trap</li>\n<li>Securely tie up a prisoner</li>\n<li>Wriggle free of bonds</li>\n<li>Play a stringed instrument</li>\n<li>Craft a small or detailed object</li>\n</ul>\n<h4 id="AttackRollsandDamage">Attack Rolls and Damage</h4>\n<p>You add your Dexterity modifier to your attack roll and your damage roll when attacking with a ranged weapon, such as a sling or a longbow. You can also add your Dexterity modifier to your attack roll and your damage roll when attacking with a melee weapon that has the finesse property, such as a dagger or a rapier.</p>\n<h4 id="ArmorClass">Armor Class</h4>\n<p>Depending on the armor you wear, you might add some or all of your Dexterity modifier to your Armor Class, as described in chapter 5, "<a href="https://www.dndbeyond.com/compendium/rules/phb/equipment#ArmorandShields">Equipment</a>."</p>\n<h4 id="Initiative">Initiative</h4>\n<p>At the beginning of every combat, you roll initiative by making a Dexterity check. Initiative determines the order of creatures\' turns in combat, as described in chapter 9, "<a href="https://www.dndbeyond.com/compendium/rules/phb/combat#Initiative">Combat</a>."</p>\n<blockquote>\n<p><strong>HIDING</strong></p>\n<p>The DM decides when circumstances are appropriate for hiding. When you try to hide, make a Dexterity (Stealth) check. Until you are discovered or you stop hiding, that check\'s total is contested by the Wisdom (Perception) check of any creature that actively searches for signs of your presence.</p>\n<p>You can\'t hide from a creature that can see you clearly, and you give away your position if you make noise, such as shouting a warning or knocking over a vase. An invisible creature can always try to hide. Signs of its passage might still be noticed, and it does have to stay quiet.</p>\n<p>In combat, most creatures stay alert for signs of danger all around, so if you come out of hiding and approach a creature, it usually sees you. However, under certain circumstances, the DM might allow you to stay hidden as you approach a creature that is distracted, allowing you to gain advantage on an attack roll before you are seen.</p>\n<p><strong>Passive Perception.</strong> When you hide, there\'s a chance someone will notice you even if they aren\'t searching. To determine whether such a creature notices you, the DM compares your Dexterity (Stealth) check with that creature\'s passive Wisdom (Perception) score, which equals 10 + the creature\'s Wisdom modifier, as well as any other bonuses or penalties. If the creature has advantage, add 5. For disadvantage, subtract 5.</p>\n<p>For example, if a 1st-level character (with a proficiency bonus of +2) has a Wisdom of 15 (a +2 modifier) and proficiency in Perception, he or she has a passive Wisdom (Perception) of 14.</p>\n<p><strong>What Can You See?</strong> One of the main factors in determining whether you can find a hidden creature or object is how well you can see in an area, which might be <strong>lightly</strong> or <strong>heavily obscured&nbsp;</strong>as explained in chapter 8, â€œ<a href="https://www.dndbeyond.com/compendium/rules/phb/adventuring#VisionandLight">Adventuring</a>.â€</p>\n</blockquote>',
    },
    {
      id: 3,
      entityTypeId: 1472902489,
      key: "CON",
      name: "Constitution",
      compendiumText:
        '<p>Constitution measures health, stamina, and vital force.</p>\n<h4 id="ConstitutionChecks">Constitution Checks</h4>\n<p>Constitution checks are uncommon, and no skills apply to Constitution checks, because the endurance this ability represents is largely passive rather than involving a specific effort on the part of a character or monster. A Constitution check can model your attempt to push beyond normal limits, however.</p>\n<p>The DM might call for a Constitution check when you try to accomplish tasks like the following:</p>\n<ul>\n<li>Hold your breath</li>\n<li>March or labor for hours without rest</li>\n<li>Go without sleep</li>\n<li>Survive without food or water</li>\n<li>Quaff an entire stein of ale in one go</li>\n</ul>\n<h4 id="HitPoints">Hit Points</h4>\n<p>Your Constitution modifier contributes to your hit points. Typically, you add your Constitution modifier to each Hit Die you roll for your hit points.</p>\n<p>If your Constitution modifier changes, your hit point maximum changes as well, as though you had the new modifier from 1st level. For example, if you raise your Constitution score when you reach 4th level and your Constitution modifier increases from +1 to +2, you adjust your hit point maximum as though the modifier had always been +2. So you add 3 hit points for your first three levels, and then roll your hit points for 4th level using your new modifier. Or if you\'re 7th level and some effect lowers your Constitution score so as to reduce your Constitution modifier by 1, your hit point maximum is reduced by 7.</p>',
    },
    {
      id: 4,
      entityTypeId: 1472902489,
      key: "INT",
      name: "Intelligence",
      compendiumText:
        '<p>Intelligence measures mental acuity, accuracy of recall, and the ability to reason.</p>\n<h4 id="IntelligenceChecks">Intelligence Checks</h4>\n<p>An Intelligence check comes into play when you need to draw on logic, education, memory, or deductive reasoning. The Arcana, History, Investigation, Nature, and Religion skills reflect aptitude in certain kinds of Intelligence checks.</p>\n<h5 id="Arcana">Arcana</h5>\n<p>Your Intelligence (Arcana) check measures your ability to recall lore about spells, magic items, eldritch symbols, magical traditions, the planes of existence, and the inhabitants of those planes.</p>\n<h5 id="History">History</h5>\n<p>Your Intelligence (History) check measures your ability to recall lore about historical events, legendary people, ancient kingdoms, past disputes, recent wars, and lost civilizations.</p>\n<h5 id="Investigation">Investigation</h5>\n<p>When you look around for clues and make deductions based on those clues, you make an Intelligence (Investigation) check. You might deduce the location of a hidden object, discern from the appearance of a wound what kind of weapon dealt it, or determine the weakest point in a tunnel that could cause it to collapse. Poring through ancient scrolls in search of a hidden fragment of knowledge might also call for an Intelligence (Investigation) check.</p>\n<h5 id="Nature">Nature</h5>\n<p>Your Intelligence (Nature) check measures your ability to recall lore about terrain, plants and animals, the weather, and natural cycles.</p>\n<h5 id="Religion">Religion</h5>\n<p>Your Intelligence (Religion) check measures your ability to recall lore about deities, rites and prayers, religious hierarchies, holy symbols, and the practices of secret cults.</p>\n<h5 id="OtherIntelligenceChecks">Other Intelligence Checks</h5>\n<p>The DM might call for an Intelligence check when you try to accomplish tasks like the following:</p>\n<ul>\n<li>Communicate with a creature without using words</li>\n<li>Estimate the value of a precious item</li>\n<li>Pull together a disguise to pass as a city guard</li>\n<li>Forge a document</li>\n<li>Recall lore about a craft or trade</li>\n<li>Win a game of skill</li>\n</ul>\n<h4 id="SpellcastingAbility">Spellcasting Ability</h4>\n<p>Wizards use Intelligence as their spellcasting ability, which helps determine the saving throw DCs of spells they cast.</p>',
    },
    {
      id: 5,
      entityTypeId: 1472902489,
      key: "WIS",
      name: "Wisdom",
      compendiumText:
        '<p>Wisdom reflects how attuned you are to the world around you and represents perceptiveness and intuition.</p>\n<h4 id="WisdomChecks">Wisdom Checks</h4>\n<p>A Wisdom check might reflect an effort to read body language, understand someoneâ€™s feelings, notice things about the environment, or care for an injured person. The Animal Handling, Insight, Medicine, Perception, and Survival skills reflect aptitude in certain kinds of Wisdom checks.</p>\n<h5 id="AnimalHandling">Animal Handling</h5>\n<p>When there is any question whether you can calm down a domesticated animal, keep a mount from getting spooked, or intuit an animalâ€™s intentions, the DM might call for a Wisdom (Animal Handling) check. You also make a Wisdom (Animal Handling) check to control your mount when you attempt a risky maneuver.</p>\n<h5 id="Insight">Insight</h5>\n<p>Your Wisdom (Insight) check decides whether you can determine the true intentions of a creature, such as when searching out a lie or predicting someoneâ€™s next move. Doing so involves gleaning clues from body language, speech habits, and changes in mannerisms.</p>\n<h5 id="Medicine">Medicine</h5>\n<p>A Wisdom (Medicine) check lets you try to stabilize a dying companion or diagnose an illness.</p>\n<h5 id="Perception">Perception</h5>\n<p>Your Wisdom (Perception) check lets you spot, hear, or otherwise detect the presence of something. It measures your general awareness of your surroundings and the keenness of your senses. For example, you might try to hear a conversation through a closed door, eavesdrop under an open window, or hear monsters moving stealthily in the forest. Or you might try to spot things that are obscured or easy to miss, whether they are orcs lying in ambush on a road, thugs hiding in the shadows of an alley, or candlelight under a closed secret door.</p>\n<aside>\n<blockquote>\n<p id="finding-a-hidden-object"><strong>FINDING A HIDDEN OBJECT</strong></p>\n<p>When your character searches for a hidden object such as a secret door or a trap, the DM typically asks you to make a Wisdom (Perception) check. Such a check can be used to find hidden details or other information and clues that you might otherwise overlook.</p>\n<p>In most cases, you need to describe where you are looking in order for the DM to determine your chance of success. For example, a key is hidden beneath a set of folded clothes in the top drawer of a bureau. If you tell the DM that you pace around the room, looking at the walls and furniture for clues, you have no chance of finding the key, regardless of your Wisdom (Perception) check result. You would have to specify that you were opening the drawers or searching the bureau in order to have any chance of success.</p>\n</blockquote>\n</aside>\n<h5 id="Survival">Survival</h5>\n<p>The DM might ask you to make a Wisdom (Survival) check to follow tracks, hunt wild game, guide your group through frozen wastelands, identify signs that owlbears live nearby, predict the weather, or avoid quicksand and other natural hazards.</p>\n<h5 id="OtherWisdomChecks">Other Wisdom Checks</h5>\n<p>The DM might call for a Wisdom check when you try to accomplish tasks like the following:</p>\n<ul>\n<li>Get a gut feeling about what course of action to follow</li>\n<li>Discern whether a seemingly dead or living creature is undead</li>\n</ul>\n<h4 id="SpellcastingAbility">Spellcasting Ability</h4>\n<p>Clerics, druids, and rangers use Wisdom as their spellcasting ability, which helps determine the saving throw DCs of spells they cast.</p>',
    },
    {
      id: 6,
      entityTypeId: 1472902489,
      key: "CHA",
      name: "Charisma",
      compendiumText:
        '<p>Charisma measures your ability to interact effectively with others. It includes such factors as confidence and eloquence, and it can represent a charming or commanding personality.</p>\n<h4 id="CharismaChecks">Charisma Checks</h4>\n<p>A Charisma check might arise when you try to influence or entertain others, when you try to make an impression or tell a convincing lie, or when you are navigating a tricky social situation. The Deception, Intimidation, Performance, and Persuasion skills reflect aptitude in certain kinds of Charisma checks.</p>\n<h5 id="Deception">Deception</h5>\n<p>Your Charisma (Deception) check determines whether you can convincingly hide the truth, either verbally or through your actions. This deception can encompass everything from misleading others through ambiguity to telling outright lies. Typical situations include trying to fast-talk a guard, con a merchant, earn money through gambling, pass yourself off in a disguise, dull someone\'s suspicions with false assurances, or maintain a straight face while telling a blatant lie.</p>\n<h5 id="Intimidation">Intimidation</h5>\n<p>When you attempt to influence someone through overt threats, hostile actions, and physical violence, the DM might ask you to make a Charisma (Intimidation) check. Examples include trying to pry information out of a prisoner, convincing street thugs to back down from a confrontation, or using the edge of a broken bottle to convince a sneering vizier to reconsider a decision.</p>\n<h5 id="Performance">Performance</h5>\n<p>Your Charisma (Performance) check determines how well you can delight an audience with music, dance, acting, storytelling, or some other form of entertainment.</p>\n<h5 id="Persuasion">Persuasion</h5>\n<p>When you attempt to influence someone or a group of people with tact, social graces, or good nature, the DM might ask you to make a Charisma (Persuasion) check. Typically, you use persuasion when acting in good faith, to foster friendships, make cordial requests, or exhibit proper etiquette. Examples of persuading others include convincing a chamberlain to let your party see the king, negotiating peace between warring tribes, or inspiring a crowd of townsfolk.</p>\n<h5 id="OtherCharismaChecks">Other Charisma Checks</h5>\n<p>The DM might call for a Charisma check when you try to accomplish tasks like the following:</p>\n<ul>\n<li>Find the best person to talk to for news, rumors, and gossip</li>\n<li>Blend into a crowd to get the sense of key topics of conversation</li>\n</ul>\n<h4 id="SpellcastingAbility">Spellcasting Ability</h4>\n<p>Bards, paladins, sorcerers, and warlocks use Charisma as their spellcasting ability, which helps determine the saving throw DCs of spells they cast.</p>',
    },
  ],
  currencyData: [
    { id: 1, name: "PP", conversionFromGp: 10.0, weight: 0.02 },
    { id: 2, name: "GP", conversionFromGp: 1.0, weight: 0.02 },
    { id: 3, name: "EP", conversionFromGp: 0.5, weight: 0.02 },
    { id: 4, name: "SP", conversionFromGp: 0.1, weight: 0.02 },
    { id: 5, name: "CP", conversionFromGp: 0.01, weight: 0.02 },
  ],
  classConfigurations: [
    {
      id: 357975,
      name: "Blood Hunter",
      primaryAbilities: [],
      spellRules: {
        multiClassSpellSlotDivisor: 3,
        multiClassSpellSlotRounding: 1,
        isRitualSpellCaster: false,
        levelCantripsKnownMaxes: [0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
        levelSpellKnownMaxes: [0, 0, 0, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 11],
        levelSpellSlots: [
          [0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0],
          [1, 0, 0, 0, 0, 0, 0, 0, 0],
          [1, 0, 0, 0, 0, 0, 0, 0, 0],
          [1, 0, 0, 0, 0, 0, 0, 0, 0],
          [2, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 2, 0, 0, 0, 0, 0, 0, 0],
          [0, 2, 0, 0, 0, 0, 0, 0, 0],
          [0, 2, 0, 0, 0, 0, 0, 0, 0],
          [0, 2, 0, 0, 0, 0, 0, 0, 0],
          [0, 2, 0, 0, 0, 0, 0, 0, 0],
          [0, 2, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 2, 0, 0, 0, 0, 0, 0],
          [0, 0, 2, 0, 0, 0, 0, 0, 0],
          [0, 0, 2, 0, 0, 0, 0, 0, 0],
          [0, 0, 2, 0, 0, 0, 0, 0, 0],
          [0, 0, 2, 0, 0, 0, 0, 0, 0],
          [0, 0, 2, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 2, 0, 0, 0, 0, 0],
          [0, 0, 0, 2, 0, 0, 0, 0, 0],
        ],
      },
      prerequisites: [
        {
          description: "Intelligence 13",
          prerequisiteMappings: [
            {
              id: 146776,
              entityId: 4,
              entityTypeId: 1472902489,
              type: "ability-score",
              subType: "intelligence",
              value: 13,
              friendlyTypeName: "Ability Score",
              friendlySubTypeName: "Intelligence",
            },
          ],
        },
      ],
    },
    {
      id: 117,
      name: "Blood Hunter (archived)",
      primaryAbilities: [],
      spellRules: {
        multiClassSpellSlotDivisor: 3,
        multiClassSpellSlotRounding: 1,
        isRitualSpellCaster: false,
        levelCantripsKnownMaxes: [0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
        levelSpellKnownMaxes: [0, 0, 0, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 11],
        levelSpellSlots: [
          [0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0],
          [1, 0, 0, 0, 0, 0, 0, 0, 0],
          [1, 0, 0, 0, 0, 0, 0, 0, 0],
          [2, 0, 0, 0, 0, 0, 0, 0, 0],
          [2, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 2, 0, 0, 0, 0, 0, 0, 0],
          [0, 2, 0, 0, 0, 0, 0, 0, 0],
          [0, 2, 0, 0, 0, 0, 0, 0, 0],
          [0, 2, 0, 0, 0, 0, 0, 0, 0],
          [0, 2, 0, 0, 0, 0, 0, 0, 0],
          [0, 2, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 2, 0, 0, 0, 0, 0, 0],
          [0, 0, 2, 0, 0, 0, 0, 0, 0],
          [0, 0, 2, 0, 0, 0, 0, 0, 0],
          [0, 0, 2, 0, 0, 0, 0, 0, 0],
          [0, 0, 2, 0, 0, 0, 0, 0, 0],
          [0, 0, 2, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 2, 0, 0, 0, 0, 0],
          [0, 0, 0, 2, 0, 0, 0, 0, 0],
        ],
      },
      prerequisites: [],
    },
    {
      id: 1,
      name: "Bard",
      primaryAbilities: [6],
      spellRules: {
        multiClassSpellSlotDivisor: 1,
        multiClassSpellSlotRounding: 1,
        isRitualSpellCaster: true,
        levelCantripsKnownMaxes: [0, 2, 2, 2, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
        levelSpellKnownMaxes: [0, 4, 5, 6, 7, 8, 9, 10, 11, 12, 14, 15, 15, 16, 18, 19, 19, 20, 22, 22, 22],
        levelSpellSlots: [
          [0, 0, 0, 0, 0, 0, 0, 0, 0],
          [2, 0, 0, 0, 0, 0, 0, 0, 0],
          [3, 0, 0, 0, 0, 0, 0, 0, 0],
          [4, 2, 0, 0, 0, 0, 0, 0, 0],
          [4, 3, 0, 0, 0, 0, 0, 0, 0],
          [4, 3, 2, 0, 0, 0, 0, 0, 0],
          [4, 3, 3, 0, 0, 0, 0, 0, 0],
          [4, 3, 3, 1, 0, 0, 0, 0, 0],
          [4, 3, 3, 2, 0, 0, 0, 0, 0],
          [4, 3, 3, 3, 1, 0, 0, 0, 0],
          [4, 3, 3, 3, 2, 0, 0, 0, 0],
          [4, 3, 3, 3, 2, 1, 0, 0, 0],
          [4, 3, 3, 3, 2, 1, 0, 0, 0],
          [4, 3, 3, 3, 2, 1, 1, 0, 0],
          [4, 3, 3, 3, 2, 1, 1, 0, 0],
          [4, 3, 3, 3, 2, 1, 1, 1, 0],
          [4, 3, 3, 3, 2, 1, 1, 1, 0],
          [4, 3, 3, 3, 2, 1, 1, 1, 1],
          [4, 3, 3, 3, 3, 1, 1, 1, 1],
          [4, 3, 3, 3, 3, 2, 1, 1, 1],
          [4, 3, 3, 3, 3, 2, 2, 1, 1],
        ],
      },
      prerequisites: [
        {
          description: "Charisma 13",
          prerequisiteMappings: [
            {
              id: 10356,
              entityId: 6,
              entityTypeId: 1472902489,
              type: "ability-score",
              subType: "charisma",
              value: 13,
              friendlyTypeName: "Ability Score",
              friendlySubTypeName: "Charisma",
            },
          ],
        },
      ],
    },
    {
      id: 2,
      name: "Cleric",
      primaryAbilities: [5],
      spellRules: {
        multiClassSpellSlotDivisor: 1,
        multiClassSpellSlotRounding: 1,
        isRitualSpellCaster: true,
        levelCantripsKnownMaxes: [0, 3, 3, 3, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5],
        levelSpellKnownMaxes: null,
        levelSpellSlots: [
          [0, 0, 0, 0, 0, 0, 0, 0, 0],
          [2, 0, 0, 0, 0, 0, 0, 0, 0],
          [3, 0, 0, 0, 0, 0, 0, 0, 0],
          [4, 2, 0, 0, 0, 0, 0, 0, 0],
          [4, 3, 0, 0, 0, 0, 0, 0, 0],
          [4, 3, 2, 0, 0, 0, 0, 0, 0],
          [4, 3, 3, 0, 0, 0, 0, 0, 0],
          [4, 3, 3, 1, 0, 0, 0, 0, 0],
          [4, 3, 3, 2, 0, 0, 0, 0, 0],
          [4, 3, 3, 3, 1, 0, 0, 0, 0],
          [4, 3, 3, 3, 2, 0, 0, 0, 0],
          [4, 3, 3, 3, 2, 1, 0, 0, 0],
          [4, 3, 3, 3, 2, 1, 0, 0, 0],
          [4, 3, 3, 3, 2, 1, 1, 0, 0],
          [4, 3, 3, 3, 2, 1, 1, 0, 0],
          [4, 3, 3, 3, 2, 1, 1, 1, 0],
          [4, 3, 3, 3, 2, 1, 1, 1, 0],
          [4, 3, 3, 3, 2, 1, 1, 1, 1],
          [4, 3, 3, 3, 3, 1, 1, 1, 1],
          [4, 3, 3, 3, 3, 2, 1, 1, 1],
          [4, 3, 3, 3, 3, 2, 2, 1, 1],
        ],
      },
      prerequisites: [
        {
          description: "Wisdom 13",
          prerequisiteMappings: [
            {
              id: 10357,
              entityId: 5,
              entityTypeId: 1472902489,
              type: "ability-score",
              subType: "wisdom",
              value: 13,
              friendlyTypeName: "Ability Score",
              friendlySubTypeName: "Wisdom",
            },
          ],
        },
      ],
    },
    {
      id: 3,
      name: "Druid",
      primaryAbilities: [5],
      spellRules: {
        multiClassSpellSlotDivisor: 1,
        multiClassSpellSlotRounding: 1,
        isRitualSpellCaster: true,
        levelCantripsKnownMaxes: [0, 2, 2, 2, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
        levelSpellKnownMaxes: null,
        levelSpellSlots: [
          [0, 0, 0, 0, 0, 0, 0, 0, 0],
          [2, 0, 0, 0, 0, 0, 0, 0, 0],
          [3, 0, 0, 0, 0, 0, 0, 0, 0],
          [4, 2, 0, 0, 0, 0, 0, 0, 0],
          [4, 3, 0, 0, 0, 0, 0, 0, 0],
          [4, 3, 2, 0, 0, 0, 0, 0, 0],
          [4, 3, 3, 0, 0, 0, 0, 0, 0],
          [4, 3, 3, 1, 0, 0, 0, 0, 0],
          [4, 3, 3, 2, 0, 0, 0, 0, 0],
          [4, 3, 3, 3, 1, 0, 0, 0, 0],
          [4, 3, 3, 3, 2, 0, 0, 0, 0],
          [4, 3, 3, 3, 2, 1, 0, 0, 0],
          [4, 3, 3, 3, 2, 1, 0, 0, 0],
          [4, 3, 3, 3, 2, 1, 1, 0, 0],
          [4, 3, 3, 3, 2, 1, 1, 0, 0],
          [4, 3, 3, 3, 2, 1, 1, 1, 0],
          [4, 3, 3, 3, 2, 1, 1, 1, 0],
          [4, 3, 3, 3, 2, 1, 1, 1, 1],
          [4, 3, 3, 3, 3, 1, 1, 1, 1],
          [4, 3, 3, 3, 3, 2, 1, 1, 1],
          [4, 3, 3, 3, 3, 2, 2, 1, 1],
        ],
      },
      prerequisites: [
        {
          description: "Wisdom 13",
          prerequisiteMappings: [
            {
              id: 10358,
              entityId: 5,
              entityTypeId: 1472902489,
              type: "ability-score",
              subType: "wisdom",
              value: 13,
              friendlyTypeName: "Ability Score",
              friendlySubTypeName: "Wisdom",
            },
          ],
        },
      ],
    },
    {
      id: 4,
      name: "Paladin",
      primaryAbilities: [6],
      spellRules: {
        multiClassSpellSlotDivisor: 2,
        multiClassSpellSlotRounding: 1,
        isRitualSpellCaster: false,
        levelCantripsKnownMaxes: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        levelSpellKnownMaxes: null,
        levelSpellSlots: [
          [0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0],
          [2, 0, 0, 0, 0, 0, 0, 0, 0],
          [3, 0, 0, 0, 0, 0, 0, 0, 0],
          [3, 0, 0, 0, 0, 0, 0, 0, 0],
          [4, 2, 0, 0, 0, 0, 0, 0, 0],
          [4, 2, 0, 0, 0, 0, 0, 0, 0],
          [4, 3, 0, 0, 0, 0, 0, 0, 0],
          [4, 3, 0, 0, 0, 0, 0, 0, 0],
          [4, 3, 2, 0, 0, 0, 0, 0, 0],
          [4, 3, 2, 0, 0, 0, 0, 0, 0],
          [4, 3, 3, 0, 0, 0, 0, 0, 0],
          [4, 3, 3, 0, 0, 0, 0, 0, 0],
          [4, 3, 3, 1, 0, 0, 0, 0, 0],
          [4, 3, 3, 1, 0, 0, 0, 0, 0],
          [4, 3, 3, 2, 0, 0, 0, 0, 0],
          [4, 3, 3, 2, 0, 0, 0, 0, 0],
          [4, 3, 3, 3, 1, 0, 0, 0, 0],
          [4, 3, 3, 3, 1, 0, 0, 0, 0],
          [4, 3, 3, 3, 2, 0, 0, 0, 0],
          [4, 3, 3, 3, 2, 0, 0, 0, 0],
        ],
      },
      prerequisites: [
        {
          description: "Strength 13 and Charisma 13",
          prerequisiteMappings: [
            {
              id: 10359,
              entityId: 1,
              entityTypeId: 1472902489,
              type: "ability-score",
              subType: "strength",
              value: 13,
              friendlyTypeName: "Ability Score",
              friendlySubTypeName: "Strength",
            },
            {
              id: 10360,
              entityId: 6,
              entityTypeId: 1472902489,
              type: "ability-score",
              subType: "charisma",
              value: 13,
              friendlyTypeName: "Ability Score",
              friendlySubTypeName: "Charisma",
            },
          ],
        },
      ],
    },
    {
      id: 5,
      name: "Ranger",
      primaryAbilities: [5],
      spellRules: {
        multiClassSpellSlotDivisor: 2,
        multiClassSpellSlotRounding: 1,
        isRitualSpellCaster: false,
        levelCantripsKnownMaxes: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        levelSpellKnownMaxes: [0, 0, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11],
        levelSpellSlots: [
          [0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0],
          [2, 0, 0, 0, 0, 0, 0, 0, 0],
          [3, 0, 0, 0, 0, 0, 0, 0, 0],
          [3, 0, 0, 0, 0, 0, 0, 0, 0],
          [4, 2, 0, 0, 0, 0, 0, 0, 0],
          [4, 2, 0, 0, 0, 0, 0, 0, 0],
          [4, 3, 0, 0, 0, 0, 0, 0, 0],
          [4, 3, 0, 0, 0, 0, 0, 0, 0],
          [4, 3, 2, 0, 0, 0, 0, 0, 0],
          [4, 3, 2, 0, 0, 0, 0, 0, 0],
          [4, 3, 3, 0, 0, 0, 0, 0, 0],
          [4, 3, 3, 0, 0, 0, 0, 0, 0],
          [4, 3, 3, 1, 0, 0, 0, 0, 0],
          [4, 3, 3, 1, 0, 0, 0, 0, 0],
          [4, 3, 3, 2, 0, 0, 0, 0, 0],
          [4, 3, 3, 2, 0, 0, 0, 0, 0],
          [4, 3, 3, 3, 1, 0, 0, 0, 0],
          [4, 3, 3, 3, 1, 0, 0, 0, 0],
          [4, 3, 3, 3, 2, 0, 0, 0, 0],
          [4, 3, 3, 3, 2, 0, 0, 0, 0],
        ],
      },
      prerequisites: [
        {
          description: "Dexterity 13 and Wisdom 13",
          prerequisiteMappings: [
            {
              id: 10361,
              entityId: 2,
              entityTypeId: 1472902489,
              type: "ability-score",
              subType: "dexterity",
              value: 13,
              friendlyTypeName: "Ability Score",
              friendlySubTypeName: "Dexterity",
            },
            {
              id: 10362,
              entityId: 5,
              entityTypeId: 1472902489,
              type: "ability-score",
              subType: "wisdom",
              value: 13,
              friendlyTypeName: "Ability Score",
              friendlySubTypeName: "Wisdom",
            },
          ],
        },
      ],
    },
    {
      id: 6,
      name: "Sorcerer",
      primaryAbilities: [6],
      spellRules: {
        multiClassSpellSlotDivisor: 1,
        multiClassSpellSlotRounding: 1,
        isRitualSpellCaster: false,
        levelCantripsKnownMaxes: [0, 4, 4, 4, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6],
        levelSpellKnownMaxes: [0, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 12, 13, 13, 14, 14, 15, 15, 15, 15],
        levelSpellSlots: [
          [0, 0, 0, 0, 0, 0, 0, 0, 0],
          [2, 0, 0, 0, 0, 0, 0, 0, 0],
          [3, 0, 0, 0, 0, 0, 0, 0, 0],
          [4, 2, 0, 0, 0, 0, 0, 0, 0],
          [4, 3, 0, 0, 0, 0, 0, 0, 0],
          [4, 3, 2, 0, 0, 0, 0, 0, 0],
          [4, 3, 3, 0, 0, 0, 0, 0, 0],
          [4, 3, 3, 1, 0, 0, 0, 0, 0],
          [4, 3, 3, 2, 0, 0, 0, 0, 0],
          [4, 3, 3, 3, 1, 0, 0, 0, 0],
          [4, 3, 3, 3, 2, 0, 0, 0, 0],
          [4, 3, 3, 3, 2, 1, 0, 0, 0],
          [4, 3, 3, 3, 2, 1, 0, 0, 0],
          [4, 3, 3, 3, 2, 1, 1, 0, 0],
          [4, 3, 3, 3, 2, 1, 1, 0, 0],
          [4, 3, 3, 3, 2, 1, 1, 1, 0],
          [4, 3, 3, 3, 2, 1, 1, 1, 0],
          [4, 3, 3, 3, 2, 1, 1, 1, 1],
          [4, 3, 3, 3, 3, 1, 1, 1, 1],
          [4, 3, 3, 3, 3, 2, 1, 1, 1],
          [4, 3, 3, 3, 3, 2, 2, 1, 1],
        ],
      },
      prerequisites: [
        {
          description: "Charisma 13",
          prerequisiteMappings: [
            {
              id: 10363,
              entityId: 6,
              entityTypeId: 1472902489,
              type: "ability-score",
              subType: "charisma",
              value: 13,
              friendlyTypeName: "Ability Score",
              friendlySubTypeName: "Charisma",
            },
          ],
        },
      ],
    },
    {
      id: 7,
      name: "Warlock",
      primaryAbilities: [6],
      spellRules: {
        multiClassSpellSlotDivisor: 1,
        multiClassSpellSlotRounding: 1,
        isRitualSpellCaster: false,
        levelCantripsKnownMaxes: [0, 2, 2, 2, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
        levelSpellKnownMaxes: [0, 2, 3, 4, 5, 6, 7, 8, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15],
        levelSpellSlots: [
          [0, 0, 0, 0, 0, 0, 0, 0, 0],
          [1, 0, 0, 0, 0, 0, 0, 0, 0],
          [2, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 2, 0, 0, 0, 0, 0, 0, 0],
          [0, 2, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 2, 0, 0, 0, 0, 0, 0],
          [0, 0, 2, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 2, 0, 0, 0, 0, 0],
          [0, 0, 0, 2, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 2, 0, 0, 0, 0],
          [0, 0, 0, 0, 2, 0, 0, 0, 0],
          [0, 0, 0, 0, 3, 0, 0, 0, 0],
          [0, 0, 0, 0, 3, 0, 0, 0, 0],
          [0, 0, 0, 0, 3, 0, 0, 0, 0],
          [0, 0, 0, 0, 3, 0, 0, 0, 0],
          [0, 0, 0, 0, 3, 0, 0, 0, 0],
          [0, 0, 0, 0, 3, 0, 0, 0, 0],
          [0, 0, 0, 0, 4, 0, 0, 0, 0],
          [0, 0, 0, 0, 4, 0, 0, 0, 0],
          [0, 0, 0, 0, 4, 0, 0, 0, 0],
          [0, 0, 0, 0, 4, 0, 0, 0, 0],
        ],
      },
      prerequisites: [
        {
          description: "Charisma 13",
          prerequisiteMappings: [
            {
              id: 10364,
              entityId: 6,
              entityTypeId: 1472902489,
              type: "ability-score",
              subType: "charisma",
              value: 13,
              friendlyTypeName: "Ability Score",
              friendlySubTypeName: "Charisma",
            },
          ],
        },
      ],
    },
    {
      id: 8,
      name: "Wizard",
      primaryAbilities: [4],
      spellRules: {
        multiClassSpellSlotDivisor: 1,
        multiClassSpellSlotRounding: 1,
        isRitualSpellCaster: true,
        levelCantripsKnownMaxes: [0, 3, 3, 3, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5],
        levelSpellKnownMaxes: null,
        levelSpellSlots: [
          [0, 0, 0, 0, 0, 0, 0, 0, 0],
          [2, 0, 0, 0, 0, 0, 0, 0, 0],
          [3, 0, 0, 0, 0, 0, 0, 0, 0],
          [4, 2, 0, 0, 0, 0, 0, 0, 0],
          [4, 3, 0, 0, 0, 0, 0, 0, 0],
          [4, 3, 2, 0, 0, 0, 0, 0, 0],
          [4, 3, 3, 0, 0, 0, 0, 0, 0],
          [4, 3, 3, 1, 0, 0, 0, 0, 0],
          [4, 3, 3, 2, 0, 0, 0, 0, 0],
          [4, 3, 3, 3, 1, 0, 0, 0, 0],
          [4, 3, 3, 3, 2, 0, 0, 0, 0],
          [4, 3, 3, 3, 2, 1, 0, 0, 0],
          [4, 3, 3, 3, 2, 1, 0, 0, 0],
          [4, 3, 3, 3, 2, 1, 1, 0, 0],
          [4, 3, 3, 3, 2, 1, 1, 0, 0],
          [4, 3, 3, 3, 2, 1, 1, 1, 0],
          [4, 3, 3, 3, 2, 1, 1, 1, 0],
          [4, 3, 3, 3, 2, 1, 1, 1, 1],
          [4, 3, 3, 3, 3, 1, 1, 1, 1],
          [4, 3, 3, 3, 3, 2, 1, 1, 1],
          [4, 3, 3, 3, 3, 2, 2, 1, 1],
        ],
      },
      prerequisites: [
        {
          description: "Intelligence 13",
          prerequisiteMappings: [
            {
              id: 10365,
              entityId: 4,
              entityTypeId: 1472902489,
              type: "ability-score",
              subType: "intelligence",
              value: 13,
              friendlyTypeName: "Ability Score",
              friendlySubTypeName: "Intelligence",
            },
          ],
        },
      ],
    },
    {
      id: 9,
      name: "Barbarian",
      primaryAbilities: [1],
      spellRules: {
        multiClassSpellSlotDivisor: 3,
        multiClassSpellSlotRounding: 1,
        isRitualSpellCaster: false,
        levelCantripsKnownMaxes: [0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
        levelSpellKnownMaxes: [0, 0, 0, 3, 4, 4, 4, 5, 6, 6, 7, 8, 8, 9, 10, 10, 11, 11, 11, 12, 13],
        levelSpellSlots: [
          [0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0],
          [2, 0, 0, 0, 0, 0, 0, 0, 0],
          [3, 0, 0, 0, 0, 0, 0, 0, 0],
          [3, 0, 0, 0, 0, 0, 0, 0, 0],
          [3, 0, 0, 0, 0, 0, 0, 0, 0],
          [4, 2, 0, 0, 0, 0, 0, 0, 0],
          [4, 2, 0, 0, 0, 0, 0, 0, 0],
          [4, 2, 0, 0, 0, 0, 0, 0, 0],
          [4, 3, 0, 0, 0, 0, 0, 0, 0],
          [4, 3, 0, 0, 0, 0, 0, 0, 0],
          [4, 3, 0, 0, 0, 0, 0, 0, 0],
          [4, 3, 2, 0, 0, 0, 0, 0, 0],
          [4, 3, 2, 0, 0, 0, 0, 0, 0],
          [4, 3, 2, 0, 0, 0, 0, 0, 0],
          [4, 3, 3, 0, 0, 0, 0, 0, 0],
          [4, 3, 3, 0, 0, 0, 0, 0, 0],
          [4, 3, 3, 0, 0, 0, 0, 0, 0],
          [4, 3, 3, 1, 0, 0, 0, 0, 0],
          [4, 3, 3, 1, 0, 0, 0, 0, 0],
        ],
      },
      prerequisites: [
        {
          description: "Strength 13",
          prerequisiteMappings: [
            {
              id: 10366,
              entityId: 1,
              entityTypeId: 1472902489,
              type: "ability-score",
              subType: "strength",
              value: 13,
              friendlyTypeName: "Ability Score",
              friendlySubTypeName: "Strength",
            },
          ],
        },
      ],
    },
    {
      id: 10,
      name: "Fighter",
      primaryAbilities: [1, 2],
      spellRules: {
        multiClassSpellSlotDivisor: 3,
        multiClassSpellSlotRounding: 1,
        isRitualSpellCaster: false,
        levelCantripsKnownMaxes: [0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
        levelSpellKnownMaxes: [0, 0, 0, 3, 4, 4, 4, 5, 6, 6, 7, 8, 8, 9, 10, 10, 11, 11, 11, 12, 13],
        levelSpellSlots: [
          [0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0],
          [2, 0, 0, 0, 0, 0, 0, 0, 0],
          [3, 0, 0, 0, 0, 0, 0, 0, 0],
          [3, 0, 0, 0, 0, 0, 0, 0, 0],
          [3, 0, 0, 0, 0, 0, 0, 0, 0],
          [4, 2, 0, 0, 0, 0, 0, 0, 0],
          [4, 2, 0, 0, 0, 0, 0, 0, 0],
          [4, 2, 0, 0, 0, 0, 0, 0, 0],
          [4, 3, 0, 0, 0, 0, 0, 0, 0],
          [4, 3, 0, 0, 0, 0, 0, 0, 0],
          [4, 3, 0, 0, 0, 0, 0, 0, 0],
          [4, 3, 2, 0, 0, 0, 0, 0, 0],
          [4, 3, 2, 0, 0, 0, 0, 0, 0],
          [4, 3, 2, 0, 0, 0, 0, 0, 0],
          [4, 3, 3, 0, 0, 0, 0, 0, 0],
          [4, 3, 3, 0, 0, 0, 0, 0, 0],
          [4, 3, 3, 0, 0, 0, 0, 0, 0],
          [4, 3, 3, 1, 0, 0, 0, 0, 0],
          [4, 3, 3, 1, 0, 0, 0, 0, 0],
        ],
      },
      prerequisites: [
        {
          description: "Strength 13",
          prerequisiteMappings: [
            {
              id: 10367,
              entityId: 1,
              entityTypeId: 1472902489,
              type: "ability-score",
              subType: "strength",
              value: 13,
              friendlyTypeName: "Ability Score",
              friendlySubTypeName: "Strength",
            },
          ],
        },
        {
          description: "or Dexterity 13",
          prerequisiteMappings: [
            {
              id: 10368,
              entityId: 2,
              entityTypeId: 1472902489,
              type: "ability-score",
              subType: "dexterity",
              value: 13,
              friendlyTypeName: "Ability Score",
              friendlySubTypeName: "Dexterity",
            },
          ],
        },
      ],
    },
    {
      id: 11,
      name: "Monk",
      primaryAbilities: [5],
      spellRules: {
        multiClassSpellSlotDivisor: 3,
        multiClassSpellSlotRounding: 1,
        isRitualSpellCaster: false,
        levelCantripsKnownMaxes: [0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
        levelSpellKnownMaxes: [0, 0, 0, 3, 4, 4, 4, 5, 6, 6, 7, 8, 8, 9, 10, 10, 11, 11, 11, 12, 13],
        levelSpellSlots: [
          [0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0],
          [2, 0, 0, 0, 0, 0, 0, 0, 0],
          [3, 0, 0, 0, 0, 0, 0, 0, 0],
          [3, 0, 0, 0, 0, 0, 0, 0, 0],
          [3, 0, 0, 0, 0, 0, 0, 0, 0],
          [4, 2, 0, 0, 0, 0, 0, 0, 0],
          [4, 2, 0, 0, 0, 0, 0, 0, 0],
          [4, 2, 0, 0, 0, 0, 0, 0, 0],
          [4, 3, 0, 0, 0, 0, 0, 0, 0],
          [4, 3, 0, 0, 0, 0, 0, 0, 0],
          [4, 3, 0, 0, 0, 0, 0, 0, 0],
          [4, 3, 2, 0, 0, 0, 0, 0, 0],
          [4, 3, 2, 0, 0, 0, 0, 0, 0],
          [4, 3, 2, 0, 0, 0, 0, 0, 0],
          [4, 3, 3, 0, 0, 0, 0, 0, 0],
          [4, 3, 3, 0, 0, 0, 0, 0, 0],
          [4, 3, 3, 0, 0, 0, 0, 0, 0],
          [4, 3, 3, 1, 0, 0, 0, 0, 0],
          [4, 3, 3, 1, 0, 0, 0, 0, 0],
        ],
      },
      prerequisites: [
        {
          description: "Dexterity 13 and Wisdom 13",
          prerequisiteMappings: [
            {
              id: 10369,
              entityId: 2,
              entityTypeId: 1472902489,
              type: "ability-score",
              subType: "dexterity",
              value: 13,
              friendlyTypeName: "Ability Score",
              friendlySubTypeName: "Dexterity",
            },
            {
              id: 10370,
              entityId: 5,
              entityTypeId: 1472902489,
              type: "ability-score",
              subType: "wisdom",
              value: 13,
              friendlyTypeName: "Ability Score",
              friendlySubTypeName: "Wisdom",
            },
          ],
        },
      ],
    },
    {
      id: 12,
      name: "Rogue",
      primaryAbilities: [2],
      spellRules: {
        multiClassSpellSlotDivisor: 3,
        multiClassSpellSlotRounding: 1,
        isRitualSpellCaster: false,
        levelCantripsKnownMaxes: [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
        levelSpellKnownMaxes: [0, 0, 0, 3, 4, 4, 4, 5, 6, 6, 7, 8, 8, 9, 10, 10, 11, 11, 11, 12, 13],
        levelSpellSlots: [
          [0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0],
          [2, 0, 0, 0, 0, 0, 0, 0, 0],
          [3, 0, 0, 0, 0, 0, 0, 0, 0],
          [3, 0, 0, 0, 0, 0, 0, 0, 0],
          [3, 0, 0, 0, 0, 0, 0, 0, 0],
          [4, 2, 0, 0, 0, 0, 0, 0, 0],
          [4, 2, 0, 0, 0, 0, 0, 0, 0],
          [4, 2, 0, 0, 0, 0, 0, 0, 0],
          [4, 3, 0, 0, 0, 0, 0, 0, 0],
          [4, 3, 0, 0, 0, 0, 0, 0, 0],
          [4, 3, 0, 0, 0, 0, 0, 0, 0],
          [4, 3, 2, 0, 0, 0, 0, 0, 0],
          [4, 3, 2, 0, 0, 0, 0, 0, 0],
          [4, 3, 2, 0, 0, 0, 0, 0, 0],
          [4, 3, 3, 0, 0, 0, 0, 0, 0],
          [4, 3, 3, 0, 0, 0, 0, 0, 0],
          [4, 3, 3, 0, 0, 0, 0, 0, 0],
          [4, 3, 3, 1, 0, 0, 0, 0, 0],
          [4, 3, 3, 1, 0, 0, 0, 0, 0],
        ],
      },
      prerequisites: [
        {
          description: "Dexterity 13",
          prerequisiteMappings: [
            {
              id: 10371,
              entityId: 2,
              entityTypeId: 1472902489,
              type: "ability-score",
              subType: "dexterity",
              value: 13,
              friendlyTypeName: "Ability Score",
              friendlySubTypeName: "Dexterity",
            },
          ],
        },
      ],
    },
    {
      id: 124727,
      name: "Artificer (UA)",
      primaryAbilities: [4],
      spellRules: {
        multiClassSpellSlotDivisor: 2,
        multiClassSpellSlotRounding: 2,
        isRitualSpellCaster: true,
        levelCantripsKnownMaxes: [0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4],
        levelSpellKnownMaxes: null,
        levelSpellSlots: [
          [0, 0, 0, 0, 0, 0, 0, 0, 0],
          [2, 0, 0, 0, 0, 0, 0, 0, 0],
          [2, 0, 0, 0, 0, 0, 0, 0, 0],
          [3, 0, 0, 0, 0, 0, 0, 0, 0],
          [3, 0, 0, 0, 0, 0, 0, 0, 0],
          [4, 2, 0, 0, 0, 0, 0, 0, 0],
          [4, 2, 0, 0, 0, 0, 0, 0, 0],
          [4, 3, 0, 0, 0, 0, 0, 0, 0],
          [4, 3, 0, 0, 0, 0, 0, 0, 0],
          [4, 3, 2, 0, 0, 0, 0, 0, 0],
          [4, 3, 2, 0, 0, 0, 0, 0, 0],
          [4, 3, 3, 0, 0, 0, 0, 0, 0],
          [4, 3, 3, 0, 0, 0, 0, 0, 0],
          [4, 3, 3, 1, 0, 0, 0, 0, 0],
          [4, 3, 3, 1, 0, 0, 0, 0, 0],
          [4, 3, 3, 2, 0, 0, 0, 0, 0],
          [4, 3, 3, 2, 0, 0, 0, 0, 0],
          [4, 3, 3, 3, 1, 0, 0, 0, 0],
          [4, 3, 3, 3, 1, 0, 0, 0, 0],
          [4, 3, 3, 3, 2, 0, 0, 0, 0],
          [4, 3, 3, 3, 2, 0, 0, 0, 0],
        ],
      },
      prerequisites: [
        {
          description: "Intelligence 13",
          prerequisiteMappings: [
            {
              id: 32395,
              entityId: 4,
              entityTypeId: 1472902489,
              type: "ability-score",
              subType: "intelligence",
              value: 13,
              friendlyTypeName: "Ability Score",
              friendlySubTypeName: "Intelligence",
            },
          ],
        },
      ],
    },
    {
      id: 252717,
      name: "Artificer",
      primaryAbilities: [4],
      spellRules: {
        multiClassSpellSlotDivisor: 2,
        multiClassSpellSlotRounding: 2,
        isRitualSpellCaster: true,
        levelCantripsKnownMaxes: [0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4],
        levelSpellKnownMaxes: null,
        levelSpellSlots: [
          [0, 0, 0, 0, 0, 0, 0, 0, 0],
          [2, 0, 0, 0, 0, 0, 0, 0, 0],
          [2, 0, 0, 0, 0, 0, 0, 0, 0],
          [3, 0, 0, 0, 0, 0, 0, 0, 0],
          [3, 0, 0, 0, 0, 0, 0, 0, 0],
          [4, 2, 0, 0, 0, 0, 0, 0, 0],
          [4, 2, 0, 0, 0, 0, 0, 0, 0],
          [4, 3, 0, 0, 0, 0, 0, 0, 0],
          [4, 3, 0, 0, 0, 0, 0, 0, 0],
          [4, 3, 2, 0, 0, 0, 0, 0, 0],
          [4, 3, 2, 0, 0, 0, 0, 0, 0],
          [4, 3, 3, 0, 0, 0, 0, 0, 0],
          [4, 3, 3, 0, 0, 0, 0, 0, 0],
          [4, 3, 3, 1, 0, 0, 0, 0, 0],
          [4, 3, 3, 1, 0, 0, 0, 0, 0],
          [4, 3, 3, 2, 0, 0, 0, 0, 0],
          [4, 3, 3, 2, 0, 0, 0, 0, 0],
          [4, 3, 3, 3, 1, 0, 0, 0, 0],
          [4, 3, 3, 3, 1, 0, 0, 0, 0],
          [4, 3, 3, 3, 2, 0, 0, 0, 0],
          [4, 3, 3, 3, 2, 0, 0, 0, 0],
        ],
      },
      prerequisites: [
        {
          description: "Intelligence 13",
          prerequisiteMappings: [
            {
              id: 74766,
              entityId: 4,
              entityTypeId: 1472902489,
              type: "ability-score",
              subType: "intelligence",
              value: 13,
              friendlyTypeName: "Ability Score",
              friendlySubTypeName: "Intelligence",
            },
          ],
        },
      ],
    },
  ],
  abilitySkills: [
    {
      id: 2,
      entityTypeId: 1958004211,
      stat: 1,
      name: "Athletics",
      description:
        "<p>Your Strength (Athletics) check covers difficult situations you encounter while climbing, jumping, or swimming. Examples include the following activities:</p>\n<ul>\n<li>You attempt to climb a sheer or slippery cliff, avoid hazards while scaling a wall, or cling to a surface while something is trying to knock you off.</li>\n<li>You try to jump an unusually long distance or pull off a stunt midjump.</li>\n<li>You struggle to swim or stay afloat in treacherous currents, storm-tossed waves, or areas of thick seaweed. Or another creature tries to push or pull you underwater or otherwise interfere with your swimming.</li>\n</ul>",
    },
    {
      id: 3,
      entityTypeId: 1958004211,
      stat: 2,
      name: "Acrobatics",
      description:
        "<p>Your Dexterity (Acrobatics) check covers your attempt to stay on your feet in a tricky situation, such as when you're trying to run across a sheet of ice, balance on a tightrope, or stay upright on a rocking ship's deck. The GM might also call for a Dexterity (Acrobatics) check to see if you can perform acrobatic stunts, including dives, rolls, somersaults, and flips.</p>",
    },
    {
      id: 4,
      entityTypeId: 1958004211,
      stat: 2,
      name: "Sleight of Hand",
      description:
        "<p>Whenever you attempt an act of legerdemain or manual trickery, such as planting something on someone else or concealing an object on your person, make a Dexterity (Sleight of Hand) check. The GM might also call for a Dexterity (Sleight of Hand) check to determine whether you can lift a coin purse off another person or slip something out of another person's pocket.</p>\n",
    },
    {
      id: 5,
      entityTypeId: 1958004211,
      stat: 2,
      name: "Stealth",
      description:
        "<p>Make a Dexterity (Stealth) check when you attempt to conceal yourself from enemies, slink past guards, slip away without being noticed, or sneak up on someone without being seen or heard.</p>",
    },
    {
      id: 6,
      entityTypeId: 1958004211,
      stat: 4,
      name: "Arcana",
      description:
        "<p>Your Intelligence (Arcana) check measures your ability to recall lore about spells, magic items, eldritch symbols, magical traditions, the planes of existence, and the inhabitants of those planes.</p>",
    },
    {
      id: 7,
      entityTypeId: 1958004211,
      stat: 4,
      name: "History",
      description:
        "<p>Your Intelligence (History) check measures your ability to recall lore about historical events, legendary people, ancient kingdoms, past disputes, recent wars, and lost civilizations.</p>",
    },
    {
      id: 8,
      entityTypeId: 1958004211,
      stat: 4,
      name: "Investigation",
      description:
        "<p>When you look around for clues and make deductions based on those clues, you make an Intelligence (Investigation) check. You might deduce the location of a hidden object, discern from the appearance of a wound what kind of weapon dealt it, or determine the weakest point in a tunnel that could cause it to collapse. Poring through ancient scrolls in search of a hidden fragment of knowledge might also call for an Intelligence (Investigation) check.</p>\n",
    },
    {
      id: 9,
      entityTypeId: 1958004211,
      stat: 4,
      name: "Nature",
      description:
        "<p>Your Intelligence (Nature) check measures your ability to recall lore about terrain, plants and animals, the weather, and natural cycles.</p>",
    },
    {
      id: 10,
      entityTypeId: 1958004211,
      stat: 4,
      name: "Religion",
      description:
        "<p>Your Intelligence (Religion) check measures your ability to recall lore about deities, rites and prayers, religious hierarchies, holy symbols, and the practices of secret cults.</p>",
    },
    {
      id: 11,
      entityTypeId: 1958004211,
      stat: 5,
      name: "Animal Handling",
      description:
        "<p>When there is any question whether you can calm down a domesticated animal, keep a mount from getting spooked, or intuit an animalâ€™s intentions, the GM might call for a Wisdom (Animal Handling) check. You also make a Wisdom (Animal Handling) check to control your mount when you attempt a risky maneuver.</p>",
    },
    {
      id: 12,
      entityTypeId: 1958004211,
      stat: 5,
      name: "Insight",
      description:
        "<p>Your Wisdom (Insight) check decides whether you can determine the true intentions of a creature, such as when searching out a lie or predicting someoneâ€™s next move. Doing so involves gleaning clues from body language, speech habits, and changes in mannerisms.</p>\n",
    },
    {
      id: 13,
      entityTypeId: 1958004211,
      stat: 5,
      name: "Medicine",
      description:
        "<p>A Wisdom (Medicine) check lets you try to stabilize a dying companion or diagnose an illness.</p>",
    },
    {
      id: 14,
      entityTypeId: 1958004211,
      stat: 5,
      name: "Perception",
      description:
        "<p>Your Wisdom (Perception) check lets you spot, hear, or otherwise detect the presence of something. It measures your general awareness of your surroundings and the keenness of your senses. For example, you might try to hear a conversation through a closed door, eavesdrop under an open window, or hear monsters moving stealthily in the forest. Or you might try to spot things that are obscured or easy to miss, whether they are orcs lying in ambush on a road, thugs hiding in the shadows of an alley, or candlelight under a closed secret door.</p>\n",
    },
    {
      id: 15,
      entityTypeId: 1958004211,
      stat: 5,
      name: "Survival",
      description:
        "<p>The GM might ask you to make a Wisdom (Survival) check to follow tracks, hunt wild game, guide your group through frozen wastelands, identify signs that owlbears live nearby, predict the weather, or avoid quicksand and other natural hazards.</p>",
    },
    {
      id: 16,
      entityTypeId: 1958004211,
      stat: 6,
      name: "Deception",
      description:
        "<p>Your Charisma (Deception) check determines whether you can convincingly hide the truth, either verbally or through your actions. This deception can encompass everything from misleading others through ambiguity to telling outright lies. Typical situations include trying to fast-talk a guard, con a merchant, earn money through gambling, pass yourself off in a disguise, dull someone's suspicions with false assurances, or maintain a straight face while telling a blatant lie.</p>\n",
    },
    {
      id: 17,
      entityTypeId: 1958004211,
      stat: 6,
      name: "Intimidation",
      description:
        "<p>When you attempt to influence someone through overt threats, hostile actions, and physical violence, the GM might ask you to make a Charisma (Intimidation) check. Examples include trying to pry information out of a prisoner, convincing street thugs to back down from a confrontation, or using the edge of a broken bottle to convince a sneering vizier to reconsider a decision.</p>\n",
    },
    {
      id: 18,
      entityTypeId: 1958004211,
      stat: 6,
      name: "Performance",
      description:
        "<p>Your Charisma (Performance) check determines how well you can delight an audience with music, dance, acting, storytelling, or some other form of entertainment.</p>",
    },
    {
      id: 19,
      entityTypeId: 1958004211,
      stat: 6,
      name: "Persuasion",
      description:
        "<p>When you attempt to influence someone or a group of people with tact, social graces, or good nature, the GM might ask you to make a Charisma (Persuasion) check. Typically, you use persuasion when acting in good faith, to foster friendships, make cordial requests, or exhibit proper etiquette. Examples of persuading others include convincing a chamberlain to let your party see the king, negotiating peace between warring tribes, or inspiring a crowd of townsfolk.</p>\n",
    },
  ],
  senses: [
    { id: 1, entityTypeId: 668550506, name: "Blindsight" },
    { id: 2, entityTypeId: 668550506, name: "Darkvision" },
    { id: 3, entityTypeId: 668550506, name: "Tremorsense" },
    { id: 4, entityTypeId: 668550506, name: "Truesight" },
    { id: 5, entityTypeId: 668550506, name: "Unknown" },
  ],
  creatureSizes: [
    { id: 2, entityTypeId: 127108918, name: "Tiny", weightType: 1 },
    { id: 3, entityTypeId: 127108918, name: "Small", weightType: 2 },
    { id: 4, entityTypeId: 127108918, name: "Medium", weightType: 2 },
    { id: 5, entityTypeId: 127108918, name: "Large", weightType: 3 },
    { id: 6, entityTypeId: 127108918, name: "Huge", weightType: 3 },
    { id: 7, entityTypeId: 127108918, name: "Gargantuan", weightType: 3 },
    { id: 10, entityTypeId: 127108918, name: "Medium or Small", weightType: 2 },
  ],
  limitedUseResetTypes: [
    { id: 1, name: "Short Rest" },
    { id: 2, name: "Long Rest" },
    { id: 3, name: "Dawn" },
    { id: 4, name: "Other" },
  ],
  sourceCategories: [
    {
      id: 1,
      name: "Core D&amp;D",
      description: null,
      isHideable: false,
      isEnabledByDefault: true,
      isToggleable: false,
      avatarUrl: "",
    },
    {
      id: 2,
      name: "Critical Role",
      description: null,
      isHideable: true,
      isEnabledByDefault: false,
      isToggleable: true,
      avatarUrl: "https://www.dndbeyond.com/avatars/105/174/636512853628516966.png",
    },
    {
      id: 3,
      name: "Playtest",
      description:
        '<p><span style="color: rgba(255, 0, 0, 1)"><strong>THIS IS UNOFFICIAL MATERIAL</strong></span></p>\n<p>The material here is presented for playtesting and to spark your imagination. These game mechanics are in draft form, usable in your campaign but not refined by&nbsp;full game design and editing. They arenâ€™t officially part of the game and arenâ€™t permitted in D&amp;D Adventurers League events.</p>\n<p>If this material is made official, it will be refined based on your feedback, and then it will appear in a D&amp;D product that you can unlock on DDB.</p>\n<p>If this material is not made official, it will be removed from D&amp;D Beyond following the playtest period and you will need to replace it with another option.</p>',
      isHideable: true,
      isEnabledByDefault: false,
      isToggleable: false,
      avatarUrl: "https://www.dndbeyond.com/avatars/110/171/636516074887091041.png",
    },
    {
      id: 6,
      name: "D&amp;D Beyond",
      description: "<p>D&amp;D Beyond</p>",
      isHideable: false,
      isEnabledByDefault: false,
      isToggleable: false,
      avatarUrl: "",
    },
    {
      id: 7,
      name: "Magic: The Gathering",
      description: "<p>Magic: The Gathering content for fifth edition Dungeons &amp; Dragons</p>",
      isHideable: false,
      isEnabledByDefault: true,
      isToggleable: true,
      avatarUrl: "",
    },
    {
      id: 8,
      name: "Eberron",
      description: "<p>The Eberron campaign setting for&nbsp;fifth edition Dungeons &amp; Dragons</p>",
      isHideable: false,
      isEnabledByDefault: true,
      isToggleable: true,
      avatarUrl: "https://www.dndbeyond.com/avatars/2588/861/636681435608150525.png",
    },
    {
      id: 9,
      name: "Archived",
      description: "<p>The Graveyard</p>",
      isHideable: false,
      isEnabledByDefault: false,
      isToggleable: false,
      avatarUrl: "",
    },
    {
      id: 10,
      name: "Rick and Morty",
      description: "<p>Source category for Rick and Morty products.</p>",
      isHideable: true,
      isEnabledByDefault: false,
      isToggleable: true,
      avatarUrl: "",
    },
    {
      id: 11,
      name: "Runeterra",
      description:
        '<p><span style="color: rgba(255, 0, 0, 1)"><strong>THIS IS UNOFFICIAL MATERIAL</strong></span></p>\n<p>These game mechanics are usable in your campaign if your DM allows them but not refined by final game design and editing. They arenâ€™t officially part of the Dungeons &amp; Dragons game and arenâ€™t permitted in D&amp;D Adventurers League events unless otherwise stated.</p>',
      isHideable: false,
      isEnabledByDefault: false,
      isToggleable: false,
      avatarUrl: "https://www.dndbeyond.com/avatars/11008/904/637274855809570341.png",
    },
    {
      id: 12,
      name: "Noncore D&amp;D",
      description:
        '<p><span style="color: rgba(255, 0, 0, 1)"><strong>THIS IS NONCORE D&amp;D MATERIAL</strong></span></p>\n<p>These game mechanics are usable in your campaign if your DM allows them but not refined by final game design and editing.</p>',
      isHideable: false,
      isEnabledByDefault: false,
      isToggleable: true,
      avatarUrl: "",
    },
    {
      id: 13,
      name: "Adventurers League",
      description: "<p>Adventurers League content for fifth edition Dungeons &amp; Dragons</p>",
      isHideable: false,
      isEnabledByDefault: false,
      isToggleable: false,
      avatarUrl: "",
    },
  ],
  movements: [
    { id: 1, name: "Walk", description: "Walking" },
    { id: 2, name: "Burrow", description: "Burrowing" },
    { id: 3, name: "Climb", description: "Climbing" },
    { id: 4, name: "Fly", description: "Flying" },
    { id: 5, name: "Swim", description: "Swimming" },
  ],
  multiClassSpellSlots: [
    [0, 0, 0, 0, 0, 0, 0, 0, 0],
    [2, 0, 0, 0, 0, 0, 0, 0, 0],
    [3, 0, 0, 0, 0, 0, 0, 0, 0],
    [4, 2, 0, 0, 0, 0, 0, 0, 0],
    [4, 3, 0, 0, 0, 0, 0, 0, 0],
    [4, 3, 2, 0, 0, 0, 0, 0, 0],
    [4, 3, 3, 0, 0, 0, 0, 0, 0],
    [4, 3, 3, 1, 0, 0, 0, 0, 0],
    [4, 3, 3, 2, 0, 0, 0, 0, 0],
    [4, 3, 3, 3, 1, 0, 0, 0, 0],
    [4, 3, 3, 3, 2, 0, 0, 0, 0],
    [4, 3, 3, 3, 2, 1, 0, 0, 0],
    [4, 3, 3, 3, 2, 1, 0, 0, 0],
    [4, 3, 3, 3, 2, 1, 1, 0, 0],
    [4, 3, 3, 3, 2, 1, 1, 0, 0],
    [4, 3, 3, 3, 2, 1, 1, 1, 0],
    [4, 3, 3, 3, 2, 1, 1, 1, 0],
    [4, 3, 3, 3, 2, 1, 1, 1, 1],
    [4, 3, 3, 3, 3, 1, 1, 1, 1],
    [4, 3, 3, 3, 3, 2, 1, 1, 1],
    [4, 3, 3, 3, 3, 2, 2, 1, 1],
  ],
  pactMagicMultiClassSpellSlots: [
    [0, 0, 0, 0, 0, 0, 0, 0, 0],
    [1, 0, 0, 0, 0, 0, 0, 0, 0],
    [2, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 2, 0, 0, 0, 0, 0, 0, 0],
    [0, 2, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 2, 0, 0, 0, 0, 0, 0],
    [0, 0, 2, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 2, 0, 0, 0, 0, 0],
    [0, 0, 0, 2, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 2, 0, 0, 0, 0],
    [0, 0, 0, 0, 2, 0, 0, 0, 0],
    [0, 0, 0, 0, 3, 0, 0, 0, 0],
    [0, 0, 0, 0, 3, 0, 0, 0, 0],
    [0, 0, 0, 0, 3, 0, 0, 0, 0],
    [0, 0, 0, 0, 3, 0, 0, 0, 0],
    [0, 0, 0, 0, 3, 0, 0, 0, 0],
    [0, 0, 0, 0, 3, 0, 0, 0, 0],
    [0, 0, 0, 0, 4, 0, 0, 0, 0],
    [0, 0, 0, 0, 4, 0, 0, 0, 0],
    [0, 0, 0, 0, 4, 0, 0, 0, 0],
    [0, 0, 0, 0, 4, 0, 0, 0, 0],
  ],
  proficiencyGroups: [
    { label: "Armor", customProficiencyGroup: 4, customAdjustments: [32], entityTypeIds: [701257905, 174869515] },
    { label: "Weapons", customProficiencyGroup: 5, customAdjustments: [33], entityTypeIds: [1782728300, 660121713] },
    { label: "Tools", customProficiencyGroup: 2, customAdjustments: [34], entityTypeIds: [2103445194, 1452973421] },
    { label: "Languages", customProficiencyGroup: 3, customAdjustments: [35], entityTypeIds: [906033267] },
  ],
  vehicleConfiguration: null,
};

;// CONCATENATED MODULE: ./src/hooks/ready/ddbConfig.js






function directConfig() {
  $.getJSON("https://www.dndbeyond.com/api/config/json")
    .then((config) => {
      if (config && config.sources) {
        setProperty(CONFIG, "DDB", config);
        src_logger/* default.info */.Z.info("Loaded DDB live config");
      }
      return config;
    })
    .catch((err) => {
      src_logger/* default.warn */.Z.warn("Failed to load DDB config, caught error using fallback.", err);
      return err;
    })
    .always(() => {
      if (!CONFIG.DDB?.sources) {
        setProperty(CONFIG, "DDB", fallbackDDBConfig);
        src_logger/* default.warn */.Z.warn("Failed to load DDB config, using fallback.");
      } else {
        src_logger/* default.info */.Z.info("A DDB config was loaded");
      }
      src_logger/* default.debug */.Z.debug("DDB_CONFIG", CONFIG.DDB);
    });
}

function proxyConfig() {
  const parsingApi = DDBProxy/* default.getProxy */.Z.getProxy();
  const debugJson = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "debug-json");

  const url = `${parsingApi}/proxy/api/config/json`;
  return new Promise((resolve, reject) => {
    fetch(url, {
      method: "GET",
      mode: "cors",
      headers: {
        "Content-Type": "application/json",
      },
    })
      .then((response) => response.json())
      .then((data) => {
        if (!data.success) {
          src_logger/* default.error */.Z.error(`API Failure: ${data.message}`);
          setProperty(CONFIG, "DDB", fallbackDDBConfig);
          reject(data.message);
        }
        if (debugJson) {
          FileHelper/* default.download */.Z.download(JSON.stringify(data), `config-raw.json`, "application/json");
        }
        return data;
      })
      .then((data) => {
        if (data.success) {
          src_logger/* default.info */.Z.info(`Retrieved DDB CONFIG DATA via proxy`);
          setProperty(CONFIG, "DDB", data.data);
        }
        src_logger/* default.debug */.Z.debug("DDB_CONFIG", CONFIG.DDB);
        resolve(data.data);
      })
      .catch((error) => reject(error));
  });
}

function loadDDBConfig() {
  if (!hasProperty(CONFIG, "DDB")) {
    setProperty(CONFIG, "DDB", fallbackDDBConfig);
    if (getProperty(CONFIG, "DEBUG.DDBI.DIRECT_CONFIG")) {
      if ((/electron/i).test(navigator.userAgent)) {
        src_logger/* default.info */.Z.info("Electron detected using DDB Config stub");
        src_logger/* default.debug */.Z.debug("DDB_CONFIG", CONFIG.DDB);
      } else {
        src_logger/* default.info */.Z.info("Loaded default DDB config, checking for live config access.");
        directConfig();
      }
    } else {
      proxyConfig();
    }
  }
}

;// CONCATENATED MODULE: ./src/hooks/ready/anchorInjection.js



function addSlugField(element, slug) {
  const titleInput = element.querySelector("input[name='text']");
  const slugHTML = `<div class="form-group">
  <label>Jump to HTML Slug</label>
  <div class="form-fields">
      <input type="text" name="slug" value="${slug}" placeholder="">
  </div>
</div>`;

  const div = utils/* default.htmlToElement */.Z.htmlToElement(slugHTML);
  titleInput.parentNode.parentNode.parentNode.insertBefore(div, titleInput.parentNode.parentNode.nextSibling.nextSibling);
}

function updateSlugField(element, slug) {
  const slugInput = element.querySelector("input[name='slug']");
  slugInput.setAttribute('value', slug);
}

async function saveSlug(note, slug) {
  await note.scene.updateEmbeddedDocuments("Note", [
    {
      _id: note.id,
      flags: {
        "anchor.slug": slug,
        "ddb.slugLink": slug,
        "ddb.labelName": note.label,
      },
    },
  ]);
}

function anchorInjection() {
  Hooks.on("activateNote", (note, options) => {
    if (note.document?.flags?.ddb?.slugLink) {
      src_logger/* default.debug */.Z.debug("Injecting note anchor", note.document.flags.ddb.slugLink);
      options["anchor"] = note.document.flags.ddb.slugLink;
    } else if (note.document.flags.anchor?.slug) {
      src_logger/* default.debug */.Z.debug("Injecting note anchor", note.document.flags.anchor.slug);
      options["anchor"] = note.document.flags.anchor.slug;
    } else if (note.document?.flags?.anchor) {
      src_logger/* default.debug */.Z.debug("Injecting note anchor", note.document.flags.anchor);
      options["anchor"] = note.document.flags.anchor;
    }
  });

  // when we render a note we add the
  Hooks.on("renderNoteConfig", (noteConfig) => {
    const slug = noteConfig.document.flags.ddb?.slugLink
      ?? noteConfig.document.flags.anchor?.slug
      ?? "";
    addSlugField(noteConfig.element[0], slug);
    noteConfig.element[0].style.height = "auto";

    // capture notes that are now refreshed after this point
    const closeRefreshId = Hooks.on("refreshNote", async (note) => {
      if (noteConfig.document.id !== note.document.id && noteConfig.document.id !== null) return;
      // capture note config close hooks and trigger a check on that
      const closeNoteId = Hooks.on("closeNoteConfig", async (closeNoteConfig) => {
        if (noteConfig.id == closeNoteConfig.id) {
          Hooks.off("closeNoteConfig", closeNoteId);
          Hooks.off("refreshNote", closeRefreshId);
          const slugInput = closeNoteConfig.element[0].querySelector("input[name='slug']");
          const slug = slugInput.value;
          if (slug && slug.trim() !== "" && slug !== closeNoteConfig.document.flags.ddb?.slugLink) {
            src_logger/* default.debug */.Z.debug("Saving anchor slug", {
              slug,
              note: note,
              noteId: note._id,
            });
            await saveSlug(note, slugInput.value);
          }
        }
      });
    });
  });

  Hooks.on("dropCanvasData", (_, dropData) => {
    if (dropData.type !== "JournalEntryPage" && !dropData.anchor?.slug) return;

    // when we create from the side bar we fill in the input label name to match
    // the anchor name and set the slug value to the anchor slug
    Hooks.once("renderNoteConfig", (noteConfig) => {
      const titleInput = noteConfig.element[0].querySelector("input[name='text']");
      titleInput.setAttribute('value', dropData.anchor.name);
      if (dropData.anchor.slug) updateSlugField(noteConfig.element[0], dropData.anchor.slug);
    });
  });
}

;// CONCATENATED MODULE: ./src/hooks/renderMuncher/earlySettings.js


function earlySettings() {
  for (const [name, data] of Object.entries(settings/* default.GET_DEFAULT_SETTINGS */.Z.GET_DEFAULT_SETTINGS(true))) {
    game.settings.register(settings/* default.MODULE_ID */.Z.MODULE_ID, name, data);
  }
}

// EXTERNAL MODULE: ./src/muncher/DDBMuncher.js + 13 modules
var DDBMuncher = __webpack_require__(1475);
;// CONCATENATED MODULE: ./src/hooks/renderMuncher/addMuncher.js




function addMuncher(app, html) {
  if (app.options.id == "compendium" && game.user.isGM) {
    let button = $("<div class='header-actions action-buttons flexrow'><button class='ddb-muncher'><i class='fas fa-pastafarianism'></i> DDB Muncher</button></div>");

    button.click(async () => {
      ui.notifications.info("Checking your DDB details - this might take a few seconds!");
      const setupComplete = (0,Settings/* isSetupComplete */.pV)();

      if (setupComplete) {
        const cobaltStatus = await (0,Secrets/* checkCobalt */.B)();
        if (cobaltStatus.success) {
          let validKey = await (0,Settings/* isValidKey */.Vj)();
          if (validKey) {
            new DDBMuncher/* default */.Z().render(true);
          }
        } else {
          new Settings/* DDBCookie */.Bp().render(true);
        }
      } else {
        game.settings.set("ddb-importer", "settings-call-muncher", true);
        new Settings/* DDBSetup */.lR().render(true);
      }
    });

    const top = game.settings.get("ddb-importer", "show-munch-top");
    if (top) {
      $(html).find(".directory-header").append(button);
    } else {
      $(html).find(".directory-footer").append(button);
    }
  }
}

;// CONCATENATED MODULE: ./src/hooks/renderMuncher/addEncounterMuncher.js







function addEncounterMuncher (app, html) {
  const tier = game.settings.get("ddb-importer", "patreon-tier");
  const tiers = PatreonHelper/* default.getPatreonTiers */.Z.getPatreonTiers(tier);
  const enabled = game.settings.get("ddb-importer", "encounter-muncher-enabled");

  if (enabled && app.options.id == "scenes" && game.user.isGM && tiers.supporter) {
    let button = $("<div class='header-actions action-buttons flexrow'><button class='ddb-muncher' id='ddb-encounter-munch-open'><i class='fas fa-dungeon'></i> DDB Encounter Muncher</button></div>");

    const actualButton = button.find('#ddb-encounter-munch-open');
    actualButton.click(async () => {
      actualButton.prop('disabled', true);
      ui.notifications.info("Fetching your DDB Encounter Information, this might take a few seconds!");
      try {
        const setupComplete = (0,Settings/* isSetupComplete */.pV)();

        if (setupComplete) {
          const cobaltStatus = await (0,Secrets/* checkCobalt */.B)();
          if (cobaltStatus.success) {
            let validKey = await (0,Settings/* isValidKey */.Vj)();
            if (validKey) {
              new DDBEncounterMunch().render(true);
            }
          } else {
            actualButton.prop('disabled', false);
            new Settings/* DDBCookie */.Bp().render(true);
          }
        } else {
          actualButton.prop('disabled', false);
          new Settings/* DDBSetup */.lR().render(true);
        }
      } catch (e) {
        src_logger/* default.error */.Z.error(e);
        actualButton.prop('disabled', false);
      }
    });

    const top = game.settings.get("ddb-importer", "show-munch-top");
    if (top) {
      $(html).find(".directory-header").prepend(button);
    } else {
      $(html).find(".directory-footer").append(button);
    }

    Hooks.on("closeApplication", (app) => {
      if (app instanceof DDBEncounterMunch) {
        actualButton.prop('disabled', false);
      }
    });

  }
}

;// CONCATENATED MODULE: ./src/hooks/socket/onSocketMessage.js


function onSocketMessage (sender, data) {
  switch (data.action) {
    case "showImage": {
      src_logger/* default.warn */.Z.warn("showImage handler has been removed, use ImagePopout instead");
    }
    // no default
  }
}

;// CONCATENATED MODULE: ./src/hooks/renderJournalSheet/linkTables.js
function linkTables(type, html) {

  // if journal
  let content;
  let findString;
  switch (type) {
    case "journal":
      content = $(html).find(`div[data-edit="content"]`);
      findString = "a.content-link[data-entity='RollTable']";
      break;
    case "item": {
      const tableCompendium = game.settings.get("ddb-importer", "entity-table-compendium");
      content = $(html).find(`div[data-edit="data.description.value"]`);
      findString = `a.content-link[data-pack='${tableCompendium}']`;
      break;
    }
    // no default
  }


  // Add a direct roll button into DDB-imported rolltables
  $(content)
    .find(findString)
    .each(async (_, link) => {
      const data = $(link).data();
      const pack = game.packs.get(data.pack);

      const table = pack
        ? await pack.getDocument(data.id)
        : game.tables.get(data.id);

      if (table?.flags?.ddb?.contentChunkId || pack) {
        const button = $(
          `<a title="Click: Roll | Shift-Click: Self Roll" class="ddbimporter roll"><i class="fas fa-dice-d20"></i>  Roll!</a>`
        );

        $(link).after(button);
        $(button).on("click", async (event) => {
          event.preventDefault();
          const rollMode = event.shiftKey ? "selfroll" : "roll";

          // fix: Table description is undefined
          if (!table.description) table.description = table.name;

          const draw = await table.roll();

          draw.results = draw.results.map((result) => {
            if (!result.img)
              result.img = "icons/svg/d20-highlight.svg";
            return result;
          });

          await table.toMessage(draw.results, {
            roll: draw.roll,
            messageOptions: {
              speaker: game.user.name,
              rollMode: rollMode,
            },
          });

        });
      }
    });
}

;// CONCATENATED MODULE: ./src/hooks/renderJournalSheet/shared.js


function getBookName(bookId) {
  const book = CONFIG.DDB.sources.find((source) => source.name.toLowerCase() == bookId.toLowerCase());
  if (book) {
    return book.description;
  } else {
    return "";
  }
}

function imageToChat(src) {
  const content = `<img class="ddbimporter-chat-image" data-src="${src}" src="${src}">`;

  ChatMessage.create({
    content,
  });
}

async function getJournal(bookCode) {
  const folder = await utils/* default.getFolder */.Z.getFolder("journal", "", "Player Handouts", "#515fc8", "#515fc8", false);
  const journalName = bookCode
    ? getBookName(bookCode)
    : "Handout Pages";
  const existingJournal = game.journal.find((journal) =>
    journal.name === journalName && journal.folder.id === folder.id
  );
  if (existingJournal) {
    return existingJournal;
  } else {
    const journal = await JournalEntry.create(
      {
        name: journalName,
        folder: folder.id,
        ownership: {
          default: CONST.DOCUMENT_OWNERSHIP_LEVELS.OBSERVER,
        },
        flags: {
          ddb: {
            bookCode,
          },
        },
      },
      {
        displaySheet: false,
      }
    );
    return journal;
  }
}

async function createPage(journal, name, type, content) {
  const page = {
    _id: randomID(),
    name,
    type,
    text: {},
    title: {
      show: true,
    },
    ownership: {
      default: CONST.DOCUMENT_OWNERSHIP_LEVELS.OBSERVER,
    }
  };
  switch (type) {
    case "image": {
      page.title.show = true;
      page.src = content;
      break;
    }
    case "text":
    default: {
      page.text.content = content;
    }
  }

  await JournalEntryPage.create(page, { parent: journal, keepId: true, displaySheet: false });
  return journal.pages.find((jp) => page._id === jp._id);
}

async function createAndShowPlayerHandout(name, content, type, bookCode) {

  const journal = await getJournal(bookCode);

  const existingPage = journal.pages.find((page) => {
    const nameCheck = page.name === name;
    const typeCheck = type === "image"
      ? page.src === content
      : type === "text"
        ? page.text?.content === content
        : true;
    return nameCheck && typeCheck;
  });

  const page = existingPage
    ? existingPage
    : await createPage(journal, name, type, content);

  Journal.showDialog(page);
}

;// CONCATENATED MODULE: ./src/hooks/renderJournalSheet/linkImages.js



function linkImages(html, data) {
  if (!game.user.isGM) return;
  const displayImages = game.settings.get("ddb-importer", "show-image-to-players");
  // does this functionality exist from anther module?
  const funcExists = !displayImages
    || game.modules.get("vtta-dndbeyond")?.active
    || game.modules.get("vtta-ddb")?.active
    || game.modules.get("token-hud-art-button")?.active;

  if (funcExists) return;

  // mark all images
  $(html)
    .find('img')
    .each((index, element) => {
      const showPlayersButton = $("<a class='ddbimporter-show-image'><i class='fas fa-eye'></i>&nbsp;Show Players Image</a>");
      const toChatButton = $("<a class='ddbimporter-to-chat'><i class='fas fa-comment'></i>&nbsp;To Chat</a>");

      $(element).wrap("<div class='ddbimporter-image-container'></div>");
      // show the button on mouseenter of the image
      $(element)
        .parent()
        .mouseenter(function addHover() {
          // eslint-disable-next-line no-invalid-this
          $(this).append(showPlayersButton);
          $(showPlayersButton).click((event) => {
            event.preventDefault();
            event.stopPropagation();
            const src = $(element).attr("src");
            Dialog.confirm({
              title: "Would you like to create a handout for the image?",
              content: "<p>Create a player viewable handout? (No will show the image only)</p>",
              yes: async () => {
                const name = await utils/* default.namePrompt */.Z.namePrompt("What would you like to call the Handout?");
                if (name && name !== "") {
                  const bookCode = data.flags?.ddb?.bookCode;
                  createAndShowPlayerHandout(name, src, "image", bookCode);
                }
              },
              no: () => {
                const popOut = new ImagePopout(src, { shareable: true });
                popOut.shareImage();
              },
              defaultYes: true
            });
          });
          // eslint-disable-next-line no-invalid-this
          $(this).append(toChatButton);
          $(toChatButton).click((event) => {
            event.preventDefault();
            event.stopPropagation();
            imageToChat($(element).attr("src"));
          });
        });
      $(element)
        .parent()
        .mouseleave(function removeHover() {
          // eslint-disable-next-line no-invalid-this
          $(this).find("a.ddbimporter-show-image, a.ddbimporter-to-chat").remove();
        });
    });
}

;// CONCATENATED MODULE: ./src/hooks/renderJournalSheet/buildNotes.js


function copyToClipboard(text) {
  src_logger/* default.debug */.Z.debug("Copy block", text);
  let dummy = document.createElement("textarea");
  document.body.appendChild(dummy);
  dummy.value = text;
  dummy.select();
  document.execCommand("copy");
  document.body.removeChild(dummy);
}

function getNoteButton(name, type) {
  return $(
    `<a id='ddb-note-${name}' class='ddb-button'><i class='fas fa-clipboard-check'></i>&nbsp;Copy ${type} ${name} </a>`
  );
}

function getTableButton() {
  return $(
    `<a id='ddb-table-name' class='ddb-button'><i class='fas fa-clipboard-check'></i>&nbsp;Copy table details </a>`
  );
}

function buildNotes(html, data) {
  if (!game.user.isGM) return;
  const allow = game.settings.get("ddb-importer", "allow-note-generation");
  if (!allow) return;

  // mark all headers
  $(html)
    .find("h1, h2, h3, h4, h5, figure, p")
    .each((index, element) => {
      $(element).wrap("<div class='ddbimporter-note-container'></div>");
      // show the button on mouseenter
      $(element)
        .parent()
        .mouseenter(function Hovering() {
          if (CONFIG.DDBI.DEV.tableInUse) return;
          const tagName = $(element).prop("tagName");
          const showStartButton = $(this).append(getNoteButton("start", tagName));
          const showEndButton = $(this).append(getNoteButton("end", tagName));
          $(showStartButton).click((e) => {
            if (e.target.id === "ddb-note-start") {
              CONFIG.DDBI.DEV.clippy = {
                ddbId: data.document.flags.ddb.ddbId,
                cobaltId: data.document.flags.ddb.cobaltId,
                parentId: data.document.flags.ddb.parentId,
                splitTag: tagName.toLowerCase(),
                slug: data.document.flags.ddb.slug,
                tagIdFirst: $(element).prop("id"),
                contentChunkIdStart: $(element).attr("data-content-chunk-id"),
                tagIdLast: "",
                contentChunkIdStop: "EOF",
                sceneName: data.document.name,
              };
              copyToClipboard(JSON.stringify(CONFIG.DDBI.DEV.clippy, null, 2));
            }
          });
          $(showEndButton).click((e) => {
            if (e.target.id === "ddb-note-end") {
              CONFIG.DDBI.DEV.clippy.tagIdLast = $(element).prop("id");
              CONFIG.DDBI.DEV.clippy.contentChunkIdStop = $(element).attr("data-content-chunk-id");
              copyToClipboard(JSON.stringify(CONFIG.DDBI.DEV.clippy, null, 2));
            }
          });
        });
      $(element)
        .parent()
        .mouseleave(function Unhovering() {
          $(this).find("#ddb-note-start").remove();
          $(this).find("#ddb-note-end").remove();
        });
    });

  // mark all headers
  $(html)
    .find("table")
    .each((index, element) => {
      $(element).wrap("<div class='ddbimporter-table-container'></div>");
      // show the button on mouseenter
      $(element)
        .parent()
        .mouseenter(function Hovering() {
          CONFIG.DDBI.DEV.tableInUse = true;
          const showButton = $(this).append(getTableButton());
          $(showButton).click((e) => {
            if (e.target.id === "ddb-table-name") {
              CONFIG.DDBI.DEV.clippy = {
                ddbId: data.flags.ddb.ddbId,
                cobaltId: data.flags.ddb.cobaltId,
                parentId: data.flags.ddb.parentId,
                slug: data.flags.ddb.slug,
                tagIdFirst: $(element).prop("id"),
                contentChunkId: $(element).attr("data-content-chunk-id"),
                sceneName: data.name,
                tableName: "",
              };
              copyToClipboard(JSON.stringify(CONFIG.DDBI.DEV.clippy, null, 2));
            }
          });
        });
      $(element)
        .parent()
        .mouseleave(function Unhovering() {
          $(this).find("#ddb-table-name").remove();
          CONFIG.DDBI.DEV.tableInUse = false;
        });
    });
}

/* harmony default export */ const renderJournalSheet_buildNotes = (buildNotes);

;// CONCATENATED MODULE: ./src/hooks/renderJournalSheet/adventure.js



const adventure_POPUPS = {
  json: null,
  web: null,
};
const adventure_renderPopup = (type, url) => {
  if (adventure_POPUPS[type] && !adventure_POPUPS[type].close) {
    adventure_POPUPS[type].focus();
    adventure_POPUPS[type].location.href = url;
  } else {
    const ratio = window.innerWidth / window.innerHeight;
    const width = Math.round(window.innerWidth * 0.5);
    const height = Math.round(window.innerWidth * 0.5 * ratio);
    adventure_POPUPS[type] = window.open(
      url,
      "ddb_sheet_popup",
      `resizeable,scrollbars,location=no,width=${width},height=${height},toolbar=1`
    );
  }
  return true;
};

function adventureFlags(app, html, data) {
  if (!game.user.isGM || !app.document.flags.ddb) return;
  const existingLink = html.closest('.app').find('.open-adventure-ddb-importer');
  if (existingLink.length > 0) return;

  const title = `Go to DDB`;
  const whiteTitle = (game.settings.get("ddb-importer", "link-title-colour-white")) ? " white" : "";
  let button = $(`<a class="open-adventure-ddb-importer" title="${title}"><i class="fab fa-d-and-d-beyond${whiteTitle}"></i></a>`);
  button.click((event) => {
    if (event.shiftKey && event.ctrlKey) {
      new DDBAdventureFlags(app.document, {}).render(true);
    } else {
      event.preventDefault();
      const flags = app.document.flags.ddb;
      const bookSource = CONFIG.DDB.sources.find((book) => flags.bookCode.toLowerCase() === book.name.toLowerCase());
      return adventure_renderPopup("web", `https://www.dndbeyond.com/${bookSource.sourceURL}/${flags.slug}`);
    }
    return true;
  });

  let titleElement = html.closest('.app').find('.window-title');
  button.insertAfter(titleElement);
  renderJournalSheet_buildNotes(html, data);
}


/* harmony default export */ const renderJournalSheet_adventure = (adventureFlags);

;// CONCATENATED MODULE: ./src/hooks/renderJournalSheet/linkReadAlouds.js



function showReadAlouds(html, data) {
  if (!game.user.isGM) return;
  const displayImages = game.settings.get("ddb-importer", "show-read-alouds-button");
  if (!displayImages) return;

  // mark all read alouds
  $(html)
    .find("aside, blockquote, .read-aloud-text, .read-aloud, .adventure-read-aloud-text, .ddb-blockquote")
    .each((index, element) => {
      const showPlayersJournalButton = $("<a class='ddbimporter-show-image'><i class='fas fa-book-open'></i>&nbsp;Create and Show Handout</a>");
      const toChatButton = $("<a class='ddbimporter-to-chat'><i class='fas fa-comment '></i>&nbsp;To Chat</a>");

      $(element).wrap("<div class='ddbimporter-image-container'></div>");
      // show the button on mouseenter of the image
      $(element)
        .parent()
        .mouseenter(function addHover() {
          // eslint-disable-next-line no-invalid-this
          $(this).append(showPlayersJournalButton);
          $(showPlayersJournalButton).click(async (event) => {
            event.preventDefault();
            event.stopPropagation();
            const name = await utils/* default.namePrompt */.Z.namePrompt("What would you like to call the Handout?");
            if (name && name !== "") {
              const bookCode = data.data?.flags?.ddb?.bookCode;
              createAndShowPlayerHandout(name, element.outerHTML, "text", bookCode);
            }
          });
          // eslint-disable-next-line no-invalid-this
          $(this).append(toChatButton);
          $(toChatButton).click((event) => {
            event.preventDefault();
            event.stopPropagation();
            ChatMessage.create({ content: element.outerHTML });
          });
        });
      $(element)
        .parent()
        .mouseleave(function removeHover() {
          // eslint-disable-next-line no-invalid-this
          $(this).find("a.ddbimporter-show-image, a.ddbimporter-to-chat").remove();
        });
    });
}

;// CONCATENATED MODULE: ./src/lib/Notification.js
/**
 * Shows notifcations and hints to the user
 */
const MARGIN = 10;

const registerNotifications = () => {
  // register the notification global object

  if ($("#ddbimporter-notifications").length === 0) {
    $("body").append(`<div id="ddbimporter-notifications"></div>`);
  }
  if ($("#ddbimporter-hints").length === 0) {
    $("body").append(`<div id="ddbimporter-hints"></div>`);
  }

  game.modules.get("ddb-importer").api.notification = {
    clear: () => {
      $("#ddbimporter-notifications div").fadeOut(200, () => {
        $("#ddbimporter-notifications").empty();
      });
    },
    show: (message, timeout = 4000) => {
      $("#ddbimporter-notifications").css("left", $("#players").css("left"));
      // prettier-ignore
      $("#ddbimporter-notifications").css("bottom", $("#players").height() + (2 * MARGIN));

      let note = $(`<div style="display: none"></div>`).append(message);
      $("#ddbimporter-notifications").append(note);
      $(note).fadeIn(200);

      if (timeout)
        setTimeout(() => {
          $(note).fadeOut(200, () => {
            $(note).remove();
          });
        }, timeout);
      else
        $(note).append('<p style="text-align: center; color: #7e7e7e; margin: 0px;"><small>Click to close</small>');

      $(note).on("click", () => {
        $(note).fadeOut(200, () => {
          $(note).remove();
        });
      });
    },
  };
  game.modules.get("ddb-importer").api.hint = {
    clear: () => {
      $("#ddbimporter-hints div").hide(200, () => {
        $("#ddbimporter-hints").empty();
      });
    },
    show: (message, options = {}) => {
      return new Promise((resolve) => {
        $("#ddbimporter-hints").css("width", options.width ? options.width : 300);

        // construct the note
        let note = $(`<div style="display: none"></div>`);
        $(note).append(message);
        $(note).append('<div class="buttons"></div>');
        $("#ddbimporter-hints").append(note);
        $(note).fadeIn(200);

        if (!options.align) options.align = options.element ? "RIGHT" : "CENTER";

        let anchor = {
          width: 0,
          height: 0,
          top: Math.round(window.innerHeight / 2),
          left: Math.round(window.innerWidth / 2),
        };

        if (options.element) {
          anchor = Object.assign(
            { width: $(options.element).width(), height: $(options.element).height() },
            $(options.element).offset()
          );
        }
        const noteInfo = Object.assign(
          { width: $("#ddbimporter-hints").width(), height: $("#ddbimporter-hints").height() },
          $("#ddbimporter-hints").position()
        );

        switch (options.align) {
          case "RIGHT":
            $("#ddbimporter-hints").css("top", anchor.top);
            $("#ddbimporter-hints").css("left", anchor.left + anchor.width + MARGIN);
            break;
          case "LEFT":
            $("#ddbimporter-hints").css("top", anchor.top);
            $("#ddbimporter-hints").css("left", anchor.left - noteInfo.width - MARGIN);
            break;
          case "TOP":
            $("#ddbimporter-hints").css("top", anchor.top - noteInfo.height - MARGIN);
            $("#ddbimporter-hints").css("left", anchor.left);
            break;
          case "BOTTOM":
            $("#ddbimporter-hints").css("top", anchor.top + anchor.height + MARGIN);
            $("#ddbimporter-hints").css("left", anchor.left);
            break;

          default:
            // eslint-disable-next-line no-mixed-operators
            $("#ddbimporter-hints").css("top", anchor.top - Math.round(noteInfo.height / 2));
            // eslint-disable-next-line no-mixed-operators
            $("#ddbimporter-hints").css("left", anchor.left - Math.round(noteInfo.width / 2));
        }

        if (options.buttons) {
          for (let name of options.buttons) {
            let btn = $("<button>" + name + "</button>");
            $("div.buttons", note).append(btn);
            $(btn).on("click", () => {
              $(note).fadeOut(100, () => {
                $(note).remove();
                resolve(name);
              });
            });
          }
        }
        if (options.hide) {
          $(options.hide.selector).on(options.hide.event, () => {
            $(note).fadeOut(100, () => {
              $(note).remove();
              resolve(true);
            });
          });
        }
      });
    },
  };
};

/* harmony default export */ const Notification = (registerNotifications);

;// CONCATENATED MODULE: ./src/hooks.js



// init hooks





// ready hooks








// monster muncher




// socket messaging


// image hooks










// foundry is initializing
function init() {
  earlySettings();
  setupLogging();
  registerApi();
  chatHooks();
  adventureImporter();
  src_logger/* default.info */.Z.info("Init complete");
}

// foundry is ready
function onceReady() {
  // register the game settings
  registerGameSettings();

  // check for valid compendiums
  checkCompendiums();

  // notificaitons
  Notification();

  // delay the startup just a tiny little bit
  setTimeout(() => {
    // register the D&DBeyond Button on the character sheets
    registerSheets();
    itemSheets();
    checkVersion();
    loadDDBConfig();
    activateUpdateHooks();

  }, 500);

  anchorInjection();
  src_logger/* default.info */.Z.info("OnceReady complete");
}

function onReady() {
  game.socket.on("module.ddb-importer", (data) => {
    if (data.sender === game.user.data._id) {
      return;
    }

    const sender = game.users.get(data.sender);
    delete data.sender;
    onSocketMessage(sender, data);
  });
}

function renderSidebarTab(app, html) {
  addEncounterMuncher(app, html);
  addMuncher(app, html);
}

function renderItemSheet(sheet, html) {
  linkTables("item", html);
  // link images disabled un v10
  // linkImages(html);
}

function renderJournalSheet(sheet, html, data) {
  if (data.cssClass !== "editable") {
    linkTables("journal", html);
    linkImages(html, data);
    showReadAlouds(html, data);
  }
  renderJournalSheet_adventure(sheet, html, data);
}

// EXTERNAL MODULE: ./src/lib/DDBSources.js
var DDBSources = __webpack_require__(5817);
;// CONCATENATED MODULE: ./src/lib/SceneEnhancerExport.js




/**
   * Extracts all notes that have been placed by ddb-importer
   * Creates the expected data structure for the database by
   * getting the real label from the appropriate Journal Entry
   * @param {Scene} scene The scene to extract the notes from
  */
function getNotes(scene, bookCode) {
  // get all notes in the Journal related to this scene
  const relatedJournalEntries = game.journal.filter((journal) =>
    journal.flags.ddb?.bookCode && journal.flags.ddb.bookCode === bookCode
  );

  // get all notes placed on the map
  const journalNotes = scene.notes
    // the user might have placed a note, unless it is based on an imported Journal Entry, we will not carry
    // that one over
    .filter((note) => relatedJournalEntries.some((journal) => journal.id === note.entryId))
    .map((note) => {
      const journal = relatedJournalEntries.find((journal) => journal.id === note.entryId);
      const page = note.pageId
        ? journal.pages.find((page) => page._id === note.pageId)
        : journal;
      const index = parseInt(journal.flags.ddb.ddbId);
      // removed un-needed userdata
      const pageFlags = page.flags.ddb;
      const noteFlags = note.flags.ddb;
      const flags = duplicate(pageFlags);
      mergeObject(flags, noteFlags, { overwrite: true, insertKeys: true, insertValues: true });
      if (flags?.userData) delete flags.userData;
      const label = flags?.labelName && flags.labelName.trim() !== ""
        ? flags.labelName
        : noteFlags?.slugLink && noteFlags.slugLink.trim() !== ""
          ? note.text
          : page.name;

      src_logger/* default.warn */.Z.warn("note details", {
        note,
        page,
        icon: note.texture.src,
        journal,
        flags,
        pageFlags,
        noteFlags,
        label,
      });

      return {
        index,
        pageId: page._id,
        texture: note.texture,
        label,
        flags: {
          ddb: flags,
        },
        iconSize: note.iconSize,
        iconTint: note.iconTint,
        textColor: note.textColor,
        textAnchor: note.textAnchor,
        x: note.x,
        y: note.y,
      };
    })
    .reduce((notes, note) => {
      const idx = notes.find((n) => n.index === note.index && n.pageId === note.pageId && note.label === n.label);
      if (idx) {
        idx.positions.push({ x: note.x, y: note.y });
      } else {
        const n = {
          label: note.label,
          texture: note.texture,
          flags: note.flags,
          index: note.index,
          iconSize: note.iconSize,
          iconTint: note.iconTint,
          textColor: note.textColor,
          textAnchor: note.textAnchor,
          positions: [{ x: note.x, y: note.y }]
        };
        notes.push(n);
      }
      return notes;
    }, [])
    .sort((a, b) => {
      return a.index - b.index;
    });

  const unLinkedNotes = scene.notes
    .filter((note) => !note.entryId)
    .map((note) => ({
      label: note.text,
      texture: note.texture,
      flags: { ddb: {
        noLink: true,
      } },
      iconSize: note.iconSize,
      iconTint: note.iconTint,
      textColor: note.textColor,
      textAnchor: note.textAnchor,
      positions: [{ x: note.x, y: note.y }]
    }));

  const notes = journalNotes.concat(unLinkedNotes)
    .map((note) => ({
      label: note.label,
      flags: note.flags,
      texture: note.texture,
      positions: note.positions,
      iconSize: note.iconSize,
      iconTint: note.iconTint,
      textColor: note.textColor,
      textAnchor: note.textAnchor,
    }));

  return notes;
}

/**
 * Prepares the scene data for download
 * @param {Scene} scene
 */
function collectSceneData(scene, bookCode) {
  const notes = getNotes(scene, bookCode);

  const data = {
    flags: scene.flags,
    background: deepClone(scene.background),
    name: scene.name,
    navName: scene.navName,
    // dimensions
    width: scene.width,
    height: scene.height,
    // grid
    grid: scene.grid,
    padding: scene.padding,
    // initial
    initial: scene.initial,
    // customization
    backgroundColor: scene.backgroundColor,
    walls: scene.walls.map((wall) => {
      const w = wall.toObject();
      delete w._id;
      return w;
    }),
    //
    drawings: scene.drawings,
    weather: scene.weather,
    // lights
    darkness: scene.darkness,
    tokenVision: scene.tokenVision,
    globalLight: scene.globalLight,
    globalLightThreshold: scene.globalLightThreshold,
    lights: scene.lights.map((light) => {
      const l = light.toObject();
      delete l._id;
      return l;
    }),
  };

  delete data.background.src;

  if (!data.flags.ddb) data.flags.ddb = {};
  data.flags.ddb.foundryVersion = game.version;

  if (data.flags.ddb.tokens) delete data.flags.ddb.tokens;
  data.flags.ddb.tokens = scene.tokens
    .filter((token) => !token.actorLink)
    .map((token) => {
      let result = {
        _id: token._id,
        name: token.name,
        width: token.width,
        height: token.height,
        scale: token.scale,
        x: token.x,
        y: token.y,
        disposition: token.disposition,
        flags: token.flags,
        actorLink: false,
        bar1: { attribute: "attributes.hp" },
        effects: [],
        elevation: token.elevation,
        hidden: token.hidden,
        tint: token.tint,
        actorData: token.actorData,
        light: token.light,
      };

      // the token actor flags here help us match up actors using the DDB ID
      if (token.actor) {
        if (token.actor.flags.ddbimporter) {
          result.flags.ddbActorFlags = token.actor.flags.ddbimporter;
          result.flags.ddbActorFlags.name = token.actor.prototypeToken?.name ? token.actor.prototypeToken.name : token.actor.name;
        }
      }

      return result;
    });


  // removed un-needed userdata
  if (data.flags.ddb?.userData) delete data.flags.ddb.userData;

  data.flags.ddb.notes = notes;
  data.flags.ddb.img = `assets/${scene.background.src.split("assets/").pop()}`;

  if (!data.flags.ddbimporter) data.flags.ddbimporter = {};
  data.flags.ddbimporter['version'] = game.modules.get("ddb-importer").version;

  return data;
}

function getCompendiumScenes(compendiumCollection, selectedId = null, selectedName = null) {
  let scenes = [];
  const compendium = game.packs.find((pack) => pack.collection === compendiumCollection);
  if (compendium) {
    compendium.index.forEach((scene) => {
      const option = {
        _id: scene._id,
        name: scene.name,
        selected: (selectedId && selectedId == scene._id) || (selectedName && selectedName.trim().includes(scene.name)),
      };
      scenes.push(option);
    });
  }

  return scenes;
}

const ddbFlags = ["ddb", "ddbimporter"];
const allowedFlags = ["stairways", "perfect-vision", "dynamic-illumination"];

class SceneEnhancerExport extends Application {

  // eslint-disable-next-line complexity
  constructor(scene) {
    super();
    this.sceneSet = false;
    this.compendiumBookSet = false;
    this.downloadBookSet = false;

    this.scene = scene;
    const sceneExportFlags = this.scene.flags.ddbimporter?.export;
    const lastCompendium = localStorage.getItem("ddb-last-compendium");
    const lastBook = localStorage.getItem("ddb-last-book");

    this.description = sceneExportFlags?.description || "";
    this.url = sceneExportFlags?.url || "";
    this.compendium = sceneExportFlags?.compendium ?? lastCompendium;
    this.compendiumSceneId = sceneExportFlags?.scene;
    this.bookCode = this.scene.flags?.ddb?.bookCode.toLowerCase() ?? lastBook;
    this.compendiumScenes = this.compendium ? getCompendiumScenes(this.compendium, this.compendiumSceneId, this.scene.name) : [];

    if (this.compendiumScenes && this.compendiumScenes.some((s) => s.selected === true)) this.sceneSet = true;

    this.compendiums = game.packs
      .filter((pack) => pack.metadata?.type === "Scene")
      .map((pack) => {
        if (this.compendium && this.compendium === pack.collection) pack.selected = true;
        else pack.selected = false;
        return pack;
      })
      .sort((a, b) => a.metadata.label.localeCompare(b.metadata.label));

    const selectedBooks = this.bookCode
      ? CONFIG.DDB.sources.filter((s) => s.name.toLowerCase() === this.bookCode).map((s) => s.id)
      : [];
    this.books = DDBSources/* default.getSourcesLookups */.Z.getSourcesLookups(selectedBooks).map((b) => {
      if (b.selected) {
        this.compendiumBookSet = true;
        this.downloadBookSet = true;
      }
      return {
        code: b.acronym.toLowerCase(),
        name: b.label,
        selected: b.selected,
      };
    }).sort((a, b) => a.name.localeCompare(b.name));

    this.exportOptionsCompendium = {
      actors: sceneExportFlags?.actors !== undefined ? sceneExportFlags.actors : true,
      notes: sceneExportFlags?.notes !== undefined ? sceneExportFlags.notes : true,
      lights: sceneExportFlags?.lights !== undefined ? sceneExportFlags.lights : false,
      walls: sceneExportFlags?.walls !== undefined ? sceneExportFlags.walls : false,
      drawings: sceneExportFlags?.drawings !== undefined ? sceneExportFlags.drawings : false,
      config: sceneExportFlags?.config !== undefined ? sceneExportFlags.config : false,
    };
    this.exportOptionsDownload = {
      actors: sceneExportFlags?.actors !== undefined ? sceneExportFlags.actors : true,
      notes: sceneExportFlags?.notes !== undefined ? sceneExportFlags.notes : true,
      lights: sceneExportFlags?.lights !== undefined ? sceneExportFlags.lights : true,
      walls: sceneExportFlags?.walls !== undefined ? sceneExportFlags.walls : true,
      drawings: sceneExportFlags?.drawings !== undefined ? sceneExportFlags.drawings : true,
      config: sceneExportFlags?.config !== undefined ? sceneExportFlags.config : true,
    };
    this.compendiumDisabled = !this.sceneSet || !this.compendiumBookSet;
    this.downloadDisabled = !this.downloadBookSet || this.url === "" || !this.url.startsWith("http");
  }

  static get defaultOptions() {
    const options = super.defaultOptions;
    options.baseApplication = "SceneEnhancerExport";
    options.id = "ddb-importer-scene-enhancer";
    options.template = "modules/ddb-importer/handlebars/enhance-export.hbs";
    options.width = 500;
    options.resizable = false;
    options.height = "auto";
    options.classes = ["ddb-muncher", "sheet"];
    options.tabs = [{ navSelector: ".tabs", contentSelector: "div", initial: "compendium" }];
    return options;
  }

  get title() {
    return `DDB Importer Scene Enhancer Exporter: ${this.scene.name}`;
  }

  /** @override */
  getData() {
    let templateData = {
      sceneName: this.scene.name,
      compendiums: this.compendiums,
      compendiumScenes: this.compendiumScenes,
      description: this.description,
      books: this.books,
      url: this.url,
      exportOptionsCompendium: this.exportOptionsCompendium,
      exportOptionsDownload: this.exportOptionsDownload,
      compendiumDisabled: this.compendiumDisabled,
      downloadDisabled: this.downloadDisabled,
    };

    return templateData;
  }

  checkState() {
    if (this.sceneSet && this.compendiumBookSet) {
      this.compendiumDisabled = false;
      $("#compendium-button").prop("disabled", false);
    } else {
      $("#compendium-button").prop("disabled", true);
    }
    if (this.downloadBookSet && this.url !== "" && this.url.startsWith("http")) {
      this.downloadDisabled = false;
      $("#download-button").prop("disabled", false);
    } else {
      $("#download-button").prop("disabled", true);
    }
  }

  activateListeners(html) {
    super.activateListeners(html);
    $("#ddb-importer-scene-enhancer").css("height", "auto");

    html.find('#compendium-form').submit(async (event) => {
      const form = document.querySelector('#compendium-form');
      const data = Object.fromEntries(new FormData(form).entries());
      this.buttonClick(event, data);
    });

    html.find('#download-form').submit(async (event) => {
      const form = document.querySelector('#download-form');
      const data = Object.fromEntries(new FormData(form).entries());
      this.buttonClick(event, data);
    });

    html.find("#select-compendium").on("change", async () => {
      const compendiumSelection = html.find("#select-compendium");

      // get selected campaign from html selection
      const compendiumCollection = compendiumSelection[0].selectedOptions[0]
        ? compendiumSelection[0].selectedOptions[0].value
        : undefined;

      let sceneList = "";

      if (compendiumCollection && compendiumCollection !== "") {
        const scenes = getCompendiumScenes(compendiumCollection);
        sceneList = `<option value="">Select...</option>`;
        scenes.forEach((scene) => {
          const selected = scene.selected ? " selected" : "";
          sceneList += `<option value="${scene._id}"${selected}>${scene.name}</option>`;
        });
      }
      const sceneSelection = html.find("#select-scene");
      sceneSelection[0].innerHTML = sceneList;
    });

    html.find("#select-scene").on("change", async () => {
      const sceneSelection = html.find("#select-scene");
      const scene = sceneSelection[0].selectedOptions[0]
        ? sceneSelection[0].selectedOptions[0].value
        : undefined;
      this.sceneSet = scene && scene !== "";
      this.checkState();
    });

    html.find("#select-book-compendium").on("change", async () => {
      const bookSelection = html.find("#select-book-compendium");
      const book = bookSelection[0].selectedOptions[0]
        ? bookSelection[0].selectedOptions[0].value
        : undefined;
      this.compendiumBookSet = book && book !== "";
      this.checkState();
    });

    html.find("#select-book-download").on("change", async () => {
      const bookSelection = html.find("#select-book-download");
      const book = bookSelection[0].selectedOptions[0]
        ? bookSelection[0].selectedOptions[0].value
        : undefined;
      this.downloadBookSet = book && book !== "";
      this.checkState();
    });

    html.find("#download-url").on("change", async () => {
      const bookSelection = html.find("#download-url");
      const url = bookSelection[0].value;
      if (url && url !== "" && url.startsWith("http")) {
        this.url = url;
      }
      this.checkState();
    });

  }


  async buttonClick(event, formData) { // eslint-disable-line class-methods-use-this
    event.preventDefault();

    let sceneFlags = duplicate(this.scene.flags);

    if (!sceneFlags.ddb) sceneFlags.ddb = {};
    if (!sceneFlags.ddbimporter) sceneFlags.ddbimporter = {};
    if (!sceneFlags.ddbimporter.export) sceneFlags.ddbimporter.export = {};

    sceneFlags.ddb["bookCode"] = formData["select-book"];
    localStorage.setItem("ddb-last-book", formData["select-book"]);
    sceneFlags.ddbimporter.export['description'] = formData["description"];
    sceneFlags.ddbimporter.export['actors'] = formData["export-actors"] == "on";
    sceneFlags.ddbimporter.export['notes'] = formData["export-notes"] == "on";
    sceneFlags.ddbimporter.export['lights'] = formData["export-lights"] == "on";
    sceneFlags.ddbimporter.export['walls'] = formData["export-walls"] == "on";
    sceneFlags.ddbimporter.export['drawings'] = formData["export-drawings"] == "on";
    sceneFlags.ddbimporter.export['config'] = formData["export-config"] == "on";

    if (formData["download-url"]) {
      sceneFlags.ddbimporter.export['url'] = formData["download-url"];
    } else {
      sceneFlags.ddbimporter.export['compendium'] = formData["select-compendium"];
      localStorage.setItem("ddb-last-compendium", formData["select-compendium"]);
      sceneFlags.ddbimporter.export['scene'] = formData["select-scene"];
    }

    await this.scene.update({ flags: sceneFlags });

    let sceneData = collectSceneData(this.scene, formData["select-book"]);

    Object.keys(sceneData.flags).forEach((flag) => {
      if (!allowedFlags.includes(flag) && !ddbFlags.includes(flag)) delete sceneData.flags[flag];
    });

    if (formData["export-actors"] !== "on") delete sceneData.flags.ddb.tokens;
    if (formData["export-notes"] !== "on") delete sceneData.flags.ddb.notes;
    if (formData["export-lights"] !== "on") delete sceneData.lights;
    if (formData["export-walls"] !== "on") delete sceneData.walls;
    if (formData["export-drawings"] !== "on") delete sceneData.drawings;
    if (formData["export-config"] !== "on") {
      delete sceneData.navName;
      delete sceneData.width;
      delete sceneData.height;
      delete sceneData.grid;
      delete sceneData.gridDistance;
      delete sceneData.gridType;
      delete sceneData.gridUnits;
      delete sceneData.shiftX;
      delete sceneData.shiftY;
      delete sceneData.padding;
      delete sceneData.weather;
      delete sceneData.darkness;
      delete sceneData.tokenVision;
      delete sceneData.globalLight;
      delete sceneData.globalLightThreshold;
      delete sceneData.backgroundColor;
      delete sceneData.initial;
      Object.keys(sceneData.flags).forEach((flag) => {
        if (!ddbFlags.includes(flag)) delete sceneData.flags[flag];
      });
    }

    src_logger/* default.debug */.Z.debug(sceneData);
    const name = sceneData.name.replace(/[^a-z0-9_-]/gi, '').toLowerCase();
    const sceneRef = `ddb-enhanced-scene-${name}`;
    FileHelper/* default.download */.Z.download(JSON.stringify(sceneData, null, 4), `${sceneRef}.json`, "application/json");

    this.close();
  }
}


;// CONCATENATED MODULE: ./src/hooks/navigationContext/extendSceneNavigationContext.js
// import utils from "../../lib/utils.js";



function getSceneId(li) {
  return $(li).attr("data-document-id")
    ? $(li).attr("data-document-id")
    : $(li).attr("data-scene-id")
      ? $(li).attr("data-scene-id")
      : $(li).attr("data-entity-id");
}

/* harmony default export */ function extendSceneNavigationContext(html, contextOptions) {
  contextOptions.push({
    name: "ddb-importer.scenes.download",
    callback: (li) => {
      const scene = game.scenes.get(getSceneId(li));
      const data = collectSceneData(scene, scene.flags.ddb.bookCode);
      const bookCode = `${scene.flags.ddb.bookCode}-${scene.flags.ddb.ddbId}`;
      const cobaltId = scene.flags.ddb?.cobaltId ? `-${scene.flags.ddb.cobaltId}` : "";
      const parentId = scene.flags.ddb?.parentId ? `-${scene.flags.ddb.parentId}` : "";
      const contentChunkId = scene.flags.ddb?.contentChunkId ? `-${scene.flags.ddb.contentChunkId}` : "";
      const name = scene.name.replace(/[^a-z0-9_-]/gi, '').toLowerCase();
      const sceneRef = `${bookCode}${cobaltId}${parentId}${contentChunkId}-${name}`;
      return FileHelper/* default.download */.Z.download(JSON.stringify(data, null, 4), `${sceneRef}-scene.json`, "application/json");
    },
    condition: (li) => {
      const scene = game.scenes.get(getSceneId(li));
      const sceneDownload = game.settings.get("ddb-importer", "allow-scene-download");
      const allowDownload = game.user.isGM && sceneDownload && scene.flags.ddb?.ddbId;
      return allowDownload;
    },
    icon: '<i class="fas fa-share-alt"></i>',
  });

  contextOptions.push({
    name: "ddb-importer.scenes.third-party-download",
    callback: (li) => {
      const scene = game.scenes.get(getSceneId(li));
      new SceneEnhancerExport(scene).render(true);
    },
    condition: (li) => {
      const scene = game.scenes.get(getSceneId(li));
      const sceneDownload = game.settings.get("ddb-importer", "allow-third-party-scene-download");
      const allowDownload = game.user.isGM && sceneDownload && !scene.flags.ddb?.ddbId;
      return allowDownload;
    },
    icon: '<i class="fas fa-share-alt"></i>',
  });
}

;// CONCATENATED MODULE: ./src/index.js



// register hooks
Hooks.once("init", init);
Hooks.once("ready", onceReady);
Hooks.on("ready", onReady);
Hooks.on("renderSidebarTab", renderSidebarTab);
Hooks.on("renderJournalPageSheet", renderJournalSheet);
Hooks.on("renderItemSheet", renderItemSheet);
Hooks.on("getSceneNavigationContext", extendSceneNavigationContext);
Hooks.on("getSceneDirectoryEntryContext", extendSceneNavigationContext);

// console.warn("SILENT MODE FOR DEBUG");
// const includeRgx = new RegExp("/module/ddb-importer/");
// CONFIG.compatibility.includePatterns.push(includeRgx);

})();

/******/ })()
;
//# sourceMappingURL=main.js.map