{"name":"Rage","type":"script","scope":"global","author":"f7l9snMm7E9laH98","img":"icons/svg/explosion.svg","command":"//\t\tDISCLAIMER:\t\tThis macro is an evolved version of the original D&D 5e Rage Macro masterwork written by Felix#6196.\n//\t\t\t\t\t\tNorc#5108 is now maintaining this macro along with continued support from Felix.\n//\n//\n//\t\tUPDATES:\t\t1.\tFixed errors resulting from declarations of \"actor\" and \"token\" in a script macro. \n//\t\t\t\t\t\t\tAdded automatic Totem Spirit: Bear detection and resistance application \n//\t\t\t\t\t\t\tAdded error messages for trying to rage with no token or no barbarian selected\n//\t\t\t\t\t\t2.\t(Felix) Added resource/usage deduction and errors (re-added after accidentally overwriting the addition)\n//\t\t\t\t\t\t\tFixed rage damage at level 8\n//\t\t\t\t\t\t3.\t(2020/05/30) \"Version 2.0\" \t\n//\t\t\t\t\t\t\tImplemented Felix's idea to use global melee weapon attack bonus instead of modifying items\n//\t\t\t\t\t\t\tImproved Rage icon toggling to be more reliable\n//\t\t\t\t\t\t\tRemoved code from the resource management that created dependency on The Furnace Advanced Macros\n//\t\t\t\t\t\t\tImplemented Felix's fix for issue where new resistances and rage uses were not saving properly\n//\t\t\t\t\t\t\tFixed rage damage formula again...\n//\t\t\t\t\t\t\tAdded basic support for non-strength Based barbarians (Dex, Hexblade)\n//\t\t\t\t\t\t\tAdded optional ability to toggle the icon and name of the macro itself based on current raging state.\n//\t\t\t\t\t\t4.\t(2020/06/04) \n//\t\t\t\t\t\t\tFixed bug with experimental macro name/icon toggle only by renaming \"actor\" and \"token\"\n//\t\t\t\t\t\t\tAdded basic localization support to allow searching for translated class features\n//\t\t\t\t\t\t5.\t(2020/06/10)\n//\t\t\t\t\t\t\tRework to rage damage logic under the hood for edge case (other changes to bonus damage mid-combat) \n//\t\t\t\t\t\t\tRemoved logic that was causing multiple character sheets to open in some cases\n//\t\t\t\t\t\t\tEnhanced localization support\n\n//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n//!!!   Bonus Tip 1: \t\tOptional Rage Resource Consumption\n//!!!\tTo automatically use and track Rage, you must have a resource exactly named \"Rage\" on your character sheet. This text can be changed\n//!!!\tby altering the value for \"rageResourceName\" in the LOCALIZATION SUPPORT section below).\n//!!!\tNote: \tImporting via VTTA Beyond Integration uses this text already. The macro can then automatically detect the Rage resource.\n//!!!\n//!!!\tBonus Tip 2: \t\tBear Totem Spirit Barbs\n//!!!\tIf you chose the Spirit Seeker Primal path, and at level 3 you chose the Bear Totem Spirit (resistance to all non-psychic damage), \n//!!!\tin your 5E character sheet, double-check that the name of your Totem Spirit feature to EXACTLY \"Totem Spirit: Bear\". This text can be\n//!!!\tchanged by altering the value for \"bearTotemFeatureName\" in the LOCALIZATION SUPPORT section below).\n//!!!\tNote: \tImporting via VTTA Beyond Integration uses this text already. The macro then automatically adds the extra \n//!!!\t\t\tBear Totem Spirit resistances.\n//!!!\n//!!!\tBonus Tip 3: \t\tThrown Weapons\n//!!!\tWhen a barb throws a weapon using strength, typically a javelin but also possibly a dagger, dart, sword, bar table etc, the rage bonus\n//!!!\tshould not be added because it is a ranged attack. However, D&D5E calls javelins and daggers Melee Weapons, because technically they\n//!!!\tare both. To solve this issue, if you always throw the weapon, click the weapon's details and change the attack type to \"Ranged Weapon\n//!!!\tAttack\" in the Action Type dropdown. If you want, you can add a second copy of the item (with no weight/quantity) to use for meleeing.\n//!!!\n//!!!\tBonus Tip 4: \t\tThe Rage Condition\n//!!!\tIf you use the Combat Utility Belt module's Condition Lab, try adding a condition called \"Raging\" with the same icon\n//!!!\tas the optional rage icon overlay, 'icons/svg/explosion.svg' by default.  See EXPERIMENTAL MACRO ICON/NAME TOGGLE section below.\n//!!!\n//!!!\tBonus Tip 5: \t\tObsidian Sheet Compatibility\n//!!!\tIf using Obsidian module, try replacing \"Barbarian\" with \"brb\" as the barbClassName value in LOCALIZATION SUPPORT below.\n//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n//!!!\tOPTIONAL TOKEN ICON-\tOn by default. If a path to a rage icon is defined, it displays like a condition on the raging barbarian.\n//!!!\t\t\t\t\t\t\tTo use a different icon, manually change the filepath below or leave it empty ('') to disable the effect.\n//!!!\nconst rageIconPath = 'icons/svg/explosion.svg';\n//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n//!!!\tOPTIONAL RESOURCE DEDUCTION \tOn by default. First option automatically subtracts from the Rage Resource if enabled.\n//!!!\t\t\t\t\t\t\t\t\tSecond option prevents raging if no Rage resource is left. Set to false if you do not want this.\n\n\t\t\tconst deductResource = true;\n\t\t\tconst preventNegativeResource = true;\n//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n//!!!\tOPTIONAL NON-STRENGTH BARBARIAN SUPPORT\t\tONLY override to FALSE if your barbarian does not use Strength to make melee attacks\n//!!!\t\t\t\t\t\t\t\t\t\t\t\tand therefore does not get the Rage bonus to melee weapon attack damage.\n//!!!\n\t\t\tconst strAttacks = true;\n//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n//!!!\tEXPERIMENTAL MACRO ICON/NAME TOGGLE\t\tIf enabled, the macro icon and name toggles based on the barbarian's rage state.\n//!!!\t\t\t\t\t\t\t\t\t\t\tCAUTIONS: \t1. \tThis feature is off by default and is intended for ADVANCED USERS ONLY.\n//!!!\t\t\t\t\t\t\t\t\t\t\t\t\t\t2. \tRequires configuration using \"The Furnace\" module for a player to run!\n//!!!\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tThe GM needs to grant The Furnace's \"Run as GM\" permission for this macro.\n//!!!\t\t\t\t\t\t\t\t\t\t\t\t\t\t3. \tWorks best with only one barbarian using this feature at a time.\n\n\t\t\t//To auto-toggle the macro's icon/name, override toggleMacro to true below.\n\t\t\tconst toggleMacro = false;\n\n\t\t\t//To use a different icon, manually change the filepath here\n\t\t\tconst stopRageIconPath = 'icons/svg/unconscious.svg';\n\n\t\t\t//You must update the following constant to this macro's exact name for the macro icon toggling to work.\n\t\t\tconst rageMacroName = 'Rage';\n//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n//declarations\nlet barb = '';\nlet chatMsg = '';\nlet bear = '';\nlet noRage = false;\nlet rageDmgAdded = false;\nlet toggleResult = false;\nlet macroActor = actor;\nlet macroToken = token;\n\n//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n//!!!\tLOCALIZATION SUPPORT\t\t\t\tSets names of D&D5E features as constants instead of hardcoding to allow easier translation.\n//!!!\t\t\t\t\t\t\t\t\t\tSets error messages and flavor text as constants also for easier translation.\n//!!!\n\t\t\t//MUST MATCH VALUES IN CHARACTER SHEET (if present)\n\t\t\tconst barbClassName = 'Barbarian';\n\t\t\tconst rageResourceName = 'Rage';\n\t\t\tconst bearTotemFeatureName = 'Totem Spirit: Bear';\n\n\t\t\t//All remaining values may be changed freely\n\n\t\t\t//Rage chat message flavor text. Actor's name appears immediately before these two strings in the message.\n\t\t\tconst rageMsg = ' is RAAAAAGING!'\n\t\t\tconst endRageMsg =  ' is no longer raging.';\n\n\t\t\t//error and warning messages\n\t\t\tconst errorSelectBarbarian = 'Please select a single barbarian token.';\n\t\t\tconst errorNoRage = ' does not have any rage left, time for a long rest!';\n\t\t\tconst warnMacroNotFound = ' is not a valid macro name, please fix. Rage toggle successful but unable to alter macro.';\n\t\t\tconst errorSelectToken = 'Please select a token.';\n\t\t\tconst errorFailRevert = 'Failed to revert global melee weapon attack bonus, please check manually.';\n//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n\n//main\n//check to see if Actor exists and is a barbarian\nif (macroActor !== undefined && macroActor !== null) {\n\n\t// get the barbarian class item\n\tbarb = macroActor.items.find(i => i.name === `${barbClassName}`);\n\tif (barb == undefined) {\n\t\tui.notifications.warn(`${errorSelectBarbarian}`);\n\t}\n\tif (barb !== undefined && barb !== null) {\n\t\tlet enabled = false;\n\t\t// Store the state of the rage toggle flags that indicate if rage is active or not\n\t\tif (macroActor.data.flags.rageMacro !== null && macroActor.data.flags.rageMacro !== undefined) {\n\t\t\tenabled = true;\n\t\t\t\t// Store whether there is also a rage damage bonus currently active\n\t\t\t\tif (macroActor.data.flags.rageMacro[\"rageDmgAdded\"] == true) {\n\t\t\t\t\trageDmgAdded = true;\n\t\t\t\t}\n\t\t}\n\n\t\t//Calculate rage value for use in damage reversion and application\n\t\t// Determining the barbarian level\n\t\tlet barblvl = barb.data.data.levels;\n\n\t\t// Formula to determine the rage bonus damage depending on barbarian level\n\t\tlet lvlCorrection =  barblvl === 16 || barblvl === 17 ? 1 : 0;\n\t\tlet rageDmg = 2 + Math.floor(barblvl / 9) + lvlCorrection;\n\t\tlet dmg = JSON.parse(JSON.stringify(macroActor.data.data.bonuses.mwak.damage));\n\n\t\t// if rage is active, disable it\n\t\tif (enabled) {\n\t\t\tchatMsg = `${macroActor.name} ${endRageMsg}`;\n\t\t\t// reset resistances and melee weapon attack bonus\n\t\t\tlet obj = {};\n\t\t\tobj['flags.rageMacro'] = null;\n\t\t\t//revert damage resistances\n\t\t\tobj['data.traits.dr'] = macroActor.data.flags.rageMacro.oldResistances;\n\n\t\t\t//carefully revert rage global mwak damage bonus to original value, if that bonus is active\n\t\t\t//eventually want to add support so only last instance found is replaced.\n\t\t\tif(rageDmgAdded) {\n\t\t\t\tif (dmg == rageDmg || dmg == null || dmg == undefined || dmg == '' || dmg == 0){\n\t\t\t\t\tconsole.log('Removing simple rage damage');\n\t\t\t\t\tobj['data.bonuses.mwak.damage']='';\n\t\t\t\t} else {\n\t\t\t\t\tconsole.log('Removing complex rage damage');\n\t\t\t\t\tlet patt = `\\\\s\\\\+\\\\s${rageDmg}($|[^0123456789dkrxcm(@{])`;\n\t\t\t\t\tlet result = dmg.search(patt);\n\t\t\t\t\tif (result !== -1) {\n\t\t\t\t\t\tlet len = ('' + rageDmg).length;\n\t\t\t\t\t\tlet origDmg = duplicate(dmg);\n\t\t\t\t\t\tlet firstHalfDmg = duplicate(dmg).substring(0,result);\n\t\t\t\t\t\t//Test String: 2d6 + 2 + 2d6\n\t\t\t\t\t\tlet lastHalfDmg = duplicate(dmg).substring(result+3+len, origDmg.length);\n\t\t\t\t\t\tdmg = `${firstHalfDmg}${lastHalfDmg}`;\n\t\t\t\t\t\tobj['data.bonuses.mwak.damage']=dmg;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tui.notifications.error(`${errorFailRevert}`);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tmacroActor.update(obj);\n\n\t\t// if rage is disabled, enable it\n\t\t} else {\n\t\t\tif (deductResource) {\n\t\t\t\tlet hasAvailableResource = false;\n\t\t\t\tlet newResources = duplicate(macroActor.data.data.resources)\n\t\t\t\tlet obj = {}\n\t\t\t\t// Look for Resources under the Core macroActor data\n\t\t\t\tlet resourceKey = Object.keys(macroActor.data.data.resources).filter(k => macroActor.data.data.resources[k].label === `${rageResourceName}`).shift();\n\t\t\t\tif (resourceKey && (macroActor.data.data.resources[resourceKey].value > 0 || !preventNegativeResource)) {\n\t\t\t\t\thasAvailableResource = true;\n\t\t\t\t\tnewResources[resourceKey].value--;\n\t\t\t\t\tobj['data.resources'] = newResources \n\t\t\t\t\tmacroActor.update(obj);\n\t\t\t\t}\n\t\t\t\tif (!hasAvailableResource) {\n\t\t\t\t\tui.notifications.error(`${macroActor.name} ${errorNoRage}`);\n\t\t\t\t\tnoRage=true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//activate rage if there is rage available, or if it is okay to rage with 0 resources\n\t\t\tif (!noRage) {\n\t\t\t\tchatMsg = `${macroActor.name} ${rageMsg}`;\n\t\t\t\t// update resistance\n\t\t\t\tlet obj = {};\n\t\t\t\t// storing old resistances in flags to restore later\n\t\t\t\tobj['flags.rageMacro.enabled'] = true;\n\t\t\t\tobj['flags.rageMacro.oldResistances'] = JSON.parse(JSON.stringify(macroActor.data.data.traits.dr));\n\t\t\t\t// add bludgeoning, piercing and slashing resistance\n\t\t\t\tlet newResistance = duplicate(macroActor.data.data.traits.dr);\n\t\t\t\tif (newResistance.value.indexOf('bludgeoning') === -1) newResistance.value.push('bludgeoning');\n\t\t\t\tif (newResistance.value.indexOf('piercing') === -1) newResistance.value.push('piercing');\n\t\t\t\tif (newResistance.value.indexOf('slashing') === -1) newResistance.value.push('slashing');\n\t\t\t\t//If bear totem, add bear totem resistances.\n\t\t\t\tbear = macroActor.items.find(i => i.name === `${bearTotemFeatureName}`)\n\t\t\t\tif (bear !== undefined && bear!== null) {\n\t\t\t\t\tif (newResistance.value.indexOf('acid') === -1) newResistance.value.push('acid');\n\t\t\t\t\tif (newResistance.value.indexOf('cold') === -1) newResistance.value.push('cold');\n\t\t\t\t\tif (newResistance.value.indexOf('fire') === -1) newResistance.value.push('fire');\n\t\t\t\t\tif (newResistance.value.indexOf('force') === -1) newResistance.value.push('force');\n\t\t\t\t\tif (newResistance.value.indexOf('lightning') === -1) newResistance.value.push('lightning');\n\t\t\t\t\tif (newResistance.value.indexOf('necrotic') === -1) newResistance.value.push('necrotic');\n\t\t\t\t\tif (newResistance.value.indexOf('poison') === -1) newResistance.value.push('poison');\n\t\t\t\t\tif (newResistance.value.indexOf('radiant') === -1) newResistance.value.push('radiant');\n\t\t\t\t\tif (newResistance.value.indexOf('thunder') === -1) newResistance.value.push('thunder');\n\t\t\t\t}\n\t\t\t\tobj['data.traits.dr'] = newResistance;\n\t\t\t\tmacroActor.update(obj);\n\n\t\t\t\t// For Strength barbarians, update global melee weapon attack bonus to include rage bonus\n\t\t\t\tif (strAttacks) {\n\t\t\t\t\tobj['flags.rageMacro.rageDmgAdded'] = true;\n\t\t\t\t\t// Preserve old mwak damage bonus if there was one, just in case\n\t\t\t\t\tobj['flags.rageMacro.oldDmg'] = JSON.parse(JSON.stringify(dmg));\n\t\t\t\t\t//actually add the bonus rage damage to the previous bonus damage\n\t\t\t\t\t//respect roll formulas by doing string addition if value is already present.\n\t\t\t\t\tif (dmg == null || dmg == undefined || dmg == 0 || dmg == '') {\n\t\t\t\t\t\tconsole.log('Adding simple rage damage');\n\t\t\t\t\t\tobj['data.bonuses.mwak.damage'] = rageDmg;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.log('Adding complex rage damage');\n\t\t\t\t\t\tobj['data.bonuses.mwak.damage'] = `${dmg} + ${rageDmg}`;\n\t\t\t\t\t}\n\t\t\t\t\tmacroActor.update(obj);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!noRage) {\n\t\t\t// toggle rage icon, if rage path is defined above\n\t\t\t(async () => { \n\t\t\t\ttoggleResult = await macroToken.toggleEffect(rageIconPath);\n\t\t\t\tif (toggleResult == enabled) macroToken.toggleEffect(rageIconPath);  \n\t\t\t})();\n\t\t\t\n\t\t\t//toggle macro icon and name, if macro name is correct and stop rage icon path is defined\n\t\t\tlet rageMacro = game.macros.getName(rageMacroName);\n\t\t\t\t//check for name of macro in its \"off\" form\n\t\t\t\tif (rageMacro == null || rageMacro == undefined) {\n\t\t\t\t\trageMacro = game.macros.getName('Stop ' + rageMacroName);\n\t\t\t\t}\n\t\t\tlet obj = {};\n\t\t\tif ( (rageMacro !== null && rageMacro !== undefined) && toggleMacro == true && \n\t\t\t\t\t+ (stopRageIconPath !== null && stopRageIconPath !== undefined && stopRageIconPath !== '') ) {\n\t\t\t\tif (enabled) {\n\t\t\t\t  obj['img'] = rageIconPath;\n\t\t\t\t  obj['name'] = rageMacroName;\n\t\t\t\t} else {\n\t\t\t\t  obj['img'] = stopRageIconPath;\n\t\t\t\t  obj['name'] = 'Stop ' + rageMacroName;\n\t\t\t\t}\n\t\t\t\trageMacro.update(obj);\n\t\t\t} else {\n\t\t\tif (toggleMacro == true) ui.notifications.warn(`${rageMacroName} ${warnMacroNotFound}`);\n\t\t\t}\n\t\t}\n\t}\n} else ui.notifications.warn(errorSelectToken);\n// write to chat if needed:\nif (chatMsg !== '') {\n\tlet chatData = {\n\t\tuser: game.user._id,\n\t\tspeaker: ChatMessage.getSpeaker(),\n\t\tcontent: chatMsg\n\t};\n\tChatMessage.create(chatData, {});\n}","folder":null,"sort":0,"ownership":{"default":0,"f7l9snMm7E9laH98":3},"flags":{},"_stats":{"systemId":"dnd5e","systemVersion":"2.1.5","coreVersion":"10.291","createdTime":1677879640766,"modifiedTime":1677879654241,"lastModifiedBy":"f7l9snMm7E9laH98"},"_id":"48HUXAqJhabKFRnI"}
{"name":"New Macro","type":"chat","scope":"global","author":"nS0HD1eC0cney1Lj","img":"icons/svg/dice-target.svg","command":"","folder":null,"sort":0,"ownership":{"default":0,"nS0HD1eC0cney1Lj":3},"flags":{},"_stats":{"systemId":"dnd5e","systemVersion":"2.1.4","coreVersion":"10.291","createdTime":1676062511276,"modifiedTime":1676062511276,"lastModifiedBy":"nS0HD1eC0cney1Lj"},"_id":"4FO8XW1rpWmLmUND"}
{"name":"New Macro","type":"chat","scope":"global","author":"nS0HD1eC0cney1Lj","img":"icons/svg/dice-target.svg","command":"","folder":null,"sort":0,"ownership":{"default":0,"nS0HD1eC0cney1Lj":3},"flags":{},"_stats":{"systemId":"dnd5e","systemVersion":"2.1.4","coreVersion":"10.291","createdTime":1676062510918,"modifiedTime":1676062510918,"lastModifiedBy":"nS0HD1eC0cney1Lj"},"_id":"86U0LzT6lvPeL9L7"}
{"name":"New Macro","type":"chat","scope":"global","author":"08RzcAqYAeDQxYQr","img":"icons/svg/dice-target.svg","command":"","folder":null,"sort":0,"ownership":{"default":0,"08RzcAqYAeDQxYQr":3},"flags":{},"_stats":{"systemId":"dnd5e","systemVersion":"2.1.5","coreVersion":"10.291","createdTime":1677878220078,"modifiedTime":1677878220078,"lastModifiedBy":"08RzcAqYAeDQxYQr"},"_id":"9Uj4bBRdTodKLzEN"}
{"name":"Active Aura Damage On Entry (Generic)","type":"script","img":"icons/svg/dice-target.svg","scope":"global","command":"if(!game.modules.get(\"ActiveAuras\")?.active) {\n  ui.notifications.error(\"ActiveAuras is not enabled\");\n  return;\n}\n\nconsole.warn(args)\n\nconst lastArg = args[args.length - 1];\n\nfunction getCantripDice(actor) {\n  const level = actor.type === \"character\" ? actor.system.details.level : actor.system.details.cr;\n  return 1 + Math.floor((level + 1) / 6);\n}\n\nasync function rollItemDamage(targetToken, itemUuid, itemLevel) {\n  const item = await fromUuid(itemUuid);\n  const caster = item.parent;\n  const ddbEffectFlags = item.flags.ddbimporter.effect;\n  const isCantrip = ddbEffectFlags.isCantrip;\n  const damageDice = ddbEffectFlags.dice;\n  const damageType = ddbEffectFlags.damageType;\n  const saveAbility = ddbEffectFlags.save;\n  const casterToken = canvas.tokens.placeables.find((t) => t.actor?.uuid === caster.uuid);\n  const scalingDiceArray = item.system.scaling.formula.split(\"d\");\n  const scalingDiceNumber = itemLevel - item.system.level;\n  const upscaledDamage =  isCantrip\n    ? `${getCantripDice(caster.data)}d${scalingDiceArray[1]}[${damageType}]`\n    : scalingDiceNumber > 0 ? `${scalingDiceNumber}d${scalingDiceArray[1]}[${damageType}] + ${damageDice}` : damageDice;\n\n  const workflowItemData = duplicate(item.data);\n  workflowItemData.system.target = { value: 1, units: \"\", type: \"creature\" };\n  workflowItemData.system.save.ability = saveAbility;\n  workflowItemData.system.components.concentration = false;\n  workflowItemData.system.level = itemLevel;\n  workflowItemData.system.duration = { value: null, units: \"inst\" };\n  workflowItemData.system.target = { value: null, width: null, units: \"\", type: \"creature\" };\n\n  setProperty(workflowItemData, \"flags.itemacro\", {});\n  setProperty(workflowItemData, \"flags.midi-qol\", {});\n  setProperty(workflowItemData, \"flags.dae\", {});\n  setProperty(workflowItemData, \"effects\", []);\n  delete workflowItemData._id;\n\n  const saveOnEntry = ddbEffectFlags.saveOnEntry;\n  console.warn(\"saveOnEntry\", {ddbEffectFlags, saveOnEntry});\n  if (saveOnEntry) {\n    const entryItem = new CONFIG.Item.documentClass(workflowItemData, { parent: caster });\n    console.warn(\"Saving item on entry\", {entryItem, targetToken});\n    const options = {\n      showFullCard: false,\n      createWorkflow: true,\n      targetUuids: [targetToken.document.uuid],\n      configureDialog: false,\n      versatile: false,\n      consumeResource: false,\n      consumeSlot: false,\n    };\n    await MidiQOL.completeItemRoll(entryItem, options);\n  } else {\n    const damageRoll = await new Roll(upscaledDamage).evaluate({ async: true });\n    if (game.dice3d) game.dice3d.showForRoll(damageRoll);\n\n    workflowItemData.name = `${workflowItemData.name}: Turn Entry Damage`;\n    // console.warn(\"workflowItemData\", workflowItemData);\n\n    await new MidiQOL.DamageOnlyWorkflow(\n      caster,\n      casterToken,\n      damageRoll.total,\n      damageType,\n      [targetToken],\n      damageRoll,\n      {\n        flavor: `(${CONFIG.DND5E.damageTypes[damageType]})`,\n        itemCardId: \"new\",\n        itemData: workflowItemData,\n        isCritical: false,\n      }\n    );\n  }\n\n}\n\nasync function attachSequencerFileToTemplate(templateUuid, sequencerFile, originUuid) {\n  if (game.modules.get(\"sequencer\")?.active) {\n    if (Sequencer.Database.entryExists(sequencerFile)) {\n      console.debug(\"Trying to apply sequencer effect\", {sequencerFile, templateUuid});\n      const template = await fromUuid(templateUuid);\n      new Sequence()\n      .effect()\n        .file(Sequencer.Database.entryExists(sequencerFile))\n        .size({\n          width: canvas.grid.size * (template.data.width / canvas.dimensions.distance),\n          height: canvas.grid.size * (template.data.width / canvas.dimensions.distance),\n        })\n        .persist(true)\n        .origin(originUuid)\n        .belowTokens()\n        .opacity(0.5)\n        .attachTo(template, { followRotation: true })\n        .stretchTo(template, { attachTo: true})\n      .play();\n    }\n  }\n}\n\nif (args[0].tag === \"OnUse\" && args[0].macroPass === \"preActiveEffects\") {\n  const safeName = lastArg.itemData.name.replace(/\\s|'|\\.|’/g, \"_\");\n  const dataTracker = {\n    randomId: randomID(),\n    targetUuids: lastArg.targetUuids,\n    startRound: game.combat.round,\n    startTurn: game.combat.turn,\n    spellLevel: lastArg.spellLevel,\n  };\n\n  const item = await fromUuid(lastArg.itemUuid);\n  await DAE.unsetFlag(item, `${safeName}Tracker`);\n  await DAE.setFlag(item, `${safeName}Tracker`, dataTracker);\n\n  const ddbEffectFlags = lastArg.item.flags.ddbimporter?.effect;\n\n  if (ddbEffectFlags) {\n    const sequencerFile = ddbEffectFlags.sequencerFile;\n    if (sequencerFile) {\n      attachSequencerFileToTemplate(lastArg.templateUuid, sequencerFile, lastArg.itemUuid)\n    }\n    if (ddbEffectFlags.isCantrip) {\n      const cantripDice = getCantripDice(lastArg.actor);\n      args[0].spellLevel = cantripDice;\n      ddbEffectFlags.cantripDice = cantripDice;\n      let newEffects = args[0].item.effects.map((effect) => {\n        effect.changes = effect.changes.map((change) => {\n          change.value = change.value.replace(\"@cantripDice\", cantripDice)\n          return change;\n        });\n        return effect;\n      });\n      args[0].item.effects = duplicate(newEffects);\n      args[0].itemData.effects = duplicate(newEffects);\n    }\n    const template = await fromUuid(lastArg.templateUuid);\n    await template.update({\"flags.effect\": ddbEffectFlags});\n  }\n\n  return await AAhelpers.applyTemplate(args);\n\n} else if (args[0] == \"on\") {\n  const safeName = lastArg.efData.label.replace(/\\s|'|\\.|’/g, \"_\");\n  const item = await fromUuid(lastArg.efData.origin);\n  const targetItemTracker = DAE.getFlag(item.parent, `${safeName}Tracker`);\n  const originalTarget = targetItemTracker.targetUuids.includes(lastArg.tokenUuid);\n  const target = canvas.tokens.get(lastArg.tokenId);\n  const targetTokenTrackerFlag = DAE.getFlag(target, `${safeName}Tracker`);\n  const targetedThisCombat = targetTokenTrackerFlag && targetItemTracker.randomId === targetTokenTrackerFlag.randomId;\n  const targetTokenTracker = targetedThisCombat\n    ? targetTokenTrackerFlag\n    : {\n      randomId: targetItemTracker.randomId,\n      round: game.combat.round,\n      turn: game.combat.turn,\n      hasLeft: false,\n    };\n\n  const castTurn = targetItemTracker.startRound === game.combat.round && targetItemTracker.startTurn === game.combat.turn;\n  const isLaterTurn = game.combat.round > targetTokenTracker.round || game.combat.turn > targetTokenTracker.turn;\n\n  // if:\n  // not cast turn, and not part of the original target\n  // AND one of the following\n  // not original template and have not yet had this effect applied this combat OR\n  // has been targeted this combat, left and re-entered effect, and is a later turn\n  if (castTurn && originalTarget) {\n    console.debug(`Token ${target.name} is part of the original target for ${item.name}`);\n  } else if (!targetedThisCombat || (targetedThisCombat && targetTokenTracker.hasLeft && isLaterTurn)){\n    console.debug(`Token ${target.name} is targeted for immediate damage with ${item.name}, using the following factors`, { originalTarget, castTurn, targetedThisCombat, targetTokenTracker, isLaterTurn });\n    targetTokenTracker.hasLeft = false;\n    await rollItemDamage(target, lastArg.efData.origin, targetItemTracker.spellLevel);\n  }\n  await DAE.setFlag(target, `${safeName}Tracker`, targetTokenTracker);\n} else if (args[0] == \"off\") {\n  const safeName = lastArg.efData.label.replace(/\\s|'|\\.|’/g, \"_\");\n  const target = canvas.tokens.get(lastArg.tokenId);\n  const targetTokenTracker = DAE.getFlag(target, `${safeName}Tracker`);\n\n  if (targetTokenTracker) {\n    targetTokenTracker.hasLeft = true;\n    targetTokenTracker.turn = game.combat.turn;\n    targetTokenTracker.round = game.combat.round;\n    await DAE.setFlag(target, `${safeName}Tracker`, targetTokenTracker);\n  }\n}","folder":"Bg8VhG8e87b0cRw5","flags":{"advanced-macros":{"runAsGM":false}},"author":"gRbX7wsbHXsd3tee","sort":0,"ownership":{"default":0,"gRbX7wsbHXsd3tee":3},"_stats":{"systemId":"dnd5e","systemVersion":"2.1.4","coreVersion":"10.291","createdTime":1675611320272,"modifiedTime":1675611320272,"lastModifiedBy":"gRbX7wsbHXsd3tee"},"_id":"AWiH0QuUFdsGhcpV"}
{"name":"Mockery","type":"script","scope":"global","author":"f7l9snMm7E9laH98","img":"icons/svg/mystery-man.svg","command":"// Courtesy of @Zarek\n// Selected target receives a random cutting word from a table called \"Mockeries\" along with the roll reduction.\n// You can find a mockeries table in the community table module.\n\nlet cuttingWords = async () => {\n  // Setup variables\n  let tableName = \"mockeries\";\n  let mockery = \"Now go away or I shall taunt you a second time-a!\"; // if table can't be found, use this.\n\n  if (!actor) {\n    ui.notifications.warn(\"You must have an actor selected.\");\n    return\n  }\n\n  let actorLevels = actor.data.data.levels || 1;\n  let table = game.tables.contents.find(t => t.name == tableName);\n  // Get Targets name\n  const targetId = game.user.targets.ids[0];\n  const targetToken = canvas.tokens.get(targetId);\n  if (!targetToken) {\n    ui.notifications.warn(\"You must target a token.\");\n    return\n  }\n  const targetName = targetToken.name;\n\n  // Roll the result, and mark it drawn\n  if (table) {\n    if (checkTable(table)) {\n      let roll = await table.roll();\n      let result = roll.results[0];\n      mockery = result.data.text;\n      await table.updateEmbeddedDocuments(\"TableResult\", [{\n        _id: result.id,\n        drawn: true\n      }]);\n    }\n  }\n\n  function checkTable(table) {\n    let results = 0;\n    for (let data of table.data.results) {\n      if (!data.drawn) {\n        results++;\n      }\n    }\n    if (results < 1) {\n      table.reset();\n      ui.notifications.notify(\"Table Reset\")\n      return false\n    }\n    return true\n  }\n\n  let dieType = 'd6';\n  if (actorLevels >= 15) {\n    dieType = 'd12';\n  } else if (actorLevels >= 10) {\n    dieType = 'd10';\n  } else if (actorLevels >= 5) {\n    dieType = 'd8';\n  }\n\n  let messageContent = `<p>${targetName} Reduce your roll by: <b>[[1${dieType}]]</b>.</p>`\n  messageContent += `<p>${token.name} exclaims <b><i>\"${mockery}\"</i></b></p>`\n  messageContent += `<details closed=\"\"><summary><a>Cutting Words</a></summary>\n  <p>When a creature that you can see within 60 feet of you makes an <b>Attack roll, an ability check, or a damage roll</b>, you can use your <b>Reaction</b> to expend one of your uses of <b>Bardic Inspiration</b>,\n  rolling a Bardic Inspiration die and subtracting the number rolled from the creature’s roll.</p>\n  <p>You can choose to use this feature after the creature makes its roll, but before the GM determines whether the Attack roll or ability check succeeds or fails, or before the creature deals its damage. \n  The creature is immune if it can’t hear you or if it’s immune to being <b>Charmed</b>.</p></details>`\n\n  // create the message\n  if (messageContent !== '') {\n    let chatData = {\n      user: game.user.id,\n      speaker: ChatMessage.getSpeaker(),\n      content: messageContent,\n    };\n    ChatMessage.create(chatData, {});\n  }\n};\n\ncuttingWords();","folder":null,"sort":0,"ownership":{"default":0,"f7l9snMm7E9laH98":3},"flags":{},"_stats":{"systemId":"dnd5e","systemVersion":"2.1.5","coreVersion":"10.291","createdTime":1677880012898,"modifiedTime":1677880031989,"lastModifiedBy":"f7l9snMm7E9laH98"},"_id":"AfVQDiGXjRQ99HJD"}
{"name":"New Macro","type":"chat","scope":"global","author":"f7l9snMm7E9laH98","img":"icons/svg/dice-target.svg","command":"","folder":null,"sort":0,"ownership":{"default":0,"f7l9snMm7E9laH98":3},"flags":{},"_stats":{"systemId":"dnd5e","systemVersion":"2.1.5","coreVersion":"10.291","createdTime":1677876552976,"modifiedTime":1677876552976,"lastModifiedBy":"f7l9snMm7E9laH98"},"_id":"BPXuwsI6iP3UkMpk"}
{"name":"Chill Touch (Target effect)","type":"script","img":"icons/magic/fire/flame-burning-hand-purple.webp","scope":"global","command":"if (this.targets.size != 1 || this.disadvantage) return;\n\nconst type = this.actor.type === \"npc\" ? this.actor.system.details?.type?.value : this.actor.system.details?.race;\nif (type !== \"undead\") return;\n\nconst effect = this.actor.effects.find((eff) => eff.label === \"Chill Touch\");\nif (!effect) return;\n\nconst sourceActor = await fromUuid(effect.origin);\nif (this.targets.first().actor.id !== sourceActor.actor.id) return;\n\nthis.disadvantage = true;","folder":"Bg8VhG8e87b0cRw5","flags":{"advanced-macros":{"runAsGM":false}},"author":"gRbX7wsbHXsd3tee","sort":0,"ownership":{"default":0,"gRbX7wsbHXsd3tee":3},"_stats":{"systemId":"dnd5e","systemVersion":"2.1.5","coreVersion":"10.291","createdTime":1677431027142,"modifiedTime":1677431027142,"lastModifiedBy":"gRbX7wsbHXsd3tee"},"_id":"BtVAMXBiSqdcVCHT"}
{"name":"What's Messing with my AC?","type":"script","scope":"global","author":"f7l9snMm7E9laH98","img":"ec2xL28.png","command":"/*\n--- What's Messing with my AC? ---\nShows a message that details all items that affect AC on the character (including dynamic effects)\n\nsource:\nhttps://github.com/itamarcu/foundry-macros/blob/master/whats-messing-with-my-ac.js\nsuggested icon:\nhttps://i.imgur.com/ec2xL28.png\n*/\n\nmain()\n\nfunction main() {\n  const tok = canvas.tokens.controlled[0]\n  if (!tok) return ui.notifications.error('You must select a token!')\n  const affectingItems = tok.actor.items.filter(it =>\n    it.labels.armor\n    || it.data.flags.dynamiceffects?.effects\n      .some(ef => ef.modSpecKey.includes('ac'))\n  )\n    .map(it => it.name).join(', ')\n  const message = `${tok.name}'s AC is potentially affected by: ${affectingItems}`\n  console.log(message)\n  ui.notifications.info(message)\n}","folder":null,"sort":0,"ownership":{"default":0,"f7l9snMm7E9laH98":3},"flags":{},"_stats":{"systemId":"dnd5e","systemVersion":"2.1.5","coreVersion":"10.291","createdTime":1677884010063,"modifiedTime":1677884034523,"lastModifiedBy":"f7l9snMm7E9laH98"},"_id":"BvR9Hit8S85DTPEw"}
{"name":"New Macro","type":"chat","scope":"global","author":"nS0HD1eC0cney1Lj","img":"icons/svg/dice-target.svg","command":"","folder":null,"sort":0,"ownership":{"default":0,"nS0HD1eC0cney1Lj":3},"flags":{},"_stats":{"systemId":"dnd5e","systemVersion":"2.1.4","coreVersion":"10.291","createdTime":1676062513123,"modifiedTime":1676062513123,"lastModifiedBy":"nS0HD1eC0cney1Lj"},"_id":"GpzUn06XPpqy4oWE"}
{"name":"Active Aura Damage and Condition On Entry (Generic)","type":"script","img":"icons/svg/dice-target.svg","scope":"global","command":"if(!game.modules.get(\"ActiveAuras\")?.active) {\n  ui.notifications.error(\"ActiveAuras is not enabled\");\n  return;\n}\n\nconst lastArg = args[args.length - 1];\n\nasync function wait(ms) { return new Promise(resolve => { setTimeout(resolve, ms); }); }\n\nfunction getHighestAbility(actor, abilities) {\n  if (typeof abilities === \"string\") {\n    return abilities;\n  } else if (Array.isArray(abilities)) {\n    return abilities.reduce((prv, current) => {\n      if (actor.system.abilities[current].value > actor.system.abilities[prv].value) return current;\n      else return prv;\n    }, abilities[0]);\n  }\n}\n\nfunction getCantripDice(actor) {\n  const level = actor.type === \"character\" ? actor.system.details.level : actor.system.details.cr;\n  return 1 + Math.floor((level + 1) / 6);\n}\n\n\nasync function attemptRemoval(targetToken, condition, item) {\n  if (game.dfreds.effectInterface.hasEffectApplied(condition, targetToken.document.uuid)) {\n    new Dialog({\n      title: `Use action to attempt to remove ${condition}?`,\n      buttons: {\n        one: {\n          label: \"Yes\",\n          callback: async () => {\n            const caster = item.parent;\n            const saveDc = caster.system.attributes.spelldc;\n            const removalCheck = item.system.flags.ddbimporter.effect.removalCheck;\n            const removalSave = item.system.flags.ddbimporter.effect.removalSave;\n            const ability = removalCheck ? getHighestAbility(targetToken.actor.data, removalCheck) : getHighestAbility(targetToken.actor.data, removalSave);\n            const type = removalCheck ? \"check\" : \"save\";\n            const flavor = `${condition} (via ${item.name}) : ${CONFIG.DND5E.abilities[ability]} ${type} vs DC${saveDc}`;\n            const rollResult = removalCheck\n              ? (await targetToken.actor.rollAbilityTest(ability, { flavor })).total\n              : (await targetToken.actor.rollAbilitySave(ability, { flavor })).total;\n\n            if (rollResult >= saveDc) {\n              game.dfreds.effectInterface.removeEffect({ effectName: condition, uuid: targetToken.document.uuid });\n            } else {\n              if (rollResult < saveDc) ChatMessage.create({ content: `${targetToken.name} fails the ${type} for ${item.name}, still has the ${condition} condition.` });\n            }\n          },\n        },\n        two: {\n          label: \"No\",\n          callback: () => {},\n        },\n      },\n    }).render(true);\n  }\n}\n\nasync function applyCondition(condition, targetToken, item, itemLevel) {\n  if (!game.dfreds.effectInterface.hasEffectApplied(condition, targetToken.document.uuid)) {\n    const caster = item.parent;\n    const workflowItemData = duplicate(item.data);\n    workflowItemData.system.target = { value: 1, units: \"\", type: \"creature\" };\n    workflowItemData.system.save.ability = item.flags.ddbimporter.effect.save;\n    workflowItemData.system.components.concentration = false;\n    workflowItemData.system.level = itemLevel;\n    workflowItemData.system.duration = { value: null, units: \"inst\" };\n    workflowItemData.system.target = { value: null, width: null, units: \"\", type: \"creature\" };\n    workflowItemData.system.preparation.mode = \"atwill\";\n    setProperty(workflowItemData, \"flags.itemacro\", {});\n    setProperty(workflowItemData, \"flags.midi-qol\", {});\n    setProperty(workflowItemData, \"flags.dae\", {});\n    setProperty(workflowItemData, \"effects\", []);\n    delete workflowItemData._id;\n    workflowItemData.name = `${workflowItemData.name}: ${item.name} Condition save`;\n    // console.warn(\"workflowItemData\", workflowItemData);\n\n    const saveTargets = [...game.user?.targets].map((t )=> t.id);\n    game.user.updateTokenTargets([targetToken.id]);\n    const saveItem = new CONFIG.Item.documentClass(workflowItemData, { parent: caster });\n    const options = { showFullCard: false, createWorkflow: true, configureDialog: true };\n    const result = await MidiQOL.completeItemRoll(saveItem, options);\n\n    game.user.updateTokenTargets(saveTargets);\n    const failedSaves = [...result.failedSaves];\n    if (failedSaves.length > 0) {\n      await game.dfreds.effectInterface.addEffect({ effectName: condition, uuid: failedSaves[0].document.uuid });\n    }\n\n    return result;\n  }\n}\n\nasync function attachSequencerFileToTemplate(templateUuid, sequencerFile, originUuid) {\n  if (game.modules.get(\"sequencer\")?.active) {\n    if (Sequencer.Database.entryExists(sequencerFile)) {\n      console.debug(`Trying to apply sequencer effect (${sequencerFile}) to ${templateUuid} from ${originUuid}`, sequencerFile);\n      const template = await fromUuid(templateUuid);\n      new Sequence()\n      .effect()\n        .file(Sequencer.Database.entryExists(sequencerFile))\n        .size({\n          width: canvas.grid.size * (template.data.width / canvas.dimensions.distance),\n          height: canvas.grid.size * (template.data.width / canvas.dimensions.distance),\n        })\n        .persist(true)\n        .origin(originUuid)\n        .belowTokens()\n        .opacity(0.5)\n        .attachTo(template, { followRotation: true })\n        .stretchTo(template, { attachTo: true})\n      .play();\n    }\n  }\n}\n\n\nasync function rollItemDamage(targetToken, itemUuid, itemLevel) {\n  const item = await fromUuid(itemUuid);\n  const caster = item.parent;\n  const isCantrip = item.flags.ddbimporter.effect.isCantrip;\n  const damageDice = item.flags.ddbimporter.effect.dice;\n  const damageType = item.flags.ddbimporter.effect.damageType;\n  const saveAbility = item.flags.ddbimporter.effect.save;\n  const casterToken = canvas.tokens.placeables.find((t) => t.actor?.uuid === caster.uuid);\n  const scalingDiceArray = item.system.scaling.formula.split(\"d\");\n  const scalingDiceNumber = itemLevel - item.system.level;\n  const upscaledDamage =  isCantrip\n    ? `${getCantripDice(caster.data)}d${scalingDiceArray[1]}[${damageType}]`\n    : scalingDiceNumber > 0 ? `${scalingDiceNumber}d${scalingDiceArray[1]}[${damageType}] + ${damageDice}` : damageDice;\n  const damageRoll = await new Roll(upscaledDamage).evaluate({ async: true });\n  if (game.dice3d) game.dice3d.showForRoll(damageRoll);\n  const workflowItemData = duplicate(item.data);\n  workflowItemData.system.target = { value: 1, units: \"\", type: \"creature\" };\n  workflowItemData.system.save.ability = saveAbility;\n  workflowItemData.system.components.concentration = false;\n  workflowItemData.system.level = itemLevel;\n  workflowItemData.system.duration = { value: null, units: \"inst\" };\n  workflowItemData.system.target = { value: null, width: null, units: \"\", type: \"creature\" };\n\n  setProperty(workflowItemData, \"flags.itemacro\", {});\n  setProperty(workflowItemData, \"flags.midi-qol\", {});\n  setProperty(workflowItemData, \"flags.dae\", {});\n  setProperty(workflowItemData, \"effects\", []);\n  delete workflowItemData._id;\n  workflowItemData.name = `${workflowItemData.name}: Turn Entry Damage`;\n  // console.warn(\"workflowItemData\", workflowItemData);\n\n  await new MidiQOL.DamageOnlyWorkflow(\n    caster,\n    casterToken,\n    damageRoll.total,\n    damageType,\n    [targetToken],\n    damageRoll,\n    {\n      flavor: `(${CONFIG.DND5E.damageTypes[damageType]})`,\n      itemCardId: \"new\",\n      itemData: workflowItemData,\n      isCritical: false,\n    }\n  );\n}\n\nif (args[0].tag === \"OnUse\" && args[0].macroPass === \"preActiveEffects\") {\n  const safeName = lastArg.itemData.name.replace(/\\s|'|\\.|’/g, \"_\");\n  const dataTracker = {\n    randomId: randomID(),\n    targetUuids: lastArg.targetUuids,\n    startRound: game.combat.round,\n    startTurn: game.combat.turn,\n    spellLevel: lastArg.spellLevel,\n  };\n\n  const item = await fromUuid(lastArg.itemUuid);\n  // await item.update(dataTracker);\n  await DAE.unsetFlag(item, `${safeName}Tracker`);\n  await DAE.setFlag(item, `${safeName}Tracker`, dataTracker);\n\n  const ddbEffectFlags = lastArg.item.flags.ddbimporter?.effect;\n  if (ddbEffectFlags) {\n    const sequencerFile = ddbEffectFlags.sequencerFile;\n    if (sequencerFile) {\n      await attachSequencerFileToTemplate(lastArg.templateUuid, sequencerFile, lastArg.itemUuid)\n    }\n    if (ddbEffectFlags.isCantrip) {\n      const cantripDice = getCantripDice(lastArg.actor);\n      args[0].spellLevel = cantripDice;\n      ddbEffectFlags.cantripDice = cantripDice;\n      let newEffects = args[0].item.effects.map((effect) => {\n        effect.changes = effect.changes.map((change) => {\n          change.value = change.value.replace(\"@cantripDice\", cantripDice)\n          return change;\n        });\n        return effect;\n      });\n      args[0].item.effects = duplicate(newEffects);\n      args[0].itemData.effects = duplicate(newEffects);\n    }\n    const template = await fromUuid(lastArg.templateUuid);\n    await template.update({\"flags.effect\": ddbEffectFlags});\n\n    if (ddbEffectFlags.applyImmediate) {\n      console.debug(\"Applying immediate effect\");\n      await wait(500);\n      const condition = ddbEffectFlags.condition;\n      for (const token of lastArg.failedSaves) {\n        if (!game.dfreds.effectInterface.hasEffectApplied(condition, token.actor.uuid)) {\n          console.debug(`Applying ${condition} to ${token.name}`);\n          await game.dfreds.effectInterface.addEffect({ effectName: condition, uuid: token.actor.uuid });\n        }\n      };\n    }\n  }\n\n  console.debug(\"ItemMacro: Pre-apply finised, applying effect to template\")\n\n  return await AAhelpers.applyTemplate(args);\n\n} else if (args[0].tag === \"OnUse\" && args[0].macroPass === \"postActiveEffects\") {\n  if (lastArg.item.flags.ddbimporter?.effect?.applyImmediate) {\n    const condition = lastArg.item.flags.ddbimporter.effect.condition;\n    for (const token of lastArg.failedSaves) {\n      if (!game.dfreds.effectInterface.hasEffectApplied(condition, token.actor.uuid)) {\n        console.debug(`Applying ${condition} to ${token.name}`);\n        await game.dfreds.effectInterface.addEffect({ effectName: condition, uuid: token.actor.uuid });\n      }\n    };\n  }\n} else if (args[0] == \"on\" || args[0] == \"each\") {\n  const safeName = lastArg.efData.label.replace(/\\s|'|\\.|’/g, \"_\");\n  const item = await fromUuid(lastArg.efData.origin);\n  const ddbEffectFlags = item.flags.ddbimporter.effect;\n  // sometimes the round info has not updated, so we pause a bit\n  if (args[0] == \"each\") await wait(500);\n  const targetItemTracker = DAE.getFlag(item.parent, `${safeName}Tracker`);\n  const originalTarget = targetItemTracker.targetUuids.includes(lastArg.tokenUuid);\n  const target = canvas.tokens.get(lastArg.tokenId);\n  const targetTokenTrackerFlag = DAE.getFlag(target, `${safeName}Tracker`);\n  const targetedThisCombat = targetTokenTrackerFlag && targetItemTracker.randomId === targetTokenTrackerFlag.randomId;\n  const targetTokenTracker = targetedThisCombat\n    ? targetTokenTrackerFlag\n    : {\n      randomId: targetItemTracker.randomId,\n      round: game.combat.round,\n      turn: game.combat.turn,\n      hasLeft: false,\n      condition: ddbEffectFlags.condition,\n    };\n\n  const castTurn = targetItemTracker.startRound === game.combat.round && targetItemTracker.startTurn === game.combat.turn;\n  const isLaterTurn = game.combat.round > targetTokenTracker.round || game.combat.turn > targetTokenTracker.turn;\n  const everyEntry = hasProperty(item.data, \"flags.ddbimporter.effect.everyEntry\")\n    ? item.flags.ddbimporter.effect.everyEntry\n    : false;\n\n  // if:\n  // not cast turn, and not part of the original target\n  // AND one of the following\n  // not original template and have not yet had this effect applied this combat OR\n  // has been targeted this combat, left and re-entered effect, and is a later turn\n\n  const autoDamageIfCondition = hasProperty(ddbEffectFlags, \"autoDamageIfCondition\") ? ddbEffectFlags.autoDamageIfCondition : false;\n  const hasConditionStart = game.dfreds.effectInterface.hasEffectApplied(targetTokenTracker.condition, target.actor.uuid);\n  const applyAutoConditionDamage = autoDamageIfCondition && hasConditionStart;\n\n  if (ddbEffectFlags.conditionEffect && !hasConditionStart) {\n    if (castTurn && originalTarget) {\n      console.debug(`Token ${target.name} is part of the original target for ${item.name}`);\n    } else if (everyEntry || !targetedThisCombat || (targetedThisCombat && isLaterTurn)) {\n      console.debug(`Token ${target.name} is targeted for immediate save vs condition with ${item.name}, using the following factors`, { originalTarget, castTurn, targetedThisCombat, targetTokenTracker, isLaterTurn });\n      targetTokenTracker.hasLeft = false;\n      await applyCondition(targetTokenTracker.condition, target, item, targetItemTracker.spellLevel);\n    } else {\n      console.debug(`Token ${target.name} has not evaluated for condition application`);\n    }\n  }\n  if (ddbEffectFlags.damageEffect) {\n    if (castTurn && originalTarget) {\n      console.debug(`Token ${target.name} is part of the original target for ${item.name}`);\n    } else if ((!targetedThisCombat && !autoDamageIfCondition) || //if auto damage applied by conditional save\n      (targetedThisCombat && ((targetTokenTracker.hasLeft && isLaterTurn) || (applyAutoConditionDamage && isLaterTurn)))\n    ) {\n      console.debug(`Token ${target.name} is targeted for immediate damage with ${item.name}, using the following factors`, { originalTarget, castTurn, targetedThisCombat, targetTokenTracker, isLaterTurn });\n      targetTokenTracker.hasLeft = false;\n      await rollItemDamage(target, lastArg.efData.origin, targetItemTracker.spellLevel);\n    } else {\n      console.debug(`Token ${target.name} has not evaluated for damage application`);\n    }\n  }\n\n  targetTokenTracker.turn = game.combat.turn;\n  targetTokenTracker.round = game.combat.round;\n  await DAE.setFlag(target, `${safeName}Tracker`, targetTokenTracker);\n  const allowVsRemoveCondition = item.flags.ddbimporter.effect.allowVsRemoveCondition;\n  const hasConditionAppliedEnd = game.dfreds.effectInterface.hasEffectApplied(targetTokenTracker.condition, target.document.uuid);\n  const currentTokenCombatTurn = game.combat.current.tokenId === lastArg.tokenId;\n  if (currentTokenCombatTurn && allowVsRemoveCondition && hasConditionAppliedEnd) {\n    console.warn(`Asking ${target.name} wants to remove ${targetTokenTracker.condition}`);\n    await attemptRemoval(target, targetTokenTracker.condition, item);\n  }\n} else if (args[0] == \"off\") {\n  const safeName = lastArg.efData.label.replace(/\\s|'|\\.|’/g, \"_\");\n  const targetToken = await fromUuid(lastArg.tokenUuid);\n  const targetTokenTracker = await DAE.getFlag(targetToken, `${safeName}Tracker`);\n  const removeOnOff = hasProperty(lastArg, \"efData.flags.ddbimporter.effect.removeOnOff\")\n    ? lastArg.efData.flags.ddbimporter.effect.removeOnOff\n    : true;\n\n  if (targetTokenTracker?.condition && removeOnOff && game.dfreds.effectInterface.hasEffectApplied(targetTokenTracker.condition, lastArg.tokenUuid)) {\n    console.debug(`Removing ${targetTokenTracker.condition} from ${targetToken.name}`);\n    game.dfreds.effectInterface.removeEffect({ effectName: targetTokenTracker.condition, uuid: lastArg.tokenUuid });\n  }\n\n  if (targetTokenTracker) {\n    targetTokenTracker.hasLeft = true;\n    await DAE.setFlag(targetToken, `${safeName}Tracker`, targetTokenTracker);\n  }\n}","folder":"Bg8VhG8e87b0cRw5","flags":{"advanced-macros":{"runAsGM":false}},"author":"gRbX7wsbHXsd3tee","sort":0,"ownership":{"default":0,"gRbX7wsbHXsd3tee":3},"_stats":{"systemId":"dnd5e","systemVersion":"2.1.4","coreVersion":"10.291","createdTime":1675611320260,"modifiedTime":1675611320260,"lastModifiedBy":"gRbX7wsbHXsd3tee"},"_id":"HBBWsuZIxColR1JU"}
{"name":"Darkness (DDB - GM)","type":"script","img":"icons/magic/unholy/orb-glowing-yellow-purple.webp","scope":"global","command":"// This Macro is called by the Darkness spell so players can place walls and lights.\n\nconst darknessParams = args[args.length - 1];\n\nfunction circleWall(cx, cy, radius) {\n  let walls = [];\n  const step = 30;\n  for (let i = step; i <= 360; i += step) {\n    let theta0 = Math.toRadians(i - step);\n    let theta1 = Math.toRadians(i);\n\n    let lastX = Math.floor((radius * Math.cos(theta0)) + cx);\n    let lastY = Math.floor((radius * Math.sin(theta0)) + cy);\n    let newX = Math.floor((radius * Math.cos(theta1)) + cx);\n    let newY = Math.floor((radius * Math.sin(theta1)) + cy);\n\n    walls.push({\n      c: [lastX, lastY, newX, newY],\n      move: CONST.WALL_MOVEMENT_TYPES.NONE,\n      light: CONST.WALL_SENSE_TYPES.NORMAL,\n      sight: CONST.WALL_SENSE_TYPES.NORMAL,\n      sound: CONST.WALL_SENSE_TYPES.NONE,\n      dir: CONST.WALL_DIRECTIONS.BOTH,\n      door: CONST.WALL_DOOR_TYPES.NONE,\n      ds: CONST.WALL_DOOR_STATES.CLOSED,\n      flags: {\n        spellEffects: {\n          Darkness: {\n            ActorId: darknessParams.targetActorId,\n          },\n        },\n      },\n    });\n  }\n\n  canvas.scene.createEmbeddedDocuments(\"Wall\", walls);\n}\n\nfunction darknessLight(cx, cy, radius) {\n  const lightTemplate = {\n    x: cx,\n    y: cy,\n    rotation: 0,\n    walls: false,\n    vision: false,\n    config: {\n      alpha: 0.5,\n      angle: 0,\n      bright: radius,\n      coloration: 1,\n      dim: 0,\n      gradual: false,\n      luminosity: -1,\n      saturation: 0,\n      contrast: 0,\n      shadows: 0,\n      animation: {\n        speed: 5,\n        intensity: 5,\n        reverse: false,\n      },\n      darkness: {\n        min: 0,\n        max: 1,\n      },\n      color: null,\n    },\n    hidden: false,\n    flags: {\n      spellEffects: {\n        Darkness: {\n          ActorId: darknessParams.targetActorId,\n        },\n      },\n      \"perfect-vision\": {\n        resolution: 1,\n        visionLimitation: {\n          enabled: true,\n          sight: 0,\n          detection: {\n            feelTremor: null,\n            seeAll: null,\n            seeInvisibility: 0,\n            senseAll: null,\n            senseInvisibility: null,\n          },\n        },\n      },\n    },\n  };\n  canvas.scene.createEmbeddedDocuments(\"AmbientLight\", [lightTemplate]);\n}\n\nif (args[0] == \"on\") {\n  if (!game.modules.get(\"perfect-vision\")?.active) circleWall(darknessParams.x, darknessParams.y, darknessParams.radius);\n  darknessLight(darknessParams.x, darknessParams.y, darknessParams.distance);\n}\n\nif (args[0] == \"off\") {\n  const darkWalls = canvas.walls.placeables.filter((w) => w.data.flags?.spellEffects?.Darkness?.ActorId === darknessParams.targetActorId);\n  const wallArray = darkWalls.map((w) => w.id);\n  const darkLights = canvas.lighting.placeables.filter((w) => w.data.flags?.spellEffects?.Darkness?.ActorId === darknessParams.targetActorId);\n  const lightArray = darkLights.map((w) => w.id);\n  await canvas.scene.deleteEmbeddedDocuments(\"Wall\", wallArray);\n  await canvas.scene.deleteEmbeddedDocuments(\"AmbientLight\", lightArray);\n}","folder":"Bg8VhG8e87b0cRw5","flags":{"advanced-macros":{"runAsGM":true}},"author":"gRbX7wsbHXsd3tee","sort":0,"ownership":{"default":0,"gRbX7wsbHXsd3tee":3},"_stats":{"systemId":"dnd5e","systemVersion":"2.1.5","coreVersion":"10.291","createdTime":1675611320279,"modifiedTime":1677431027129,"lastModifiedBy":"gRbX7wsbHXsd3tee"},"_id":"HRgsbcJkbafxXYsb"}
{"name":"New Macro","type":"chat","scope":"global","author":"nS0HD1eC0cney1Lj","img":"icons/svg/dice-target.svg","command":"","folder":null,"sort":0,"ownership":{"default":0,"nS0HD1eC0cney1Lj":3},"flags":{},"_stats":{"systemId":"dnd5e","systemVersion":"2.1.4","coreVersion":"10.291","createdTime":1676062512129,"modifiedTime":1676062512129,"lastModifiedBy":"nS0HD1eC0cney1Lj"},"_id":"Q9F13j40MD7bEGkb"}
{"name":"All actions","type":"script","scope":"global","author":"f7l9snMm7E9laH98","img":"icons/svg/upgrade.svg","command":"/*\n* Requires: DND5e.\n* Provides a dialog showing all action-triggered equipment, prepared and at-will spells, feats, and consumables,\n* as well as passive feats. Hopefully makes triggering actions easier without needing the character sheet open\n* all the time.\n* WARNING: Very ugly.\n* author/blame: ^ and stick#0520\n* with enormous help on the button events (and no blame to be attributed to): Skimble#8601\n*/\n\nclass ActionDialog extends Application {\n    super(options){\n    }\n\n    activateListeners(html) {\n        super.activateListeners(html);\n        const buttons = html.find(\"button[class='show-action-button']\");\n\n        if (buttons.length > 0)\n            buttons.on(\"click\", event => {this.openActionTab(event, html);});\n    }\n\n    openActionTab(event, html) {\n        // Declare all variables\n        var i, tabcontent, tablinks;\n\n        // Get all elements with class=\"tabcontent\" and hide them\n        tabcontent = document.getElementsByClassName(\"show-action-category\");\n        for (let t of tabcontent) {\n            t.style.display = \"none\";\n        }\n\n        // Get all elements with class=\"tablinks\" and remove the class \"active\"\n        tablinks = document.getElementsByClassName(\"show-action-button\");\n        for (let t of tablinks) {\n            t.className = t.className.replace(\" active\", \"\");\n        }\n\n        // Show the current tab, and add an \"active\" class to the button that opened the tab\n        if (event.target.value == \"showActionAll\") {\n            tabcontent = document.getElementsByClassName(\"show-action-category\");\n            for (let t of tabcontent) {\n                t.style.display= \"block\";\n            }\n        } else {\n            if (document.getElementById(event.target.value) != null)\n                document.getElementById(event.target.value).style.display = \"block\";\n        }\n        event.currentTarget.className += \" active\";\n    }\n\n    getData(){\n        // Get user's character or the first token from the controlled list.\n        function getTargetActor() {\n            const character = game.user.character;\n            if (character != null)\n                return character;\n\n            const controlled = canvas.tokens.controlled;\n\n            if (controlled.length === 0) return character || null;\n\n            if (controlled.length > 0 && controlled[0] != null) {\n                return controlled[0].actor;\n            }\n        }\n\n        function buildActionsList(targetActor) {\n            let equipped = targetActor.data.items.filter(i => i.type !=\"consumable\" && getProperty(i.data, \"data.equipped\"));\n            let activeEquipped = getActiveEquipment(equipped);\n            let weapons = activeEquipped.filter(i => i.type == \"weapon\");\n            let equipment = activeEquipped.filter(i => i.type == \"equipment\");\n\n            let other = activeEquipped.filter(i => i.type != \"weapon\" && i.type != \"equipment\");\n            let consumables = targetActor.data.items.filter(i => i.type == \"consumable\");\n            let items = { \"weapons\": weapons, \"equipment\": equipment, \"other\": other, \"consumables\": consumables };\n\n            let preparedSpells = targetActor.data.items.filter(i => i.type == \"spell\" && getProperty(i.data, \"data.preparation.prepared\"));\n            let spells = categoriseSpells(preparedSpells);\n\n            let allFeats = targetActor.data.items.filter(i => i.type == \"feat\");\n            let activeFeats = getActiveFeats(allFeats);\n            let passiveFeats =  getPassiveFeats(allFeats);\n            let feats = {\"active\": activeFeats, \"passive\": passiveFeats};\n\n\n            return { \"equipment\": items,\"spells\": spells, \"feats\": feats };\n        }\n\n        function getActiveEquipment(equipment) {\n            const activationTypes = Object.entries(game.dnd5e.config.abilityActivationTypes);\n\n            let activeEquipment = equipment.filter(e => {\n                if (getProperty(e.data, \"data.activation\") == undefined)\n                    return false;\n\n                for (let [key, value] of activationTypes) {\n                    if (getProperty(e.data, \"data.activation.type\") == key)\n                        return true;\n                }\n\n                return false;\n            });\n\n            return activeEquipment;\n        }\n\n        function categoriseSpells(spells) {\n            let powers = {};\n            let book = {}\n\n            book = spells.reduce(function (book, spell) {\n                var level = getProperty(spell.data, \"data.level\");\n                let prep = getProperty(spell.data, \"data.preparation.mode\");\n\n                const prepTypes = game.dnd5e.config.spellPreparationModes;\n                let prepType = prepTypes[prep];\n\n                if (prep == \"pact\" || prep == \"atwill\" || prep == \"innate\") {\n                    if (!powers.hasOwnProperty(prepType)) {\n                        powers[prepTypes[prep]] = [];\n                    }\n\n                    powers[prepType].push(spell);\n                } else {\n                    if (!book.hasOwnProperty(level)) {\n                        book[level] = [];\n                    }\n\n                    book[level].push(spell);\n                }\n\n                return book;\n            }, {});\n\n            return {\"book\": Object.entries(book), \"powers\": Object.entries(powers)};\n        }\n\n        function getActiveFeats(feats) {\n            const activationTypes = Object.entries(game.dnd5e.config.abilityActivationTypes);\n            let activeFeats = feats.filter(f => {\n                if (getProperty(f.data, \"data.activation\") == undefined)\n                    return false;\n\n                for (let [key, value] of activationTypes) {\n                    if (getProperty(f.data, \"data.activation.type\") == key)\n                        return true;\n                }\n\n                return false;\n            });\n\n            return Object.entries(activeFeats);\n        }\n\n        function getPassiveFeats(feats) {\n            const activationTypes = Object.entries(game.dnd5e.config.abilityActivationTypes);\n            let passiveFeats = feats.filter(f => {\n                if (getProperty(f.data, \"data.activation\") == undefined)\n                    return false;\n\n                for (let [key, value] of activationTypes) {\n                    if (getProperty(f.data, \"data.activation\") == key)\n                        return false;\n                }\n\n                return true;\n            });\n\n            return Object.entries(passiveFeats);\n        }\n\n        function getContentTemplate(actions) {\n            let template = `\n            <div>\n                 ${getCssStyle()}\n                <div class=\"show-action-form-group\">\n                    <div class=\"show-action-buttons\">\n                        <button value=\"showActionItems\" class=\"show-action-button\">Items</button>\n                        <button value=\"showActionSpells\" class=\"show-action-button\">Spells</button>\n                        <button value=\"showActionFeats\" class=\"show-action-button\">Feats</button>\n                        <button value=\"showActionAll\" class=\"show-action-button\">Show all</button>\n                    </div>\n                    </div>\n                    <div class=\"show-action-categories\">\n                        <div id=\"showActionItems\" class=\"show-action-category\">\n                            ${getItemsTemplate(actions.equipment)}\n                        </div>\n                        <div id=\"showActionSpells\" class=\"show-action-category\">\n                            ${getSpellsTemplate(actions.spells)}\n                        <div id=\"showActionFeats\" class=\"show-action-category\">\n                            ${getFeatsTemplate(actions.feats)}\n                        </div>\n                    </div>\n                </div>\n            </div>`;\n\n            return template;\n        }\n\n        // Gets a template of abilities or skills, based on the type of check chosen.\n        function getItemsTemplate(items) {\n            if (items.weapons.length + items.equipment.length + items.other.length + items.consumables.length === 0)\n                return \"\";\n\n            let template = `<div id=\"actionItems\" class=\"show-action-tabcontent\">\n                                <div class=\"show-action-tabcontent-title\">Items</div>\n                                    ${getItemsCategoryTemplate(\"Weapons\", items.weapons)}\n                                    ${getItemsCategoryTemplate(\"Equipment\", items.equipment)}\n                                    ${getItemsCategoryTemplate(\"Other\", items.other)}\n                                    ${getItemsCategoryTemplate(\"Consumables\", items.consumables)}\n                                </div>\n                            </div>`;\n\n            return template;\n        }\n\n        function getSpellsTemplate(spells) {\n            let template = `<div id=\"actionSpells\" class=\"show-action-tabcontent\">\n                                <div class=\"show-action-tabcontent-title\">Spells</div>\n                                    ${getSpellsCategoryTemplate(spells.powers)}\n                                    ${getSpellsCategoryTemplate(spells.book)}\n                                </div>\n                            </div>`;\n\n            return template;\n        }\n\n        function getFeatsTemplate(feats) {\n            if (feats.active.length + feats.passive.length === 0)\n                return \"\";\n\n            let template = `<div id=\"actionFeats\" class=\"show-action-tabcontent\">\n                                <div class=\"show-action-tabcontent-title\">Feats</div>\n                                    ${getFeatsCategoryTemplate(\"Active\", feats.active)}\n                                    ${getFeatsCategoryTemplate(\"Passive\", feats.passive)}\n                                </div>\n                            </div>`;\n\n            return template;\n        }\n\n        function getItemsCategoryTemplate(title, items) {\n            if (items.length === 0)\n                return \"\";\n\n            let template = `<div class=\"show-action-tabcontent-subtitle\">${title}</div>\n                            <div class=\"show-action-tabcontent-actions\">`;\n            for (let i of items) {\n                template += `<input id=\"weapon-${i.name}\" type=\"button\" value=\"${i.name}\" onclick=\"${getRollItemMacro(i.name)}\"/>`;\n            }\n\n            template += `</div>`;\n\n            return template;\n        }\n\n        function getSpellsCategoryTemplate(spells) {\n            if (spells.length === 0)\n                return \"\";\n\n            let template = \"\";\n\n            for (let [level, entries] of spells) {\n                console.log(!isNaN(level.toString()));\n                let subtitle = isNaN(level) ? level : (level.toString() === '0' ? `Cantrips` : `Level ${level}`);\n\n                template += `<div class=\"show-action-tabcontent-subtitle\">${subtitle}</div>\n                                <div class=\"show-action-tabcontent-actions\">`;\n\n                for (let s of entries) {\n                    template += `<input id=\"spell-${s.name}\" type=\"button\" value=\"${s.name}\" onclick=\"${getRollItemMacro(s.name)}\"/>`;\n                }\n\n                template += `</div>`;\n            }\n\n            return template;\n        }\n\n        function getFeatsCategoryTemplate(subtitle, feats) {\n            if (feats.length === 0)\n                return \"\";\n\n            let template = `<div class=\"show-action-tabcontent-subtitle\">${subtitle}</div>\n                            <div class=\"show-action-tabcontent-actions\">`\n\n            for (let [index, f] of feats) {\n                template += `<input id=\"feat-${f.name}\" type=\"button\" value=\"${f.name}\" onclick=\"${getRollItemMacro(f.name)}\"/>`;\n            }\n\n            template += `</div>`\n\n\n            return template;\n        }\n\n        function getCssStyle() {\n            return `\n            <style type=\"text/css\">\n            .show-action-buttons {\n                display: grid;\n                grid-template-columns: repeat(5, 1fr);\n                grid-gap: 10px;\n            }\n\n            .show-action-buttons button {\n                width: auto;\n                height: auto;\n                background-color: #eee;\n                float: left;\n                border: none;\n                outline: none;\n                cursor: pointer;\n                padding: 5px 8px;\n                transition: 0.3s;\n                display: block;\n              }\n                            \n              /* Change background color of buttons on hover */\n              .show-action-buttons button:hover {\n                background-color: #ddd;\n              }\n              \n              /* Create an active/current tablink class */\n              .show-action-buttons button.active {\n                background-color: #ccc;\n              }\n\n              .show-action-categories {\n                clear: both;\n              }\n              \n              /* Style the tab content */\n              .show-action-tabcontent {\n                display: block;\n                padding: 6px 12px;\n                border: 1px solid #ccc;\n                border-bottom: none;\n                border-left: none;\n                border-right: none;\n              }\n\n              .show-action-tabcontent-title {\n                    clear: both;\n                    font-size: large;\n              }\n\n              .show-action-tabcontent-subtitle {\n                  padding: 5px;\n                  margin: 2px;\n                  float: left;\n              }\n\n              .show-action-tabcontent input {\n                border: 1px solid #555;\n                padding: 5px;\n                margin: 2px;\n              }\n              \n              .show-action-tabcontent input:hover {\n              background-color: #ddd;\n              }\n            </style>`\n        }\n\n        function getRollItemMacro(itemName) {\n            return `game.dnd5e.rollItemMacro(&quot;${itemName}&quot;)`;\n        }\n\n        // set this to true if you want results whispered to the GM\n        let targetActor = getTargetActor();\n        let innerContent = \"\";\n\n        if (targetActor != null || targetActor) {\n            this.options.title = `${targetActor.name} actions`;\n            let actionLists = buildActionsList(targetActor);\n            innerContent = getContentTemplate(actionLists);\n        } else {\n            ui.notifications.error(\"No token selected or user character found.\");\n            throw new Error(\"No token selected or character found\");\n        }\n\n        var content =  `<div id=\"actionDialog\">${innerContent}</div>`;\n        var contentsObject = {content:`${content}`}\n        return contentsObject;\n    }\n}\n\nlet opt=Dialog.defaultOptions;\nopt.resizable=true;\nopt.title=\"Choose action\";\nopt.minimizable=true;\nopt.width=600;\nvar viewer;\nviewer = new ActionDialog(opt);\nviewer.render(true);","folder":null,"sort":0,"ownership":{"default":0,"f7l9snMm7E9laH98":3},"flags":{},"_stats":{"systemId":"dnd5e","systemVersion":"2.1.5","coreVersion":"10.291","createdTime":1677880456188,"modifiedTime":1677880478230,"lastModifiedBy":"f7l9snMm7E9laH98"},"_id":"RTuLvvkHe79ZOApx"}
{"name":"New Macro","type":"script","scope":"global","author":"nS0HD1eC0cney1Lj","img":"icons/svg/dice-target.svg","command":"","folder":null,"sort":0,"ownership":{"default":0,"nS0HD1eC0cney1Lj":3},"flags":{},"_stats":{"systemId":"dnd5e","systemVersion":"2.1.4","coreVersion":"10.291","createdTime":1676062509356,"modifiedTime":1676062595259,"lastModifiedBy":"nS0HD1eC0cney1Lj"},"_id":"SNxdVq9iT5baH9S1"}
{"name":"Stealth check","type":"chat","scope":"global","author":"nS0HD1eC0cney1Lj","img":"icons/svg/invisible.svg","command":"// Grabs selected tokens and rolls a stealth check against all other tokens passive perception on the map. Then returns the result.\n\n// getting all actors of selected tokens\nlet actors = canvas.tokens.controlled.map(({ actor }) => actor);\n\n// if there are no selected tokens, roll for the player's character.\nif (actors.length < 1 && game.user.character) {\n  actors = [game.user.character];\n}\nconst validActors = actors.filter(actor => actor != null);\n\nlet messageContent;\nif (validActors.length) {\n  messageContent = 'pp = passive perception<br>';\n} else {\n  messageContent = 'No tokens selected, please select at least one.';\n}\n// roll for every actor\nfor (const selectedActor of validActors) {\n  const stealthMod = selectedActor.data.data.skills.ste.total; // stealth roll\n  const result = await new Roll(`1d20+${stealthMod}`).roll({async: true});\n  const stealth = result.total; // rolling the formula\n  messageContent += `<hr><h3>${selectedActor.name} stealth roll was a <b>${stealth}</b> (1d20 + ${stealthMod}).</h3>`; // creating the output string\n\n  // grab a list of unique tokens then check their passive perception against the rolled stealth.\n  const uniqueActor = {};\n  const caughtBy = canvas.tokens.placeables\n    .filter(token => !!token.actor)\n    .filter(({ actor }) => actor.data.data.attributes.hp.value > 0) // filter out dead creatures.\n    .filter(({ actor }) => { // filter out duplicate token names. ie: we assume all goblins have the same passive perception\n      if (uniqueActor[actor.name]) {\n        return false;\n      }\n      uniqueActor[actor.name] = true;\n      return true;\n    })\n    .filter(({ actor }) => {\n      return selectedActor.id !== actor.id; // Don't check to see if the token sees himself.\n    })\n    .filter(({ actor }) => actor.data.data.skills.prc.passive >= stealth); // check map tokens passives with roller stealth\n\n  if (!caughtBy.length) {\n    messageContent += 'Stealth successful!<br>';\n  } else {\n    messageContent += 'Stealth questionable:<br>';\n    caughtBy.map(({ actor }) => {\n      messageContent += `<b>${actor.name}</b> pp(${actor.data.data.skills.prc.passive}).<br>`;\n    });\n  }\n}\n\n// create the message\nconst chatData = {\n  user: game.user._id,\n  speaker: game.user,\n  content: messageContent,\n  whisper: game.users.filter((u) => u.isGM).map((u) => u._id),\n};\nChatMessage.create(chatData, {});","folder":null,"sort":0,"ownership":{"default":0,"nS0HD1eC0cney1Lj":3},"flags":{},"_stats":{"systemId":"dnd5e","systemVersion":"2.1.5","coreVersion":"10.291","createdTime":1676062663079,"modifiedTime":1677885563819,"lastModifiedBy":"nS0HD1eC0cney1Lj"},"_id":"Z0qNtcHFiDbXsr2d"}
{"name":"Active Aura Condition On Entry (Generic)","type":"script","img":"icons/svg/dice-target.svg","scope":"global","command":"if(!game.modules.get(\"ActiveAuras\")?.active) {\n  ui.notifications.error(\"ActiveAuras is not enabled\");\n  return;\n}\n\nconst lastArg = args[args.length - 1];\n\nasync function wait(ms) { return new Promise(resolve => { setTimeout(resolve, ms); }); }\n\nasync function attemptRemoval(targetToken, condition, item) {\n  if (game.dfreds.effectInterface.hasEffectApplied(condition, targetToken.document.uuid)) {\n    new Dialog({\n      title: `Use action to attempt to remove ${condition}?`,\n      buttons: {\n        one: {\n          label: \"Yes\",\n          callback: async () => {\n            const caster = item.parent;\n            const saveDc = caster.system.attributes.spelldc;\n            const removalCheck = item.flags.ddbimporter.effect.removalCheck;\n            const removalSave = item.flags.ddbimporter.effect.removalSave;\n            const ability = removalCheck ? removalCheck : removalSave;\n            const type = removalCheck ? \"check\" : \"save\";\n            const flavor = `${condition} (via ${item.name}) : ${CONFIG.DND5E.abilities[ability]} ${type} vs DC${saveDc}`;\n            const rollResult = removalCheck\n              ? (await targetToken.actor.rollAbilityTest(ability, { flavor })).total\n              : (await targetToken.actor.rollAbilitySave(ability, { flavor })).total;\n\n            if (rollResult >= saveDc) {\n              game.dfreds.effectInterface.removeEffect({ effectName: condition, uuid: targetToken.document.uuid });\n            } else {\n              if (rollResult < saveDc) ChatMessage.create({ content: `${targetToken.name} fails the ${type} for ${item.name}, still has the ${condition} condition.` });\n            }\n          },\n        },\n        two: {\n          label: \"No\",\n          callback: () => {},\n        },\n      },\n    }).render(true);\n  }\n}\n\nasync function applyCondition(condition, targetToken, item, itemLevel) {\n  if (!game.dfreds.effectInterface.hasEffectApplied(condition, targetToken.document.uuid)) {\n    const caster = item.parent;\n    const workflowItemData = duplicate(item.data);\n    workflowItemData.system.target = { value: 1, units: \"\", type: \"creature\" };\n    workflowItemData.system.save.ability = item.flags.ddbimporter.effect.save;\n    workflowItemData.system.components.concentration = false;\n    workflowItemData.system.level = itemLevel;\n    workflowItemData.system.duration = { value: null, units: \"inst\" };\n    workflowItemData.system.target = { value: null, width: null, units: \"\", type: \"creature\" };\n    workflowItemData.system.preparation.mode = \"atwill\";\n    setProperty(workflowItemData, \"flags.itemacro\", {});\n    setProperty(workflowItemData, \"flags.midi-qol\", {});\n    setProperty(workflowItemData, \"flags.dae\", {});\n    setProperty(workflowItemData, \"effects\", []);\n    delete workflowItemData._id;\n    workflowItemData.name = `${workflowItemData.name}: ${item.name} Condition save`;\n    // console.warn(\"workflowItemData\", workflowItemData);\n\n    const saveTargets = [...game.user?.targets].map((t )=> t.id);\n    game.user.updateTokenTargets([targetToken.id]);\n    const saveItem = new CONFIG.Item.documentClass(workflowItemData, { parent: caster });\n    const options = { showFullCard: false, createWorkflow: true, configureDialog: true };\n    const result = await MidiQOL.completeItemRoll(saveItem, options);\n\n    game.user.updateTokenTargets(saveTargets);\n    const failedSaves = [...result.failedSaves];\n    if (failedSaves.length > 0) {\n      await game.dfreds.effectInterface.addEffect({ effectName: condition, uuid: failedSaves[0].document.uuid });\n    }\n\n    return result;\n  }\n}\n\nasync function attachSequencerFileToTemplate(templateUuid, sequencerFile, originUuid) {\n  if (game.modules.get(\"sequencer\")?.active) {\n    if (Sequencer.Database.entryExists(sequencerFile)) {\n      console.debug(`Trying to apply sequencer effect (${sequencerFile}) to ${templateUuid} from ${originUuid}`, sequencerFile);\n      const template = await fromUuid(templateUuid);\n      new Sequence()\n      .effect()\n        .file(Sequencer.Database.entryExists(sequencerFile))\n        .size({\n          width: canvas.grid.size * (template.data.width / canvas.dimensions.distance),\n          height: canvas.grid.size * (template.data.width / canvas.dimensions.distance),\n        })\n        .persist(true)\n        .origin(originUuid)\n        .belowTokens()\n        .opacity(0.5)\n        .attachTo(template, { followRotation: true })\n        .stretchTo(template, { attachTo: true})\n      .play();\n    }\n  }\n}\n\nif (args[0].tag === \"OnUse\" && args[0].macroPass === \"preActiveEffects\") {\n  const safeName = lastArg.itemData.name.replace(/\\s|'|\\.|’/g, \"_\");\n  const dataTracker = {\n    randomId: randomID(),\n    targetUuids: lastArg.targetUuids,\n    startRound: game.combat.round,\n    startTurn: game.combat.turn,\n    spellLevel: lastArg.spellLevel,\n  };\n\n  const item = await fromUuid(lastArg.itemUuid);\n  // await item.update(dataTracker);\n  await DAE.unsetFlag(item, `${safeName}Tracker`);\n  await DAE.setFlag(item, `${safeName}Tracker`, dataTracker);\n\n  const sequencerFile = lastArg.item.flags.ddbimporter?.effect?.sequencerFile;\n  if (sequencerFile) {\n    attachSequencerFileToTemplate(lastArg.templateUuid, sequencerFile, lastArg.itemUuid)\n  }\n\n  if (lastArg.item.flags.ddbimporter?.effect?.applyImmediate) {\n    await wait(500);\n    const condition = lastArg.item.flags.ddbimporter.effect.condition;\n    for (const token of lastArg.failedSaves) {\n      if (!game.dfreds.effectInterface.hasEffectApplied(condition, token.actor.uuid)) {\n        console.debug(`Applying ${condition} to ${token.name}`);\n        await game.dfreds.effectInterface.addEffect({ effectName: condition, uuid: token.actor.uuid });\n      }\n    };\n  }\n\n  return await AAhelpers.applyTemplate(args);\n\n} else if (args[0].tag === \"OnUse\" && args[0].macroPass === \"postActiveEffects\") {\n  if (lastArg.item.flags.ddbimporter?.effect?.applyImmediate) {\n    const condition = lastArg.item.flags.ddbimporter.effect.condition;\n    for (const token of lastArg.failedSaves) {\n      if (!game.dfreds.effectInterface.hasEffectApplied(condition, token.actor.uuid)) {\n        console.debug(`Applying ${condition} to ${token.name}`);\n        await game.dfreds.effectInterface.addEffect({ effectName: condition, uuid: token.actor.uuid });\n      }\n    };\n  }\n} else if (args[0] == \"on\" || args[0] == \"each\") {\n  const safeName = lastArg.efData.label.replace(/\\s|'|\\.|’/g, \"_\");\n  const item = await fromUuid(lastArg.efData.origin);\n  // sometimes the round info has not updated, so we pause a bit\n  if (args[0] == \"each\") await wait(500);\n  const targetItemTracker = DAE.getFlag(item.parent, `${safeName}Tracker`);\n  const originalTarget = targetItemTracker.targetUuids.includes(lastArg.tokenUuid);\n  const target = canvas.tokens.get(lastArg.tokenId);\n  const targetTokenTrackerFlag = DAE.getFlag(target, `${safeName}Tracker`);\n  const targetedThisCombat = targetTokenTrackerFlag && targetItemTracker.randomId === targetTokenTrackerFlag.randomId;\n  const targetTokenTracker = targetedThisCombat\n    ? targetTokenTrackerFlag\n    : {\n      randomId: targetItemTracker.randomId,\n      round: game.combat.round,\n      turn: game.combat.turn,\n      hasLeft: false,\n      condition: item.flags.ddbimporter.effect.condition,\n    };\n\n  const castTurn = targetItemTracker.startRound === game.combat.round && targetItemTracker.startTurn === game.combat.turn;\n  const isLaterTurn = game.combat.round > targetTokenTracker.round || game.combat.turn > targetTokenTracker.turn;\n  const everyEntry = hasProperty(item.data, \"flags.ddbimporter.effect.everyEntry\")\n    ? item.flags.ddbimporter.effect.everyEntry\n    : false;\n\n  // if:\n  // not cast turn, and not part of the original target\n  // AND one of the following\n  // not original template and have not yet had this effect applied this combat OR\n  // has been targeted this combat, left and re-entered effect, and is a later turn\n\n  if (castTurn && originalTarget) {\n    console.debug(`Token ${target.name} is part of the original target for ${item.name}`);\n  } else if (everyEntry || !targetedThisCombat || (targetedThisCombat && isLaterTurn)) {\n    console.debug(`Token ${target.name} is targeted for immediate save vs condition with ${item.name}, using the following factors`, { originalTarget, castTurn, targetedThisCombat, targetTokenTracker, isLaterTurn });\n    targetTokenTracker.hasLeft = false;\n    await applyCondition(targetTokenTracker.condition, target, item, targetItemTracker.spellLevel);\n  }\n  await DAE.setFlag(target, `${safeName}Tracker`, targetTokenTracker);\n  const allowVsRemoveCondition = item.flags.ddbimporter.effect.allowVsRemoveCondition;\n  const effectApplied = game.dfreds.effectInterface.hasEffectApplied(targetTokenTracker.condition, target.document.uuid);\n  const currentTokenCombatTurn = game.combat.current.tokenId === lastArg.tokenId;\n  if (currentTokenCombatTurn && allowVsRemoveCondition && effectApplied) {\n    console.warn(`Removing ${targetTokenTracker.condition}`);\n    await attemptRemoval(target, targetTokenTracker.condition, item);\n  }\n} else if (args[0] == \"off\") {\n  const safeName = lastArg.efData.label.replace(/\\s|'|\\.|’/g, \"_\");\n  const targetToken = await fromUuid(lastArg.tokenUuid);\n  const targetTokenTracker = await DAE.getFlag(targetToken, `${safeName}Tracker`);\n  const removeOnOff = hasProperty(lastArg, \"efData.flags.ddbimporter.effect.removeOnOff\")\n    ? lastArg.efData.flags.ddbimporter.effect.removeOnOff\n    : true;\n\n  if (targetTokenTracker?.condition && removeOnOff && game.dfreds.effectInterface.hasEffectApplied(targetTokenTracker.condition, lastArg.tokenUuid)) {\n    console.debug(`Removing ${targetTokenTracker.condition} from ${targetToken.name}`);\n    game.dfreds.effectInterface.removeEffect({ effectName: targetTokenTracker.condition, uuid: lastArg.tokenUuid });\n  }\n\n  if (targetTokenTracker) {\n    targetTokenTracker.hasLeft = true;\n    targetTokenTracker.turn = game.combat.turn;\n    targetTokenTracker.round = game.combat.round;\n    await DAE.setFlag(targetToken, `${safeName}Tracker`, targetTokenTracker);\n  }\n}","folder":"Bg8VhG8e87b0cRw5","flags":{"advanced-macros":{"runAsGM":false}},"author":"gRbX7wsbHXsd3tee","sort":0,"ownership":{"default":0,"gRbX7wsbHXsd3tee":3},"_stats":{"systemId":"dnd5e","systemVersion":"2.1.4","coreVersion":"10.291","createdTime":1675611320266,"modifiedTime":1675611320266,"lastModifiedBy":"gRbX7wsbHXsd3tee"},"_id":"ZfVhWps5YEOfq5pN"}
{"name":"New Macro","type":"chat","scope":"global","author":"fbVZr33TyM9AhMIH","img":"icons/svg/dice-target.svg","command":"","folder":null,"sort":0,"ownership":{"default":0,"fbVZr33TyM9AhMIH":3},"flags":{},"_stats":{"systemId":"dnd5e","systemVersion":"2.1.5","coreVersion":"10.291","createdTime":1677886001786,"modifiedTime":1677886001786,"lastModifiedBy":"fbVZr33TyM9AhMIH"},"_id":"aM8WFCmiBb0pP7g0"}
{"name":"New Macro","type":"chat","scope":"global","author":"nS0HD1eC0cney1Lj","img":"icons/svg/dice-target.svg","command":"","folder":null,"sort":0,"ownership":{"default":0,"nS0HD1eC0cney1Lj":3},"flags":{},"_stats":{"systemId":"dnd5e","systemVersion":"2.1.4","coreVersion":"10.291","createdTime":1676062510376,"modifiedTime":1676062510376,"lastModifiedBy":"nS0HD1eC0cney1Lj"},"_id":"aRltuslADRHTd6rp"}
{"name":"New Macro","type":"chat","scope":"global","author":"nS0HD1eC0cney1Lj","img":"icons/svg/dice-target.svg","command":"","folder":null,"sort":0,"ownership":{"default":0,"nS0HD1eC0cney1Lj":3},"flags":{},"_stats":{"systemId":"dnd5e","systemVersion":"2.1.4","coreVersion":"10.291","createdTime":1676062512830,"modifiedTime":1676062512830,"lastModifiedBy":"nS0HD1eC0cney1Lj"},"_id":"bW3BFrFMTbL1nHHr"}
{"name":"New Macro","type":"chat","scope":"global","author":"nS0HD1eC0cney1Lj","img":"icons/svg/dice-target.svg","command":"","folder":null,"sort":0,"ownership":{"default":0,"nS0HD1eC0cney1Lj":3},"flags":{},"_stats":{"systemId":"dnd5e","systemVersion":"2.1.4","coreVersion":"10.291","createdTime":1676062511441,"modifiedTime":1676062511441,"lastModifiedBy":"nS0HD1eC0cney1Lj"},"_id":"d9ZZ7RppDVZSL2Ns"}
{"name":"New Macro","type":"chat","scope":"global","author":"nS0HD1eC0cney1Lj","img":"icons/svg/dice-target.svg","command":"","folder":null,"sort":0,"ownership":{"default":0,"nS0HD1eC0cney1Lj":3},"flags":{},"_stats":{"systemId":"dnd5e","systemVersion":"2.1.4","coreVersion":"10.291","createdTime":1676062512602,"modifiedTime":1676062512602,"lastModifiedBy":"nS0HD1eC0cney1Lj"},"_id":"ht5IIoPiz0W3pyNc"}
{"name":"New Macro","type":"chat","scope":"global","author":"08RzcAqYAeDQxYQr","img":"icons/svg/dice-target.svg","command":"","folder":null,"sort":0,"ownership":{"default":0,"08RzcAqYAeDQxYQr":3},"flags":{},"_stats":{"systemId":"dnd5e","systemVersion":"2.1.5","coreVersion":"10.291","createdTime":1677878220452,"modifiedTime":1677878220452,"lastModifiedBy":"08RzcAqYAeDQxYQr"},"_id":"icvwkhGeJnifPQUy"}
{"name":"New Macro","type":"chat","scope":"global","author":"nS0HD1eC0cney1Lj","img":"icons/svg/dice-target.svg","command":"","folder":null,"sort":0,"ownership":{"default":0,"nS0HD1eC0cney1Lj":3},"flags":{},"_stats":{"systemId":"dnd5e","systemVersion":"2.1.4","coreVersion":"10.291","createdTime":1676062509708,"modifiedTime":1676062509708,"lastModifiedBy":"nS0HD1eC0cney1Lj"},"_id":"oAYBOsvPJxILvuor"}
{"name":"New Macro","type":"chat","scope":"global","author":"08RzcAqYAeDQxYQr","img":"icons/svg/dice-target.svg","command":"","folder":null,"sort":0,"ownership":{"default":0,"08RzcAqYAeDQxYQr":3},"flags":{},"_stats":{"systemId":"dnd5e","systemVersion":"2.1.5","coreVersion":"10.291","createdTime":1677878220081,"modifiedTime":1677878220081,"lastModifiedBy":"08RzcAqYAeDQxYQr"},"_id":"oUJM7q5vKEFgHQh5"}
{"name":"New Macro","type":"chat","scope":"global","author":"nS0HD1eC0cney1Lj","img":"icons/svg/d20.svg","command":"","folder":null,"sort":0,"ownership":{"default":0,"nS0HD1eC0cney1Lj":3},"flags":{},"_stats":{"systemId":"dnd5e","systemVersion":"2.1.4","coreVersion":"10.291","createdTime":1676062604951,"modifiedTime":1676062617738,"lastModifiedBy":"nS0HD1eC0cney1Lj"},"_id":"w8eGEEoqOCPlxAdH"}
{"name":"Active Aura Only (Generic)","type":"script","img":"icons/svg/dice-target.svg","scope":"global","command":"if(!game.modules.get(\"ActiveAuras\")?.active) {\n  ui.notifications.error(\"ActiveAuras is not enabled\");\n  return;\n}\n\nconst lastArg = args[args.length - 1];\n\nasync function wait(ms) { return new Promise(resolve => { setTimeout(resolve, ms); }); }\n\nasync function attemptRemoval(targetToken, condition, item) {\n  if (game.dfreds.effectInterface.hasEffectApplied(condition, targetToken.document.uuid)) {\n    new Dialog({\n      title: `Use action to attempt to remove ${condition}?`,\n      buttons: {\n        one: {\n          label: \"Yes\",\n          callback: async () => {\n            const caster = item.parent;\n            const saveDc = caster.system.attributes.spelldc;\n            const removalCheck = item.flags.ddbimporter.effect.removalCheck;\n            const removalSave = item.flags.ddbimporter.effect.removalSave;\n            const ability = removalCheck ? removalCheck : removalSave;\n            const type = removalCheck ? \"check\" : \"save\";\n            const flavor = `${condition} (via ${item.name}) : ${CONFIG.DND5E.abilities[ability]} ${type} vs DC${saveDc}`;\n            const rollResult = removalCheck\n              ? (await targetToken.actor.rollAbilityTest(ability, { flavor })).total\n              : (await targetToken.actor.rollAbilitySave(ability, { flavor })).total;\n\n            if (rollResult >= saveDc) {\n              game.dfreds.effectInterface.removeEffect({ effectName: condition, uuid: targetToken.document.uuid });\n            } else {\n              if (rollResult < saveDc) ChatMessage.create({ content: `${targetToken.name} fails the ${type} for ${item.name}, still has the ${condition} condition.` });\n            }\n          },\n        },\n        two: {\n          label: \"No\",\n          callback: () => {},\n        },\n      },\n    }).render(true);\n  }\n}\n\nasync function applyCondition(condition, targetToken, item, itemLevel) {\n  if (!game.dfreds.effectInterface.hasEffectApplied(condition, targetToken.document.uuid)) {\n    const caster = item.parent;\n    const workflowItemData = duplicate(item.data);\n    workflowItemData.system.target = { value: 1, units: \"\", type: \"creature\" };\n    workflowItemData.system.save.ability = item.flags.ddbimporter.effect.save;\n    workflowItemData.system.components.concentration = false;\n    workflowItemData.system.level = itemLevel;\n    workflowItemData.system.duration = { value: null, units: \"inst\" };\n    workflowItemData.system.target = { value: null, width: null, units: \"\", type: \"creature\" };\n    workflowItemData.system.preparation.mode = \"atwill\";\n    setProperty(workflowItemData, \"flags.itemacro\", {});\n    setProperty(workflowItemData, \"flags.midi-qol\", {});\n    setProperty(workflowItemData, \"flags.dae\", {});\n    setProperty(workflowItemData, \"effects\", []);\n    delete workflowItemData._id;\n    workflowItemData.name = `${workflowItemData.name}: ${item.name} Condition save`;\n    // console.warn(\"workflowItemData\", workflowItemData);\n\n    const saveTargets = [...game.user?.targets].map((t )=> t.id);\n    game.user.updateTokenTargets([targetToken.id]);\n    const saveItem = new CONFIG.Item.documentClass(workflowItemData, { parent: caster });\n    const options = { showFullCard: false, createWorkflow: true, configureDialog: true };\n    const result = await MidiQOL.completeItemRoll(saveItem, options);\n\n    game.user.updateTokenTargets(saveTargets);\n    const failedSaves = [...result.failedSaves];\n    if (failedSaves.length > 0) {\n      await game.dfreds.effectInterface.addEffect({ effectName: condition, uuid: failedSaves[0].document.uuid });\n    }\n\n    return result;\n  }\n}\n\nasync function attachSequencerFileToTemplate(templateUuid, sequencerFile, originUuid) {\n  if (game.modules.get(\"sequencer\")?.active) {\n    if (Sequencer.Database.entryExists(sequencerFile)) {\n      console.debug(`Trying to apply sequencer effect (${sequencerFile}) to ${templateUuid} from ${originUuid}`, sequencerFile);\n      const template = await fromUuid(templateUuid);\n      new Sequence()\n      .effect()\n        .file(Sequencer.Database.entryExists(sequencerFile))\n        .size({\n          width: canvas.grid.size * (template.data.width / canvas.dimensions.distance),\n          height: canvas.grid.size * (template.data.width / canvas.dimensions.distance),\n        })\n        .persist(true)\n        .origin(originUuid)\n        .belowTokens()\n        .opacity(0.5)\n        .attachTo(template, { followRotation: true })\n        .stretchTo(template, { attachTo: true})\n      .play();\n    }\n  }\n}\n\nif (args[0].tag === \"OnUse\" && args[0].macroPass === \"preActiveEffects\") {\n  const safeName = lastArg.itemData.name.replace(/\\s|'|\\.|’/g, \"_\");\n  const dataTracker = {\n    randomId: randomID(),\n    targetUuids: lastArg.targetUuids,\n    startRound: game.combat.round,\n    startTurn: game.combat.turn,\n    spellLevel: lastArg.spellLevel,\n  };\n\n  const item = await fromUuid(lastArg.itemUuid);\n  // await item.update(dataTracker);\n  await DAE.unsetFlag(item, `${safeName}Tracker`);\n  await DAE.setFlag(item, `${safeName}Tracker`, dataTracker);\n\n  const sequencerFile = lastArg.item.flags.ddbimporter?.effect?.sequencerFile;\n  if (sequencerFile) {\n    attachSequencerFileToTemplate(lastArg.templateUuid, sequencerFile, lastArg.itemUuid)\n  }\n\n  if (lastArg.item.flags.ddbimporter?.effect?.applyImmediate) {\n    await wait(500);\n    const condition = lastArg.item.flags.ddbimporter.effect.condition;\n    for (const token of lastArg.failedSaves) {\n      if (!game.dfreds.effectInterface.hasEffectApplied(condition, token.actor.uuid)) {\n        console.debug(`Applying ${condition} to ${token.name}`);\n        await game.dfreds.effectInterface.addEffect({ effectName: condition, uuid: token.actor.uuid });\n      }\n    };\n  }\n\n  return await AAhelpers.applyTemplate(args);\n\n} else if (args[0].tag === \"OnUse\" && args[0].macroPass === \"postActiveEffects\") {\n  if (lastArg.item.flags.ddbimporter?.effect?.applyImmediate) {\n    const condition = lastArg.item.flags.ddbimporter.effect.condition;\n    for (const token of lastArg.failedSaves) {\n      if (!game.dfreds.effectInterface.hasEffectApplied(condition, token.actor.uuid)) {\n        console.debug(`Applying ${condition} to ${token.name}`);\n        await game.dfreds.effectInterface.addEffect({ effectName: condition, uuid: token.actor.uuid });\n      }\n    };\n  }\n} else if (args[0] == \"on\" || args[0] == \"each\") {\n  const safeName = lastArg.efData.label.replace(/\\s|'|\\.|’/g, \"_\");\n  const item = await fromUuid(lastArg.efData.origin);\n  // sometimes the round info has not updated, so we pause a bit\n  if (args[0] == \"each\") await wait(500);\n  const targetItemTracker = DAE.getFlag(item.parent, `${safeName}Tracker`);\n  const originalTarget = targetItemTracker.targetUuids.includes(lastArg.tokenUuid);\n  const target = canvas.tokens.get(lastArg.tokenId);\n  const targetTokenTrackerFlag = DAE.getFlag(target, `${safeName}Tracker`);\n  const targetedThisCombat = targetTokenTrackerFlag && targetItemTracker.randomId === targetTokenTrackerFlag.randomId;\n  const targetTokenTracker = targetedThisCombat\n    ? targetTokenTrackerFlag\n    : {\n      randomId: targetItemTracker.randomId,\n      round: game.combat.round,\n      turn: game.combat.turn,\n      hasLeft: false,\n      condition: item.flags.ddbimporter.effect.condition,\n    };\n\n  const castTurn = targetItemTracker.startRound === game.combat.round && targetItemTracker.startTurn === game.combat.turn;\n  const isLaterTurn = game.combat.round > targetTokenTracker.round || game.combat.turn > targetTokenTracker.turn;\n  const everyEntry = hasProperty(item.data, \"flags.ddbimporter.effect.everyEntry\")\n    ? item.flags.ddbimporter.effect.everyEntry\n    : false;\n\n  // if:\n  // not cast turn, and not part of the original target\n  // AND one of the following\n  // not original template and have not yet had this effect applied this combat OR\n  // has been targeted this combat, left and re-entered effect, and is a later turn\n\n  if (castTurn && originalTarget) {\n    console.debug(`Token ${target.name} is part of the original target for ${item.name}`);\n  } else if (everyEntry || !targetedThisCombat || (targetedThisCombat && isLaterTurn)) {\n    console.debug(`Token ${target.name} is targeted for immediate save vs condition with ${item.name}, using the following factors`, { originalTarget, castTurn, targetedThisCombat, targetTokenTracker, isLaterTurn });\n    targetTokenTracker.hasLeft = false;\n    await applyCondition(targetTokenTracker.condition, target, item, targetItemTracker.spellLevel);\n  }\n  await DAE.setFlag(target, `${safeName}Tracker`, targetTokenTracker);\n  const allowVsRemoveCondition = item.flags.ddbimporter.effect.allowVsRemoveCondition;\n  const effectApplied = game.dfreds.effectInterface.hasEffectApplied(targetTokenTracker.condition, target.document.uuid);\n  const currentTokenCombatTurn = game.combat.current.tokenId === lastArg.tokenId;\n  if (currentTokenCombatTurn && allowVsRemoveCondition && effectApplied) {\n    console.warn(`Removing ${targetTokenTracker.condition}`);\n    await attemptRemoval(target, targetTokenTracker.condition, item);\n  }\n} else if (args[0] == \"off\") {\n  const safeName = lastArg.efData.label.replace(/\\s|'|\\.|’/g, \"_\");\n  const targetToken = await fromUuid(lastArg.tokenUuid);\n  const targetTokenTracker = await DAE.getFlag(targetToken, `${safeName}Tracker`);\n  const removeOnOff = hasProperty(lastArg, \"efData.flags.ddbimporter.effect.removeOnOff\")\n    ? lastArg.efData.flags.ddbimporter.effect.removeOnOff\n    : true;\n\n  if (targetTokenTracker?.condition && removeOnOff && game.dfreds.effectInterface.hasEffectApplied(targetTokenTracker.condition, lastArg.tokenUuid)) {\n    console.debug(`Removing ${targetTokenTracker.condition} from ${targetToken.name}`);\n    game.dfreds.effectInterface.removeEffect({ effectName: targetTokenTracker.condition, uuid: lastArg.tokenUuid });\n  }\n\n  if (targetTokenTracker) {\n    targetTokenTracker.hasLeft = true;\n    targetTokenTracker.turn = game.combat.turn;\n    targetTokenTracker.round = game.combat.round;\n    await DAE.setFlag(targetToken, `${safeName}Tracker`, targetTokenTracker);\n  }\n}","folder":"Bg8VhG8e87b0cRw5","flags":{"advanced-macros":{"runAsGM":false}},"author":"gRbX7wsbHXsd3tee","sort":0,"ownership":{"default":0,"gRbX7wsbHXsd3tee":3},"_stats":{"systemId":"dnd5e","systemVersion":"2.1.4","coreVersion":"10.291","createdTime":1675611320252,"modifiedTime":1675611320252,"lastModifiedBy":"gRbX7wsbHXsd3tee"},"_id":"wlrPcMhljngRrWtw"}
